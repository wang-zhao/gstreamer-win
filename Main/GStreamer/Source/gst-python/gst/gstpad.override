/* -*- Mode: C; c-basic-offset: 4 -*- */
 * vi:si:et:sw=4:sts=4:ts=4
 *
 * gst-python
 * Copyright (C) 2004 Johan Dahlin
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * 
 * Author: Johan Dahlin <johan@gnome.org
 */
%%
headers

#if ((GST_VERSION_MAJOR > 0) ||                                    \
     (GST_VERSION_MAJOR == 0 && GST_VERSION_MINOR > 10) ||         \
     (GST_VERSION_MAJOR == 0 && GST_VERSION_MINOR == 10 &&         \
      GST_VERSION_MICRO >= 23) ||						   \
     (GST_VERSION_MAJOR == 0 && GST_VERSION_MINOR == 10 &&         \
      GST_VERSION_MICRO == 22 && GST_VERSION_NANO > 0))
#define HAVE_SET_BLOCKED_ASYNC_FULL 1
#else
#define HAVE_SET_BLOCKED_ASYNC_FULL 0
#endif

/* we need to do this until PyClosures get exception handlers */
#ifndef pyg_closure_set_exception_handler
#  define pyg_closure_set_exception_handler(ig, nore)
#  define EXCEPTION_HANDLER G_GNUC_UNUSED
#else
#  define EXCEPTION_HANDLER
#endif
#define SET_PAD_CLOSURE(self, args, kwargs, name) \
    static char *kwlist[] = { G_STRINGIFY (name), NULL }; \
    PyObject *function; \
    GstPad *pad; \
    GClosure *closure; \
    PyGstPadPrivate *priv; \
\
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, \
                     "O:GstPad.set_" G_STRINGIFY (name), \
                     kwlist, \
                     &function)) { \
        return NULL; \
    } \
\
    if (!PyCallable_Check(function)) { \
        PyErr_SetString(PyExc_TypeError, G_STRINGIFY (name) " not callable"); \
        return NULL; \
    } \
\
    closure = pyg_closure_new (function, NULL, NULL); \
    pyg_closure_set_exception_handler (closure, handle_ ## name ## _exception); \
    pygobject_watch_closure((PyObject *)self, closure); \
    priv = py_pad_private(self);\
    if (priv->name) { \
      g_closure_invalidate (priv->name); \
      g_closure_unref (priv->name); \
    } \
    priv->name = closure; \
    pad = (GstPad*)pygobject_get(self); \
    gst_pad_set_ ## name (pad, call_ ## name); \
\
    Py_INCREF(Py_None); \
    return Py_None;
    
static void
free_pad_private (gpointer data)
{
  PyGstPadPrivate *private = data;
#define INVALIDATE_CLOSURE(closure) \
  if (closure) { \
    g_closure_invalidate (closure); \
    g_closure_unref (closure); \
    closure = NULL; \
  } 
  INVALIDATE_CLOSURE (private->link_function)
  INVALIDATE_CLOSURE (private->event_function)
  INVALIDATE_CLOSURE (private->chain_function)
  INVALIDATE_CLOSURE (private->get_function)
  INVALIDATE_CLOSURE (private->getcaps_function)
  INVALIDATE_CLOSURE (private->setcaps_function)
  INVALIDATE_CLOSURE (private->activate_function)
  INVALIDATE_CLOSURE (private->activatepull_function)
  INVALIDATE_CLOSURE (private->activatepush_function)
#undef INVALIDATE_CLOSURE

  if (private->query_function) {
    Py_DECREF (private->query_function);
    private->query_function = NULL;
  }
}

static PyGstPadPrivate*
pad_private(GstPad *pad)
{
    PyGstPadPrivate *private;
    static GQuark padprivate = 0;

    if (!padprivate)
        padprivate = g_quark_from_static_string ("PyGst::PadPrivate");
    private = g_object_get_qdata (G_OBJECT (pad), padprivate);
    if (private == NULL) {
        private = g_new0(PyGstPadPrivate, 1);
        private->pad = (PyGObject *) pygobject_new (G_OBJECT (pad));
        Py_DECREF (private->pad);
        g_object_set_qdata_full (G_OBJECT (pad), padprivate, private, free_pad_private);
    }
    return private;
}
    
static PyGstPadPrivate*
py_pad_private(PyGObject *pad)
{
    return pad_private ((GstPad *)pygobject_get(pad));
}

%%
ignore
  gst_pad_select
  gst_pad_selectv
  gst_pad_new_from_template
  gst_pad_load_and_link
%%
override gst_pad_set_getcaps_function kwargs

static void EXCEPTION_HANDLER
handle_getcaps_function_exception (GValue *ret, guint n, const GValue *params)
{
  g_value_set_boxed (ret, gst_pad_get_pad_template_caps (
      GST_PAD (g_value_get_object (&params[0]))));
  PyErr_Clear ();
}

static GstCaps *
call_getcaps_function (GstPad *pad)
{
    GClosure *closure;
    GValue ret = { 0, };
    GValue args = { 0, };
    GstCaps *caps;
    
    g_value_init (&ret, GST_TYPE_CAPS);
    g_value_init (&args, GST_TYPE_PAD);
    g_value_set_object (&args, pad);
    
    closure = pad_private(pad)->getcaps_function;
    
    g_closure_invoke (closure, &ret, 1, &args, NULL);

    caps = g_value_dup_boxed (&ret);
    g_value_unset (&ret);
    g_value_unset (&args);
    return caps;
}

static PyObject*
_wrap_gst_pad_set_getcaps_function (PyGObject *self,
        PyObject  *args,
        PyObject  *kwargs)
{
    SET_PAD_CLOSURE (self, args, kwargs, getcaps_function)
}

%%
override gst_pad_set_link_function kwargs

static void EXCEPTION_HANDLER
handle_link_function_exception (GValue *ret, guint n, const GValue *params)
{
  g_value_set_enum (ret, GST_PAD_LINK_REFUSED);
  PyErr_Clear ();
}

static GstPadLinkReturn
call_link_function (GstPad *pad, GstPad *peer)
{
    GClosure *closure;
    GValue ret = { 0, };
    GValue args[2] = { { 0, }, {0, } };
    GstPadLinkReturn i;
    
    g_value_init (&ret, GST_TYPE_PAD_LINK_RETURN);
    g_value_init (&args[0], GST_TYPE_PAD);
    g_value_init (&args[1], GST_TYPE_PAD);
    g_value_set_object (&args[0], pad);
    g_value_set_object (&args[1], peer);
    
    closure = pad_private(pad)->link_function;
    
    g_closure_invoke (closure, &ret, 2, args, NULL);

    i = g_value_get_enum (&ret);
    g_value_unset (&ret);
    g_value_unset (&args[0]);
    g_value_unset (&args[1]);
    return i;
}

static PyObject*
_wrap_gst_pad_set_link_function (PyGObject *self,
        PyObject  *args,
        PyObject  *kwargs)
{
    SET_PAD_CLOSURE (self, args, kwargs, link_function)
}

%%
override gst_pad_set_chain_function kwargs

static void EXCEPTION_HANDLER
handle_chain_function_exception (GValue *ret, guint n, const GValue *params)
{
  GstElement *element = GST_ELEMENT (gst_object_get_parent (g_value_get_object (&params[0])));
  
  if (!_pygst_element_check_error (element)) {
    g_assert_not_reached (); /* only returns FALSE when there's no error */
  }
}

static GstFlowReturn
call_chain_function(GstPad *pad, GstBuffer *buffer)
{
    GClosure *closure;
    GValue ret = { 0, };
    GValue args[2] = { { 0, }, { 0, } };
    GstFlowReturn    flow;
    
    g_value_init (&ret, GST_TYPE_FLOW_RETURN);
    g_value_set_enum (&ret, GST_FLOW_ERROR);
    g_value_init (&args[0], GST_TYPE_PAD);
    g_value_init (&args[1], GST_TYPE_BUFFER);

    g_value_set_object (&args[0], pad);
    gst_value_set_mini_object (&args[1], GST_MINI_OBJECT (buffer));
    closure = pad_private(pad)->chain_function;
    
    g_closure_invoke (closure, &ret, 2, args, NULL);
    flow = g_value_get_enum (&ret);

    g_value_unset (&ret);
    g_value_unset (&args[0]);
    g_value_unset (&args[1]);

    /* a chain function takes over the ref of the buffer handed to it;
     * so we should unref after calling the pythonic chain func */
    gst_buffer_unref (buffer);
    return flow;
}

static PyObject*
_wrap_gst_pad_set_chain_function(PyGObject *self,
                PyObject  *args,
                PyObject  *kwargs)
{
    SET_PAD_CLOSURE (self, args, kwargs, chain_function)
}

%%
override gst_pad_set_event_function kwargs

static void EXCEPTION_HANDLER
handle_event_function_exception (GValue *ret, guint n, const GValue *params)
{
  GstElement *element = GST_ELEMENT (gst_pad_get_parent (g_value_get_object (&params[0])));
  
  if (!_pygst_element_check_error (element)) {
    g_assert_not_reached (); /* only returns FALSE when there's no error */
  }
}

static gboolean
call_event_function (GstPad *pad, GstEvent *event)
{
    GClosure *closure;
    GValue ret = { 0, };
    GValue args[2] = { { 0, }, { 0, } };
    gboolean bool;
    
    g_value_init (&ret, G_TYPE_BOOLEAN);
    g_value_set_boolean (&ret, FALSE);
    g_value_init (&args[0], GST_TYPE_PAD);
    g_value_init (&args[1], GST_TYPE_EVENT);
    g_value_set_object (&args[0], pad);
    gst_value_set_mini_object (&args[1], GST_MINI_OBJECT (event));
    closure = pad_private(pad)->event_function;
    
    g_closure_invoke (closure, &ret, 2, args, NULL);

    bool = g_value_get_boolean (&ret);

    g_value_unset (&ret);
    g_value_unset (&args[0]);
    g_value_unset (&args[1]);
    return bool;
}

static PyObject*
_wrap_gst_pad_set_event_function (PyGObject *self,
                  PyObject  *args,
                  PyObject  *kwargs)
{
    SET_PAD_CLOSURE (self, args, 
		     kwargs, event_function)
}

%%
override gst_pad_set_query_function kwargs

static gboolean
pypad_copy_struct_members (GQuark field_id, const GValue * value, 
    GstStructure* to_structure)
{
    gst_structure_id_set_value (to_structure, field_id, value);

    return TRUE;
}

static gboolean
call_query_function (GstPad *pad, GstQuery *query)
{
    PyGILState_STATE __py_state;
    PyGObject *py_pad;
    PyGstPadPrivate *priv;

    PyObject *py_ret;
    PyObject *py_args;
    gboolean ret = FALSE;
    GstQuery *query_copy;
    PyObject *py_query;

    /* Push our GIL state */
    __py_state = pyg_gil_state_ensure();

    /* Get the python version of the pad */
    py_pad = (PyGObject *) pygobject_new((GObject*) (pad));
    if (!py_pad) {
        if (PyErr_Occurred())
            PyErr_Print();
        goto beach;
    }
    /* Private data, where our callback should be stored */
    priv = py_pad_private(py_pad);
    if (priv->query_function == NULL) {
        /* FIXME: Generate an error message somewhere? */
        Py_DECREF(py_pad);
        goto beach;
    }
    
    /* Create our arguments tuple and populate */
    py_args = PyTuple_New(2);

    /* We copy the query into a new one so that it can have a refcount
     * of exactly 1 and be owned by python */
    pyg_begin_allow_threads;
    query_copy = gst_query_copy (query);
    pyg_end_allow_threads;
    py_query = pygstminiobject_new((GstMiniObject *)query_copy);
    gst_query_unref (query_copy);

    PyTuple_SetItem(py_args, 0, (PyObject *) (py_pad));
    PyTuple_SetItem(py_args, 1, py_query);

    /* Perform the callback into python, then parse the result */
    py_ret = PyObject_CallObject(priv->query_function, py_args);
    if (!py_ret) {
        if (PyErr_Occurred())
            PyErr_Print();

        Py_DECREF(py_args);
        goto beach;
    }

    ret = (py_ret == Py_True ? TRUE : FALSE);

    /* If the query succeeded, copy the result back into the original query.
     * We still have a refcount to it, because we didn't unref the py_query
     * wrapper yet. */
    if (ret) {
        /* I feel ill violating the poor query like this, but it's the only
         * way to transfer data from our copy back to the original query */
        GstStructure *from, *to;
        
        pyg_begin_allow_threads;
        from = GST_QUERY (query_copy)->structure; 
        to = query->structure;
        gst_structure_foreach (from, 
            (GstStructureForeachFunc) pypad_copy_struct_members, to);
        pyg_end_allow_threads;
    }

    Py_DECREF(py_args);
    Py_DECREF(py_ret);
beach:
    pyg_gil_state_release(__py_state);
    
    return ret;
}

static PyObject*
_wrap_gst_pad_set_query_function (PyGObject *self,
                  PyObject  *args,
                  PyObject  *kwargs)
{
    static char *kwlist[] = { "query_function", NULL };
    PyObject *function;
    GstPad *pad;
    PyGstPadPrivate *priv;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "O:GstPad.set_query_function",
                     kwlist,
                     &function)) {
        return NULL;
    }

    pad = (GstPad*)pygobject_get(self);
    priv = py_pad_private(self);

    /* Allow setting query_function to None to clear it to NULL */
    if (function == Py_None) {
        if (priv->query_function) {
            Py_DECREF (priv->query_function);
            priv->query_function = NULL;
        }
        gst_pad_set_query_function (pad, NULL);
        goto out;
    }

    if (!PyCallable_Check(function)) {
        PyErr_SetString(PyExc_TypeError, "Passed query_function not callable");
        return NULL;
    }

    if (priv->query_function) {
        Py_DECREF (priv->query_function);
    }

    Py_INCREF(function);
    priv->query_function = function;

    gst_pad_set_query_function (pad, call_query_function);

out:
    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gst_pad_set_setcaps_function kwargs

static void EXCEPTION_HANDLER
handle_setcaps_function_exception (GValue *ret, guint n, const GValue *params)
{
  GstElement *element = GST_ELEMENT (gst_pad_get_parent (g_value_get_object (&params[0])));
  
  if (!_pygst_element_check_error (element)) {
    g_assert_not_reached (); /* only returns FALSE when there's no error */
  }
}

static gboolean
call_setcaps_function (GstPad *pad, GstCaps *caps)
{
    GClosure *closure;
    GValue ret = { 0, };
    GValue args[2] = { { 0, }, { 0, } };
    gboolean bool;
    
    g_value_init (&ret, G_TYPE_BOOLEAN);
    g_value_set_boolean (&ret, FALSE);
    g_value_init (&args[0], GST_TYPE_PAD);
    g_value_init (&args[1], GST_TYPE_CAPS);
    g_value_set_object (&args[0], pad);
    gst_value_set_caps (&args[1], (const GstCaps*) caps);
    closure = pad_private(pad)->setcaps_function;
    
    g_closure_invoke (closure, &ret, 2, args, NULL);

    bool = g_value_get_boolean (&ret);

    g_value_unset (&ret);
    g_value_unset (&args[0]);
    g_value_unset (&args[1]);
    return bool;
}

static PyObject*
_wrap_gst_pad_set_setcaps_function (PyGObject *self,
                  PyObject  *args,
                  PyObject  *kwargs)
{
    SET_PAD_CLOSURE (self, args, 
		     kwargs, setcaps_function)
}
%%
override gst_pad_set_activate_function kwargs

static void EXCEPTION_HANDLER
handle_activate_function_exception (GValue * ret, guint n, const GValue * params)
{
  GstElement *element = GST_ELEMENT (gst_pad_get_parent (g_value_get_object (&params[0])));
  
  if (!_pygst_element_check_error (element)) {
    g_assert_not_reached (); /* only returns FALSE when there's no error */
  }
}

static gboolean
call_activate_function (GstPad * pad)
{
    GClosure * closure;
    GValue ret = { 0, };
    GValue args[1] = { {0, }};
    gboolean bool;

    g_value_init (&ret, G_TYPE_BOOLEAN);
    g_value_set_boolean (&ret, FALSE);
    g_value_init(&args[0], GST_TYPE_PAD);
    g_value_set_object (&args[0], pad);
    closure = pad_private(pad)->activate_function;

    g_closure_invoke (closure, &ret, 1, args, NULL);
    
    bool = g_value_get_boolean (&ret);

    g_value_unset (&ret);
    g_value_unset (&args[0]);
    
    return bool;
}

static PyObject *
_wrap_gst_pad_set_activate_function (PyGObject *self,
				     PyObject *args,
				     PyObject *kwargs)
{
    SET_PAD_CLOSURE (self, args, kwargs, activate_function)
}
%%
override gst_pad_set_activatepull_function kwargs

static void EXCEPTION_HANDLER
handle_activatepull_function_exception (GValue * ret, guint n, const GValue * params)
{
  GstElement *element = GST_ELEMENT (gst_pad_get_parent (g_value_get_object (&params[0])));
  
  if (!_pygst_element_check_error (element)) {
    g_assert_not_reached (); /* only returns FALSE when there's no error */
  }
}

static gboolean
call_activatepull_function (GstPad * pad, gboolean active)
{
    GClosure * closure;
    GValue ret = { 0, };
    GValue args[2] = { {0, }, {0, } };
    gboolean bool;

    g_value_init (&ret, G_TYPE_BOOLEAN);
    g_value_set_boolean (&ret, FALSE);
    g_value_init (&args[0], GST_TYPE_PAD);
    g_value_set_object (&args[0], pad);
    g_value_init (&args[1], G_TYPE_BOOLEAN);
    g_value_set_boolean (&args[1], active);
    closure = pad_private(pad)->activatepull_function;

    g_closure_invoke (closure, &ret, 2, args, NULL);

    bool = g_value_get_boolean (&ret);
    
    g_value_unset (&ret);
    g_value_unset (&args[0]);
    g_value_unset (&args[1]);

    return bool;
}

static PyObject *
_wrap_gst_pad_set_activatepull_function (PyGObject *self,
					 PyObject *args,
					 PyObject *kwargs)
{
    SET_PAD_CLOSURE (self, args, kwargs, activatepull_function);
}
%%
override gst_pad_set_activatepush_function kwargs

static void EXCEPTION_HANDLER
handle_activatepush_function_exception (GValue * ret, guint n, const GValue * params)
{
  GstElement *element = GST_ELEMENT (gst_pad_get_parent (g_value_get_object (&params[0])));
  
  if (!_pygst_element_check_error (element)) {
    g_assert_not_reached (); /* only returns FALSE when there's no error */
  }
}

static gboolean
call_activatepush_function (GstPad * pad, gboolean active)
{
    GClosure * closure;
    GValue ret = { 0, };
    GValue args[2] = { {0, }, {0, }};
    gboolean bool;

    g_value_init (&ret, G_TYPE_BOOLEAN);
    g_value_set_boolean (&ret, FALSE);
    g_value_init (&args[0], GST_TYPE_PAD);
    g_value_set_object (&args[0], pad);
    g_value_init (&args[1], G_TYPE_BOOLEAN);
    g_value_set_boolean (&args[1], active);
    closure = pad_private(pad)->activatepush_function;

    g_closure_invoke (closure, &ret, 2, args, NULL);

    bool = g_value_get_boolean (&ret);
    
    g_value_unset (&ret);
    g_value_unset (&args[0]);
    g_value_unset (&args[1]);

    return bool;
}

static PyObject *
_wrap_gst_pad_set_activatepush_function (PyGObject *self,
					 PyObject *args,
					 PyObject *kwargs)
{
    SET_PAD_CLOSURE (self, args, kwargs, activatepush_function);
}
%%
override-slot GstPad.tp_repr
static PyObject *
_wrap_gst_pad_tp_repr (PyGObject *self)
{
    char *buf;
    PyObject *retval;
    GstPad *pad;
    GstElement *parent;
    gchar *padname = NULL;
    gchar *elementname = NULL;

    pad = GST_PAD(self->obj);

    pyg_begin_allow_threads;
    padname = gst_pad_get_name (pad);

    parent = GST_ELEMENT (gst_pad_get_parent (pad));
    if (parent)
	    elementname = gst_element_get_name (parent);

    buf = g_strdup_printf ("<GstPad (%s:%s) at %lx>",
        parent ? elementname : "---",
        padname, (long) self->obj);

    g_free(padname);

    if (parent) {
        gst_object_unref (parent);
	    g_free(elementname);
    }
    pyg_end_allow_threads;

    retval = PyString_FromString(buf);
    g_free(buf);

    return retval;
}

%%
override gst_pad_query kwargs
static PyObject *
_wrap_gst_pad_query(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "query", NULL };
    int ret;
    PyGstMiniObject *query;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GstPad.query", kwlist, &PyGstQuery_Type, &query))
        return NULL;

    pyg_begin_allow_threads;
    ret = gst_pad_query(GST_PAD(self->obj), GST_QUERY (query->obj));
    pyg_end_allow_threads;

    return PyBool_FromLong(ret);   
}
%%
override gst_pad_convert kwargs
static PyObject *
_wrap_gst_pad_convert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "src_format", "src_value",
                  "dest_format", NULL };
    GstFormat src_format, dest_format;
    PyObject *src_value_obj;
    gint64 src_value, dest_value = 0;
    gboolean ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "iOi:GstPad.convert", kwlist,
                     &src_format, &src_value_obj,
                     &dest_format))
        return NULL;
    
    src_value = PyLong_AsLongLong(src_value_obj);
    
    ret = gst_pad_convert(GST_PAD(self->obj), src_format, src_value,
                  &dest_format, &dest_value);
    return PyLong_FromLongLong(dest_value);
}
%%
override gst_pad_link kwargs
static PyObject *
_wrap_gst_pad_link(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sinkpad", NULL };
    PyGObject *sinkpad;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GstPad.link", kwlist,
                                     &PyGstPad_Type, &sinkpad))
        return NULL;
    pyg_begin_allow_threads;
    ret = gst_pad_link(GST_PAD(self->obj), GST_PAD(sinkpad->obj));
    pyg_end_allow_threads;
    if (ret) {
        PyObject *exc_val = pyg_enum_from_gtype(GST_TYPE_PAD_LINK_RETURN, ret);
        PyErr_SetObject(PyGstExc_LinkError, exc_val);
        Py_DECREF(exc_val);
        return NULL;
    }
    return PyBool_FromLong(ret);
}

%%
override gst_pad_link_filtered kwargs
static PyObject *
_wrap_gst_pad_link_filtered(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sinkpad", "filtercaps", NULL };
    PyGObject *sinkpad;
    PyObject *py_filtercaps;
    int ret;
    GstCaps *filtercaps = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O:GstPad.link_filtered",
                                     kwlist, &PyGstPad_Type, &sinkpad,
                                     &py_filtercaps))
        return NULL;
    if (pyg_boxed_check(py_filtercaps, GST_TYPE_CAPS))
        filtercaps = pyg_boxed_get(py_filtercaps, GstCaps);
    else {
        PyErr_SetString(PyExc_TypeError, "filtercaps should be a GstCaps");
        return NULL;
    }
    ret = gst_pad_link_filtered(GST_PAD(self->obj),
                                GST_PAD(sinkpad->obj),
                                filtercaps);
    if (ret) {
        PyObject *exc_val = pyg_enum_from_gtype(GST_TYPE_PAD_LINK_RETURN, ret);
        PyErr_SetObject(PyGstExc_LinkError, exc_val);
        Py_DECREF(exc_val);
        return NULL;
    }
    return PyBool_FromLong(ret);
}
%%
override gst_pad_get_pad_template_caps noargs
static PyObject *
_wrap_gst_pad_get_pad_template_caps(PyGObject *self)
{
    GstCaps *ret = (GstCaps*)gst_pad_get_pad_template_caps(GST_PAD(self->obj));
    return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_template_get_caps noargs
static PyObject *
_wrap_gst_pad_template_get_caps(PyGObject *self)
{
    GstCaps *ret = (GstCaps*)gst_pad_template_get_caps(GST_PAD_TEMPLATE(self->obj));
    return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
override gst_pad_template_get_caps_by_name kwargs
static PyObject *
_wrap_gst_pad_template_get_caps_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    GstCaps *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:GstPadTemplate.get_caps_by_name", kwlist, &name))
        return NULL;
    ret = (GstCaps*)gst_pad_template_get_caps_by_name(GST_PAD_TEMPLATE(self->obj), name);
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GST_TYPE_CAPS, ret, TRUE, TRUE);
}
%%
new-constructor GST_TYPE_PAD
%%
override gst_pad_new kwargs
static int
_wrap_gst_pad_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "direction", NULL };
    static char *kwlist2[] = { "template", "name", NULL };
    PyGObject *templ;
    char *name = NULL;
    PyObject *py_direction = NULL;
    GstPadDirection direction;

    if (PyArg_ParseTupleAndKeywords (args, kwargs, "zO:GstPad.__init__",
                                     kwlist, &name, &py_direction)) {

        GST_LOG ("gst.Pad.__init__: using gst_pad_new");
        if (pyg_enum_get_value (GST_TYPE_PAD_DIRECTION, py_direction,
                                (gint *) &direction)) {
            GST_LOG ("gst.Pad.__init__: direction is not valid");
            return -1;
        }

        self->obj = (GObject *) gst_pad_new (name, direction);
    } else {
        PyErr_Clear ();

        GST_LOG ("gst.Pad.__init__: using gst_pad_new_from_template");
        if (PyArg_ParseTupleAndKeywords (args, kwargs, "O!|s:GstPad.__init__",
                                         kwlist2, &PyGstPadTemplate_Type,
                                         &templ, &name)) {
            if (name == NULL) 
                name = GST_PAD_TEMPLATE_NAME_TEMPLATE (GST_PAD_TEMPLATE (
                    templ->obj));
            self->obj = (GObject *) gst_pad_new_from_template (
                GST_PAD_TEMPLATE (templ->obj), name);
        }
    }
    if (!self->obj) {
      PyErr_SetString (PyExc_RuntimeError, "could not create GstPad object");
      return -1;
    }
    pygobject_register_wrapper ((PyObject *)self);
    return 0;
}
%%
override gst_pad_add_data_probe args
static PyObject *
_wrap_gst_pad_add_data_probe(PyGObject *self, PyObject *args)
{
    GstPad *pad = GST_PAD(self->obj);
    PyObject *method = NULL;
    PyObject *rv = NULL;
    PyObject *mylist = PyList_New(1);
    PyObject *mynewlist = NULL;
    PyObject *myargs = NULL;
    PyObject *signalname = NULL;

    signalname = PyString_FromString("have-data");

    if (PyList_SetItem(mylist, 0, signalname)) {
	Py_DECREF(mylist);
	return NULL;
    }

    mynewlist = PySequence_InPlaceConcat(mylist, args);

    Py_DECREF(mylist);

    if (!mynewlist)
	return NULL;

    myargs = PyList_AsTuple(mynewlist);

    Py_DECREF(mynewlist);

    if (!myargs)
	return NULL;

    method = PyObject_GetAttrString((PyObject*)self, "connect");

    if (!method) {
	Py_DECREF(mylist);
        return NULL;
    }

    GST_OBJECT_LOCK (pad);

    rv = PyObject_CallObject(method, myargs);
    if (rv) {
	GST_PAD_DO_BUFFER_SIGNALS (pad)++;
	GST_PAD_DO_EVENT_SIGNALS (pad)++;
    }

    GST_OBJECT_UNLOCK (pad);

    Py_DECREF(myargs);
    Py_DECREF(method);

    return rv;
}
%%
override gst_pad_add_event_probe args
static PyObject *
_wrap_gst_pad_add_event_probe(PyGObject *self, PyObject *args)
{
    GstPad *pad = GST_PAD(self->obj);
    PyObject *method = NULL;
    PyObject *rv = NULL;
    PyObject *mylist = PyList_New(1);
    PyObject *mynewlist = NULL;
    PyObject *myargs = NULL;
    PyObject *signalname = NULL;

    signalname = PyString_FromString("have-data::event");

    if (PyList_SetItem(mylist, 0, signalname)) {
	Py_DECREF(mylist);
	return NULL;
    }

    mynewlist = PySequence_InPlaceConcat(mylist, args);

    Py_DECREF(mylist);

    if (!mynewlist)
	return NULL;

    myargs = PyList_AsTuple(mynewlist);

    Py_DECREF(mynewlist);

    if (!myargs)
	return NULL;

    method = PyObject_GetAttrString((PyObject*)self, "connect");

    if (!method) {
	Py_DECREF(mylist);
        return NULL;
    }

    GST_OBJECT_LOCK (pad);

    rv = PyObject_CallObject(method, myargs);
    if (rv)
	GST_PAD_DO_EVENT_SIGNALS (pad)++;

    GST_PAD_DO_BUFFER_SIGNALS (pad)++;
    GST_DEBUG ("adding event probe to pad %s:%s, now %d probes",
	       GST_DEBUG_PAD_NAME (pad), GST_PAD_DO_BUFFER_SIGNALS (pad));
    GST_OBJECT_UNLOCK (pad);

    Py_DECREF(myargs);
    Py_DECREF(method);

    return rv;
}
%%
override gst_pad_add_buffer_probe args
static PyObject *
_wrap_gst_pad_add_buffer_probe(PyGObject *self, PyObject *args)
{
    GstPad *pad = GST_PAD(self->obj);
    PyObject *method = NULL;
    PyObject *rv = NULL;
    PyObject *mylist = PyList_New(1);
    PyObject *mynewlist = NULL;
    PyObject *myargs = NULL;
    PyObject *signalname = NULL;

    signalname = PyString_FromString("have-data::buffer");

    if (PyList_SetItem(mylist, 0, signalname)) {
	Py_DECREF(mylist);
	return NULL;
    }

    mynewlist = PySequence_InPlaceConcat(mylist, args);

    Py_DECREF(mylist);

    if (!mynewlist)
	return NULL;

    myargs = PyList_AsTuple(mynewlist);

    Py_DECREF(mynewlist);

    if (!myargs)
	return NULL;

    method = PyObject_GetAttrString((PyObject*)self, "connect");

    if (!method) {
	Py_DECREF(mylist);
        return NULL;
    }

    GST_OBJECT_LOCK (pad);

    rv = PyObject_CallObject(method, myargs);
    if (rv)
	GST_PAD_DO_BUFFER_SIGNALS (pad)++;

    GST_OBJECT_UNLOCK (pad);

    Py_DECREF(myargs);
    Py_DECREF(method);

    return rv;
}
%%
override-slot GstPadTemplate.tp_getattr
#define IS_ATTR(name) (strcmp (name, attr) == 0)
static PyObject *
_wrap_gst_pad_template_tp_getattr(PyObject *self, char *attr)
{
  GstPadTemplate *templ = GST_PAD_TEMPLATE (pygobject_get (self));
  
  if (IS_ATTR ("__members__")) {
    return Py_BuildValue("[ssss]", "name_template", "direction", "presence", "caps" );
  } else if (IS_ATTR ("name_template")) {
    return PyString_FromString (GST_PAD_TEMPLATE_NAME_TEMPLATE(templ));
  } else if (IS_ATTR ("direction")) {
    return pyg_enum_from_gtype(GST_TYPE_PAD_DIRECTION, GST_PAD_TEMPLATE_DIRECTION(templ));
  } else if (IS_ATTR ("presence")) {
    return pyg_enum_from_gtype(GST_TYPE_PAD_PRESENCE, GST_PAD_TEMPLATE_PRESENCE(templ));
  } else if (IS_ATTR ("caps")) {
    return pyg_boxed_new (GST_TYPE_CAPS, GST_PAD_TEMPLATE_CAPS(templ), TRUE, TRUE);
  }
  return Py_FindMethod((PyMethodDef*) _PyGstPadTemplate_methods, self, attr);
}
%%
override gst_pad_query_position args
static PyObject *
_wrap_gst_pad_query_position (PyGObject *self, PyObject *args)
{
    gint64    cur;
    gint    format;
    PyObject    *pformat;
    PyObject    *ret;

    pformat = (PyObject*)PyTuple_GetItem(args, 0);
    if (pyg_enum_get_value (GST_TYPE_FORMAT, pformat, &format)) {
        PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
        return NULL;
    }

    if ((gst_pad_query_position(GST_PAD (self->obj), (GstFormat*) &format, &cur))) {
	ret = Py_BuildValue("(LO)", cur,
			    pyg_enum_from_gtype (GST_TYPE_FORMAT, format));
    } else {
        Py_INCREF(Py_None);
        ret = Py_None;
    }

    return ret;
}
%%
override gst_pad_query_duration args
static PyObject *
_wrap_gst_pad_query_duration (PyGObject *self, PyObject *args)
{
    gint64    cur;
    gint    format;
    PyObject    *pformat;
    PyObject    *ret;

    pformat = (PyObject*)PyTuple_GetItem(args, 0);
    if (pyg_enum_get_value (GST_TYPE_FORMAT, pformat, &format)) {
        PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
        return NULL;
    }

    if ((gst_pad_query_duration(GST_PAD (self->obj), (GstFormat*) &format, &cur))) {
	ret = Py_BuildValue("(LO)", cur,
			    pyg_enum_from_gtype (GST_TYPE_FORMAT, format));
    } else {
        Py_INCREF(Py_None);
        ret = Py_None;
    }

    return ret;
}
%%
override gst_pad_query_convert kwargs
static PyObject *
_wrap_gst_pad_query_convert (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fromformat", "fromvalue", "destformat", NULL };
    PyObject    *pfromformat, *pdestformat;
    GstFormat    srcformat, destformat;
    gint64    fromval, dstval;

    /* Input : src_format, src_val, dst_format */
    /* Returns : dst_format, dst_val OR None */

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "0L0:GstPad.query_convert",
                     kwlist, &pfromformat, &fromval, &pdestformat))
    return NULL;
    if (pyg_enum_get_value(GST_TYPE_FORMAT, pfromformat, (gint *) &srcformat)) {
    PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
    return NULL;
    }
    if (pyg_enum_get_value(GST_TYPE_FORMAT, pdestformat, (gint *) &destformat)) {
    PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
    return NULL;
    }

    if (!(gst_pad_query_convert (GST_PAD(self->obj),
                 srcformat, fromval,
                 &destformat, &dstval))) {
    Py_INCREF(Py_None);
    return Py_None;
    }
    
    return Py_BuildValue("(OL)",
			 pyg_enum_from_gtype (GST_TYPE_FORMAT, destformat),
			 dstval);
}
%%
override gst_pad_alloc_buffer kwargs
static PyObject *
_wrap_gst_pad_alloc_buffer (PyGObject *self, PyObject * args, PyObject *kwargs)
{
    static char *kwlist[] = {"offset", "size", "caps", NULL};
    guint64    offset;
    gint    size;
    PyObject    *pcaps;
    GstCaps    *caps;
    PyObject    *ret;
    GstBuffer    *buf;
    GstFlowReturn    res;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "KiO:GstPad.alloc_buffer",
                     kwlist, &offset, &size, &pcaps))
    return NULL;
    caps = pyg_boxed_get(pcaps, GstCaps);
    res = gst_pad_alloc_buffer (GST_PAD(pygobject_get(self)),
                offset, size, caps, &buf);
    ret = PyList_New(2);
    PyList_SetItem(ret, 0, pyg_enum_from_gtype(GST_TYPE_FLOW_RETURN, res));
    if (res != GST_FLOW_OK) {
        PyList_SetItem(ret, 1, Py_None);
    } else {
        PyList_SetItem(ret, 1, pygstminiobject_new(GST_MINI_OBJECT(buf)));
	/* Bring down the reference count, since we are meant to be the only
	 * one holding a reference to the newly created buffer. */
	gst_buffer_unref (buf);
    }
    return ret;
}
%%
override gst_pad_alloc_buffer_and_set_caps kwargs
static PyObject *
_wrap_gst_pad_alloc_buffer_and_set_caps (PyGObject *self, PyObject * args, PyObject *kwargs)
{
    static char *kwlist[] = {"offset", "size", "caps", NULL};
    guint64    offset;
    gint    size;
    PyObject    *pcaps;
    GstCaps    *caps;
    PyObject    *ret;
    GstBuffer    *buf;
    GstFlowReturn    res;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "KiO:GstPad.alloc_buffer_and_set_caps",
                     kwlist, &offset, &size, &pcaps))
    return NULL;
    caps = pyg_boxed_get(pcaps, GstCaps);
    res = gst_pad_alloc_buffer_and_set_caps (GST_PAD(pygobject_get(self)),
                offset, size, caps, &buf);
    ret = PyList_New(2);
    PyList_SetItem(ret, 0, pyg_enum_from_gtype(GST_TYPE_FLOW_RETURN, res));
    if (res != GST_FLOW_OK) {
        PyList_SetItem(ret, 1, Py_None);
    } else {
        PyList_SetItem(ret, 1, pygstminiobject_new(GST_MINI_OBJECT(buf)));
	/* Bring down the reference count, since we are meant to be the only
	 * one holding a reference to the newly created buffer. */
	gst_buffer_unref (buf);
    }
    return ret;
}
%%
override gst_pad_pull_range kwargs
static PyObject *
_wrap_gst_pad_pull_range (PyGObject *self, PyObject * args, PyObject *kwargs)
{
    static char *kwlist[] = {"offset", "size", NULL};
    guint64    offset;
    gint    size;
    PyObject    *ret;
    GstBuffer    *buf;
    GstFlowReturn    res;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "Ki:GstPad.pull_range",
                     kwlist, &offset, &size))
    return NULL;
    res = gst_pad_pull_range (GST_PAD(pygobject_get(self)),
                  offset, size, &buf);
    ret = PyList_New(2);
    PyList_SetItem(ret, 0, pyg_enum_from_gtype(GST_TYPE_FLOW_RETURN, res));
    if (res != GST_FLOW_OK) {
        PyList_SetItem(ret, 1, Py_None);
    } else {
        PyList_SetItem(ret, 1, pygstminiobject_new(GST_MINI_OBJECT(buf)));
	/* Bring down the reference count, since we are meant to be the only
	 * one holding a reference to the newly created buffer. */
	gst_buffer_unref (buf);
    }
    return ret;
}
%%
override gst_pad_get_range kwargs
static PyObject *
_wrap_gst_pad_get_range (PyGObject *self, PyObject * args, PyObject *kwargs)
{
    static char *kwlist[] = {"offset", "size", NULL};
    guint64    offset;
    gint    size;
    PyObject    *ret;
    GstBuffer    *buf;
    GstFlowReturn    res;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "Ki:GstPad.get_range",
                     kwlist, &offset, &size))
    return NULL;
    res = gst_pad_get_range (GST_PAD(pygobject_get(self)),
                 offset, size, &buf);
    ret = PyList_New(2);
    PyList_SetItem(ret, 0, pyg_enum_from_gtype(GST_TYPE_FLOW_RETURN, res));
    if (res != GST_FLOW_OK) {
        PyList_SetItem(ret, 1, Py_None);
    } else {
        PyList_SetItem(ret, 1, pygstminiobject_new(GST_MINI_OBJECT(buf)));
	/* Bring down the reference count, since we are meant to be the only
	 * one holding a reference to the newly created buffer. */
	gst_buffer_unref (buf);
    }
    return ret;
}
%%
override gst_pad_get_internal_links noargs
static PyObject *
_wrap_gst_pad_get_internal_links (PyGObject * self)
{
    PyObject    *ret;
    GList    *lst, *tmp;
    gint i;

    lst = gst_pad_get_internal_links (GST_PAD (pygobject_get(self)));

    ret = PyList_New(g_list_length(lst));
    for (tmp = lst, i = 0 ; tmp; tmp = g_list_next(tmp), ++i) {
        PyList_SetItem(ret, i, pygobject_new(G_OBJECT(tmp->data)));
    }
    g_list_free(lst);
    return ret;
}
%%
override gst_pad_get_internal_links_default noargs
static PyObject *
_wrap_gst_pad_get_internal_links_default (PyGObject * self)
{
    PyObject    *ret;
    GList    *lst, *tmp;
    gint i;

    lst = gst_pad_get_internal_links_default (GST_PAD (pygobject_get(self)));

    ret = PyList_New(g_list_length(lst));
    for (tmp = lst, i = 0 ; tmp; tmp = g_list_next(tmp), ++i) {
        PyList_SetItem(ret, i, pygobject_new(G_OBJECT(tmp->data)));
    }
    g_list_free(lst);
    return ret;
}
%%
override gst_pad_get_query_types noargs
static PyObject *
_wrap_gst_pad_get_query_types (PyGObject *self)
{
    PyObject    *ret;
    PyObject    *item;
    int        i;
    GstQueryType    *tab;

    tab = (GstQueryType*) gst_pad_get_query_types(GST_PAD(self->obj));
    if (tab == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
    }

    ret = PyList_New(0);
    for (i = 0; tab[i] != 0; i++) {
        item = pyg_enum_from_gtype (GST_TYPE_QUERY_TYPE, tab[i]);
        PyList_Append(ret, item);
        Py_XDECREF(item);
    }
    
    return ret;
}
%%
override gst_pad_get_query_types_default noargs
static PyObject *
_wrap_gst_pad_get_query_types_default (PyGObject *self)
{
    PyObject    *ret;
    PyObject    *item;
    int        i;
    GstQueryType    *tab;

    tab = (GstQueryType*) gst_pad_get_query_types_default(GST_PAD(self->obj));
    if (tab == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
    }

    ret = PyList_New(0);
    for (i = 0; tab[i] != 0; i++) {
        item = pyg_enum_from_gtype (GST_TYPE_QUERY_TYPE, tab[i]);
        PyList_Append(ret, item);
        Py_XDECREF(item);
    }
    
    return ret;
}
%%
override gst_pad_set_blocked_async args

#if HAVE_SET_BLOCKED_ASYNC_FULL
static void
pad_block_destroy_data (gpointer data)
{
    PyGILState_STATE state;
    PyObject *py_data = (PyObject *) data;
    
    state = pyg_gil_state_ensure();
 
    Py_DECREF (py_data);

    pyg_gil_state_release(state);
}
#endif

static void
pad_block_callback_marshal(GstPad *pad, gboolean blocked, gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args;
    PyObject *ret;
    PyObject *py_user_data;

    g_return_if_fail(user_data != NULL);

    state = pyg_gil_state_ensure();

    py_user_data = (PyObject *) user_data;

    callback = PyTuple_GetItem(py_user_data, 0);
    args = Py_BuildValue("(NO)",
             pygobject_new(G_OBJECT(pad)),
             blocked ? Py_True : Py_False);
    
    {
        PyObject *tmp = args;
        args = PySequence_Concat(tmp, PyTuple_GetItem(py_user_data, 1));
        Py_DECREF (tmp);
    }

    ret = PyObject_CallObject(callback, args);
    Py_DECREF(args);

    if (!ret)
        PyErr_Print();
    else
        Py_DECREF(ret);
    
    pyg_gil_state_release(state);
}

static PyObject *
_wrap_gst_pad_set_blocked_async (PyGObject *self, PyObject *args)
{
    PyObject *callback, *cbargs = NULL, *data;
    PyObject    *pblocked, *pret;
    gboolean    blocked;
    gboolean    ret;
    gint    len;

    len = PyTuple_Size(args);

    if (len < 2) {
        PyErr_SetString(PyExc_TypeError, "Requires at least 2 arg");
        return NULL;
    }
    pblocked = PyTuple_GetItem(args, 0);
    blocked = PyObject_IsTrue(pblocked);

    callback = PyTuple_GetItem(args, 1);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "callback is not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 2, len);
    if (cbargs == NULL)
        return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
        return NULL;
    pyg_begin_allow_threads;
#if HAVE_SET_BLOCKED_ASYNC_FULL
    ret = gst_pad_set_blocked_async_full (GST_PAD (self->obj), blocked,
        (GstPadBlockCallback) pad_block_callback_marshal, data,
				pad_block_destroy_data);
#else
    ret = gst_pad_set_blocked_async (GST_PAD (self->obj), blocked,
        (GstPadBlockCallback) pad_block_callback_marshal, data);
#endif
    pyg_end_allow_threads;
    if (ret)
        pret = Py_True;
    else
        pret = Py_False;
    Py_INCREF(pret);

    return pret;
}
%%
override gst_pad_set_caps kwargs
static PyObject *
_wrap_gst_pad_set_caps(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "caps", NULL };
    PyObject *py_caps;
    int ret;
    GstCaps *caps;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GstPad.set_caps", kwlist, &py_caps))
        return NULL;
    if (py_caps == Py_None) {
	caps = NULL;
    } else {
	caps = pygst_caps_from_pyobject (py_caps, NULL);
	if (PyErr_Occurred())
	    return NULL;
    }
    pyg_begin_allow_threads;
    ret = gst_pad_set_caps(GST_PAD(self->obj), caps);
    if (ret && caps)
	gst_caps_unref (caps);
    pyg_end_allow_threads;
    return PyBool_FromLong(ret);

}
%%
override gst_pad_query_peer_position args
static PyObject *
_wrap_gst_pad_query_peer_position (PyGObject *self, PyObject *args)
{
    gint64    cur;
    gint    format;
    PyObject    *pformat;
    PyObject    *ret;

    pformat = (PyObject*)PyTuple_GetItem(args, 0);
    if (pyg_enum_get_value (GST_TYPE_FORMAT, pformat, &format)) {
        PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
        return NULL;
    }

    if ((gst_pad_query_peer_position(GST_PAD (self->obj), (GstFormat*) &format, &cur))) {
        ret = PyList_New(2);
        PyList_SetItem(ret, 0, PyLong_FromLongLong(cur));
        PyList_SetItem(ret, 1, pyg_enum_from_gtype (GST_TYPE_FORMAT, format ));
    } else {
        Py_INCREF(Py_None);
        ret = Py_None;
    }

    return ret;
}
%%
override gst_pad_query_peer_duration args
static PyObject *
_wrap_gst_pad_query_peer_duration (PyGObject *self, PyObject *args)
{
    gint64    cur;
    gint    format;
    PyObject    *pformat;
    PyObject    *ret;

    pformat = (PyObject*)PyTuple_GetItem(args, 0);
    if (pyg_enum_get_value (GST_TYPE_FORMAT, pformat, &format)) {
        PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
        return NULL;
    }

    if ((gst_pad_query_peer_duration(GST_PAD (self->obj), (GstFormat*) &format, &cur))) {
        ret = PyList_New(2);
        PyList_SetItem(ret, 0, PyLong_FromLongLong(cur));
        PyList_SetItem(ret, 1, pyg_enum_from_gtype (GST_TYPE_FORMAT, format ));
    } else {
        Py_INCREF(Py_None);
        ret = Py_None;
    }

    return ret;
}
%%
override gst_pad_query_peer_convert kwargs
static PyObject *
_wrap_gst_pad_query_peer_convert (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fromformat", "fromvalue", "destformat", NULL };
    PyObject    *pfromformat, *pdestformat;
    GstFormat    srcformat, destformat;
    gint64    fromval, dstval;
    PyObject    *ret;

    /* Input : src_format, src_val, dst_format */
    /* Returns : dst_format, dst_val OR None */

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                     "0L0:GstPad.query_peer_convert",
                     kwlist, &pfromformat, &fromval, &pdestformat))
    return NULL;
    if (pyg_enum_get_value(GST_TYPE_FORMAT, pfromformat, (gint *) &srcformat)) {
    PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
    return NULL;
    }
    if (pyg_enum_get_value(GST_TYPE_FORMAT, pdestformat, (gint *) &destformat)) {
    PyErr_SetString(PyExc_TypeError, "argument should be a GstFormat");
    return NULL;
    }

    if (!(gst_pad_query_peer_convert (GST_PAD(self->obj),
                 srcformat, fromval,
                 &destformat, &dstval))) {
    Py_INCREF(Py_None);
    return Py_None;
    }
    
    ret = PyList_New(2);
    PyList_SetItem(ret, 0, pyg_enum_from_gtype (GST_TYPE_FORMAT, destformat));
    PyList_SetItem(ret, 1, PyLong_FromLongLong(dstval));

    return ret;
}
%%
override-attr GstStaticPadTemplate.static_caps
static PyObject *
_wrap_gst_static_pad_template__get_static_caps(PyObject *self, void *closure)
{
    GstStaticPadTemplate *templ;


    templ = pyg_pointer_get(self, GstStaticPadTemplate);
    return pyg_pointer_new(GST_TYPE_STATIC_CAPS, &(templ->static_caps));
}
%%
override gst_pad_start_task args
static void
pad_task_handler(void *data) {
    PyGILState_STATE state;
    PyObject *callback, *args = NULL;
    PyObject *py_user_data;

    if (data == NULL)
	return;

    state = pyg_gil_state_ensure();
    py_user_data = (PyObject*) data;

    callback = PyTuple_GetItem(py_user_data, 0);
    if (!(PyCallable_Check(callback))) {
	PyErr_Print();
	goto beach;
    }
    if (!(args = PyTuple_GetSlice(py_user_data, 1, PyTuple_Size(py_user_data)))) {
	PyErr_Print();
	goto beach;
    }

    if (!(PyTuple_Check(args))) {
	PyErr_Print();
	goto beach;
    }

    PyObject_CallObject(callback, args);

    if(PyErr_Occurred())
	PyErr_Print();

    Py_DECREF(args);

 beach:
    pyg_gil_state_release(state);
}

static PyObject *
_wrap_gst_pad_start_task(PyGObject *self, PyObject *args)
{
    PyObject *callback, *data, *cbargs, *py_ret;
    gboolean ret;

    /* 1st argument must be a callable */
    if (PyTuple_Size(args) < 1) {
	PyErr_SetString(PyExc_TypeError, "gst.Pad.start_task() requires at least 1 argument");
	return NULL;
    }

    callback = PySequence_GetItem(args, 0);
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be a function or method");
	Py_DECREF(callback);
	return NULL;
    }
    
    if (!(cbargs = PySequence_GetSlice(args, 1, PyTuple_Size(args)))) {
	Py_DECREF(callback);
	return NULL;
    }

    if (!(data = Py_BuildValue("(ON)", callback, cbargs))) {
	Py_DECREF(callback);
	Py_DECREF(cbargs);
	return NULL;
    }
    
    pyg_begin_allow_threads;
    ret = gst_pad_start_task(GST_PAD(self->obj), (GstTaskFunction) pad_task_handler, data);
    pyg_end_allow_threads;

    if (ret == TRUE)
	py_ret = Py_True;
    else
	py_ret = Py_False;

    Py_INCREF(py_ret);
    return py_ret;
}
%%
override gst_static_pad_template_get_caps noargs
static PyObject *
_wrap_gst_static_pad_template_get_caps(PyObject *self)
{
    GstCaps *ret;

    ret = gst_static_pad_template_get_caps(pyg_pointer_get(self, GstStaticPadTemplate));
    /* We take a copy of the caps so they don't disappear */
    ret = gst_caps_copy(ret);
    return pyg_boxed_new (GST_TYPE_CAPS, ret, FALSE, TRUE);
}
