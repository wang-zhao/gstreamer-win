/* -- THIS FILE IS GENERATED - DO NOT EDIT *//* -*- Mode: C; c-basic-offset: 4 -*- */

#define PY_SSIZE_T_CLEAN
#include <Python.h>




#if PY_VERSION_HEX < 0x02050000
typedef int Py_ssize_t;
#define PY_SSIZE_T_MAX INT_MAX
#define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intobjargproc ssizeobjargproc;
#endif


#line 24 "./gtk.override"
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"

#include <fcntl.h>
#include <locale.h>

#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gdk-pixbuf/gdk-pixdata.h>

#include <pycairo.h>
extern Pycairo_CAPI_t *Pycairo_CAPI;
extern PyTypeObject PyGdkCairoContext_Type;

#include "pygtk-private.h"

#define PYGTK_CONTAINER_FOREACH 0
#define PYGTK_CONTAINER_FORALL 1
#define countof(array) (sizeof(array)/sizeof(array[0]))

/* make GDK_DISPLAY() the case macro */
#undef GDK_DISPLAY
#define GDK_DISPLAY(object) (GDK_DISPLAY_OBJECT(object))

/* from the gdk portion ... */
extern PyTypeObject PyGdkColormap_Type;
extern PyTypeObject PyGdkGC_Type;
extern PyTypeObject PyGdkWindow_Type;
extern PyTypeObject PyGdkPixmap_Type;
extern PyTypeObject PyGdkImage_Type;
extern PyTypeObject PyGdkPixbuf_Type;
extern PyTypeObject PyGdkPixbufAnimation_Type;
extern PyTypeObject PyGdkDragContext_Type;
extern PyTypeObject PyGdkDrawable_Type;
extern PyTypeObject PyGdkDisplay_Type;
extern PyTypeObject PyGdkScreen_Type;
extern PyTypeObject PyGdkRectangle_Type;
extern PyTypeObject PyGdkDevice_Type;

extern PyObject *PyGtkWarning;

#ifndef pyg_add_warning_redirection

static guint _gtk_handler = -1, _gdk_handler = -1, _gdk_pixbuf_handler = -1;

static void
_pygtk_log_func(const gchar *log_domain,
                GLogLevelFlags log_level,
                const gchar *message,
                gpointer user_data)
 {
    if (G_LIKELY(Py_IsInitialized()))
    {
        PyGILState_STATE state;
        
        state = pyg_gil_state_ensure();
        PyErr_Warn(PyGtkWarning, (char *) message);
        pyg_gil_state_release(state);
    } else
        g_log_default_handler(log_domain, log_level, message, user_data);
}

#endif /* ifndef pyg_add_warning_redirection */

static gboolean
pygtk_util_pyobject_as_double(PyObject *obj, gdouble *value, const char *argument_name)
{
    PyObject *number;

    if (!PyNumber_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "'%s' must be a number", argument_name);
        return FALSE;
    }
    number = PyNumber_Float(obj);
    if (!number) {
        PyErr_Format(PyExc_TypeError, "Could not convert '%s' to a float", argument_name);
        return FALSE;
    }
    *value = PyFloat_AsDouble(number);
    Py_DECREF(number);
    return TRUE;
}

static gboolean
_main_quit(GIOChannel* source, GIOCondition condition, gpointer data)
{
    gtk_main_quit();
    return FALSE;
}

static int _loop(void)
{
    PyGILState_STATE gstate;
    GIOChannel* channel;

    /* Watch for input on stdin */
    channel = g_io_channel_unix_new(fileno(stdin));
    g_io_add_watch(channel, G_IO_IN, _main_quit, NULL);
    g_io_channel_unref(channel);

    /* Start the main loop */
    gstate = PyGILState_Ensure();
    gtk_main();
    PyGILState_Release(gstate);

    return 0;
}


#line 25 "gtkbuilder.override"

static gboolean
pylist_to_strv (PyObject *list,
                char   ***strvp)
{
    int i, len;
    char **ret;

    *strvp = NULL;

    if (list == Py_None)
        return TRUE;

    if (!PySequence_Check (list))
    {
        PyErr_Format (PyExc_TypeError,
		      "argument must be a list or tuple of strings");
        return FALSE;
    }

    if ((len = PySequence_Size (list)) < 0)
        return FALSE;

    ret = g_new (char*, len + 1);
    for (i = 0; i <= len; ++i)
        ret[i] = NULL;

    for (i = 0; i < len; ++i)
    {
        PyObject *item = PySequence_GetItem (list, i);

        if (!item)
        {
            g_strfreev (ret);
            return FALSE;
        }

        if (!PyString_Check (item))
        {
            Py_DECREF (item);
            g_strfreev (ret);
            PyErr_Format (PyExc_TypeError,
			  "argument must be a list of strings");
            return FALSE;
        }

        ret[i] = g_strdup (PyString_AsString (item));
        Py_DECREF (item);
    }

    *strvp = ret;
    return TRUE;
}

typedef struct{
    PyObject    *obj;
    PyObject    *data;
    PyObject    *missing_handlers;
    gboolean     exception_pending;
} PyGCustomSignalNotify;


#line 24 "gtktreeview.override"
#include "pygtktreemodel.h"
#include "pygtkcellrenderer.h"

static void
pygtk_cell_data_func_marshal (GtkCellLayout *cell_layout,
                              GtkCellRenderer   *cell,
                              GtkTreeModel      *tree_model,
                              GtkTreeIter       *iter,
			      gpointer           data);

#line 204 "gtk.c"


/* ---------- types from other modules ---------- */
static PyTypeObject *_PyGObject_Type;
#define PyGObject_Type (*_PyGObject_Type)
static PyTypeObject *_PyAtkObject_Type;
#define PyAtkObject_Type (*_PyAtkObject_Type)
static PyTypeObject *_PyPangoContext_Type;
#define PyPangoContext_Type (*_PyPangoContext_Type)
static PyTypeObject *_PyPangoFont_Type;
#define PyPangoFont_Type (*_PyPangoFont_Type)
static PyTypeObject *_PyPangoLayout_Type;
#define PyPangoLayout_Type (*_PyPangoLayout_Type)
static PyTypeObject *_PyGFile_Type;
#define PyGFile_Type (*_PyGFile_Type)
static PyTypeObject *_PyGIcon_Type;
#define PyGIcon_Type (*_PyGIcon_Type)
static PyTypeObject *_PyGMountOperation_Type;
#define PyGMountOperation_Type (*_PyGMountOperation_Type)


/* ---------- forward type declarations ---------- */
PyTypeObject G_GNUC_INTERNAL PyGtkBorder_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkIconInfo_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkIconSet_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkIconSource_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRequisition_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkSelectionData_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTextAttributes_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTextIter_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeIter_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeRowReference_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkPaperSize_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRecentInfo_Type;
PyTypeObject G_GNUC_INTERNAL PyPyGtkGenericTreeModel_Type;
PyTypeObject G_GNUC_INTERNAL PyPyGtkGenericCellRenderer_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkAboutDialog_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkAccelGroup_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkAccelLabel_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkAccelMap_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkAccessible_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkAction_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkActionGroup_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkAdjustment_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkAlignment_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkArrow_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkAspectFrame_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkBin_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkBox_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkButtonBox_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCalendar_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellRenderer_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererCombo_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererPixbuf_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererProgress_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererText_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererToggle_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellView_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCheckButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCheckMenuItem_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkClipboard_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCList_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkColorButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkColorSelection_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkColorSelectionDialog_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCombo_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkComboBox_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkComboBoxEntry_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkContainer_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCTree_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCurve_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkDialog_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkDrawingArea_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkEntry_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkEntryCompletion_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkEventBox_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkExpander_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFileChooserButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFileChooserDialog_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFileChooserWidget_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFileFilter_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFileSelection_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFixed_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFontButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFontSelection_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFontSelectionDialog_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFrame_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkGammaCurve_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkHandleBox_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkHBox_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkHButtonBox_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkHPaned_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkHRuler_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkHScale_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkHScrollbar_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkHSeparator_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkIconFactory_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkIconTheme_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkIconView_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkImage_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkImageMenuItem_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkIMContext_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkIMContextSimple_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkIMMulticontext_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkInputDialog_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkInvisible_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkItem_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkItemFactory_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkLabel_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkLayout_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkList_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkListItem_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkListStore_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkMenu_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkMenuBar_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkMenuItem_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkMenuShell_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkMenuToolButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkMessageDialog_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkMisc_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkNotebook_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkObject_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkOldEditable_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkOptionMenu_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkPaned_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkPixmap_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkPlug_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkPreview_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkProgress_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkProgressBar_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRadioAction_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRadioButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRadioMenuItem_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRadioToolButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRange_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRcStyle_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRuler_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkScale_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkScrollbar_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkScrolledWindow_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkSeparator_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkSeparatorMenuItem_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkSeparatorToolItem_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkSettings_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkSizeGroup_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkSocket_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkSpinButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkStatusbar_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkStyle_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTable_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTearoffMenuItem_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTextBuffer_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTextChildAnchor_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTextMark_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTextTag_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTextTagTable_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTextView_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkToggleAction_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkToggleButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkToggleToolButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkToolbar_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkToolButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkToolItem_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTooltips_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeModelFilter_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeModelSort_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeSelection_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeStore_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeView_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeViewColumn_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkUIManager_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkVBox_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkVButtonBox_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkViewport_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkVPaned_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkVRuler_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkVScale_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkVScrollbar_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkVSeparator_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkWidget_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkWindow_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkWindowGroup_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkAssistant_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererAccel_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererSpin_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkLinkButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkPageSetup_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkPrintContext_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkPrintOperation_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkPrintSettings_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRecentChooserDialog_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRecentChooserMenu_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRecentChooserWidget_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRecentFilter_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRecentManager_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkStatusIcon_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkBuilder_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRecentAction_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkScaleButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTooltip_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkVolumeButton_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkMountOperation_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkEntryBuffer_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkInfoBar_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkHSV_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkToolItemGroup_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkToolPalette_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererSpinner_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkOffscreenWindow_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkSpinner_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellEditable_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkCellLayout_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkEditable_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkFileChooser_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeDragDest_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeDragSource_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeModel_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkTreeSortable_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkPrintOperationPreview_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkRecentChooser_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkBuildable_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkToolShell_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkActivatable_Type;
PyTypeObject G_GNUC_INTERNAL PyGtkOrientable_Type;

#line 431 "gtk.c"



/* ----------- GtkBorder ----------- */

#line 24 "gtkborder.override"
static int
_wrap_gtk_border_new(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "left", "right", "top", "bottom", NULL };
    GtkBorder border = {0, 0, 0, 0};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|iiii:GdkRectangle.__init__",
				     kwlist, &border.left, &border.right,
				     &border.top, &border.bottom))
	return -1;

    self->boxed = g_boxed_copy(GTK_TYPE_BORDER, &border);
    self->free_on_dealloc = TRUE;
    self->gtype = GTK_TYPE_BORDER;
    
    return 0;
}
#line 456 "gtk.c"


static PyObject *
_wrap_gtk_border_copy(PyObject *self)
{
    GtkBorder *ret;

    
    ret = gtk_border_copy(pyg_boxed_get(self, GtkBorder));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_BORDER, ret, FALSE, TRUE);
}

#line 6834 "./gtk.override"
static PyObject *
_wrap_gtk_border_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Border.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
#line 480 "gtk.c"


static const PyMethodDef _PyGtkBorder_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_border_copy, METH_NOARGS,
      NULL },
    { "free", (PyCFunction)_wrap_gtk_border_free, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 109 "gtkborder.override"
static int
_wrap_gtk_border__set_left(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkBorder)->left = val;
    return 0;
}
#line 503 "gtk.c"


static PyObject *
_wrap_gtk_border__get_left(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkBorder)->left;
    return PyInt_FromLong(ret);
}

#line 122 "gtkborder.override"
static int
_wrap_gtk_border__set_right(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkBorder)->right = val;
    return 0;
}
#line 527 "gtk.c"


static PyObject *
_wrap_gtk_border__get_right(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkBorder)->right;
    return PyInt_FromLong(ret);
}

#line 135 "gtkborder.override"
static int
_wrap_gtk_border__set_top(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkBorder)->top = val;
    return 0;
}
#line 551 "gtk.c"


static PyObject *
_wrap_gtk_border__get_top(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkBorder)->top;
    return PyInt_FromLong(ret);
}

#line 148 "gtkborder.override"
static int
_wrap_gtk_border__set_bottom(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkBorder)->bottom = val;
    return 0;
}

#line 576 "gtk.c"


static PyObject *
_wrap_gtk_border__get_bottom(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkBorder)->bottom;
    return PyInt_FromLong(ret);
}

static const PyGetSetDef gtk_border_getsets[] = {
    { "left", (getter)_wrap_gtk_border__get_left, (setter)_wrap_gtk_border__set_left },
    { "right", (getter)_wrap_gtk_border__get_right, (setter)_wrap_gtk_border__set_right },
    { "top", (getter)_wrap_gtk_border__get_top, (setter)_wrap_gtk_border__set_top },
    { "bottom", (getter)_wrap_gtk_border__get_bottom, (setter)_wrap_gtk_border__set_bottom },
    { NULL, (getter)0, (setter)0 },
};

#line 44 "gtkborder.override"
static Py_ssize_t
_wrap_gtk_border_length(PyGBoxed *self)
{
    return 4;
}
static PyObject *
_wrap_gtk_border_getitem(PyGBoxed *self, Py_ssize_t pos)
{
    GtkBorder *border;

    if (pos < 0)
        pos += 4;
    if (pos < 0 || pos >= 4) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return NULL;
    }
    border = pyg_boxed_get(self, GtkBorder);
    switch (pos) {
    case 0: return PyInt_FromLong(border->left);
    case 1: return PyInt_FromLong(border->right);
    case 2: return PyInt_FromLong(border->top);
    case 3: return PyInt_FromLong(border->bottom);
    default:
        g_assert_not_reached();
        return NULL;
    }
}
static int
_wrap_gtk_border_setitem(PyGBoxed *self, Py_ssize_t pos, PyObject *value)
{
    GtkBorder *border;
    gint val;

    if (pos < 0)
        pos += 4;
    if (pos < 0 || pos >= 4) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return -1;
    }
    border = pyg_boxed_get(self, GtkBorder);
    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    switch(pos) {
    case 0: border->left   = val; break;
    case 1: border->right  = val; break;
    case 2: border->top    = val; break;
    case 3: border->bottom = val; break;
    default:
        g_assert_not_reached();
        return -1;
    }
    return 0;
}
static PySequenceMethods _wrap_gtk_border_tp_as_sequence = {
    (lenfunc)_wrap_gtk_border_length,
    0,
    0,
    (ssizeargfunc)_wrap_gtk_border_getitem,
    0,
    (ssizeobjargproc)_wrap_gtk_border_setitem,
    0,
};
#line 660 "gtk.c"


PyTypeObject G_GNUC_INTERNAL PyGtkBorder_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Border",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)&_wrap_gtk_border_tp_as_sequence, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkBorder_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_border_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_gtk_border_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkIconInfo ----------- */

static int
pygobject_no_constructor(PyObject *self, PyObject *args, PyObject *kwargs)
{
    gchar buf[512];

    g_snprintf(buf, sizeof(buf), "%s is an abstract widget", self->ob_type->tp_name);
    PyErr_SetString(PyExc_NotImplementedError, buf);
    return -1;
}

static PyObject *
_wrap_gtk_icon_info_copy(PyObject *self)
{
    GtkIconInfo *ret;

    
    ret = gtk_icon_info_copy(pyg_boxed_get(self, GtkIconInfo));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_ICON_INFO, ret, FALSE, TRUE);
}

#line 6784 "./gtk.override"
static PyObject *
_wrap_gtk_icon_info_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.IconInfo.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
#line 743 "gtk.c"


static PyObject *
_wrap_gtk_icon_info_get_base_size(PyObject *self)
{
    int ret;

    
    ret = gtk_icon_info_get_base_size(pyg_boxed_get(self, GtkIconInfo));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_info_get_filename(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_icon_info_get_filename(pyg_boxed_get(self, GtkIconInfo));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_info_get_builtin_pixbuf(PyObject *self)
{
    GdkPixbuf *ret;

    
    ret = gtk_icon_info_get_builtin_pixbuf(pyg_boxed_get(self, GtkIconInfo));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_icon_info_load_icon(PyObject *self)
{
    GdkPixbuf *ret;
    GError *error = NULL;

    
    ret = gtk_icon_info_load_icon(pyg_boxed_get(self, GtkIconInfo), &error);
    
    if (pyg_error_check(&error))
        return NULL;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_icon_info_set_raw_coordinates(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "raw_coordinates", NULL };
    int raw_coordinates;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconInfo.set_raw_coordinates", kwlist, &raw_coordinates))
        return NULL;
    
    gtk_icon_info_set_raw_coordinates(pyg_boxed_get(self, GtkIconInfo), raw_coordinates);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 5297 "./gtk.override"
static PyObject *
_wrap_gtk_icon_info_get_embedded_rect(PyGObject *self)
{
    GdkRectangle rect;
    int ret;

    ret = gtk_icon_info_get_embedded_rect(pyg_boxed_get(self, GtkIconInfo),
					  &rect);

    if (ret)
	return pyg_boxed_new(GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 829 "gtk.c"


#line 5314 "./gtk.override"
static PyObject *
_wrap_gtk_icon_info_get_attach_points(PyGObject *self)
{
    GdkPoint *points;
    gint n_points;
    int ret;
    PyObject *py_points;

    ret = gtk_icon_info_get_attach_points(pyg_boxed_get(self, GtkIconInfo),
					  &points, &n_points);
    if (ret) {
	int i;

	py_points = PyTuple_New(n_points);
	for (i = 0; i < n_points; i++)
	    PyTuple_SetItem(py_points, i, Py_BuildValue("(ii)",
							points[i].x,
							points[i].y));
	g_free(points);
	return py_points;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 858 "gtk.c"


static PyObject *
_wrap_gtk_icon_info_get_display_name(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_icon_info_get_display_name(pyg_boxed_get(self, GtkIconInfo));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkIconInfo_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_icon_info_copy, METH_NOARGS,
      NULL },
    { "free", (PyCFunction)_wrap_gtk_icon_info_free, METH_NOARGS,
      NULL },
    { "get_base_size", (PyCFunction)_wrap_gtk_icon_info_get_base_size, METH_NOARGS,
      NULL },
    { "get_filename", (PyCFunction)_wrap_gtk_icon_info_get_filename, METH_NOARGS,
      NULL },
    { "get_builtin_pixbuf", (PyCFunction)_wrap_gtk_icon_info_get_builtin_pixbuf, METH_NOARGS,
      NULL },
    { "load_icon", (PyCFunction)_wrap_gtk_icon_info_load_icon, METH_NOARGS,
      NULL },
    { "set_raw_coordinates", (PyCFunction)_wrap_gtk_icon_info_set_raw_coordinates, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_embedded_rect", (PyCFunction)_wrap_gtk_icon_info_get_embedded_rect, METH_NOARGS,
      NULL },
    { "get_attach_points", (PyCFunction)_wrap_gtk_icon_info_get_attach_points, METH_NOARGS,
      NULL },
    { "get_display_name", (PyCFunction)_wrap_gtk_icon_info_get_display_name, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkIconInfo_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.IconInfo",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkIconInfo_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)pygobject_no_constructor,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkIconSet ----------- */

#line 2957 "./gtk.override"
static int
_wrap_gtk_icon_set_new_from_pixbuf(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkIconSet.__init__", kwlist, &pixbuf))
        return -1;
    if (pixbuf && !pygobject_check(pixbuf, &PyGdkPixbuf_Type)) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf");
        return -1;
    }
    self->gtype = GTK_TYPE_ICON_SET;
    self->free_on_dealloc = FALSE;
    if (pixbuf)
        self->boxed = gtk_icon_set_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
    else
        self->boxed = gtk_icon_set_new();

    if (!self->boxed) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkIconSet object");
        return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}
#line 975 "gtk.c"


static PyObject *
_wrap_gtk_icon_set_copy(PyObject *self)
{
    GtkIconSet *ret;

    
    ret = gtk_icon_set_copy(pyg_boxed_get(self, GtkIconSet));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_ICON_SET, ret, FALSE, TRUE);
}

static PyObject *
_wrap_gtk_icon_set_render_icon(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "style", "direction", "state", "size", "widget", "detail", NULL };
    PyObject *py_direction = NULL, *py_state = NULL, *py_size = NULL;
    GdkPixbuf *ret;
    char *detail = NULL;
    GtkTextDirection direction;
    GtkIconSize size;
    GtkWidget *widget = NULL;
    PyGObject *style, *py_widget = NULL;
    GtkStateType state;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOO|Oz:Gtk.IconSet.render_icon", kwlist, &PyGtkStyle_Type, &style, &py_direction, &py_state, &py_size, &py_widget, &detail))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, py_direction, (gpointer)&direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state, (gpointer)&state))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    if ((PyObject *)py_widget == Py_None)
        widget = NULL;
    else if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if (py_widget) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    ret = gtk_icon_set_render_icon(pyg_boxed_get(self, GtkIconSet), GTK_STYLE(style->obj), direction, state, size, (GtkWidget *) widget, detail);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_icon_set_add_source(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "source", NULL };
    PyObject *py_source;
    GtkIconSource *source = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconSet.add_source", kwlist, &py_source))
        return NULL;
    if (pyg_boxed_check(py_source, GTK_TYPE_ICON_SOURCE))
        source = pyg_boxed_get(py_source, GtkIconSource);
    else {
        PyErr_SetString(PyExc_TypeError, "source should be a GtkIconSource");
        return NULL;
    }
    
    gtk_icon_set_add_source(pyg_boxed_get(self, GtkIconSet), source);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2985 "./gtk.override"
static PyObject *
_wrap_gtk_icon_set_get_sizes(PyGObject *self)
{
    GtkIconSize *sizes;
    int i, n_sizes;
    PyObject *ret;

    gtk_icon_set_get_sizes(pyg_boxed_get(self, GtkIconSet), &sizes, &n_sizes);

    ret = PyTuple_New(n_sizes);
    for (i = 0; i < n_sizes; i++)
        PyTuple_SetItem(ret, i, PyInt_FromLong(sizes[i]));
    g_free(sizes);

    return ret;
}
#line 1065 "gtk.c"


static const PyMethodDef _PyGtkIconSet_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_icon_set_copy, METH_NOARGS,
      NULL },
    { "render_icon", (PyCFunction)_wrap_gtk_icon_set_render_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_source", (PyCFunction)_wrap_gtk_icon_set_add_source, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_sizes", (PyCFunction)_wrap_gtk_icon_set_get_sizes, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkIconSet_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.IconSet",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkIconSet_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_gtk_icon_set_new_from_pixbuf,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkIconSource ----------- */

static int
_wrap_gtk_icon_source_new(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,":Gtk.IconSource.__init__", kwlist))
        return -1;
    self->gtype = GTK_TYPE_ICON_SOURCE;
    self->free_on_dealloc = FALSE;
    self->boxed = gtk_icon_source_new();

    if (!self->boxed) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkIconSource object");
        return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}

static PyObject *
_wrap_gtk_icon_source_copy(PyObject *self)
{
    GtkIconSource *ret;

    
    ret = gtk_icon_source_copy(pyg_boxed_get(self, GtkIconSource));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_ICON_SOURCE, ret, FALSE, TRUE);
}

#line 6794 "./gtk.override"
static PyObject *
_wrap_gtk_icon_source_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.IconSource.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
#line 1169 "gtk.c"


static PyObject *
_wrap_gtk_icon_source_set_filename(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.IconSource.set_filename", kwlist, &filename))
        return NULL;
    
    gtk_icon_source_set_filename(pyg_boxed_get(self, GtkIconSource), filename);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_set_icon_name(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    char *icon_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.IconSource.set_icon_name", kwlist, &icon_name))
        return NULL;
    
    gtk_icon_source_set_icon_name(pyg_boxed_get(self, GtkIconSource), icon_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_set_pixbuf(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IconSource.set_pixbuf", kwlist, &PyGdkPixbuf_Type, &pixbuf))
        return NULL;
    
    gtk_icon_source_set_pixbuf(pyg_boxed_get(self, GtkIconSource), GDK_PIXBUF(pixbuf->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_get_filename(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_icon_source_get_filename(pyg_boxed_get(self, GtkIconSource));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_get_icon_name(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_icon_source_get_icon_name(pyg_boxed_get(self, GtkIconSource));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_get_pixbuf(PyObject *self)
{
    GdkPixbuf *ret;

    
    ret = gtk_icon_source_get_pixbuf(pyg_boxed_get(self, GtkIconSource));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_icon_source_set_direction_wildcarded(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconSource.set_direction_wildcarded", kwlist, &setting))
        return NULL;
    
    gtk_icon_source_set_direction_wildcarded(pyg_boxed_get(self, GtkIconSource), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_set_state_wildcarded(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconSource.set_state_wildcarded", kwlist, &setting))
        return NULL;
    
    gtk_icon_source_set_state_wildcarded(pyg_boxed_get(self, GtkIconSource), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_set_size_wildcarded(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconSource.set_size_wildcarded", kwlist, &setting))
        return NULL;
    
    gtk_icon_source_set_size_wildcarded(pyg_boxed_get(self, GtkIconSource), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_get_size_wildcarded(PyObject *self)
{
    int ret;

    
    ret = gtk_icon_source_get_size_wildcarded(pyg_boxed_get(self, GtkIconSource));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_icon_source_get_state_wildcarded(PyObject *self)
{
    int ret;

    
    ret = gtk_icon_source_get_state_wildcarded(pyg_boxed_get(self, GtkIconSource));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_icon_source_get_direction_wildcarded(PyObject *self)
{
    int ret;

    
    ret = gtk_icon_source_get_direction_wildcarded(pyg_boxed_get(self, GtkIconSource));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_icon_source_set_direction(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "direction", NULL };
    GtkTextDirection direction;
    PyObject *py_direction = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconSource.set_direction", kwlist, &py_direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, py_direction, (gpointer)&direction))
        return NULL;
    
    gtk_icon_source_set_direction(pyg_boxed_get(self, GtkIconSource), direction);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_set_state(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "state", NULL };
    PyObject *py_state = NULL;
    GtkStateType state;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconSource.set_state", kwlist, &py_state))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state, (gpointer)&state))
        return NULL;
    
    gtk_icon_source_set_state(pyg_boxed_get(self, GtkIconSource), state);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_set_size(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    PyObject *py_size = NULL;
    GtkIconSize size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconSource.set_size", kwlist, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    gtk_icon_source_set_size(pyg_boxed_get(self, GtkIconSource), size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_source_get_direction(PyObject *self)
{
    gint ret;

    
    ret = gtk_icon_source_get_direction(pyg_boxed_get(self, GtkIconSource));
    
    return pyg_enum_from_gtype(GTK_TYPE_TEXT_DIRECTION, ret);
}

static PyObject *
_wrap_gtk_icon_source_get_state(PyObject *self)
{
    gint ret;

    
    ret = gtk_icon_source_get_state(pyg_boxed_get(self, GtkIconSource));
    
    return pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, ret);
}

static PyObject *
_wrap_gtk_icon_source_get_size(PyObject *self)
{
    gint ret;

    
    ret = gtk_icon_source_get_size(pyg_boxed_get(self, GtkIconSource));
    
    return pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, ret);
}

static const PyMethodDef _PyGtkIconSource_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_icon_source_copy, METH_NOARGS,
      NULL },
    { "free", (PyCFunction)_wrap_gtk_icon_source_free, METH_NOARGS,
      NULL },
    { "set_filename", (PyCFunction)_wrap_gtk_icon_source_set_filename, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_name", (PyCFunction)_wrap_gtk_icon_source_set_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_pixbuf", (PyCFunction)_wrap_gtk_icon_source_set_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_filename", (PyCFunction)_wrap_gtk_icon_source_get_filename, METH_NOARGS,
      NULL },
    { "get_icon_name", (PyCFunction)_wrap_gtk_icon_source_get_icon_name, METH_NOARGS,
      NULL },
    { "get_pixbuf", (PyCFunction)_wrap_gtk_icon_source_get_pixbuf, METH_NOARGS,
      NULL },
    { "set_direction_wildcarded", (PyCFunction)_wrap_gtk_icon_source_set_direction_wildcarded, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_state_wildcarded", (PyCFunction)_wrap_gtk_icon_source_set_state_wildcarded, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_size_wildcarded", (PyCFunction)_wrap_gtk_icon_source_set_size_wildcarded, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_size_wildcarded", (PyCFunction)_wrap_gtk_icon_source_get_size_wildcarded, METH_NOARGS,
      NULL },
    { "get_state_wildcarded", (PyCFunction)_wrap_gtk_icon_source_get_state_wildcarded, METH_NOARGS,
      NULL },
    { "get_direction_wildcarded", (PyCFunction)_wrap_gtk_icon_source_get_direction_wildcarded, METH_NOARGS,
      NULL },
    { "set_direction", (PyCFunction)_wrap_gtk_icon_source_set_direction, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_state", (PyCFunction)_wrap_gtk_icon_source_set_state, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_size", (PyCFunction)_wrap_gtk_icon_source_set_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_direction", (PyCFunction)_wrap_gtk_icon_source_get_direction, METH_NOARGS,
      NULL },
    { "get_state", (PyCFunction)_wrap_gtk_icon_source_get_state, METH_NOARGS,
      NULL },
    { "get_size", (PyCFunction)_wrap_gtk_icon_source_get_size, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkIconSource_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.IconSource",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkIconSource_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_gtk_icon_source_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkRequisition ----------- */

static PyObject *
_wrap_gtk_requisition_copy(PyObject *self)
{
    GtkRequisition *ret;

    
    ret = gtk_requisition_copy(pyg_boxed_get(self, GtkRequisition));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_REQUISITION, ret, FALSE, TRUE);
}

#line 6804 "./gtk.override"
static PyObject *
_wrap_gtk_requisition_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Requisition.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
#line 1539 "gtk.c"


static const PyMethodDef _PyGtkRequisition_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_requisition_copy, METH_NOARGS,
      NULL },
    { "free", (PyCFunction)_wrap_gtk_requisition_free, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 2146 "./gtk.override"
static int
_wrap_gtk_requisition__set_width(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkRequisition)->width = val;
    return 0;
}
#line 1562 "gtk.c"


static PyObject *
_wrap_gtk_requisition__get_width(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkRequisition)->width;
    return PyInt_FromLong(ret);
}

#line 2159 "./gtk.override"
static int
_wrap_gtk_requisition__set_height(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkRequisition)->height = val;
    return 0;
}
#line 1586 "gtk.c"


static PyObject *
_wrap_gtk_requisition__get_height(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkRequisition)->height;
    return PyInt_FromLong(ret);
}

static const PyGetSetDef gtk_requisition_getsets[] = {
    { "width", (getter)_wrap_gtk_requisition__get_width, (setter)_wrap_gtk_requisition__set_width },
    { "height", (getter)_wrap_gtk_requisition__get_height, (setter)_wrap_gtk_requisition__set_height },
    { NULL, (getter)0, (setter)0 },
};

#line 2087 "./gtk.override"
static Py_ssize_t
_wrap_gtk_requisition_length(PyGBoxed *self)
{
    return 2;
}
static PyObject *
_wrap_gtk_requisition_getitem(PyGBoxed *self, Py_ssize_t pos)
{
    GtkRequisition *requisition;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return NULL;
    }
    requisition = pyg_boxed_get(self, GtkRequisition);
    switch (pos) {
    case 0: return PyInt_FromLong(requisition->width);
    case 1: return PyInt_FromLong(requisition->height);
    default:
        g_assert_not_reached();
        return NULL;
    }
}
static int
_wrap_gtk_requisition_setitem(PyGBoxed *self, Py_ssize_t pos, PyObject *value)
{
    GtkRequisition *requisition;
    gint val;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return -1;
    }
    requisition = pyg_boxed_get(self, GtkRequisition);
    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    switch(pos) {
    case 0: requisition->width      = val; break;
    case 1: requisition->height     = val; break;
    default:
        g_assert_not_reached();
        return -1;
    }
    return 0;
}
static PySequenceMethods _wrap_gtk_requisition_tp_as_sequence = {
    (lenfunc)_wrap_gtk_requisition_length,
    0,
    0,
    (ssizeargfunc)_wrap_gtk_requisition_getitem,
    0,
    (ssizeobjargproc)_wrap_gtk_requisition_setitem,
    0,
};
#line 1662 "gtk.c"


PyTypeObject G_GNUC_INTERNAL PyGtkRequisition_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Requisition",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)&_wrap_gtk_requisition_tp_as_sequence, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRequisition_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_requisition_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)pygobject_no_constructor,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkSelectionData ----------- */

#line 610 "./gtk.override"
static PyObject *
_wrap_gtk_selection_data_set(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "format", "data", NULL };
    PyObject *py_type;
    GdkAtom type;
    int format;
    Py_ssize_t length;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Ois#:GtkSelectionData.set", kwlist,
                                     &py_type, &format, &data, &length))
        return NULL;
    type = pygdk_atom_from_pyobject(py_type);
    if (PyErr_Occurred())
        return NULL;

    gtk_selection_data_set(pyg_boxed_get(self, GtkSelectionData),
                           type, format, data, length);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 1738 "gtk.c"


static PyObject *
_wrap_gtk_selection_data_set_text(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "str", "len", NULL };
    char *str;
    int len = -1, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s|i:Gtk.SelectionData.set_text", kwlist, &str, &len))
        return NULL;
    
    ret = gtk_selection_data_set_text(pyg_boxed_get(self, GtkSelectionData), str, len);
    
    return PyBool_FromLong(ret);

}

#line 635 "./gtk.override"
static PyObject *
_wrap_gtk_selection_data_get_text(PyObject *self)
{
    gchar *ret;

    ret = (char*)gtk_selection_data_get_text(pyg_boxed_get(self,
							   GtkSelectionData));
    if (ret) {
        PyObject *py_ret = PyUnicode_DecodeUTF8(ret, strlen(ret), "strict");
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 1773 "gtk.c"


#line 652 "./gtk.override"
static PyObject *
_wrap_gtk_selection_data_get_targets(PyObject *self)
{
    GdkAtom *targets;
    gint n_atoms;

    if (gtk_selection_data_get_targets(pyg_boxed_get(self, GtkSelectionData),
                                       &targets, &n_atoms)) {
        PyObject *ret;
        gint i;

        ret = PyTuple_New(n_atoms);
        for (i = 0; i < n_atoms; i++) {
            gchar *name = gdk_atom_name(targets[i]);

            PyTuple_SetItem(ret, i, PyString_FromString(name));
            g_free(name);
        }
        g_free(targets);
        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 1801 "gtk.c"


static PyObject *
_wrap_gtk_selection_data_targets_include_text(PyObject *self)
{
    int ret;

    
    ret = gtk_selection_data_targets_include_text(pyg_boxed_get(self, GtkSelectionData));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_selection_data_set_pixbuf(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.SelectionData.set_pixbuf", kwlist, &PyGdkPixbuf_Type, &pixbuf))
        return NULL;
    
    ret = gtk_selection_data_set_pixbuf(pyg_boxed_get(self, GtkSelectionData), GDK_PIXBUF(pixbuf->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_selection_data_get_pixbuf(PyObject *self)
{
    GdkPixbuf *ret;

    
    ret = gtk_selection_data_get_pixbuf(pyg_boxed_get(self, GtkSelectionData));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 5897 "./gtk.override"
static PyObject *
_wrap_gtk_selection_data_set_uris(PyGBoxed *self, PyObject *args,
				  PyObject *kwargs)
{
    gchar **uris = NULL;
    static char *kwlist[] = { "uris", NULL };
    PyObject *py_uris = NULL;
    int i, n_uris;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkSelectionData.set_uris",
                                     kwlist, &py_uris))
        return NULL;

    if (!PySequence_Check(py_uris)) {
        PyErr_SetString(PyExc_TypeError, "uris must be a sequence");
        return NULL;
    }

    n_uris = PySequence_Length(py_uris);
    uris = g_new(gchar *, n_uris + 1);
    for (i = 0; i < n_uris; i++) {
        PyObject *item = PySequence_GetItem(py_uris, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        uris[i] = PyString_AsString(item);
    }
    uris[n_uris] = NULL;

    gtk_selection_data_set_uris(pyg_boxed_get(self, GtkSelectionData), uris);

    g_free(uris);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 1880 "gtk.c"


#line 5934 "./gtk.override"
static PyObject *
_wrap_gtk_selection_data_get_uris(PyGBoxed *self)
{
    gchar **uris, **tmp;
    int i = 0, j;
    PyObject *ret;

    uris = gtk_selection_data_get_uris(pyg_boxed_get(self, GtkSelectionData));
    if (!uris)
	return PyTuple_New(0);
    
    tmp = uris;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(uris[j]));

    return ret;
}
#line 1905 "gtk.c"


static PyObject *
_wrap_gtk_selection_data_targets_include_image(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "writable", NULL };
    int writable, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.SelectionData.targets_include_image", kwlist, &writable))
        return NULL;
    
    ret = gtk_selection_data_targets_include_image(pyg_boxed_get(self, GtkSelectionData), writable);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_set_row_drag_data(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tree_model", "path", NULL };
    PyGObject *tree_model;
    PyObject *py_path;
    int ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.SelectionData.tree_set_row_drag_data", kwlist, &PyGtkTreeModel_Type, &tree_model, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_set_row_drag_data(pyg_boxed_get(self, GtkSelectionData), GTK_TREE_MODEL(tree_model->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

#line 776 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_get_row_drag_data(PyObject *self)
{
    GtkTreeModel *tree_model;
    GtkTreePath *path;

    if (gtk_tree_get_row_drag_data(pyg_boxed_get(self, GtkSelectionData),
                                   &tree_model, &path)) {
        PyObject *ret = Py_BuildValue("(NN)",
                                      pygobject_new((GObject *)tree_model),
                                      pygtk_tree_path_to_pyobject(path));

        gtk_tree_path_free(path);
        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 1967 "gtk.c"


static PyObject *
_wrap_gtk_selection_data_targets_include_rich_text(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    PyGObject *buffer;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.SelectionData.targets_include_rich_text", kwlist, &PyGtkTextBuffer_Type, &buffer))
        return NULL;
    
    ret = gtk_selection_data_targets_include_rich_text(pyg_boxed_get(self, GtkSelectionData), GTK_TEXT_BUFFER(buffer->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_selection_data_targets_include_uri(PyObject *self)
{
    int ret;

    
    ret = gtk_selection_data_targets_include_uri(pyg_boxed_get(self, GtkSelectionData));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_selection_data_get_target(PyObject *self)
{
    PyObject * py_ret;
    gchar * name;
    GdkAtom ret;

    
    ret = gtk_selection_data_get_target(pyg_boxed_get(self, GtkSelectionData));
    
    name = gdk_atom_name(ret);
    py_ret = PyString_FromString(name);
    g_free(name);
    return py_ret;
}

static PyObject *
_wrap_gtk_selection_data_get_data_type(PyObject *self)
{
    PyObject * py_ret;
    gchar * name;
    GdkAtom ret;

    
    ret = gtk_selection_data_get_data_type(pyg_boxed_get(self, GtkSelectionData));
    
    name = gdk_atom_name(ret);
    py_ret = PyString_FromString(name);
    g_free(name);
    return py_ret;
}

static PyObject *
_wrap_gtk_selection_data_get_format(PyObject *self)
{
    int ret;

    
    ret = gtk_selection_data_get_format(pyg_boxed_get(self, GtkSelectionData));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_selection_data_get_length(PyObject *self)
{
    int ret;

    
    ret = gtk_selection_data_get_length(pyg_boxed_get(self, GtkSelectionData));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_selection_data_get_display(PyObject *self)
{
    GdkDisplay *ret;

    
    ret = gtk_selection_data_get_display(pyg_boxed_get(self, GtkSelectionData));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_selection_data_get_selection(PyObject *self)
{
    PyObject * py_ret;
    gchar * name;
    GdkAtom ret;

    
    ret = gtk_selection_data_get_selection(pyg_boxed_get(self, GtkSelectionData));
    
    name = gdk_atom_name(ret);
    py_ret = PyString_FromString(name);
    g_free(name);
    return py_ret;
}

static const PyMethodDef _PyGtkSelectionData_methods[] = {
    { "set", (PyCFunction)_wrap_gtk_selection_data_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_text", (PyCFunction)_wrap_gtk_selection_data_set_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text", (PyCFunction)_wrap_gtk_selection_data_get_text, METH_NOARGS,
      NULL },
    { "get_targets", (PyCFunction)_wrap_gtk_selection_data_get_targets, METH_NOARGS,
      NULL },
    { "targets_include_text", (PyCFunction)_wrap_gtk_selection_data_targets_include_text, METH_NOARGS,
      NULL },
    { "set_pixbuf", (PyCFunction)_wrap_gtk_selection_data_set_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_pixbuf", (PyCFunction)_wrap_gtk_selection_data_get_pixbuf, METH_NOARGS,
      NULL },
    { "set_uris", (PyCFunction)_wrap_gtk_selection_data_set_uris, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_uris", (PyCFunction)_wrap_gtk_selection_data_get_uris, METH_NOARGS,
      NULL },
    { "targets_include_image", (PyCFunction)_wrap_gtk_selection_data_targets_include_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "tree_set_row_drag_data", (PyCFunction)_wrap_gtk_tree_set_row_drag_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "tree_get_row_drag_data", (PyCFunction)_wrap_gtk_tree_get_row_drag_data, METH_NOARGS,
      NULL },
    { "targets_include_rich_text", (PyCFunction)_wrap_gtk_selection_data_targets_include_rich_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "targets_include_uri", (PyCFunction)_wrap_gtk_selection_data_targets_include_uri, METH_NOARGS,
      NULL },
    { "get_target", (PyCFunction)_wrap_gtk_selection_data_get_target, METH_NOARGS,
      NULL },
    { "get_data_type", (PyCFunction)_wrap_gtk_selection_data_get_data_type, METH_NOARGS,
      NULL },
    { "get_format", (PyCFunction)_wrap_gtk_selection_data_get_format, METH_NOARGS,
      NULL },
    { "get_length", (PyCFunction)_wrap_gtk_selection_data_get_length, METH_NOARGS,
      NULL },
    { "get_display", (PyCFunction)_wrap_gtk_selection_data_get_display, METH_NOARGS,
      NULL },
    { "get_selection", (PyCFunction)_wrap_gtk_selection_data_get_selection, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_selection_data__get_selection(PyObject *self, void *closure)
{
    PyObject * py_ret;
    gchar * name;
    GdkAtom ret;

    ret = pyg_boxed_get(self, GtkSelectionData)->selection;
    name = gdk_atom_name(ret);
    py_ret = PyString_FromString(name);
    g_free(name);
    return py_ret;
}

static PyObject *
_wrap_gtk_selection_data__get_target(PyObject *self, void *closure)
{
    PyObject * py_ret;
    gchar * name;
    GdkAtom ret;

    ret = pyg_boxed_get(self, GtkSelectionData)->target;
    name = gdk_atom_name(ret);
    py_ret = PyString_FromString(name);
    g_free(name);
    return py_ret;
}

static PyObject *
_wrap_gtk_selection_data__get_type(PyObject *self, void *closure)
{
    PyObject * py_ret;
    gchar * name;
    GdkAtom ret;

    ret = pyg_boxed_get(self, GtkSelectionData)->type;
    name = gdk_atom_name(ret);
    py_ret = PyString_FromString(name);
    g_free(name);
    return py_ret;
}

static PyObject *
_wrap_gtk_selection_data__get_format(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkSelectionData)->format;
    return PyInt_FromLong(ret);
}

#line 596 "./gtk.override"
static PyObject *
_wrap_gtk_selection_data__get_data(PyGObject *self, void *closure)
{
    if (pyg_boxed_get(self, GtkSelectionData)->length >= 0) {
        return PyString_FromStringAndSize(
	    (char*)pyg_boxed_get(self, GtkSelectionData)->data,
	    pyg_boxed_get(self, GtkSelectionData)->length);
    } else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
#line 2188 "gtk.c"


static const PyGetSetDef gtk_selection_data_getsets[] = {
    { "selection", (getter)_wrap_gtk_selection_data__get_selection, (setter)0 },
    { "target", (getter)_wrap_gtk_selection_data__get_target, (setter)0 },
    { "type", (getter)_wrap_gtk_selection_data__get_type, (setter)0 },
    { "format", (getter)_wrap_gtk_selection_data__get_format, (setter)0 },
    { "data", (getter)_wrap_gtk_selection_data__get_data, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkSelectionData_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.SelectionData",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkSelectionData_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_selection_data_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)pygobject_no_constructor,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTextAttributes ----------- */

static int
_wrap_gtk_text_attributes_new(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,":Gtk.TextAttributes.__init__", kwlist))
        return -1;
    self->gtype = GTK_TYPE_TEXT_ATTRIBUTES;
    self->free_on_dealloc = FALSE;
    self->boxed = gtk_text_attributes_new();

    if (!self->boxed) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkTextAttributes object");
        return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}

static PyObject *
_wrap_gtk_text_attributes_copy(PyObject *self)
{
    GtkTextAttributes *ret;

    
    ret = gtk_text_attributes_copy(pyg_boxed_get(self, GtkTextAttributes));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_TEXT_ATTRIBUTES, ret, FALSE, TRUE);
}

static PyObject *
_wrap_gtk_text_attributes_copy_values(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dest", NULL };
    PyObject *py_dest;
    GtkTextAttributes *dest = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextAttributes.copy_values", kwlist, &py_dest))
        return NULL;
    if (pyg_boxed_check(py_dest, GTK_TYPE_TEXT_ATTRIBUTES))
        dest = pyg_boxed_get(py_dest, GtkTextAttributes);
    else {
        PyErr_SetString(PyExc_TypeError, "dest should be a GtkTextAttributes");
        return NULL;
    }
    
    gtk_text_attributes_copy_values(pyg_boxed_get(self, GtkTextAttributes), dest);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTextAttributes_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_text_attributes_copy, METH_NOARGS,
      NULL },
    { "copy_values", (PyCFunction)_wrap_gtk_text_attributes_copy_values, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 1038 "gtktextview.override"
static PyObject *
_wrap_gtk_text_attributes__get_bg_color(PyObject *self, void *closure)
{
    GdkColor ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->appearance.bg_color;
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GDK_TYPE_COLOR, &ret, TRUE, TRUE);
}
#line 2320 "gtk.c"


#line 1049 "gtktextview.override"
static PyObject *
_wrap_gtk_text_attributes__get_fg_color(PyObject *self, void *closure)
{
    GdkColor ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->appearance.fg_color;
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GDK_TYPE_COLOR, &ret, TRUE, TRUE);
}
#line 2333 "gtk.c"


#line 1060 "gtktextview.override"
static PyObject *
_wrap_gtk_text_attributes__get_bg_stipple(PyObject *self, void *closure)
{
    GdkBitmap *ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->appearance.bg_stipple;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
#line 2346 "gtk.c"


#line 1071 "gtktextview.override"
static PyObject *
_wrap_gtk_text_attributes__get_fg_stipple(PyObject *self, void *closure)
{
    GdkBitmap *ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->appearance.fg_stipple;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
#line 2359 "gtk.c"


#line 1082 "gtktextview.override"
static PyObject *
_wrap_gtk_text_attributes__get_rise(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->appearance.rise;
    return PyInt_FromLong(ret);
}
#line 2371 "gtk.c"


#line 1092 "gtktextview.override"
static PyObject *
_wrap_gtk_text_attributes__get_underline(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->appearance.underline;
    return PyInt_FromLong(ret);
}
#line 2383 "gtk.c"


#line 1102 "gtktextview.override"
static PyObject *
_wrap_gtk_text_attributes__get_strikethrough(PyObject *self, void *closure)
{
    return PyBool_FromLong(pyg_boxed_get(self, GtkTextAttributes)->appearance.strikethrough);
}
#line 2392 "gtk.c"


#line 1109 "gtktextview.override"
static PyObject *
_wrap_gtk_text_attributes__get_draw_bg(PyObject *self, void *closure)
{
    return PyBool_FromLong(pyg_boxed_get(self, GtkTextAttributes)->appearance.draw_bg);
}
#line 2401 "gtk.c"


static PyObject *
_wrap_gtk_text_attributes__get_justification(PyObject *self, void *closure)
{
    gint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->justification;
    return pyg_enum_from_gtype(GTK_TYPE_JUSTIFICATION, ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_direction(PyObject *self, void *closure)
{
    gint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->direction;
    return pyg_enum_from_gtype(GTK_TYPE_TEXT_DIRECTION, ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_font(PyObject *self, void *closure)
{
    PangoFontDescription *ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->font;
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PANGO_TYPE_FONT_DESCRIPTION, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_text_attributes__get_font_scale(PyObject *self, void *closure)
{
    double ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->font_scale;
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_left_margin(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->left_margin;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_indent(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->indent;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_right_margin(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->right_margin;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_pixels_above_lines(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->pixels_above_lines;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_pixels_below_lines(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->pixels_below_lines;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_pixels_inside_wrap(PyObject *self, void *closure)
{
    int ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->pixels_inside_wrap;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_tabs(PyObject *self, void *closure)
{
    PangoTabArray *ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->tabs;
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PANGO_TYPE_TAB_ARRAY, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_text_attributes__get_wrap_mode(PyObject *self, void *closure)
{
    gint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->wrap_mode;
    return pyg_enum_from_gtype(GTK_TYPE_WRAP_MODE, ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_language(PyObject *self, void *closure)
{
    PangoLanguage *ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->language;
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PANGO_TYPE_LANGUAGE, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_text_attributes__get_invisible(PyObject *self, void *closure)
{
    guint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->invisible;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_bg_full_height(PyObject *self, void *closure)
{
    guint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->bg_full_height;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_editable(PyObject *self, void *closure)
{
    guint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->editable;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_realized(PyObject *self, void *closure)
{
    guint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->realized;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_pad1(PyObject *self, void *closure)
{
    guint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->pad1;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_pad2(PyObject *self, void *closure)
{
    guint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->pad2;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_pad3(PyObject *self, void *closure)
{
    guint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->pad3;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_text_attributes__get_pad4(PyObject *self, void *closure)
{
    guint ret;

    ret = pyg_boxed_get(self, GtkTextAttributes)->pad4;
    return PyLong_FromUnsignedLong(ret);
}

static const PyGetSetDef gtk_text_attributes_getsets[] = {
    { "bg_color", (getter)_wrap_gtk_text_attributes__get_bg_color, (setter)0 },
    { "fg_color", (getter)_wrap_gtk_text_attributes__get_fg_color, (setter)0 },
    { "bg_stipple", (getter)_wrap_gtk_text_attributes__get_bg_stipple, (setter)0 },
    { "fg_stipple", (getter)_wrap_gtk_text_attributes__get_fg_stipple, (setter)0 },
    { "rise", (getter)_wrap_gtk_text_attributes__get_rise, (setter)0 },
    { "underline", (getter)_wrap_gtk_text_attributes__get_underline, (setter)0 },
    { "strikethrough", (getter)_wrap_gtk_text_attributes__get_strikethrough, (setter)0 },
    { "draw_bg", (getter)_wrap_gtk_text_attributes__get_draw_bg, (setter)0 },
    { "justification", (getter)_wrap_gtk_text_attributes__get_justification, (setter)0 },
    { "direction", (getter)_wrap_gtk_text_attributes__get_direction, (setter)0 },
    { "font", (getter)_wrap_gtk_text_attributes__get_font, (setter)0 },
    { "font_scale", (getter)_wrap_gtk_text_attributes__get_font_scale, (setter)0 },
    { "left_margin", (getter)_wrap_gtk_text_attributes__get_left_margin, (setter)0 },
    { "indent", (getter)_wrap_gtk_text_attributes__get_indent, (setter)0 },
    { "right_margin", (getter)_wrap_gtk_text_attributes__get_right_margin, (setter)0 },
    { "pixels_above_lines", (getter)_wrap_gtk_text_attributes__get_pixels_above_lines, (setter)0 },
    { "pixels_below_lines", (getter)_wrap_gtk_text_attributes__get_pixels_below_lines, (setter)0 },
    { "pixels_inside_wrap", (getter)_wrap_gtk_text_attributes__get_pixels_inside_wrap, (setter)0 },
    { "tabs", (getter)_wrap_gtk_text_attributes__get_tabs, (setter)0 },
    { "wrap_mode", (getter)_wrap_gtk_text_attributes__get_wrap_mode, (setter)0 },
    { "language", (getter)_wrap_gtk_text_attributes__get_language, (setter)0 },
    { "invisible", (getter)_wrap_gtk_text_attributes__get_invisible, (setter)0 },
    { "bg_full_height", (getter)_wrap_gtk_text_attributes__get_bg_full_height, (setter)0 },
    { "editable", (getter)_wrap_gtk_text_attributes__get_editable, (setter)0 },
    { "realized", (getter)_wrap_gtk_text_attributes__get_realized, (setter)0 },
    { "pad1", (getter)_wrap_gtk_text_attributes__get_pad1, (setter)0 },
    { "pad2", (getter)_wrap_gtk_text_attributes__get_pad2, (setter)0 },
    { "pad3", (getter)_wrap_gtk_text_attributes__get_pad3, (setter)0 },
    { "pad4", (getter)_wrap_gtk_text_attributes__get_pad4, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkTextAttributes_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TextAttributes",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTextAttributes_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_text_attributes_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_gtk_text_attributes_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTextIter ----------- */

static PyObject *
_wrap_gtk_text_iter_get_buffer(PyObject *self)
{
    GtkTextBuffer *ret;

    
    ret = gtk_text_iter_get_buffer(pyg_boxed_get(self, GtkTextIter));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 214 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_copy(PyGBoxed *self)
{
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, pyg_boxed_get(self, GtkTextIter),
                         TRUE, TRUE);
}
#line 2697 "gtk.c"


static PyObject *
_wrap_gtk_text_iter_get_offset(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_get_offset(pyg_boxed_get(self, GtkTextIter));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_iter_get_line(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_get_line(pyg_boxed_get(self, GtkTextIter));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_iter_get_line_offset(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_get_line_offset(pyg_boxed_get(self, GtkTextIter));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_iter_get_line_index(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_get_line_index(pyg_boxed_get(self, GtkTextIter));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_iter_get_visible_line_offset(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_get_visible_line_offset(pyg_boxed_get(self, GtkTextIter));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_iter_get_visible_line_index(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_get_visible_line_index(pyg_boxed_get(self, GtkTextIter));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_iter_get_char(PyObject *self)
{
    gunichar ret;
    Py_UNICODE py_ret;

    
    ret = gtk_text_iter_get_char(pyg_boxed_get(self, GtkTextIter));
    
#if !defined(Py_UNICODE_SIZE) || Py_UNICODE_SIZE == 2
    if (ret > 0xffff) {
        PyErr_SetString(PyExc_RuntimeError, "returned character can not be represented in 16-bit unicode");
        return NULL;
    }
#endif
    py_ret = (Py_UNICODE)ret;
    return PyUnicode_FromUnicode(&py_ret, 1);

}

#line 243 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_get_slice(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextIter.get_slice",
                                     kwlist, &end))
        return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
        PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
        return NULL;
    }
    text = gtk_text_iter_get_slice(pyg_boxed_get(self, GtkTextIter),
                                   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
#line 2808 "gtk.c"


#line 266 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_get_text(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextIter.get_text",
                                     kwlist, &end))
        return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
        PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
        return NULL;
    }
    text = gtk_text_iter_get_text(pyg_boxed_get(self, GtkTextIter),
                                   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
#line 2833 "gtk.c"


#line 289 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_get_visible_slice(PyGBoxed *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkTextIter.get_visible_slice", kwlist,
                                     &end))
        return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
        PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
        return NULL;
    }
    text = gtk_text_iter_get_visible_slice(pyg_boxed_get(self, GtkTextIter),
                                           pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
#line 2860 "gtk.c"


#line 314 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_get_visible_text(PyGBoxed *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkTextIter.get_visible_text", kwlist,
                                     &end))
        return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
        PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
        return NULL;
    }
    text = gtk_text_iter_get_visible_text(pyg_boxed_get(self, GtkTextIter),
                                          pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
#line 2887 "gtk.c"


static PyObject *
_wrap_gtk_text_iter_get_pixbuf(PyObject *self)
{
    GdkPixbuf *ret;

    
    ret = gtk_text_iter_get_pixbuf(pyg_boxed_get(self, GtkTextIter));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 339 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_get_marks(PyGBoxed *self)
{
    GSList *ret, *tmp;
    PyObject *pyret;

    ret = gtk_text_iter_get_marks(pyg_boxed_get(self, GtkTextIter));
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
        PyObject *mark = pygobject_new((GObject *)tmp->data);
        PyList_Append(pyret, mark);
        Py_DECREF(mark);
    }
    g_slist_free(ret);
    return pyret;
}
#line 2919 "gtk.c"


static PyObject *
_wrap_gtk_text_iter_get_child_anchor(PyObject *self)
{
    GtkTextChildAnchor *ret;

    
    ret = gtk_text_iter_get_child_anchor(pyg_boxed_get(self, GtkTextIter));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 357 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_get_toggled_tags(PyGBoxed *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "toggled_on", NULL };
    GSList *ret, *tmp;
    int toggled_on;
    PyObject *pyret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "i:GtkTextIter.get_toggled_tags", kwlist,
                                     &toggled_on))
        return NULL;
    ret = gtk_text_iter_get_toggled_tags(pyg_boxed_get(self, GtkTextIter),
                                         toggled_on);
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
        PyObject *tag = pygobject_new((GObject *)tmp->data);
        PyList_Append(pyret, tag);
        Py_DECREF(tag);
    }
    g_slist_free(ret);
    return pyret;
}
#line 2959 "gtk.c"


static PyObject *
_wrap_gtk_text_iter_begins_tag(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag", NULL };
    PyGObject *py_tag = NULL;
    int ret;
    GtkTextTag *tag = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.TextIter.begins_tag", kwlist, &py_tag))
        return NULL;
    if ((PyObject *)py_tag == Py_None)
        tag = NULL;
    else if (py_tag && pygobject_check(py_tag, &PyGtkTextTag_Type))
        tag = GTK_TEXT_TAG(py_tag->obj);
    else if (py_tag) {
        PyErr_SetString(PyExc_TypeError, "tag should be a GtkTextTag or None");
        return NULL;
    }
    
    ret = gtk_text_iter_begins_tag(pyg_boxed_get(self, GtkTextIter), (GtkTextTag *) tag);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_ends_tag(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag", NULL };
    PyGObject *py_tag = NULL;
    int ret;
    GtkTextTag *tag = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.TextIter.ends_tag", kwlist, &py_tag))
        return NULL;
    if ((PyObject *)py_tag == Py_None)
        tag = NULL;
    else if (py_tag && pygobject_check(py_tag, &PyGtkTextTag_Type))
        tag = GTK_TEXT_TAG(py_tag->obj);
    else if (py_tag) {
        PyErr_SetString(PyExc_TypeError, "tag should be a GtkTextTag or None");
        return NULL;
    }
    
    ret = gtk_text_iter_ends_tag(pyg_boxed_get(self, GtkTextIter), (GtkTextTag *) tag);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_toggles_tag(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag", NULL };
    PyGObject *py_tag = NULL;
    int ret;
    GtkTextTag *tag = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.TextIter.toggles_tag", kwlist, &py_tag))
        return NULL;
    if ((PyObject *)py_tag == Py_None)
        tag = NULL;
    else if (py_tag && pygobject_check(py_tag, &PyGtkTextTag_Type))
        tag = GTK_TEXT_TAG(py_tag->obj);
    else if (py_tag) {
        PyErr_SetString(PyExc_TypeError, "tag should be a GtkTextTag or None");
        return NULL;
    }
    
    ret = gtk_text_iter_toggles_tag(pyg_boxed_get(self, GtkTextIter), (GtkTextTag *) tag);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_has_tag(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag", NULL };
    PyGObject *tag;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextIter.has_tag", kwlist, &PyGtkTextTag_Type, &tag))
        return NULL;
    
    ret = gtk_text_iter_has_tag(pyg_boxed_get(self, GtkTextIter), GTK_TEXT_TAG(tag->obj));
    
    return PyBool_FromLong(ret);

}

#line 383 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_get_tags(PyGBoxed *self)
{
    GSList *ret, *tmp;
    PyObject *pyret;

    ret = gtk_text_iter_get_tags(pyg_boxed_get(self, GtkTextIter));
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
        PyObject *tag = pygobject_new((GObject *)tmp->data);
        PyList_Append(pyret, tag);
        Py_DECREF(tag);
    }
    g_slist_free(ret);
    return pyret;
}
#line 3070 "gtk.c"


static PyObject *
_wrap_gtk_text_iter_editable(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "default_setting", NULL };
    int default_setting, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.editable", kwlist, &default_setting))
        return NULL;
    
    ret = gtk_text_iter_editable(pyg_boxed_get(self, GtkTextIter), default_setting);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_can_insert(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "default_editability", NULL };
    int default_editability, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.can_insert", kwlist, &default_editability))
        return NULL;
    
    ret = gtk_text_iter_can_insert(pyg_boxed_get(self, GtkTextIter), default_editability);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_starts_word(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_starts_word(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_ends_word(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_ends_word(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_inside_word(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_inside_word(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_starts_sentence(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_starts_sentence(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_ends_sentence(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_ends_sentence(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_inside_sentence(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_inside_sentence(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_starts_line(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_starts_line(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_ends_line(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_ends_line(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_is_cursor_position(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_is_cursor_position(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_get_chars_in_line(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_get_chars_in_line(pyg_boxed_get(self, GtkTextIter));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_iter_get_bytes_in_line(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_get_bytes_in_line(pyg_boxed_get(self, GtkTextIter));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_iter_get_attributes(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "values", NULL };
    PyObject *py_values;
    int ret;
    GtkTextAttributes *values = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextIter.get_attributes", kwlist, &py_values))
        return NULL;
    if (pyg_boxed_check(py_values, GTK_TYPE_TEXT_ATTRIBUTES))
        values = pyg_boxed_get(py_values, GtkTextAttributes);
    else {
        PyErr_SetString(PyExc_TypeError, "values should be a GtkTextAttributes");
        return NULL;
    }
    
    ret = gtk_text_iter_get_attributes(pyg_boxed_get(self, GtkTextIter), values);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_get_language(PyObject *self)
{
    PangoLanguage *ret;

    
    ret = gtk_text_iter_get_language(pyg_boxed_get(self, GtkTextIter));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PANGO_TYPE_LANGUAGE, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_text_iter_is_end(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_is_end(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_is_start(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_is_start(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_char(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_forward_char(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_char(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_backward_char(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_chars(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.forward_chars", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_forward_chars(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_chars(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.backward_chars", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_backward_chars(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_line(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_forward_line(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_line(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_backward_line(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_lines(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.forward_lines", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_forward_lines(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_lines(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.backward_lines", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_backward_lines(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_word_end(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_forward_word_end(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_word_start(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_backward_word_start(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_word_ends(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.forward_word_ends", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_forward_word_ends(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_word_starts(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.backward_word_starts", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_backward_word_starts(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_visible_line(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_forward_visible_line(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_visible_line(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_backward_visible_line(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_visible_lines(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.forward_visible_lines", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_forward_visible_lines(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_visible_lines(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.backward_visible_lines", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_backward_visible_lines(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_visible_word_end(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_forward_visible_word_end(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_visible_word_start(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_backward_visible_word_start(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_visible_word_ends(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.forward_visible_word_ends", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_forward_visible_word_ends(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_visible_word_starts(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.backward_visible_word_starts", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_backward_visible_word_starts(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_sentence_end(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_forward_sentence_end(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_sentence_start(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_backward_sentence_start(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_sentence_ends(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.forward_sentence_ends", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_forward_sentence_ends(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_sentence_starts(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.backward_sentence_starts", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_backward_sentence_starts(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_cursor_position(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_forward_cursor_position(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_cursor_position(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_backward_cursor_position(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_cursor_positions(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.forward_cursor_positions", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_forward_cursor_positions(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_cursor_positions(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.backward_cursor_positions", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_backward_cursor_positions(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_visible_cursor_position(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_forward_visible_cursor_position(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_visible_cursor_position(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_backward_visible_cursor_position(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_forward_visible_cursor_positions(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.forward_visible_cursor_positions", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_forward_visible_cursor_positions(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_visible_cursor_positions(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "count", NULL };
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.backward_visible_cursor_positions", kwlist, &count))
        return NULL;
    
    ret = gtk_text_iter_backward_visible_cursor_positions(pyg_boxed_get(self, GtkTextIter), count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_set_offset(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "char_offset", NULL };
    int char_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.set_offset", kwlist, &char_offset))
        return NULL;
    
    gtk_text_iter_set_offset(pyg_boxed_get(self, GtkTextIter), char_offset);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_iter_set_line(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", NULL };
    int line_number;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.set_line", kwlist, &line_number))
        return NULL;
    
    gtk_text_iter_set_line(pyg_boxed_get(self, GtkTextIter), line_number);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_iter_set_line_offset(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "char_on_line", NULL };
    int char_on_line;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.set_line_offset", kwlist, &char_on_line))
        return NULL;
    
    gtk_text_iter_set_line_offset(pyg_boxed_get(self, GtkTextIter), char_on_line);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_iter_set_line_index(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "byte_on_line", NULL };
    int byte_on_line;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.set_line_index", kwlist, &byte_on_line))
        return NULL;
    
    gtk_text_iter_set_line_index(pyg_boxed_get(self, GtkTextIter), byte_on_line);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_iter_forward_to_end(PyObject *self)
{
    
    gtk_text_iter_forward_to_end(pyg_boxed_get(self, GtkTextIter));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_iter_forward_to_line_end(PyObject *self)
{
    int ret;

    
    ret = gtk_text_iter_forward_to_line_end(pyg_boxed_get(self, GtkTextIter));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_set_visible_line_offset(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "char_on_line", NULL };
    int char_on_line;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.set_visible_line_offset", kwlist, &char_on_line))
        return NULL;
    
    gtk_text_iter_set_visible_line_offset(pyg_boxed_get(self, GtkTextIter), char_on_line);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_iter_set_visible_line_index(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "byte_on_line", NULL };
    int byte_on_line;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextIter.set_visible_line_index", kwlist, &byte_on_line))
        return NULL;
    
    gtk_text_iter_set_visible_line_index(pyg_boxed_get(self, GtkTextIter), byte_on_line);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_iter_forward_to_tag_toggle(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag", NULL };
    PyGObject *py_tag;
    int ret;
    GtkTextTag *tag = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextIter.forward_to_tag_toggle", kwlist, &py_tag))
        return NULL;
    if (py_tag && pygobject_check(py_tag, &PyGtkTextTag_Type))
        tag = GTK_TEXT_TAG(py_tag->obj);
    else if ((PyObject *)py_tag != Py_None) {
        PyErr_SetString(PyExc_TypeError, "tag should be a GtkTextTag or None");
        return NULL;
    }
    
    ret = gtk_text_iter_forward_to_tag_toggle(pyg_boxed_get(self, GtkTextIter), (GtkTextTag *) tag);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_backward_to_tag_toggle(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag", NULL };
    PyGObject *py_tag;
    int ret;
    GtkTextTag *tag = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextIter.backward_to_tag_toggle", kwlist, &py_tag))
        return NULL;
    if (py_tag && pygobject_check(py_tag, &PyGtkTextTag_Type))
        tag = GTK_TEXT_TAG(py_tag->obj);
    else if ((PyObject *)py_tag != Py_None) {
        PyErr_SetString(PyExc_TypeError, "tag should be a GtkTextTag or None");
        return NULL;
    }
    
    ret = gtk_text_iter_backward_to_tag_toggle(pyg_boxed_get(self, GtkTextIter), (GtkTextTag *) tag);
    
    return PyBool_FromLong(ret);

}

#line 1162 "gtktextview.override"
static gboolean
pygtk_find_char_pred(gunichar ch, gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *pred, *args, *pyret = Py_False;
    gboolean ret;

    state = pyg_gil_state_ensure();

#if !defined(Py_UNICODE_SIZE) || Py_UNICODE_SIZE == 2
    if (ch > 0xffff) {
        PyErr_SetString(PyExc_RuntimeError,
			"character can not be represented in 16-bit unicode");
	PyErr_Print();
        return FALSE;
    }
#endif
    pred = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NO)", PyUnicode_FromUnicode((Py_UNICODE *)&ch, 1),
			 PyTuple_GetItem((PyObject *)user_data, 1));

    pyret = PyObject_CallObject(pred, args);
    if (!pyret)
	PyErr_Print();
    ret = (pyret == Py_True) ? TRUE : FALSE;

    Py_XDECREF(pyret);
    pyg_gil_state_release(state);

    return ret;
}
static PyObject *
_wrap_gtk_text_iter_forward_find_char(PyGObject *self, PyObject *args,
				      PyObject *kwargs)
{
    static char *kwlist[] = { "pred", "user_data", "limit", NULL };
    GtkTextIter *iter, *limit = NULL;
    gboolean ret;
    PyObject *pylimit = Py_None, *pred, *data, *pydata = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|OO:gtk.TextIter.forward_find_char",
				     kwlist, &pred, &pydata, &pylimit))
	return NULL;

    if (pylimit != Py_None) {
	if (pyg_boxed_check(pylimit, GTK_TYPE_TEXT_ITER)) {
	    limit = pyg_boxed_get(pylimit, GtkTextIter);
	} else {
	    PyErr_SetString(PyExc_TypeError,
			    "limit should be a gtk.TextIter or None");
	    return NULL;
	}
    }
    if (!PyCallable_Check(pred)) {
	PyErr_SetString(PyExc_TypeError, "pred must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", pred, pydata);
    iter = pyg_boxed_get(self, GtkTextIter);

    ret = gtk_text_iter_forward_find_char(iter, pygtk_find_char_pred,
					  (gpointer)data, limit);

    return PyBool_FromLong(ret);
}
#line 3950 "gtk.c"


#line 1231 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_backward_find_char(PyGObject *self, PyObject *args,
				       PyObject *kwargs)
{
    static char *kwlist[] = { "pred", "user_data", "limit", NULL };
    GtkTextIter *iter, *limit = NULL;
    gboolean ret;
    PyObject *pylimit = Py_None, *pred, *data, *pydata = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|OO:gtk.TextIter.backward_find_char",
				     kwlist, &pred, &pydata, &pylimit))
	return NULL;

    if (pylimit != Py_None) {
	if (pyg_boxed_check(pylimit, GTK_TYPE_TEXT_ITER)) {
	    limit = pyg_boxed_get(pylimit, GtkTextIter);
	} else {
	    PyErr_SetString(PyExc_TypeError,
			    "limit should be a gtk.TextIter or None");
	    return NULL;
	}
    }
    if (!PyCallable_Check(pred)) {
	PyErr_SetString(PyExc_TypeError, "pred must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", pred, pydata);
    iter = pyg_boxed_get(self, GtkTextIter);

    ret = gtk_text_iter_backward_find_char(iter, pygtk_find_char_pred,
					   (gpointer)data, limit);

    return PyBool_FromLong(ret);
}
#line 3990 "gtk.c"


#line 401 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_forward_search(PyGBoxed *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "str", "flags", "limit", NULL };
    gchar *str;
    PyObject *py_flags, *py_limit = Py_None;
    GtkTextIter match_start, match_end, *limit = NULL;
    GtkTextSearchFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "sO|O:GtkTextIter.forward_search",
                                     kwlist, &str, &py_flags, &py_limit))
        return NULL;
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
        limit = pyg_boxed_get(py_limit, GtkTextIter);
    else if (py_limit != Py_None) {
        PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
        return NULL;
    }
    if (pyg_flags_get_value(GTK_TYPE_TEXT_SEARCH_FLAGS, py_flags,
                            (gint *)&flags))
        return NULL;
    if (gtk_text_iter_forward_search(pyg_boxed_get(self, GtkTextIter), str,
                                     flags, &match_start, &match_end, limit))
        return Py_BuildValue("(NN)",
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
                                           TRUE, TRUE),
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
                                           TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
#line 4027 "gtk.c"


#line 436 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_backward_search(PyGBoxed *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "str", "flags", "limit", NULL };
    gchar *str;
    PyObject *py_flags, *py_limit = Py_None;
    GtkTextIter match_start, match_end, *limit = NULL;
    GtkTextSearchFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "sO|O:GtkTextIter.backward_search",
                                     kwlist, &str, &py_flags, &py_limit))
        return NULL;
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
        limit = pyg_boxed_get(py_limit, GtkTextIter);
    else if (py_limit != Py_None) {
        PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
        return NULL;
    }
    if (pyg_flags_get_value(GTK_TYPE_TEXT_SEARCH_FLAGS, py_flags,
                            (gint *)&flags))
        return NULL;
    if (gtk_text_iter_backward_search(pyg_boxed_get(self, GtkTextIter), str,
                                      flags, &match_start, &match_end, limit))
        return Py_BuildValue("(NN)",
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
                                           TRUE, TRUE),
                             pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
                                           TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
#line 4064 "gtk.c"


static PyObject *
_wrap_gtk_text_iter_equal(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "rhs", NULL };
    PyObject *py_rhs;
    int ret;
    GtkTextIter *rhs = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextIter.equal", kwlist, &py_rhs))
        return NULL;
    if (pyg_boxed_check(py_rhs, GTK_TYPE_TEXT_ITER))
        rhs = pyg_boxed_get(py_rhs, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "rhs should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_iter_equal(pyg_boxed_get(self, GtkTextIter), rhs);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_compare(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "rhs", NULL };
    PyObject *py_rhs;
    int ret;
    GtkTextIter *rhs = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextIter.compare", kwlist, &py_rhs))
        return NULL;
    if (pyg_boxed_check(py_rhs, GTK_TYPE_TEXT_ITER))
        rhs = pyg_boxed_get(py_rhs, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "rhs should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_iter_compare(pyg_boxed_get(self, GtkTextIter), rhs);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_iter_in_range(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start", "end", NULL };
    PyObject *py_start, *py_end;
    int ret;
    GtkTextIter *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TextIter.in_range", kwlist, &py_start, &py_end))
        return NULL;
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_iter_in_range(pyg_boxed_get(self, GtkTextIter), start, end);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_iter_order(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "second", NULL };
    PyObject *py_second;
    GtkTextIter *second = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextIter.order", kwlist, &py_second))
        return NULL;
    if (pyg_boxed_check(py_second, GTK_TYPE_TEXT_ITER))
        second = pyg_boxed_get(py_second, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "second should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_iter_order(pyg_boxed_get(self, GtkTextIter), second);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 222 "gtktextview.override"
static PyObject *
_wrap_gtk_text_iter_assign(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "other", NULL };
    PyGBoxed *other;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:gtk.TextIter.assign",
                                     kwlist, &other))
        return NULL;
    if (!pyg_boxed_check(other, GTK_TYPE_TEXT_ITER)) {
        PyErr_SetString(PyExc_TypeError, "other must be a GtkTextIter");
        return NULL;
    }

    *pyg_boxed_get(self, GtkTextIter) = *pyg_boxed_get(other, GtkTextIter);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 4183 "gtk.c"


static const PyMethodDef _PyGtkTextIter_methods[] = {
    { "get_buffer", (PyCFunction)_wrap_gtk_text_iter_get_buffer, METH_NOARGS,
      NULL },
    { "copy", (PyCFunction)_wrap_gtk_text_iter_copy, METH_NOARGS,
      NULL },
    { "get_offset", (PyCFunction)_wrap_gtk_text_iter_get_offset, METH_NOARGS,
      NULL },
    { "get_line", (PyCFunction)_wrap_gtk_text_iter_get_line, METH_NOARGS,
      NULL },
    { "get_line_offset", (PyCFunction)_wrap_gtk_text_iter_get_line_offset, METH_NOARGS,
      NULL },
    { "get_line_index", (PyCFunction)_wrap_gtk_text_iter_get_line_index, METH_NOARGS,
      NULL },
    { "get_visible_line_offset", (PyCFunction)_wrap_gtk_text_iter_get_visible_line_offset, METH_NOARGS,
      NULL },
    { "get_visible_line_index", (PyCFunction)_wrap_gtk_text_iter_get_visible_line_index, METH_NOARGS,
      NULL },
    { "get_char", (PyCFunction)_wrap_gtk_text_iter_get_char, METH_NOARGS,
      NULL },
    { "get_slice", (PyCFunction)_wrap_gtk_text_iter_get_slice, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text", (PyCFunction)_wrap_gtk_text_iter_get_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible_slice", (PyCFunction)_wrap_gtk_text_iter_get_visible_slice, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible_text", (PyCFunction)_wrap_gtk_text_iter_get_visible_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_pixbuf", (PyCFunction)_wrap_gtk_text_iter_get_pixbuf, METH_NOARGS,
      NULL },
    { "get_marks", (PyCFunction)_wrap_gtk_text_iter_get_marks, METH_NOARGS,
      NULL },
    { "get_child_anchor", (PyCFunction)_wrap_gtk_text_iter_get_child_anchor, METH_NOARGS,
      NULL },
    { "get_toggled_tags", (PyCFunction)_wrap_gtk_text_iter_get_toggled_tags, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "begins_tag", (PyCFunction)_wrap_gtk_text_iter_begins_tag, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "ends_tag", (PyCFunction)_wrap_gtk_text_iter_ends_tag, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "toggles_tag", (PyCFunction)_wrap_gtk_text_iter_toggles_tag, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "has_tag", (PyCFunction)_wrap_gtk_text_iter_has_tag, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tags", (PyCFunction)_wrap_gtk_text_iter_get_tags, METH_NOARGS,
      NULL },
    { "editable", (PyCFunction)_wrap_gtk_text_iter_editable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "can_insert", (PyCFunction)_wrap_gtk_text_iter_can_insert, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "starts_word", (PyCFunction)_wrap_gtk_text_iter_starts_word, METH_NOARGS,
      NULL },
    { "ends_word", (PyCFunction)_wrap_gtk_text_iter_ends_word, METH_NOARGS,
      NULL },
    { "inside_word", (PyCFunction)_wrap_gtk_text_iter_inside_word, METH_NOARGS,
      NULL },
    { "starts_sentence", (PyCFunction)_wrap_gtk_text_iter_starts_sentence, METH_NOARGS,
      NULL },
    { "ends_sentence", (PyCFunction)_wrap_gtk_text_iter_ends_sentence, METH_NOARGS,
      NULL },
    { "inside_sentence", (PyCFunction)_wrap_gtk_text_iter_inside_sentence, METH_NOARGS,
      NULL },
    { "starts_line", (PyCFunction)_wrap_gtk_text_iter_starts_line, METH_NOARGS,
      NULL },
    { "ends_line", (PyCFunction)_wrap_gtk_text_iter_ends_line, METH_NOARGS,
      NULL },
    { "is_cursor_position", (PyCFunction)_wrap_gtk_text_iter_is_cursor_position, METH_NOARGS,
      NULL },
    { "get_chars_in_line", (PyCFunction)_wrap_gtk_text_iter_get_chars_in_line, METH_NOARGS,
      NULL },
    { "get_bytes_in_line", (PyCFunction)_wrap_gtk_text_iter_get_bytes_in_line, METH_NOARGS,
      NULL },
    { "get_attributes", (PyCFunction)_wrap_gtk_text_iter_get_attributes, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_language", (PyCFunction)_wrap_gtk_text_iter_get_language, METH_NOARGS,
      NULL },
    { "is_end", (PyCFunction)_wrap_gtk_text_iter_is_end, METH_NOARGS,
      NULL },
    { "is_start", (PyCFunction)_wrap_gtk_text_iter_is_start, METH_NOARGS,
      NULL },
    { "forward_char", (PyCFunction)_wrap_gtk_text_iter_forward_char, METH_NOARGS,
      NULL },
    { "backward_char", (PyCFunction)_wrap_gtk_text_iter_backward_char, METH_NOARGS,
      NULL },
    { "forward_chars", (PyCFunction)_wrap_gtk_text_iter_forward_chars, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_chars", (PyCFunction)_wrap_gtk_text_iter_backward_chars, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_line", (PyCFunction)_wrap_gtk_text_iter_forward_line, METH_NOARGS,
      NULL },
    { "backward_line", (PyCFunction)_wrap_gtk_text_iter_backward_line, METH_NOARGS,
      NULL },
    { "forward_lines", (PyCFunction)_wrap_gtk_text_iter_forward_lines, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_lines", (PyCFunction)_wrap_gtk_text_iter_backward_lines, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_word_end", (PyCFunction)_wrap_gtk_text_iter_forward_word_end, METH_NOARGS,
      NULL },
    { "backward_word_start", (PyCFunction)_wrap_gtk_text_iter_backward_word_start, METH_NOARGS,
      NULL },
    { "forward_word_ends", (PyCFunction)_wrap_gtk_text_iter_forward_word_ends, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_word_starts", (PyCFunction)_wrap_gtk_text_iter_backward_word_starts, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_visible_line", (PyCFunction)_wrap_gtk_text_iter_forward_visible_line, METH_NOARGS,
      NULL },
    { "backward_visible_line", (PyCFunction)_wrap_gtk_text_iter_backward_visible_line, METH_NOARGS,
      NULL },
    { "forward_visible_lines", (PyCFunction)_wrap_gtk_text_iter_forward_visible_lines, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_visible_lines", (PyCFunction)_wrap_gtk_text_iter_backward_visible_lines, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_visible_word_end", (PyCFunction)_wrap_gtk_text_iter_forward_visible_word_end, METH_NOARGS,
      NULL },
    { "backward_visible_word_start", (PyCFunction)_wrap_gtk_text_iter_backward_visible_word_start, METH_NOARGS,
      NULL },
    { "forward_visible_word_ends", (PyCFunction)_wrap_gtk_text_iter_forward_visible_word_ends, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_visible_word_starts", (PyCFunction)_wrap_gtk_text_iter_backward_visible_word_starts, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_sentence_end", (PyCFunction)_wrap_gtk_text_iter_forward_sentence_end, METH_NOARGS,
      NULL },
    { "backward_sentence_start", (PyCFunction)_wrap_gtk_text_iter_backward_sentence_start, METH_NOARGS,
      NULL },
    { "forward_sentence_ends", (PyCFunction)_wrap_gtk_text_iter_forward_sentence_ends, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_sentence_starts", (PyCFunction)_wrap_gtk_text_iter_backward_sentence_starts, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_cursor_position", (PyCFunction)_wrap_gtk_text_iter_forward_cursor_position, METH_NOARGS,
      NULL },
    { "backward_cursor_position", (PyCFunction)_wrap_gtk_text_iter_backward_cursor_position, METH_NOARGS,
      NULL },
    { "forward_cursor_positions", (PyCFunction)_wrap_gtk_text_iter_forward_cursor_positions, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_cursor_positions", (PyCFunction)_wrap_gtk_text_iter_backward_cursor_positions, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_visible_cursor_position", (PyCFunction)_wrap_gtk_text_iter_forward_visible_cursor_position, METH_NOARGS,
      NULL },
    { "backward_visible_cursor_position", (PyCFunction)_wrap_gtk_text_iter_backward_visible_cursor_position, METH_NOARGS,
      NULL },
    { "forward_visible_cursor_positions", (PyCFunction)_wrap_gtk_text_iter_forward_visible_cursor_positions, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_visible_cursor_positions", (PyCFunction)_wrap_gtk_text_iter_backward_visible_cursor_positions, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_offset", (PyCFunction)_wrap_gtk_text_iter_set_offset, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_line", (PyCFunction)_wrap_gtk_text_iter_set_line, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_line_offset", (PyCFunction)_wrap_gtk_text_iter_set_line_offset, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_line_index", (PyCFunction)_wrap_gtk_text_iter_set_line_index, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_to_end", (PyCFunction)_wrap_gtk_text_iter_forward_to_end, METH_NOARGS,
      NULL },
    { "forward_to_line_end", (PyCFunction)_wrap_gtk_text_iter_forward_to_line_end, METH_NOARGS,
      NULL },
    { "set_visible_line_offset", (PyCFunction)_wrap_gtk_text_iter_set_visible_line_offset, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_visible_line_index", (PyCFunction)_wrap_gtk_text_iter_set_visible_line_index, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_to_tag_toggle", (PyCFunction)_wrap_gtk_text_iter_forward_to_tag_toggle, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_to_tag_toggle", (PyCFunction)_wrap_gtk_text_iter_backward_to_tag_toggle, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_find_char", (PyCFunction)_wrap_gtk_text_iter_forward_find_char, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_find_char", (PyCFunction)_wrap_gtk_text_iter_backward_find_char, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_search", (PyCFunction)_wrap_gtk_text_iter_forward_search, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_search", (PyCFunction)_wrap_gtk_text_iter_backward_search, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "equal", (PyCFunction)_wrap_gtk_text_iter_equal, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "compare", (PyCFunction)_wrap_gtk_text_iter_compare, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "in_range", (PyCFunction)_wrap_gtk_text_iter_in_range, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "order", (PyCFunction)_wrap_gtk_text_iter_order, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "assign", (PyCFunction)_wrap_gtk_text_iter_assign, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTextIter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TextIter",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTextIter_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)pygobject_no_constructor,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTreeIter ----------- */

static PyObject *
_wrap_gtk_tree_iter_copy(PyObject *self)
{
    GtkTreeIter *ret;

    
    ret = gtk_tree_iter_copy(pyg_boxed_get(self, GtkTreeIter));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, ret, FALSE, TRUE);
}

#line 6814 "./gtk.override"
static PyObject *
_wrap_gtk_tree_iter_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.TreeIter.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
#line 4440 "gtk.c"


static const PyMethodDef _PyGtkTreeIter_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_tree_iter_copy, METH_NOARGS,
      NULL },
    { "free", (PyCFunction)_wrap_gtk_tree_iter_free, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeIter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeIter",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeIter_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)pygobject_no_constructor,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTreeRowReference ----------- */

static int
_wrap_gtk_tree_row_reference_new(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", "path", NULL };
    PyGObject *model;
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeRowReference.__init__", kwlist, &PyGtkTreeModel_Type, &model, &py_path))
        return -1;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return -1;
    }
    self->gtype = GTK_TYPE_TREE_ROW_REFERENCE;
    self->free_on_dealloc = FALSE;
    self->boxed = gtk_tree_row_reference_new(GTK_TREE_MODEL(model->obj), path);
    if (path)
        gtk_tree_path_free(path);

    if (!self->boxed) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkTreeRowReference object");
        return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}

static PyObject *
_wrap_gtk_tree_row_reference_get_path(PyObject *self)
{
    GtkTreePath *ret;

    
    ret = gtk_tree_row_reference_get_path(pyg_boxed_get(self, GtkTreeRowReference));
    
    if (ret) {
        PyObject *py_ret = pygtk_tree_path_to_pyobject(ret);
        gtk_tree_path_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_row_reference_get_model(PyObject *self)
{
    GtkTreeModel *ret;

    
    ret = gtk_tree_row_reference_get_model(pyg_boxed_get(self, GtkTreeRowReference));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tree_row_reference_valid(PyObject *self)
{
    int ret;

    
    ret = gtk_tree_row_reference_valid(pyg_boxed_get(self, GtkTreeRowReference));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_row_reference_copy(PyObject *self)
{
    GtkTreeRowReference *ret;

    
    ret = gtk_tree_row_reference_copy(pyg_boxed_get(self, GtkTreeRowReference));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_TREE_ROW_REFERENCE, ret, TRUE, TRUE);
}

#line 6824 "./gtk.override"
static PyObject *
_wrap_gtk_tree_row_reference_free(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.TreeRowReference.free should not be used") < 0)
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
#line 4591 "gtk.c"


static const PyMethodDef _PyGtkTreeRowReference_methods[] = {
    { "get_path", (PyCFunction)_wrap_gtk_tree_row_reference_get_path, METH_NOARGS,
      NULL },
    { "get_model", (PyCFunction)_wrap_gtk_tree_row_reference_get_model, METH_NOARGS,
      NULL },
    { "valid", (PyCFunction)_wrap_gtk_tree_row_reference_valid, METH_NOARGS,
      NULL },
    { "copy", (PyCFunction)_wrap_gtk_tree_row_reference_copy, METH_NOARGS,
      NULL },
    { "free", (PyCFunction)_wrap_gtk_tree_row_reference_free, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeRowReference_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeRowReference",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeRowReference_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tree_row_reference_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};






/* ----------- GtkPaperSize ----------- */

static int
_wrap_gtk_paper_size_new(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|z:Gtk.PaperSize.__init__", kwlist, &name))
        return -1;
    self->gtype = GTK_TYPE_PAPER_SIZE;
    self->free_on_dealloc = FALSE;
    self->boxed = gtk_paper_size_new(name);

    if (!self->boxed) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkPaperSize object");
        return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}

static PyObject *
_wrap_gtk_paper_size_copy(PyObject *self)
{
    GtkPaperSize *ret;

    
    ret = gtk_paper_size_copy(pyg_boxed_get(self, GtkPaperSize));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_PAPER_SIZE, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_paper_size_is_equal(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "size2", NULL };
    PyObject *py_size2;
    int ret;
    GtkPaperSize *size2 = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PaperSize.is_equal", kwlist, &py_size2))
        return NULL;
    if (pyg_boxed_check(py_size2, GTK_TYPE_PAPER_SIZE))
        size2 = pyg_boxed_get(py_size2, GtkPaperSize);
    else {
        PyErr_SetString(PyExc_TypeError, "size2 should be a GtkPaperSize");
        return NULL;
    }
    
    ret = gtk_paper_size_is_equal(pyg_boxed_get(self, GtkPaperSize), size2);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_paper_size_get_name(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_paper_size_get_name(pyg_boxed_get(self, GtkPaperSize));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paper_size_get_display_name(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_paper_size_get_display_name(pyg_boxed_get(self, GtkPaperSize));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paper_size_get_ppd_name(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_paper_size_get_ppd_name(pyg_boxed_get(self, GtkPaperSize));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paper_size_get_width(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PaperSize.get_width", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_paper_size_get_width(pyg_boxed_get(self, GtkPaperSize), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_paper_size_get_height(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PaperSize.get_height", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_paper_size_get_height(pyg_boxed_get(self, GtkPaperSize), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_paper_size_is_custom(PyObject *self)
{
    int ret;

    
    ret = gtk_paper_size_is_custom(pyg_boxed_get(self, GtkPaperSize));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_paper_size_set_size(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", "height", "unit", NULL };
    PyObject *py_unit = NULL;
    double width, height;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ddO:Gtk.PaperSize.set_size", kwlist, &width, &height, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    gtk_paper_size_set_size(pyg_boxed_get(self, GtkPaperSize), width, height, unit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paper_size_get_default_top_margin(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PaperSize.get_default_top_margin", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_paper_size_get_default_top_margin(pyg_boxed_get(self, GtkPaperSize), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_paper_size_get_default_bottom_margin(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PaperSize.get_default_bottom_margin", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_paper_size_get_default_bottom_margin(pyg_boxed_get(self, GtkPaperSize), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_paper_size_get_default_left_margin(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PaperSize.get_default_left_margin", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_paper_size_get_default_left_margin(pyg_boxed_get(self, GtkPaperSize), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_paper_size_get_default_right_margin(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PaperSize.get_default_right_margin", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_paper_size_get_default_right_margin(pyg_boxed_get(self, GtkPaperSize), unit);
    
    return PyFloat_FromDouble(ret);
}

static const PyMethodDef _PyGtkPaperSize_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_paper_size_copy, METH_NOARGS,
      NULL },
    { "is_equal", (PyCFunction)_wrap_gtk_paper_size_is_equal, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_name", (PyCFunction)_wrap_gtk_paper_size_get_name, METH_NOARGS,
      NULL },
    { "get_display_name", (PyCFunction)_wrap_gtk_paper_size_get_display_name, METH_NOARGS,
      NULL },
    { "get_ppd_name", (PyCFunction)_wrap_gtk_paper_size_get_ppd_name, METH_NOARGS,
      NULL },
    { "get_width", (PyCFunction)_wrap_gtk_paper_size_get_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_height", (PyCFunction)_wrap_gtk_paper_size_get_height, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "is_custom", (PyCFunction)_wrap_gtk_paper_size_is_custom, METH_NOARGS,
      NULL },
    { "set_size", (PyCFunction)_wrap_gtk_paper_size_set_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_default_top_margin", (PyCFunction)_wrap_gtk_paper_size_get_default_top_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_default_bottom_margin", (PyCFunction)_wrap_gtk_paper_size_get_default_bottom_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_default_left_margin", (PyCFunction)_wrap_gtk_paper_size_get_default_left_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_default_right_margin", (PyCFunction)_wrap_gtk_paper_size_get_default_right_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkPaperSize_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.PaperSize",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkPaperSize_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_gtk_paper_size_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkRecentInfo ----------- */

static PyObject *
_wrap_gtk_recent_info_get_uri(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_recent_info_get_uri(pyg_boxed_get(self, GtkRecentInfo));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_info_get_display_name(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_recent_info_get_display_name(pyg_boxed_get(self, GtkRecentInfo));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_info_get_description(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_recent_info_get_description(pyg_boxed_get(self, GtkRecentInfo));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_info_get_mime_type(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_recent_info_get_mime_type(pyg_boxed_get(self, GtkRecentInfo));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_info_get_added(PyObject *self)
{
    time_t ret;

    
    ret = gtk_recent_info_get_added(pyg_boxed_get(self, GtkRecentInfo));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_recent_info_get_modified(PyObject *self)
{
    time_t ret;

    
    ret = gtk_recent_info_get_modified(pyg_boxed_get(self, GtkRecentInfo));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_recent_info_get_visited(PyObject *self)
{
    time_t ret;

    
    ret = gtk_recent_info_get_visited(pyg_boxed_get(self, GtkRecentInfo));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_recent_info_get_private_hint(PyObject *self)
{
    int ret;

    
    ret = gtk_recent_info_get_private_hint(pyg_boxed_get(self, GtkRecentInfo));
    
    return PyBool_FromLong(ret);

}

#line 7534 "./gtk.override"
static PyObject *
_wrap_gtk_recent_info_get_application_info(PyGObject *self, PyObject *args,
                                           PyObject *kwargs)
{
    static char *kwlist[] = { "app_name", NULL };
    gchar *app_name;
    const gchar *app_exec = NULL;
    gboolean ret;
    PyObject *py_ret;
    guint count = 0;
    time_t time_;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s:GtkRecentInfo.get_application_info",
                                     kwlist, &app_name))
        return NULL;

    ret = gtk_recent_info_get_application_info(pyg_boxed_get(self,
                                                             GtkRecentInfo),
                                               app_name, &app_exec, &count,
                                               &time_);
    if (ret) {
        py_ret = Py_BuildValue("(sii)", app_exec, count, time_);
        /* Note that we mustn't free 'app_exec' even though it's not
         * 'const'.  See bug #585458. */
    } else {
        py_ret = Py_None;
    }
    return py_ret;
}
#line 5107 "gtk.c"


#line 7494 "./gtk.override"
static PyObject *
_wrap_gtk_recent_info_get_applications(PyGObject *self)
{
    gchar **apps;
    PyObject *py_apps;
    gsize length, i;

    apps = gtk_recent_info_get_applications(pyg_boxed_get(self, GtkRecentInfo),
                                            &length);
    if (!apps)
        length = 0;
    py_apps = PyList_New(length);
    for (i = 0; i < length; i++)
        PyList_SetItem(py_apps, i, PyString_FromString(apps[i]));
    g_strfreev(apps);

    return py_apps;
}
#line 5129 "gtk.c"


static PyObject *
_wrap_gtk_recent_info_last_application(PyObject *self)
{
    gchar *ret;

    
    ret = gtk_recent_info_last_application(pyg_boxed_get(self, GtkRecentInfo));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_info_has_application(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "app_name", NULL };
    char *app_name;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentInfo.has_application", kwlist, &app_name))
        return NULL;
    
    ret = gtk_recent_info_has_application(pyg_boxed_get(self, GtkRecentInfo), app_name);
    
    return PyBool_FromLong(ret);

}

#line 7514 "./gtk.override"
static PyObject *
_wrap_gtk_recent_info_get_groups(PyGObject *self)
{
    gchar **groups;
    PyObject *py_groups;
    gsize length, i;

    groups = gtk_recent_info_get_groups(pyg_boxed_get(self, GtkRecentInfo),
                                        &length);
    if (!groups)
        length = 0;
    py_groups = PyList_New(length);
    for (i = 0; i < length; i++)
        PyList_SetItem(py_groups, i, PyString_FromString(groups[i]));
    g_strfreev(groups);

    return py_groups;
}
#line 5184 "gtk.c"


static PyObject *
_wrap_gtk_recent_info_has_group(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group_name", NULL };
    char *group_name;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentInfo.has_group", kwlist, &group_name))
        return NULL;
    
    ret = gtk_recent_info_has_group(pyg_boxed_get(self, GtkRecentInfo), group_name);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_info_get_icon(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    int size;
    GdkPixbuf *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentInfo.get_icon", kwlist, &size))
        return NULL;
    
    ret = gtk_recent_info_get_icon(pyg_boxed_get(self, GtkRecentInfo), size);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_recent_info_get_short_name(PyObject *self)
{
    gchar *ret;

    
    ret = gtk_recent_info_get_short_name(pyg_boxed_get(self, GtkRecentInfo));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_info_get_uri_display(PyObject *self)
{
    gchar *ret;

    
    ret = gtk_recent_info_get_uri_display(pyg_boxed_get(self, GtkRecentInfo));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_info_get_age(PyObject *self)
{
    int ret;

    
    ret = gtk_recent_info_get_age(pyg_boxed_get(self, GtkRecentInfo));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_recent_info_is_local(PyObject *self)
{
    int ret;

    
    ret = gtk_recent_info_is_local(pyg_boxed_get(self, GtkRecentInfo));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_info_exists(PyObject *self)
{
    int ret;

    
    ret = gtk_recent_info_exists(pyg_boxed_get(self, GtkRecentInfo));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_info_match(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "info_b", NULL };
    GtkRecentInfo *info_b = NULL;
    PyObject *py_info_b;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.RecentInfo.match", kwlist, &py_info_b))
        return NULL;
    if (pyg_boxed_check(py_info_b, GTK_TYPE_RECENT_INFO))
        info_b = pyg_boxed_get(py_info_b, GtkRecentInfo);
    else {
        PyErr_SetString(PyExc_TypeError, "info_b should be a GtkRecentInfo");
        return NULL;
    }
    
    ret = gtk_recent_info_match(pyg_boxed_get(self, GtkRecentInfo), info_b);
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkRecentInfo_methods[] = {
    { "get_uri", (PyCFunction)_wrap_gtk_recent_info_get_uri, METH_NOARGS,
      NULL },
    { "get_display_name", (PyCFunction)_wrap_gtk_recent_info_get_display_name, METH_NOARGS,
      NULL },
    { "get_description", (PyCFunction)_wrap_gtk_recent_info_get_description, METH_NOARGS,
      NULL },
    { "get_mime_type", (PyCFunction)_wrap_gtk_recent_info_get_mime_type, METH_NOARGS,
      NULL },
    { "get_added", (PyCFunction)_wrap_gtk_recent_info_get_added, METH_NOARGS,
      NULL },
    { "get_modified", (PyCFunction)_wrap_gtk_recent_info_get_modified, METH_NOARGS,
      NULL },
    { "get_visited", (PyCFunction)_wrap_gtk_recent_info_get_visited, METH_NOARGS,
      NULL },
    { "get_private_hint", (PyCFunction)_wrap_gtk_recent_info_get_private_hint, METH_NOARGS,
      NULL },
    { "get_application_info", (PyCFunction)_wrap_gtk_recent_info_get_application_info, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_applications", (PyCFunction)_wrap_gtk_recent_info_get_applications, METH_NOARGS,
      NULL },
    { "last_application", (PyCFunction)_wrap_gtk_recent_info_last_application, METH_NOARGS,
      NULL },
    { "has_application", (PyCFunction)_wrap_gtk_recent_info_has_application, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_groups", (PyCFunction)_wrap_gtk_recent_info_get_groups, METH_NOARGS,
      NULL },
    { "has_group", (PyCFunction)_wrap_gtk_recent_info_has_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon", (PyCFunction)_wrap_gtk_recent_info_get_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_short_name", (PyCFunction)_wrap_gtk_recent_info_get_short_name, METH_NOARGS,
      NULL },
    { "get_uri_display", (PyCFunction)_wrap_gtk_recent_info_get_uri_display, METH_NOARGS,
      NULL },
    { "get_age", (PyCFunction)_wrap_gtk_recent_info_get_age, METH_NOARGS,
      NULL },
    { "is_local", (PyCFunction)_wrap_gtk_recent_info_is_local, METH_NOARGS,
      NULL },
    { "exists", (PyCFunction)_wrap_gtk_recent_info_exists, METH_NOARGS,
      NULL },
    { "match", (PyCFunction)_wrap_gtk_recent_info_match, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRecentInfo_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RecentInfo",                   /* tp_name */
    sizeof(PyGBoxed),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRecentInfo_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)pygobject_no_constructor,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};




/* ----------- GtkCTreeNode ----------- */

#line 485 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree_node_tp_getattr(PyGPointer *self, char *attr)
{
    if (!strcmp(attr, "__members__"))
        return Py_BuildValue("[ssssss]", "children", "expanded", "is_leaf",
                             "level", "parent", "sibling");
    if (!strcmp(attr, "parent")) {
        GtkCTreeNode *node = GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->parent;
        if (node)
            return pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
        Py_INCREF(Py_None);
        return Py_None;
    } else if (!strcmp(attr, "sibling")) {
        GtkCTreeNode *node = GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->sibling;
        if (node)
            return pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
        Py_INCREF(Py_None);
        return Py_None;
    } else if (!strcmp(attr, "children")) {
        GtkCTreeNode *node = GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->children;
        PyObject *ret = PyList_New(0);
        if (ret == NULL)
            return NULL;
        while (node) {
            PyObject *py_node = pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
            if (py_node == NULL) {
                Py_DECREF(ret);
                return NULL;
            }
            PyList_Append(ret, py_node);
            Py_DECREF(py_node);
            node = GTK_CTREE_ROW(node)->sibling;
        }
        return ret;
    } else if (!strcmp(attr, "level"))
        return PyInt_FromLong(GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->level);
    else if (!strcmp(attr, "is_leaf"))
        return PyInt_FromLong(GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->is_leaf);
    else if (!strcmp(attr, "expanded"))
        return PyInt_FromLong(GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->expanded);
    PyErr_SetString(PyExc_AttributeError, attr);
    return NULL;
}
#line 5451 "gtk.c"


PyTypeObject G_GNUC_INTERNAL PyGtkCTreeNode_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CTreeNode",                   /* tp_name */
    sizeof(PyGPointer),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)_wrap_gtk_ctree_node_tp_getattr,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)pygobject_no_constructor,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- PyGtkGenericTreeModel ----------- */

static int
_wrap_pygtk_generic_tree_model_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.GenericTreeModel.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.GenericTreeModel object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_pygtk_generic_tree_model_invalidate_iters(PyGObject *self)
{
    
    pygtk_generic_tree_model_invalidate_iters(PYGTK_GENERIC_TREE_MODEL(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_pygtk_generic_tree_model_iter_is_valid(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:PyGtk.GenericTreeModel.iter_is_valid", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = pygtk_generic_tree_model_iter_is_valid(PYGTK_GENERIC_TREE_MODEL(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_pygtk_generic_tree_model_get_user_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter, *ret;
    GtkTreeIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:PyGtk.GenericTreeModel.get_user_data", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = pygtk_generic_tree_model_get_user_data(PYGTK_GENERIC_TREE_MODEL(self->obj), iter);
    
    if (!ret) ret = Py_None;
    Py_INCREF(ret);
    return ret;
}

static PyObject *
_wrap_pygtk_generic_tree_model_create_tree_iter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "user_data", NULL };
    PyObject *user_data;
    GtkTreeIter ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:PyGtk.GenericTreeModel.create_tree_iter", kwlist, &user_data))
        return NULL;
    
    ret = pygtk_generic_tree_model_create_tree_iter(PYGTK_GENERIC_TREE_MODEL(self->obj), user_data);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &ret, TRUE, TRUE);
}

static const PyMethodDef _PyPyGtkGenericTreeModel_methods[] = {
    { "invalidate_iters", (PyCFunction)_wrap_pygtk_generic_tree_model_invalidate_iters, METH_NOARGS,
      NULL },
    { "iter_is_valid", (PyCFunction)_wrap_pygtk_generic_tree_model_iter_is_valid, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_user_data", (PyCFunction)_wrap_pygtk_generic_tree_model_get_user_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "create_tree_iter", (PyCFunction)_wrap_pygtk_generic_tree_model_create_tree_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyPyGtkGenericTreeModel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.GenericTreeModel",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyPyGtkGenericTreeModel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_pygtk_generic_tree_model_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkObject ----------- */

static PyObject *
_wrap_GTK_OBJECT_FLAGS(PyGObject *self)
{
    guint ret;

    
    ret = GTK_OBJECT_FLAGS(GTK_OBJECT(self->obj));
    
    return pyg_flags_from_gtype(GTK_TYPE_WIDGET_FLAGS, ret);
}

static PyObject *
_wrap_GTK_OBJECT_SET_FLAGS(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", NULL };
    PyObject *py_flags = NULL;
    GtkWidgetFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Object.set_flags", kwlist, &py_flags))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_WIDGET_FLAGS, py_flags, (gpointer)&flags))
        return NULL;
    
    GTK_OBJECT_SET_FLAGS(GTK_OBJECT(self->obj), flags);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GTK_OBJECT_UNSET_FLAGS(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", NULL };
    PyObject *py_flags = NULL;
    GtkWidgetFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Object.unset_flags", kwlist, &py_flags))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_WIDGET_FLAGS, py_flags, (gpointer)&flags))
        return NULL;
    
    GTK_OBJECT_UNSET_FLAGS(GTK_OBJECT(self->obj), flags);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_object_destroy(PyGObject *self)
{
    
    gtk_object_destroy(GTK_OBJECT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_object_remove_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    char *key;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Object.remove_data", kwlist, &key))
        return NULL;
    
    gtk_object_remove_data(GTK_OBJECT(self->obj), key);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_object_remove_no_notify(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    char *key;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Object.remove_no_notify", kwlist, &key))
        return NULL;
    
    gtk_object_remove_no_notify(GTK_OBJECT(self->obj), key);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkObject__do_destroy(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Object.destroy", kwlist, &PyGtkObject_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OBJECT_CLASS(klass)->destroy)
        GTK_OBJECT_CLASS(klass)->destroy(GTK_OBJECT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Object.destroy not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkObject_methods[] = {
    { "flags", (PyCFunction)_wrap_GTK_OBJECT_FLAGS, METH_NOARGS,
      NULL },
    { "set_flags", (PyCFunction)_wrap_GTK_OBJECT_SET_FLAGS, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unset_flags", (PyCFunction)_wrap_GTK_OBJECT_UNSET_FLAGS, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "destroy", (PyCFunction)_wrap_gtk_object_destroy, METH_NOARGS,
      NULL },
    { "remove_data", (PyCFunction)_wrap_gtk_object_remove_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_no_notify", (PyCFunction)_wrap_gtk_object_remove_no_notify, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_destroy", (PyCFunction)_wrap_GtkObject__do_destroy, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkObject_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Object",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkObject_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkObject__proxy_do_destroy(GtkObject *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_destroy");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkObject_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkObjectClass *klass = GTK_OBJECT_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_destroy");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "destroy")))
            klass->destroy = _wrap_GtkObject__proxy_do_destroy;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkCellRenderer ----------- */

#line 2538 "gtktreeview.override"
static PyObject *
_wrap_gtk_cell_renderer_get_size(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "cell_area", NULL };
    gint x_offset = 0, y_offset = 0, width = 0, height = 0;
    GdkRectangle cell_area;
    PyObject *py_widget, *py_cell_area = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkCellRenderer.get_size", kwlist,
                                     &py_widget, &py_cell_area))
        return NULL;

    if (!pygobject_check(py_widget, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError, "widget must be a GtkWidget");
        return NULL;
    }
    if (py_cell_area != Py_None) {
        if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
            return NULL;
    }

    gtk_cell_renderer_get_size(GTK_CELL_RENDERER(self->obj),
                               GTK_WIDGET(pygobject_get(py_widget)),
                               (py_cell_area == Py_None) ? NULL : &cell_area,
                               &x_offset, &y_offset, &width, &height);

    return Py_BuildValue("(iiii)", x_offset, y_offset, width, height);
}
#line 5934 "gtk.c"


static PyObject *
_wrap_gtk_cell_renderer_render(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "widget", "background_area", "cell_area", "expose_area", "flags", NULL };
    PyGObject *window, *widget;
    PyObject *py_background_area, *py_cell_area, *py_expose_area, *py_flags = NULL;
    GdkRectangle background_area = { 0, 0, 0, 0 }, cell_area = { 0, 0, 0, 0 }, expose_area = { 0, 0, 0, 0 };
    GtkCellRendererState flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO:Gtk.CellRenderer.render", kwlist, &PyGdkWindow_Type, &window, &PyGtkWidget_Type, &widget, &py_background_area, &py_cell_area, &py_expose_area, &py_flags))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_background_area, &background_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_expose_area, &expose_area))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_CELL_RENDERER_STATE, py_flags, (gpointer)&flags))
        return NULL;
    
    gtk_cell_renderer_render(GTK_CELL_RENDERER(self->obj), GDK_WINDOW(window->obj), GTK_WIDGET(widget->obj), &background_area, &cell_area, &expose_area, flags);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_renderer_activate(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", "widget", "path", "background_area", "cell_area", "flags", NULL };
    PyObject *py_event, *py_background_area, *py_cell_area, *py_flags = NULL;
    char *path;
    GtkCellRendererState flags;
    int ret;
    GdkRectangle background_area = { 0, 0, 0, 0 }, cell_area = { 0, 0, 0, 0 };
    PyGObject *widget;
    GdkEvent *event = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO!sOOO:Gtk.CellRenderer.activate", kwlist, &py_event, &PyGtkWidget_Type, &widget, &path, &py_background_area, &py_cell_area, &py_flags))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    if (!pygdk_rectangle_from_pyobject(py_background_area, &background_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_CELL_RENDERER_STATE, py_flags, (gpointer)&flags))
        return NULL;
    
    ret = gtk_cell_renderer_activate(GTK_CELL_RENDERER(self->obj), event, GTK_WIDGET(widget->obj), path, &background_area, &cell_area, flags);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_cell_renderer_start_editing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", "widget", "path", "background_area", "cell_area", "flags", NULL };
    PyObject *py_event, *py_background_area, *py_cell_area, *py_flags = NULL;
    char *path;
    GtkCellRendererState flags;
    GdkRectangle background_area = { 0, 0, 0, 0 }, cell_area = { 0, 0, 0, 0 };
    PyGObject *widget;
    GtkCellEditable *ret;
    GdkEvent *event = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO!sOOO:Gtk.CellRenderer.start_editing", kwlist, &py_event, &PyGtkWidget_Type, &widget, &path, &py_background_area, &py_cell_area, &py_flags))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    if (!pygdk_rectangle_from_pyobject(py_background_area, &background_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_CELL_RENDERER_STATE, py_flags, (gpointer)&flags))
        return NULL;
    
    ret = gtk_cell_renderer_start_editing(GTK_CELL_RENDERER(self->obj), event, GTK_WIDGET(widget->obj), path, &background_area, &cell_area, flags);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_cell_renderer_set_fixed_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", "height", NULL };
    int width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CellRenderer.set_fixed_size", kwlist, &width, &height))
        return NULL;
    
    gtk_cell_renderer_set_fixed_size(GTK_CELL_RENDERER(self->obj), width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2570 "gtktreeview.override"
static PyObject *
_wrap_gtk_cell_renderer_get_fixed_size(PyGObject *self)
{
    gint width, height;

    gtk_cell_renderer_get_fixed_size(GTK_CELL_RENDERER(self->obj),
                                     &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
#line 6055 "gtk.c"


static PyObject *
_wrap_gtk_cell_renderer_editing_canceled(PyGObject *self)
{
    
    gtk_cell_renderer_editing_canceled(GTK_CELL_RENDERER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_renderer_stop_editing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "canceled", NULL };
    int canceled;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CellRenderer.stop_editing", kwlist, &canceled))
        return NULL;
    
    gtk_cell_renderer_stop_editing(GTK_CELL_RENDERER(self->obj), canceled);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_renderer_set_alignment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "xalign", "yalign", NULL };
    double xalign, yalign;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dd:Gtk.CellRenderer.set_alignment", kwlist, &xalign, &yalign))
        return NULL;
    
    gtk_cell_renderer_set_alignment(GTK_CELL_RENDERER(self->obj), xalign, yalign);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 8785 "./gtk.override"
static PyObject *
_wrap_gtk_cell_renderer_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_cell_renderer_get_alignment(GTK_CELL_RENDERER(self->obj),
                                    &xalign, &yalign);

    return Py_BuildValue("(dd)", xalign, yalign);
}
#line 6109 "gtk.c"


static PyObject *
_wrap_gtk_cell_renderer_set_padding(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "xpad", "ypad", NULL };
    int xpad, ypad;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CellRenderer.set_padding", kwlist, &xpad, &ypad))
        return NULL;
    
    gtk_cell_renderer_set_padding(GTK_CELL_RENDERER(self->obj), xpad, ypad);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 8797 "./gtk.override"
static PyObject *
_wrap_gtk_cell_renderer_get_padding(PyGObject *self)
{
    gint xpad, ypad;

    gtk_cell_renderer_get_padding(GTK_CELL_RENDERER(self->obj), &xpad, &ypad);

    return Py_BuildValue("(ii)", xpad, ypad);
}
#line 6137 "gtk.c"


static PyObject *
_wrap_gtk_cell_renderer_set_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible", NULL };
    int visible;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CellRenderer.set_visible", kwlist, &visible))
        return NULL;
    
    gtk_cell_renderer_set_visible(GTK_CELL_RENDERER(self->obj), visible);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_renderer_get_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_cell_renderer_get_visible(GTK_CELL_RENDERER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_cell_renderer_set_sensitive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sensitive", NULL };
    int sensitive;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CellRenderer.set_sensitive", kwlist, &sensitive))
        return NULL;
    
    gtk_cell_renderer_set_sensitive(GTK_CELL_RENDERER(self->obj), sensitive);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_renderer_get_sensitive(PyGObject *self)
{
    int ret;

    
    ret = gtk_cell_renderer_get_sensitive(GTK_CELL_RENDERER(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 6616 "./gtk.override"
static PyObject *
_wrap_GtkCellRenderer__do_get_size(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "widget", "cell_area", NULL };
    PyGObject *self, *widget;
    PyObject *py_cell_area = Py_None;
    gint x, y, width, height;
    GdkRectangle cell_area, *cell_area_ptr;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!|O:GtkCellRenderer.do_get_size", kwlist,
                                     &PyGtkCellRenderer_Type, &self,
                                     &PyGtkWidget_Type, &widget,
                                     &py_cell_area))
        return NULL;

    if (py_cell_area == Py_None) {
	cell_area_ptr = NULL;
    }
    else {
	if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
	    return NULL;
	cell_area_ptr = &cell_area;
    }

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_CLASS(klass)->get_size)
        GTK_CELL_RENDERER_CLASS(klass)->get_size(GTK_CELL_RENDERER(self->obj),
                                                 GTK_WIDGET(widget->obj),
                                                 cell_area_ptr,
                                                 &x, &y, &width, &height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkContainer.get_child_property not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    
    return Py_BuildValue("(iiii)", x, y, width, height);
}


#line 6237 "gtk.c"


static PyObject *
_wrap_GtkCellRenderer__do_render(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "widget", "background_area", "cell_area", "expose_area", "flags", NULL };
    PyGObject *self, *window, *widget;
    PyObject *py_background_area, *py_cell_area, *py_expose_area, *py_flags = NULL;
    GdkRectangle background_area = { 0, 0, 0, 0 }, cell_area = { 0, 0, 0, 0 }, expose_area = { 0, 0, 0, 0 };
    GtkCellRendererState flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!OOOO:Gtk.CellRenderer.render", kwlist, &PyGtkCellRenderer_Type, &self, &PyGdkDrawable_Type, &window, &PyGtkWidget_Type, &widget, &py_background_area, &py_cell_area, &py_expose_area, &py_flags))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_background_area, &background_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_expose_area, &expose_area))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_CELL_RENDERER_STATE, py_flags, (gpointer)&flags))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_CLASS(klass)->render)
        GTK_CELL_RENDERER_CLASS(klass)->render(GTK_CELL_RENDERER(self->obj), GDK_DRAWABLE(window->obj), GTK_WIDGET(widget->obj), &background_area, &cell_area, &expose_area, flags);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CellRenderer.render not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellRenderer__do_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", "widget", "path", "background_area", "cell_area", "flags", NULL };
    PyObject *py_event, *py_background_area, *py_cell_area, *py_flags = NULL;
    char *path;
    GdkEvent *event = NULL;
    int ret;
    GdkRectangle background_area = { 0, 0, 0, 0 }, cell_area = { 0, 0, 0, 0 };
    GtkCellRendererState flags;
    PyGObject *self, *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO!sOOO:Gtk.CellRenderer.activate", kwlist, &PyGtkCellRenderer_Type, &self, &py_event, &PyGtkWidget_Type, &widget, &path, &py_background_area, &py_cell_area, &py_flags))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    if (!pygdk_rectangle_from_pyobject(py_background_area, &background_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_CELL_RENDERER_STATE, py_flags, (gpointer)&flags))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_CLASS(klass)->activate)
        ret = GTK_CELL_RENDERER_CLASS(klass)->activate(GTK_CELL_RENDERER(self->obj), event, GTK_WIDGET(widget->obj), path, &background_area, &cell_area, flags);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CellRenderer.activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkCellRenderer__do_editing_canceled(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CellRenderer.editing_canceled", kwlist, &PyGtkCellRenderer_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_CLASS(klass)->editing_canceled)
        GTK_CELL_RENDERER_CLASS(klass)->editing_canceled(GTK_CELL_RENDERER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CellRenderer.editing_canceled not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellRenderer__do_editing_started(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "editable", "path", NULL };
    PyGObject *self, *editable;
    char *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!s:Gtk.CellRenderer.editing_started", kwlist, &PyGtkCellRenderer_Type, &self, &PyGtkCellEditable_Type, &editable, &path))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_CLASS(klass)->editing_started)
        GTK_CELL_RENDERER_CLASS(klass)->editing_started(GTK_CELL_RENDERER(self->obj), GTK_CELL_EDITABLE(editable->obj), path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CellRenderer.editing_started not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellRenderer__do_start_editing(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", "widget", "path", "background_area", "cell_area", "flags", NULL };
    PyObject *py_event, *py_background_area, *py_cell_area, *py_flags = NULL;
    char *path;
    GdkEvent *event = NULL;
    GdkRectangle background_area = { 0, 0, 0, 0 }, cell_area = { 0, 0, 0, 0 };
    GtkCellRendererState flags;
    GtkCellEditable *ret;
    PyGObject *self, *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO!sOOO:Gtk.CellRenderer.start_editing", kwlist, &PyGtkCellRenderer_Type, &self, &py_event, &PyGtkWidget_Type, &widget, &path, &py_background_area, &py_cell_area, &py_flags))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    if (!pygdk_rectangle_from_pyobject(py_background_area, &background_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_CELL_RENDERER_STATE, py_flags, (gpointer)&flags))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_CLASS(klass)->start_editing)
        ret = GTK_CELL_RENDERER_CLASS(klass)->start_editing(GTK_CELL_RENDERER(self->obj), event, GTK_WIDGET(widget->obj), path, &background_area, &cell_area, flags);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CellRenderer.start_editing not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkCellRenderer_methods[] = {
    { "get_size", (PyCFunction)_wrap_gtk_cell_renderer_get_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "render", (PyCFunction)_wrap_gtk_cell_renderer_render, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "activate", (PyCFunction)_wrap_gtk_cell_renderer_activate, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "start_editing", (PyCFunction)_wrap_gtk_cell_renderer_start_editing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_fixed_size", (PyCFunction)_wrap_gtk_cell_renderer_set_fixed_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_fixed_size", (PyCFunction)_wrap_gtk_cell_renderer_get_fixed_size, METH_NOARGS,
      NULL },
    { "editing_canceled", (PyCFunction)_wrap_gtk_cell_renderer_editing_canceled, METH_NOARGS,
      NULL },
    { "stop_editing", (PyCFunction)_wrap_gtk_cell_renderer_stop_editing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_alignment", (PyCFunction)_wrap_gtk_cell_renderer_set_alignment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_alignment", (PyCFunction)_wrap_gtk_cell_renderer_get_alignment, METH_NOARGS,
      NULL },
    { "set_padding", (PyCFunction)_wrap_gtk_cell_renderer_set_padding, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_padding", (PyCFunction)_wrap_gtk_cell_renderer_get_padding, METH_NOARGS,
      NULL },
    { "set_visible", (PyCFunction)_wrap_gtk_cell_renderer_set_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible", (PyCFunction)_wrap_gtk_cell_renderer_get_visible, METH_NOARGS,
      NULL },
    { "set_sensitive", (PyCFunction)_wrap_gtk_cell_renderer_set_sensitive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_sensitive", (PyCFunction)_wrap_gtk_cell_renderer_get_sensitive, METH_NOARGS,
      NULL },
    { "do_get_size", (PyCFunction)_wrap_GtkCellRenderer__do_get_size, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_render", (PyCFunction)_wrap_GtkCellRenderer__do_render, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_activate", (PyCFunction)_wrap_GtkCellRenderer__do_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_editing_canceled", (PyCFunction)_wrap_GtkCellRenderer__do_editing_canceled, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_editing_started", (PyCFunction)_wrap_GtkCellRenderer__do_editing_started, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_start_editing", (PyCFunction)_wrap_GtkCellRenderer__do_start_editing, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkCellRenderer_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellRenderer",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCellRenderer_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

#line 6561 "./gtk.override"
static void
_wrap_GtkCellRenderer__proxy_do_get_size (GtkCellRenderer *cell,
                                          GtkWidget       *widget,
                                          GdkRectangle    *cell_area,
                                          gint            *x_offset,
                                          gint            *y_offset,
                                          gint            *width,
                                          gint            *height)
{
    PyGILState_STATE state;
    PyObject *self, *py_ret, *py_widget, *py_cell_area;
    gint my_x, my_y, my_width, my_height;

    state = pyg_gil_state_ensure();
    self = pygobject_new((GObject *)cell);
    py_widget = pygobject_new((GObject *)widget);
    py_cell_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, cell_area, TRUE, TRUE);

    py_ret = PyObject_CallMethod(self, "do_get_size", "OO",
				 py_widget, py_cell_area);
    if (!py_ret) {
	PyErr_Print();
	Py_DECREF(self);
	Py_DECREF(py_widget);
	Py_DECREF(py_cell_area);
	pyg_gil_state_release(state);
	return;
    }
    Py_DECREF(self);
    Py_DECREF(py_widget);
    Py_DECREF(py_cell_area);

    if (!PyArg_ParseTuple(py_ret, "iiii",
			  &my_x, &my_y, &my_width, &my_height)) {
	PyErr_Print();
	Py_DECREF(py_ret);
	pyg_gil_state_release(state);
	return;
    }
    Py_DECREF(py_ret);

    pyg_gil_state_release(state);

    /* success */
    if (x_offset)
	*x_offset = my_x;
    if (y_offset)
	*y_offset = my_y;
    if (width)
	*width = my_width;
    if (height)
	*height = my_height;
}
#line 6545 "gtk.c"


static void
_wrap_GtkCellRenderer__proxy_do_render(GtkCellRenderer *self, GdkDrawable*window, GtkWidget*widget, GdkRectangle*background_area, GdkRectangle*cell_area, GdkRectangle*expose_area, GtkCellRendererState flags)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_widget = NULL;
    PyObject *py_background_area;
    PyObject *py_cell_area;
    PyObject *py_expose_area;
    PyObject *py_flags;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    py_background_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, background_area, TRUE, TRUE);
    py_cell_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, cell_area, TRUE, TRUE);
    py_expose_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, expose_area, TRUE, TRUE);
    py_flags = pyg_flags_from_gtype(GTK_TYPE_CELL_RENDERER_STATE, flags);
    if (!py_flags) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_expose_area);
        Py_DECREF(py_cell_area);
        Py_DECREF(py_background_area);
        Py_DECREF(py_widget);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(6);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_widget);
    PyTuple_SET_ITEM(py_args, 2, py_background_area);
    PyTuple_SET_ITEM(py_args, 3, py_cell_area);
    PyTuple_SET_ITEM(py_args, 4, py_expose_area);
    PyTuple_SET_ITEM(py_args, 5, py_flags);
    
    py_method = PyObject_GetAttrString(py_self, "do_render");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkCellRenderer__proxy_do_activate(GtkCellRenderer *self, GdkEvent*event, GtkWidget*widget, const gchar*path, GdkRectangle*background_area, GdkRectangle*cell_area, GtkCellRendererState flags)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    PyObject *py_widget = NULL;
    PyObject *py_path = NULL;
    PyObject *py_background_area;
    PyObject *py_cell_area;
    PyObject *py_flags;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (path)
        py_path = PyString_FromString(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_event);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_background_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, background_area, TRUE, TRUE);
    py_cell_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, cell_area, TRUE, TRUE);
    py_flags = pyg_flags_from_gtype(GTK_TYPE_CELL_RENDERER_STATE, flags);
    if (!py_flags) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_cell_area);
        Py_DECREF(py_background_area);
        Py_DECREF(py_path);
        Py_DECREF(py_widget);
        Py_DECREF(py_event);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(6);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    PyTuple_SET_ITEM(py_args, 1, py_widget);
    PyTuple_SET_ITEM(py_args, 2, py_path);
    PyTuple_SET_ITEM(py_args, 3, py_background_area);
    PyTuple_SET_ITEM(py_args, 4, py_cell_area);
    PyTuple_SET_ITEM(py_args, 5, py_flags);
    
    py_method = PyObject_GetAttrString(py_self, "do_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkCellRenderer__proxy_do_editing_canceled(GtkCellRenderer *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_editing_canceled");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCellRenderer__proxy_do_editing_started(GtkCellRenderer *self, GtkCellEditable*editable, const gchar*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_editable = NULL;
    PyObject *py_path = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (editable)
        py_editable = pygobject_new((GObject *) editable);
    else {
        Py_INCREF(Py_None);
        py_editable = Py_None;
    }
    if (path)
        py_path = PyString_FromString(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_editable);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_editable);
    PyTuple_SET_ITEM(py_args, 1, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_editing_started");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GtkCellEditable*
_wrap_GtkCellRenderer__proxy_do_start_editing(GtkCellRenderer *self, GdkEvent*event, GtkWidget*widget, const gchar*path, GdkRectangle*background_area, GdkRectangle*cell_area, GtkCellRendererState flags)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    PyObject *py_widget = NULL;
    PyObject *py_path = NULL;
    PyObject *py_background_area;
    PyObject *py_cell_area;
    PyObject *py_flags;
    GtkCellEditable* retval = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (path)
        py_path = PyString_FromString(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_event);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_background_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, background_area, TRUE, TRUE);
    py_cell_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, cell_area, TRUE, TRUE);
    py_flags = pyg_flags_from_gtype(GTK_TYPE_CELL_RENDERER_STATE, flags);
    if (!py_flags) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_cell_area);
        Py_DECREF(py_background_area);
        Py_DECREF(py_path);
        Py_DECREF(py_widget);
        Py_DECREF(py_event);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    py_args = PyTuple_New(6);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    PyTuple_SET_ITEM(py_args, 1, py_widget);
    PyTuple_SET_ITEM(py_args, 2, py_path);
    PyTuple_SET_ITEM(py_args, 3, py_background_area);
    PyTuple_SET_ITEM(py_args, 4, py_cell_area);
    PyTuple_SET_ITEM(py_args, 5, py_flags);
    
    py_method = PyObject_GetAttrString(py_self, "do_start_editing");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (py_retval != Py_None && !PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be None or a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (py_retval != Py_None) {
        retval = (GtkCellEditable*) pygobject_get(py_retval);
        g_object_ref((GObject *) retval);
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkCellRenderer_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkCellRendererClass *klass = GTK_CELL_RENDERER_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_get_size");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "get_size")))
            klass->get_size = _wrap_GtkCellRenderer__proxy_do_get_size;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_render");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "render")))
            klass->render = _wrap_GtkCellRenderer__proxy_do_render;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate")))
            klass->activate = _wrap_GtkCellRenderer__proxy_do_activate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_editing_canceled");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "editing_canceled")))
            klass->editing_canceled = _wrap_GtkCellRenderer__proxy_do_editing_canceled;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_editing_started");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "editing_started")))
            klass->editing_started = _wrap_GtkCellRenderer__proxy_do_editing_started;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_start_editing");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "start_editing")))
            klass->start_editing = _wrap_GtkCellRenderer__proxy_do_start_editing;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- PyGtkGenericCellRenderer ----------- */

static int
_wrap_pygtk_generic_cell_renderer_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.GenericCellRenderer.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.GenericCellRenderer object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyPyGtkGenericCellRenderer_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.GenericCellRenderer",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_pygtk_generic_cell_renderer_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkWidget ----------- */

#line 90 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_get_allocation(PyGObject *self)
{
    GtkAllocation allocation;

    allocation = GTK_WIDGET(self->obj)->allocation;
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &allocation, TRUE, TRUE);
}
#line 7146 "gtk.c"


static PyObject *
_wrap_gtk_drag_check_threshold(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_x", "start_y", "current_x", "current_y", NULL };
    int start_x, start_y, current_x, current_y, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iiii:Gtk.Widget.drag_check_threshold", kwlist, &start_x, &start_y, &current_x, &current_y))
        return NULL;
    
    ret = gtk_drag_check_threshold(GTK_WIDGET(self->obj), start_x, start_y, current_x, current_y);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_drag_get_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "context", "target", "time", NULL };
    PyGObject *context;
    PyObject *py_target = NULL;
    GdkAtom target;
    unsigned long time = GDK_CURRENT_TIME;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O|k:Gtk.Widget.drag_get_data", kwlist, &PyGdkDragContext_Type, &context, &py_target, &time))
        return NULL;
    target = pygdk_atom_from_pyobject(py_target);
    if (PyErr_Occurred())
        return NULL;
    
    gtk_drag_get_data(GTK_WIDGET(self->obj), GDK_DRAG_CONTEXT(context->obj), target, time);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_highlight(PyGObject *self)
{
    
    gtk_drag_highlight(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_unhighlight(PyGObject *self)
{
    
    gtk_drag_unhighlight(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2377 "./gtk.override"
static PyObject *
_wrap_gtk_drag_dest_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", "targets", "actions", NULL };
    PyObject *py_flags, *py_targets, *py_actions;
    GtkDestDefaults flags;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO:GtkWidget.drag_dest_set", kwlist,
                                     &py_flags, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, py_flags, (gint *)&flags))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!PySequence_Check(py_targets)) {
        PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
        return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_GetItem(py_targets, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
            return NULL;
        }
    }
    gtk_drag_dest_set(GTK_WIDGET(self->obj), flags, targets, n_targets,
                      actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 7249 "gtk.c"


static PyObject *
_wrap_gtk_drag_dest_set_proxy(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "proxy_window", "protocol", "use_coordinates", NULL };
    PyGObject *proxy_window;
    GdkDragProtocol protocol;
    int use_coordinates;
    PyObject *py_protocol = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oi:Gtk.Widget.drag_dest_set_proxy", kwlist, &PyGdkWindow_Type, &proxy_window, &py_protocol, &use_coordinates))
        return NULL;
    if (pyg_enum_get_value(GDK_TYPE_DRAG_PROTOCOL, py_protocol, (gpointer)&protocol))
        return NULL;
    
    gtk_drag_dest_set_proxy(GTK_WIDGET(self->obj), GDK_WINDOW(proxy_window->obj), protocol, use_coordinates);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_dest_unset(PyGObject *self)
{
    
    gtk_drag_dest_unset(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2422 "./gtk.override"
static PyObject *
_wrap_gtk_drag_dest_find_target(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "context", "target_list", NULL };
    PyObject *context, *py_targets;
    GtkTargetList *target_list;
    GdkAtom atom;
    gchar *name;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O:GtkWidget.drag_dest_find_target",
                                     kwlist, &PyGdkDragContext_Type, &context,
                                     &py_targets))
        return NULL;

    if (!(target_list = pygtk_target_list_from_sequence(py_targets)))
        return NULL;

    atom = gtk_drag_dest_find_target(GTK_WIDGET(self->obj),
                                     GDK_DRAG_CONTEXT(pygobject_get(context)),
                                     target_list);
    gtk_target_list_unref(target_list);

    name = gdk_atom_name(atom);
    ret = PyString_FromString(name);
    g_free(name);
    return ret;
}
#line 7313 "gtk.c"


#line 2454 "./gtk.override"
static PyObject *
_wrap_gtk_drag_dest_get_target_list(PyGObject *self)
{
    GtkTargetList *target_list;

    target_list = gtk_drag_dest_get_target_list(GTK_WIDGET(self->obj));

    if (!target_list) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return pygtk_target_list_to_list(target_list);
}
#line 7331 "gtk.c"


#line 2470 "./gtk.override"
static PyObject *
_wrap_gtk_drag_dest_set_target_list(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "target_list", NULL };
    PyObject *py_targets;
    GtkTargetList *target_list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkWidget.drag_dest_set_target_list",
                                     kwlist, &py_targets))
        return NULL;

    if (!(target_list = pygtk_target_list_from_sequence(py_targets)))
        return NULL;

    gtk_drag_dest_set_target_list(GTK_WIDGET(self->obj), target_list);
    gtk_target_list_unref(target_list);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 7356 "gtk.c"


#line 2493 "./gtk.override"
static PyObject *
_wrap_gtk_drag_source_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_button_mask", "targets", "actions", NULL };
    PyObject *py_sbmask, *py_targets, *py_actions;
    GdkModifierType sbmask;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO:GtkWidget.drag_source_set", kwlist,
                                     &py_sbmask, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,
                             py_sbmask, (gint *)&sbmask))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    gtk_drag_source_set(GTK_WIDGET(self->obj), sbmask, targets, n_targets,
                        actions);
    g_free(targets);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 7403 "gtk.c"


static PyObject *
_wrap_gtk_drag_source_unset(PyGObject *self)
{
    
    gtk_drag_source_unset(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_source_set_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "colormap", "pixmap", "mask", NULL };
    PyGObject *colormap, *pixmap, *py_mask = NULL;
    GdkPixmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!|O:Gtk.Widget.drag_source_set_icon", kwlist, &PyGdkColormap_Type, &colormap, &PyGdkPixmap_Type, &pixmap, &py_mask))
        return NULL;
    if ((PyObject *)py_mask == Py_None)
        mask = NULL;
    else if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if (py_mask) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return NULL;
    }
    
    gtk_drag_source_set_icon(GTK_WIDGET(self->obj), GDK_COLORMAP(colormap->obj), GDK_PIXMAP(pixmap->obj), (GdkBitmap *) mask);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_source_set_icon_pixbuf(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.drag_source_set_icon_pixbuf", kwlist, &PyGdkPixbuf_Type, &pixbuf))
        return NULL;
    
    gtk_drag_source_set_icon_pixbuf(GTK_WIDGET(self->obj), GDK_PIXBUF(pixbuf->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_source_set_icon_stock(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", NULL };
    char *stock_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Widget.drag_source_set_icon_stock", kwlist, &stock_id))
        return NULL;
    
    gtk_drag_source_set_icon_stock(GTK_WIDGET(self->obj), stock_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_source_set_icon_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    char *icon_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Widget.drag_source_set_icon_name", kwlist, &icon_name))
        return NULL;
    
    gtk_drag_source_set_icon_name(GTK_WIDGET(self->obj), icon_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 5957 "./gtk.override"
static PyObject *
_wrap_gtk_drag_source_get_target_list(PyGObject *self)
{
    GtkTargetList *target_list;

    target_list = gtk_drag_source_get_target_list(GTK_WIDGET(self->obj));

    if (!target_list) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return pygtk_target_list_to_list(target_list);
}
#line 7500 "gtk.c"


#line 5973 "./gtk.override"
static PyObject *
_wrap_gtk_drag_source_set_target_list(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "target_list", NULL };
    PyObject *py_targets;
    GtkTargetList *target_list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkWidget.drag_source_set_target_list",
                                     kwlist, &py_targets))
        return NULL;

    if (!(target_list = pygtk_target_list_from_sequence(py_targets)))
        return NULL;

    gtk_drag_source_set_target_list(GTK_WIDGET(self->obj), target_list);
    gtk_target_list_unref(target_list);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 7525 "gtk.c"


#line 2538 "./gtk.override"
static PyObject *
_wrap_gtk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "actions", "button", "event", NULL };
    PyObject *py_targets, *py_actions, *event;
    GtkTargetList *targets;
    GdkDragAction actions;
    gint button;
    GdkDragContext *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOiO:GtkWidget.drag_begin", kwlist,
                                     &py_targets, &py_actions, &button,
                                     &event))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!pyg_boxed_check(event, GDK_TYPE_EVENT)) {
        PyErr_SetString(PyExc_TypeError, "event must be a GdkEvent");
        return NULL;
    }
    if (!(targets = pygtk_target_list_from_sequence(py_targets)))
        return NULL;

    context = gtk_drag_begin(GTK_WIDGET(self->obj), targets, actions, button,
                             pyg_boxed_get(event, GdkEvent));
    gtk_target_list_unref(targets);
    return pygobject_new((GObject *)context);
}
#line 7559 "gtk.c"


static PyObject *
_wrap_gtk_drag_dest_add_text_targets(PyGObject *self)
{
    
    gtk_drag_dest_add_text_targets(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_dest_add_image_targets(PyGObject *self)
{
    
    gtk_drag_dest_add_image_targets(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_dest_add_uri_targets(PyGObject *self)
{
    
    gtk_drag_dest_add_uri_targets(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_source_add_text_targets(PyGObject *self)
{
    
    gtk_drag_source_add_text_targets(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_source_add_image_targets(PyGObject *self)
{
    
    gtk_drag_source_add_image_targets(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_source_add_uri_targets(PyGObject *self)
{
    
    gtk_drag_source_add_uri_targets(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_grab_add(PyGObject *self)
{
    
    gtk_grab_add(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_grab_remove(PyGObject *self)
{
    
    gtk_grab_remove(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 365 "gtkwidget.override"
static PyObject *
_wrap_gtk_menu_get_for_attach_widget(PyGObject *self)
{
    GList *menus;
    gint len, i;
    PyObject *pymenus;

    menus = gtk_menu_get_for_attach_widget(GTK_WIDGET(self->obj));
    len = g_list_length(menus);
    if ((pymenus = PyTuple_New(len)) == NULL)
        return NULL;

    for (i = 0; i < len; i++) {
        GtkMenu *menu = GTK_MENU(g_list_nth_data(menus, i));
        PyObject *pymenu = pygobject_new((GObject *)menu);
        PyTuple_SET_ITEM(pymenus, i, pymenu);
    }
    return pymenus;
}
#line 7662 "gtk.c"


static PyObject *
_wrap_gtk_rc_get_style(PyGObject *self)
{
    GtkStyle *ret;

    
    ret = gtk_rc_get_style(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_selection_owner_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "time", NULL };
    PyObject *py_selection = NULL;
    unsigned long time = GDK_CURRENT_TIME;
    int ret;
    GdkAtom selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O|k:Gtk.Widget.selection_owner_set", kwlist, &py_selection, &time))
        return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;
    
    ret = gtk_selection_owner_set(GTK_WIDGET(self->obj), selection, time);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_selection_add_target(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "target", "info", NULL };
    PyObject *py_selection = NULL, *py_target = NULL, *py_info = NULL;
    GdkAtom selection, target;
    guint info = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOO:Gtk.Widget.selection_add_target", kwlist, &py_selection, &py_target, &py_info))
        return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;
    target = pygdk_atom_from_pyobject(py_target);
    if (PyErr_Occurred())
        return NULL;
    if (py_info) {
        if (PyLong_Check(py_info))
            info = PyLong_AsUnsignedLong(py_info);
        else if (PyInt_Check(py_info))
            info = PyInt_AsLong(py_info);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'info' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_selection_add_target(GTK_WIDGET(self->obj), selection, target, info);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2570 "./gtk.override"
static PyObject *
_wrap_gtk_selection_add_targets(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "targets", NULL };
    PyObject *py_targets, *py_selection;
    GtkTargetEntry *targets;
    GdkAtom selection;
    int n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:GtkWidget.selection_add_targets",
                                     kwlist, &py_selection, &py_targets))
        return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;

    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    gtk_selection_add_targets(GTK_WIDGET(self->obj), selection,
                              targets, n_targets);
    g_free(targets);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 7773 "gtk.c"


static PyObject *
_wrap_gtk_selection_clear_targets(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "selection", NULL };
    PyObject *py_selection = NULL;
    GdkAtom selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.selection_clear_targets", kwlist, &py_selection))
        return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;
    
    gtk_selection_clear_targets(GTK_WIDGET(self->obj), selection);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_selection_convert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "target", "time", NULL };
    PyObject *py_selection = NULL, *py_target = NULL;
    unsigned long time = GDK_CURRENT_TIME;
    int ret;
    GdkAtom selection, target;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO|k:Gtk.Widget.selection_convert", kwlist, &py_selection, &py_target, &time))
        return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;
    target = pygdk_atom_from_pyobject(py_target);
    if (PyErr_Occurred())
        return NULL;
    
    ret = gtk_selection_convert(GTK_WIDGET(self->obj), selection, target, time);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_selection_remove_all(PyGObject *self)
{
    
    gtk_selection_remove_all(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_destroy(PyGObject *self)
{
    
    gtk_widget_destroy(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_unparent(PyGObject *self)
{
    
    gtk_widget_unparent(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_show(PyGObject *self)
{
    
    gtk_widget_show(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_show_now(PyGObject *self)
{
    
    gtk_widget_show_now(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_hide(PyGObject *self)
{
    
    gtk_widget_hide(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_show_all(PyGObject *self)
{
    
    gtk_widget_show_all(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_hide_all(PyGObject *self)
{
    
    gtk_widget_hide_all(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_no_show_all(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "no_show_all", NULL };
    int no_show_all;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_no_show_all", kwlist, &no_show_all))
        return NULL;
    
    gtk_widget_set_no_show_all(GTK_WIDGET(self->obj), no_show_all);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_no_show_all(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_no_show_all(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_map(PyGObject *self)
{
    
    gtk_widget_map(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_unmap(PyGObject *self)
{
    
    gtk_widget_unmap(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_realize(PyGObject *self)
{
    
    gtk_widget_realize(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_unrealize(PyGObject *self)
{
    
    gtk_widget_unrealize(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_queue_draw(PyGObject *self)
{
    
    gtk_widget_queue_draw(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_queue_draw_area(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", "width", "height", NULL };
    int x, y, width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iiii:Gtk.Widget.queue_draw_area", kwlist, &x, &y, &width, &height))
        return NULL;
    
    gtk_widget_queue_draw_area(GTK_WIDGET(self->obj), x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_queue_clear(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkWidget.queue_draw") < 0)
        return NULL;
    
    gtk_widget_queue_clear(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_queue_clear_area(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", "width", "height", NULL };
    int x, y, width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iiii:Gtk.Widget.queue_clear_area", kwlist, &x, &y, &width, &height))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkWidget.queue_draw_area") < 0)
        return NULL;
    
    gtk_widget_queue_clear_area(GTK_WIDGET(self->obj), x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_queue_resize(PyGObject *self)
{
    
    gtk_widget_queue_resize(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_queue_resize_no_redraw(PyGObject *self)
{
    
    gtk_widget_queue_resize_no_redraw(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_draw(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "area", NULL };
    PyObject *py_area;
    GdkRectangle area = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.draw", kwlist, &py_area))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkWidget.queue_draw_area") < 0)
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    
    gtk_widget_draw(GTK_WIDGET(self->obj), &area);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 70 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_size_request(PyGObject *self)
{
    GtkRequisition requisition;

    gtk_widget_size_request(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
#line 8069 "gtk.c"


static PyObject *
_wrap_gtk_widget_size_allocate(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "allocation", NULL };
    PyObject *py_allocation;
    GdkRectangle allocation = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.size_allocate", kwlist, &py_allocation))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_allocation, &allocation))
        return NULL;
    
    gtk_widget_size_allocate(GTK_WIDGET(self->obj), &allocation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 80 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_get_child_requisition(PyGObject *self)
{
    GtkRequisition requisition;

    gtk_widget_get_child_requisition(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
#line 8099 "gtk.c"


static PyObject *
_wrap_gtk_widget_add_accelerator(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_signal", "accel_group", "accel_key", "accel_mods", "accel_flags", NULL };
    PyObject *py_accel_key = NULL, *py_accel_mods = NULL, *py_accel_flags = NULL;
    GdkModifierType accel_mods;
    GtkAccelFlags accel_flags;
    guint accel_key = 0;
    char *accel_signal;
    PyGObject *accel_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO!OOO:Gtk.Widget.add_accelerator", kwlist, &accel_signal, &PyGtkAccelGroup_Type, &accel_group, &py_accel_key, &py_accel_mods, &py_accel_flags))
        return NULL;
    if (py_accel_key) {
        if (PyLong_Check(py_accel_key))
            accel_key = PyLong_AsUnsignedLong(py_accel_key);
        else if (PyInt_Check(py_accel_key))
            accel_key = PyInt_AsLong(py_accel_key);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'accel_key' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gpointer)&accel_mods))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_ACCEL_FLAGS, py_accel_flags, (gpointer)&accel_flags))
        return NULL;
    
    gtk_widget_add_accelerator(GTK_WIDGET(self->obj), accel_signal, GTK_ACCEL_GROUP(accel_group->obj), accel_key, accel_mods, accel_flags);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_remove_accelerator(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_group", "accel_key", "accel_mods", NULL };
    PyGObject *accel_group;
    PyObject *py_accel_key = NULL, *py_accel_mods = NULL;
    int ret;
    GdkModifierType accel_mods;
    guint accel_key = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.Widget.remove_accelerator", kwlist, &PyGtkAccelGroup_Type, &accel_group, &py_accel_key, &py_accel_mods))
        return NULL;
    if (py_accel_key) {
        if (PyLong_Check(py_accel_key))
            accel_key = PyLong_AsUnsignedLong(py_accel_key);
        else if (PyInt_Check(py_accel_key))
            accel_key = PyInt_AsLong(py_accel_key);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'accel_key' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gpointer)&accel_mods))
        return NULL;
    
    ret = gtk_widget_remove_accelerator(GTK_WIDGET(self->obj), GTK_ACCEL_GROUP(accel_group->obj), accel_key, accel_mods);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_set_accel_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", "accel_group", NULL };
    char *accel_path;
    PyGObject *py_accel_group;
    GtkAccelGroup *accel_group = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"zO:Gtk.Widget.set_accel_path", kwlist, &accel_path, &py_accel_group))
        return NULL;
    if (py_accel_group && pygobject_check(py_accel_group, &PyGtkAccelGroup_Type))
        accel_group = GTK_ACCEL_GROUP(py_accel_group->obj);
    else if ((PyObject *)py_accel_group != Py_None) {
        PyErr_SetString(PyExc_TypeError, "accel_group should be a GtkAccelGroup or None");
        return NULL;
    }
    
    gtk_widget_set_accel_path(GTK_WIDGET(self->obj), accel_path, (GtkAccelGroup *) accel_group);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 579 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_list_accel_closures(PyGObject *self)
{
    int i;
    GList *ret, *tmp;
    PyObject *pyret;

    ret = gtk_widget_list_accel_closures(GTK_WIDGET(self->obj));

    pyret = PyList_New(g_list_length(ret));
    for (tmp = ret, i = 0; tmp; tmp = tmp->next, i++) {
        PyObject *item = pyg_boxed_new(G_TYPE_CLOSURE, tmp->data, TRUE, TRUE);
        PyList_SET_ITEM(pyret, i, item);
    }

    g_list_free(ret);
    return pyret;
}
#line 8209 "gtk.c"


static PyObject *
_wrap_gtk_widget_can_activate_accel(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "signal_id", NULL };
    PyObject *py_signal_id = NULL;
    int ret;
    guint signal_id = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.can_activate_accel", kwlist, &py_signal_id))
        return NULL;
    if (py_signal_id) {
        if (PyLong_Check(py_signal_id))
            signal_id = PyLong_AsUnsignedLong(py_signal_id);
        else if (PyInt_Check(py_signal_id))
            signal_id = PyInt_AsLong(py_signal_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'signal_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_widget_can_activate_accel(GTK_WIDGET(self->obj), signal_id);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_mnemonic_activate(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group_cycling", NULL };
    int group_cycling, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.mnemonic_activate", kwlist, &group_cycling))
        return NULL;
    
    ret = gtk_widget_mnemonic_activate(GTK_WIDGET(self->obj), group_cycling);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_event(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", NULL };
    GdkEvent *event = NULL;
    PyObject *py_event;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.event", kwlist, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    ret = gtk_widget_event(GTK_WIDGET(self->obj), event);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_send_expose(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", NULL };
    GdkEvent *event = NULL;
    PyObject *py_event;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.send_expose", kwlist, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    ret = gtk_widget_send_expose(GTK_WIDGET(self->obj), event);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_widget_activate(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_activate(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_set_scroll_adjustments(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "hadjustment", "vadjustment", NULL };
    PyGObject *py_hadjustment, *py_vadjustment;
    int ret;
    GtkAdjustment *hadjustment = NULL, *vadjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Widget.set_scroll_adjustments", kwlist, &py_hadjustment, &py_vadjustment))
        return NULL;
    if (py_hadjustment && pygobject_check(py_hadjustment, &PyGtkAdjustment_Type))
        hadjustment = GTK_ADJUSTMENT(py_hadjustment->obj);
    else if ((PyObject *)py_hadjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "hadjustment should be a GtkAdjustment or None");
        return NULL;
    }
    if (py_vadjustment && pygobject_check(py_vadjustment, &PyGtkAdjustment_Type))
        vadjustment = GTK_ADJUSTMENT(py_vadjustment->obj);
    else if ((PyObject *)py_vadjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "vadjustment should be a GtkAdjustment or None");
        return NULL;
    }
    
    ret = gtk_widget_set_scroll_adjustments(GTK_WIDGET(self->obj), (GtkAdjustment *) hadjustment, (GtkAdjustment *) vadjustment);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_reparent(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "new_parent", NULL };
    PyGObject *new_parent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.reparent", kwlist, &PyGtkWidget_Type, &new_parent))
        return NULL;
    
    gtk_widget_reparent(GTK_WIDGET(self->obj), GTK_WIDGET(new_parent->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 100 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_intersect(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "area", NULL };
    PyObject *py_area;
    GdkRectangle area, intersect;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkWidget.intersect",
                                    kwlist, &py_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (gtk_widget_intersect(GTK_WIDGET(self->obj), &area, &intersect))
        return pyg_boxed_new(GDK_TYPE_RECTANGLE, &intersect, TRUE, TRUE);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
#line 8375 "gtk.c"


static PyObject *
_wrap_gtk_widget_region_intersect(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "region", NULL };
    PyObject *py_region;
    GdkRegion *region = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.region_intersect", kwlist, &py_region))
        return NULL;
    if (pyg_boxed_check(py_region, PYGDK_TYPE_REGION))
        region = pyg_boxed_get(py_region, GdkRegion);
    else {
        PyErr_SetString(PyExc_TypeError, "region should be a GdkRegion");
        return NULL;
    }
    
    ret = gtk_widget_region_intersect(GTK_WIDGET(self->obj), region);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PYGDK_TYPE_REGION, ret, FALSE, TRUE);
}

static PyObject *
_wrap_gtk_widget_freeze_child_notify(PyGObject *self)
{
    
    gtk_widget_freeze_child_notify(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_child_notify(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child_property", NULL };
    char *child_property;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Widget.child_notify", kwlist, &child_property))
        return NULL;
    
    gtk_widget_child_notify(GTK_WIDGET(self->obj), child_property);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_thaw_child_notify(PyGObject *self)
{
    
    gtk_widget_thaw_child_notify(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_is_focus(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_is_focus(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_grab_focus(PyGObject *self)
{
    
    gtk_widget_grab_focus(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_grab_default(PyGObject *self)
{
    
    gtk_widget_grab_default(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Widget.set_name", kwlist, &name))
        return NULL;
    
    gtk_widget_set_name(GTK_WIDGET(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_widget_get_name(GTK_WIDGET(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_state(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "state", NULL };
    PyObject *py_state = NULL;
    GtkStateType state;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.set_state", kwlist, &py_state))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state, (gpointer)&state))
        return NULL;
    
    gtk_widget_set_state(GTK_WIDGET(self->obj), state);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_sensitive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sensitive", NULL };
    int sensitive;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_sensitive", kwlist, &sensitive))
        return NULL;
    
    gtk_widget_set_sensitive(GTK_WIDGET(self->obj), sensitive);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_app_paintable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "app_paintable", NULL };
    int app_paintable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_app_paintable", kwlist, &app_paintable))
        return NULL;
    
    gtk_widget_set_app_paintable(GTK_WIDGET(self->obj), app_paintable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_double_buffered(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "double_buffered", NULL };
    int double_buffered;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_double_buffered", kwlist, &double_buffered))
        return NULL;
    
    gtk_widget_set_double_buffered(GTK_WIDGET(self->obj), double_buffered);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_redraw_on_allocate(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "redraw_on_allocate", NULL };
    int redraw_on_allocate;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_redraw_on_allocate", kwlist, &redraw_on_allocate))
        return NULL;
    
    gtk_widget_set_redraw_on_allocate(GTK_WIDGET(self->obj), redraw_on_allocate);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_parent(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyGObject *parent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.set_parent", kwlist, &PyGtkWidget_Type, &parent))
        return NULL;
    
    gtk_widget_set_parent(GTK_WIDGET(self->obj), GTK_WIDGET(parent->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_parent_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent_window", NULL };
    PyGObject *py_parent_window;
    GdkWindow *parent_window = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.set_parent_window", kwlist, &py_parent_window))
        return NULL;
    if (py_parent_window && pygobject_check(py_parent_window, &PyGdkWindow_Type))
        parent_window = GDK_WINDOW(py_parent_window->obj);
    else if ((PyObject *)py_parent_window != Py_None) {
        PyErr_SetString(PyExc_TypeError, "parent_window should be a GdkWindow or None");
        return NULL;
    }
    
    gtk_widget_set_parent_window(GTK_WIDGET(self->obj), (GdkWindow *) parent_window);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_child_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "is_visible", NULL };
    int is_visible;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_child_visible", kwlist, &is_visible))
        return NULL;
    
    gtk_widget_set_child_visible(GTK_WIDGET(self->obj), is_visible);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_child_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_child_visible(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_get_parent(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_widget_get_parent(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_get_parent_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_widget_get_parent_window(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_child_focus(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "direction", NULL };
    PyObject *py_direction = NULL;
    int ret;
    GtkDirectionType direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.child_focus", kwlist, &py_direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, py_direction, (gpointer)&direction))
        return NULL;
    
    ret = gtk_widget_child_focus(GTK_WIDGET(self->obj), direction);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_set_size_request(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", "height", NULL };
    int width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Widget.set_size_request", kwlist, &width, &height))
        return NULL;
    
    gtk_widget_set_size_request(GTK_WIDGET(self->obj), width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 172 "gtkwindow.override"
static PyObject *
_wrap_gtk_widget_get_size_request(PyGObject *self)
{
    int width, height;

    gtk_widget_get_size_request(GTK_WIDGET(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
#line 8705 "gtk.c"


static PyObject *
_wrap_gtk_widget_set_uposition(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    int x, y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Widget.set_uposition", kwlist, &x, &y))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_widget_set_uposition(GTK_WIDGET(self->obj), x, y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_usize(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", "height", NULL };
    int width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Widget.set_usize", kwlist, &width, &height))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkWidget.set_size_request") < 0)
        return NULL;
    
    gtk_widget_set_usize(GTK_WIDGET(self->obj), width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_events(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "events", NULL };
    int events;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_events", kwlist, &events))
        return NULL;
    
    gtk_widget_set_events(GTK_WIDGET(self->obj), events);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_add_events(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "events", NULL };
    int events;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.add_events", kwlist, &events))
        return NULL;
    
    gtk_widget_add_events(GTK_WIDGET(self->obj), events);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_extension_events(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mode", NULL };
    PyObject *py_mode = NULL;
    GdkExtensionMode mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.set_extension_events", kwlist, &py_mode))
        return NULL;
    if (pyg_enum_get_value(GDK_TYPE_EXTENSION_MODE, py_mode, (gpointer)&mode))
        return NULL;
    
    gtk_widget_set_extension_events(GTK_WIDGET(self->obj), mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_extension_events(PyGObject *self)
{
    gint ret;

    
    ret = gtk_widget_get_extension_events(GTK_WIDGET(self->obj));
    
    return pyg_enum_from_gtype(GDK_TYPE_EXTENSION_MODE, ret);
}

static PyObject *
_wrap_gtk_widget_get_toplevel(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_widget_get_toplevel(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_get_ancestor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget_type", NULL };
    PyObject *py_widget_type = NULL;
    GType widget_type;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.get_ancestor", kwlist, &py_widget_type))
        return NULL;
    if ((widget_type = pyg_type_from_object(py_widget_type)) == 0)
        return NULL;
    
    ret = gtk_widget_get_ancestor(GTK_WIDGET(self->obj), widget_type);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_get_colormap(PyGObject *self)
{
    GdkColormap *ret;

    
    ret = gtk_widget_get_colormap(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_get_visual(PyGObject *self)
{
    GdkVisual *ret;

    
    ret = gtk_widget_get_visual(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_get_screen(PyGObject *self)
{
    GdkScreen *ret;

    
    ret = gtk_widget_get_screen(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_has_screen(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_has_screen(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_get_display(PyGObject *self)
{
    GdkDisplay *ret;

    
    ret = gtk_widget_get_display(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_get_root_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_widget_get_root_window(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_get_settings(PyGObject *self)
{
    GtkSettings *ret;

    
    ret = gtk_widget_get_settings(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_get_clipboard(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "selection", NULL };
    PyObject *py_selection = NULL;
    GdkAtom selection;
    GtkClipboard *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.get_clipboard", kwlist, &py_selection))
        return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;
    
    ret = gtk_widget_get_clipboard(GTK_WIDGET(self->obj), selection);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_get_accessible(PyGObject *self)
{
    AtkObject *ret;

    
    ret = gtk_widget_get_accessible(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_set_colormap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "colormap", NULL };
    PyGObject *colormap;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.set_colormap", kwlist, &PyGdkColormap_Type, &colormap))
        return NULL;
    
    gtk_widget_set_colormap(GTK_WIDGET(self->obj), GDK_COLORMAP(colormap->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_events(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_events(GTK_WIDGET(self->obj));
    
    return PyInt_FromLong(ret);
}

#line 121 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_get_pointer(PyGObject *self)
{
    int x, y;

    gtk_widget_get_pointer(GTK_WIDGET(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
#line 8983 "gtk.c"


static PyObject *
_wrap_gtk_widget_is_ancestor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "ancestor", NULL };
    PyGObject *ancestor;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.is_ancestor", kwlist, &PyGtkWidget_Type, &ancestor))
        return NULL;
    
    ret = gtk_widget_is_ancestor(GTK_WIDGET(self->obj), GTK_WIDGET(ancestor->obj));
    
    return PyBool_FromLong(ret);

}

#line 35 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_translate_coordinates(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dest_widget", "src_x", "src_y", NULL };
    PyObject *py_dest_widget;
    int src_x, src_y;
    GtkWidget *dest_widget = NULL;
    int dest_x, dest_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oii:GtkWidget.translate_coordinates",
                                     kwlist, &py_dest_widget, &src_x, &src_y)) {
        return NULL;
    }

    if (pygobject_check(py_dest_widget, &PyGtkWidget_Type)) {
        dest_widget = GTK_WIDGET(pygobject_get(py_dest_widget));
    } else if (py_dest_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "dest_widget must be a GtkWidget or None");
        return NULL;
    }

    if (!gtk_widget_translate_coordinates(GTK_WIDGET(self->obj),
                                          dest_widget,
                                          src_x,
                                          src_y,
                                          &dest_x,
                                          &dest_y)) {
       return Py_BuildValue ("()");
   }

   return Py_BuildValue ("(ii)", dest_x, dest_y);
}
#line 9036 "gtk.c"


#line 356 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_hide_on_delete(PyGObject *self, PyObject *args)
{
    /* args is just ignored, so obj.connect(signal, func) always works */

    return PyBool_FromLong(gtk_widget_hide_on_delete(GTK_WIDGET(self->obj)));
}
#line 9047 "gtk.c"


static PyObject *
_wrap_gtk_widget_set_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "style", NULL };
    PyGObject *py_style;
    GtkStyle *style = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.set_style", kwlist, &py_style))
        return NULL;
    if (py_style && pygobject_check(py_style, &PyGtkStyle_Type))
        style = GTK_STYLE(py_style->obj);
    else if ((PyObject *)py_style != Py_None) {
        PyErr_SetString(PyExc_TypeError, "style should be a GtkStyle or None");
        return NULL;
    }
    
    gtk_widget_set_style(GTK_WIDGET(self->obj), (GtkStyle *) style);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_ensure_style(PyGObject *self)
{
    
    gtk_widget_ensure_style(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_style(PyGObject *self)
{
    GtkStyle *ret;

    
    ret = gtk_widget_get_style(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_modify_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "style", NULL };
    PyGObject *style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.modify_style", kwlist, &PyGtkRcStyle_Type, &style))
        return NULL;
    
    gtk_widget_modify_style(GTK_WIDGET(self->obj), GTK_RC_STYLE(style->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_modifier_style(PyGObject *self)
{
    GtkRcStyle *ret;

    
    ret = gtk_widget_get_modifier_style(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_modify_fg(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "state", "color", NULL };
    PyObject *py_state = NULL, *py_color = Py_None;
    GtkStateType state;
    GdkColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Widget.modify_fg", kwlist, &py_state, &py_color))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state, (gpointer)&state))
        return NULL;
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else if (py_color != Py_None) {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor or None");
        return NULL;
    }
    
    gtk_widget_modify_fg(GTK_WIDGET(self->obj), state, color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_modify_bg(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "state", "color", NULL };
    PyObject *py_state = NULL, *py_color = Py_None;
    GtkStateType state;
    GdkColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Widget.modify_bg", kwlist, &py_state, &py_color))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state, (gpointer)&state))
        return NULL;
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else if (py_color != Py_None) {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor or None");
        return NULL;
    }
    
    gtk_widget_modify_bg(GTK_WIDGET(self->obj), state, color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_modify_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "state", "color", NULL };
    PyObject *py_state = NULL, *py_color = Py_None;
    GtkStateType state;
    GdkColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Widget.modify_text", kwlist, &py_state, &py_color))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state, (gpointer)&state))
        return NULL;
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else if (py_color != Py_None) {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor or None");
        return NULL;
    }
    
    gtk_widget_modify_text(GTK_WIDGET(self->obj), state, color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_modify_base(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "state", "color", NULL };
    PyObject *py_state = NULL, *py_color = Py_None;
    GtkStateType state;
    GdkColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Widget.modify_base", kwlist, &py_state, &py_color))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state, (gpointer)&state))
        return NULL;
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else if (py_color != Py_None) {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor or None");
        return NULL;
    }
    
    gtk_widget_modify_base(GTK_WIDGET(self->obj), state, color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_modify_font(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "font_desc", NULL };
    PyObject *py_font_desc = Py_None;
    PangoFontDescription *font_desc = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.modify_font", kwlist, &py_font_desc))
        return NULL;
    if (pyg_boxed_check(py_font_desc, PANGO_TYPE_FONT_DESCRIPTION))
        font_desc = pyg_boxed_get(py_font_desc, PangoFontDescription);
    else if (py_font_desc != Py_None) {
        PyErr_SetString(PyExc_TypeError, "font_desc should be a PangoFontDescription or None");
        return NULL;
    }
    
    gtk_widget_modify_font(GTK_WIDGET(self->obj), font_desc);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_create_pango_context(PyGObject *self)
{
    PangoContext *ret;
    PyObject *py_ret;

    
    ret = gtk_widget_create_pango_context(GTK_WIDGET(self->obj));
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_widget_get_pango_context(PyGObject *self)
{
    PangoContext *ret;

    
    ret = gtk_widget_get_pango_context(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_create_pango_layout(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;
    PyObject *py_ret;
    PangoLayout *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Widget.create_pango_layout", kwlist, &text))
        return NULL;
    
    ret = gtk_widget_create_pango_layout(GTK_WIDGET(self->obj), text);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_widget_render_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "size", "detail", NULL };
    char *stock_id, *detail = NULL;
    PyObject *py_size = NULL, *py_ret;
    GdkPixbuf *ret;
    GtkIconSize size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO|z:Gtk.Widget.render_icon", kwlist, &stock_id, &py_size, &detail))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    ret = gtk_widget_render_icon(GTK_WIDGET(self->obj), stock_id, size, detail);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_widget_set_composite_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Widget.set_composite_name", kwlist, &name))
        return NULL;
    
    gtk_widget_set_composite_name(GTK_WIDGET(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_composite_name(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_widget_get_composite_name(GTK_WIDGET(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_reset_rc_styles(PyGObject *self)
{
    
    gtk_widget_reset_rc_styles(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 269 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_style_get_property(PyGObject *self, PyObject *args,
				    PyObject*kwargs)
{
    static char *kwlist[] = { "property_name", NULL };
    gchar *param_name;
    GParamSpec *pspec;
    GValue value = { 0, };
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkWidget.style_get_property", kwlist,
				     &param_name))
	return NULL;
    pspec = gtk_widget_class_find_style_property(GTK_WIDGET_GET_CLASS(self->obj),
						 param_name);
    if (!pspec) {
	PyErr_SetString(PyExc_TypeError,
			"the widget does not support the given style parameter");
	return NULL;
    }
    if (!(pspec->flags & G_PARAM_READABLE)) {
	PyErr_Format(PyExc_TypeError, "style property %s is not readable",
		     param_name);
	return NULL;
    }
    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
    gtk_widget_style_get_property(GTK_WIDGET(self->obj), (const gchar*)param_name, &value);
    ret = pyg_value_as_pyobject(&value, TRUE);
    g_value_unset(&value);
    return ret;
}
#line 9386 "gtk.c"


static PyObject *
_wrap_gtk_widget_set_direction(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dir", NULL };
    GtkTextDirection dir;
    PyObject *py_dir = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.set_direction", kwlist, &py_dir))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, py_dir, (gpointer)&dir))
        return NULL;
    
    gtk_widget_set_direction(GTK_WIDGET(self->obj), dir);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_direction(PyGObject *self)
{
    gint ret;

    
    ret = gtk_widget_get_direction(GTK_WIDGET(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_TEXT_DIRECTION, ret);
}

static PyObject *
_wrap_gtk_widget_shape_combine_mask(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "shape_mask", "offset_x", "offset_y", NULL };
    PyGObject *shape_mask;
    int offset_x, offset_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.Widget.shape_combine_mask", kwlist, &PyGdkPixmap_Type, &shape_mask, &offset_x, &offset_y))
        return NULL;
    
    gtk_widget_shape_combine_mask(GTK_WIDGET(self->obj), GDK_PIXMAP(shape_mask->obj), offset_x, offset_y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_reset_shapes(PyGObject *self)
{
    
    gtk_widget_reset_shapes(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 131 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_path(PyGObject *self)
{
    guint length;
    gchar *path;
    gchar *path_reversed;
    PyObject *result;

    gtk_widget_path(GTK_WIDGET(self->obj), &length, &path, &path_reversed);
    result = PyString_FromString(path);
    g_free(path);
    g_free(path_reversed);

    return result;
}
#line 9460 "gtk.c"


#line 148 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_class_path(PyGObject *self)
{
    guint length;
    gchar *path;
    gchar *path_reversed;
    PyObject *result;

    gtk_widget_class_path(GTK_WIDGET(self->obj), &length, &path,
                          &path_reversed);
    result = PyString_FromString(path);
    g_free(path);
    g_free(path_reversed);

    return result;
}
#line 9480 "gtk.c"


#line 303 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_list_mnemonic_labels(PyGObject *self)
{
    GList *labels;
    PyObject *py_labels;
    gint i, len;

    labels = gtk_widget_list_mnemonic_labels(GTK_WIDGET(self->obj));
    len = g_list_length(labels);

    py_labels = PyList_New(len);

    for (i = 0; i < len; i++) {
	PyObject *obj;

	obj = pygobject_new((GObject *)g_list_nth_data(labels, i));
	PyList_SetItem(py_labels, i, obj);
    }

    g_list_free(labels);

    return py_labels;
}
#line 9507 "gtk.c"


static PyObject *
_wrap_gtk_widget_add_mnemonic_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    PyGObject *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.add_mnemonic_label", kwlist, &PyGtkWidget_Type, &label))
        return NULL;
    
    gtk_widget_add_mnemonic_label(GTK_WIDGET(self->obj), GTK_WIDGET(label->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_remove_mnemonic_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    PyGObject *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.remove_mnemonic_label", kwlist, &PyGtkWidget_Type, &label))
        return NULL;
    
    gtk_widget_remove_mnemonic_label(GTK_WIDGET(self->obj), GTK_WIDGET(label->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_action(PyGObject *self)
{
    GtkAction *ret;

    
    ret = gtk_widget_get_action(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_drag_dest_set_track_motion(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "track_motion", NULL };
    int track_motion;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.drag_dest_set_track_motion", kwlist, &track_motion))
        return NULL;
    
    gtk_drag_dest_set_track_motion(GTK_WIDGET(self->obj), track_motion);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_drag_dest_get_track_motion(PyGObject *self)
{
    int ret;

    
    ret = gtk_drag_dest_get_track_motion(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_is_composited(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_is_composited(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_input_shape_combine_mask(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "shape_mask", "offset_x", "offset_y", NULL };
    PyGObject *py_shape_mask;
    int offset_x, offset_y;
    GdkPixmap *shape_mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oii:Gtk.Widget.input_shape_combine_mask", kwlist, &py_shape_mask, &offset_x, &offset_y))
        return NULL;
    if (py_shape_mask && pygobject_check(py_shape_mask, &PyGdkPixmap_Type))
        shape_mask = GDK_PIXMAP(py_shape_mask->obj);
    else if ((PyObject *)py_shape_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "shape_mask should be a GdkPixmap or None");
        return NULL;
    }
    
    gtk_widget_input_shape_combine_mask(GTK_WIDGET(self->obj), (GdkBitmap *) shape_mask, offset_x, offset_y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_keynav_failed(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "direction", NULL };
    PyObject *py_direction = NULL;
    int ret;
    GtkDirectionType direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.keynav_failed", kwlist, &py_direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, py_direction, (gpointer)&direction))
        return NULL;
    
    ret = gtk_widget_keynav_failed(GTK_WIDGET(self->obj), direction);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_error_bell(PyGObject *self)
{
    
    gtk_widget_error_bell(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_tooltip_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "custom_window", NULL };
    PyGObject *py_custom_window;
    GtkWindow *custom_window = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.set_tooltip_window", kwlist, &py_custom_window))
        return NULL;
    if (py_custom_window && pygobject_check(py_custom_window, &PyGtkWindow_Type))
        custom_window = GTK_WINDOW(py_custom_window->obj);
    else if ((PyObject *)py_custom_window != Py_None) {
        PyErr_SetString(PyExc_TypeError, "custom_window should be a GtkWindow or None");
        return NULL;
    }
    
    gtk_widget_set_tooltip_window(GTK_WIDGET(self->obj), (GtkWindow *) custom_window);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_tooltip_window(PyGObject *self)
{
    GtkWindow *ret;

    
    ret = gtk_widget_get_tooltip_window(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_trigger_tooltip_query(PyGObject *self)
{
    
    gtk_widget_trigger_tooltip_query(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_tooltip_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.Widget.set_tooltip_text", kwlist, &text))
        return NULL;
    
    gtk_widget_set_tooltip_text(GTK_WIDGET(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_tooltip_text(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_widget_get_tooltip_text(GTK_WIDGET(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_tooltip_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "markup", NULL };
    char *markup;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.Widget.set_tooltip_markup", kwlist, &markup))
        return NULL;
    
    gtk_widget_set_tooltip_markup(GTK_WIDGET(self->obj), markup);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_tooltip_markup(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_widget_get_tooltip_markup(GTK_WIDGET(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_modify_cursor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "primary", "secondary", NULL };
    PyObject *py_primary = Py_None, *py_secondary = Py_None;
    GdkColor *primary = NULL, *secondary = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Widget.modify_cursor", kwlist, &py_primary, &py_secondary))
        return NULL;
    if (pyg_boxed_check(py_primary, GDK_TYPE_COLOR))
        primary = pyg_boxed_get(py_primary, GdkColor);
    else if (py_primary != Py_None) {
        PyErr_SetString(PyExc_TypeError, "primary should be a GdkColor or None");
        return NULL;
    }
    if (pyg_boxed_check(py_secondary, GDK_TYPE_COLOR))
        secondary = pyg_boxed_get(py_secondary, GdkColor);
    else if (py_secondary != Py_None) {
        PyErr_SetString(PyExc_TypeError, "secondary should be a GdkColor or None");
        return NULL;
    }
    
    gtk_widget_modify_cursor(GTK_WIDGET(self->obj), primary, secondary);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_set_has_tooltip(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "has_tooltip", NULL };
    int has_tooltip;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_has_tooltip", kwlist, &has_tooltip))
        return NULL;
    
    gtk_widget_set_has_tooltip(GTK_WIDGET(self->obj), has_tooltip);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_has_tooltip(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_has_tooltip(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_get_snapshot(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "clip_rect", NULL };
    PyObject *py_clip_rect = Py_None, *py_ret;
    GdkRectangle clip_rect_rect = { 0, 0, 0, 0 }, *clip_rect;
    GdkPixmap *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.Widget.get_snapshot", kwlist, &py_clip_rect))
        return NULL;
    if (py_clip_rect == Py_None)
        clip_rect = NULL;
    else if (pygdk_rectangle_from_pyobject(py_clip_rect, &clip_rect_rect))
        clip_rect = &clip_rect_rect;
    else
            return NULL;
    
    ret = gtk_widget_get_snapshot(GTK_WIDGET(self->obj), clip_rect);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_widget_get_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_widget_get_window(GTK_WIDGET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 8808 "./gtk.override"
static PyObject *
_wrap_gtk_widget_set_allocation(PyGObject *self,
                                PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "allocation", NULL };
    PyObject *py_allocation;
    GdkRectangle allocation = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.set_allocation",
                                     kwlist, &py_allocation))
        return NULL;

    if (!pygdk_rectangle_from_pyobject(py_allocation, &allocation))
        return NULL;
    
    gtk_widget_set_allocation(GTK_WIDGET(self->obj), &allocation);
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 9865 "gtk.c"


static PyObject *
_wrap_gtk_widget_get_app_paintable(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_app_paintable(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_set_can_default(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "can_default", NULL };
    int can_default;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_can_default", kwlist, &can_default))
        return NULL;
    
    gtk_widget_set_can_default(GTK_WIDGET(self->obj), can_default);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_can_default(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_can_default(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_set_can_focus(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "can_focus", NULL };
    int can_focus;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_can_focus", kwlist, &can_focus))
        return NULL;
    
    gtk_widget_set_can_focus(GTK_WIDGET(self->obj), can_focus);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_can_focus(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_can_focus(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_get_double_buffered(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_double_buffered(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_set_has_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "has_window", NULL };
    int has_window;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_has_window", kwlist, &has_window))
        return NULL;
    
    gtk_widget_set_has_window(GTK_WIDGET(self->obj), has_window);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_has_window(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_has_window(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_set_receives_default(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "receives_default", NULL };
    int receives_default;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_receives_default", kwlist, &receives_default))
        return NULL;
    
    gtk_widget_set_receives_default(GTK_WIDGET(self->obj), receives_default);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_receives_default(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_receives_default(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_get_sensitive(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_sensitive(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_get_state(PyGObject *self)
{
    gint ret;

    
    ret = gtk_widget_get_state(GTK_WIDGET(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, ret);
}

static PyObject *
_wrap_gtk_widget_set_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible", NULL };
    int visible;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_visible", kwlist, &visible))
        return NULL;
    
    gtk_widget_set_visible(GTK_WIDGET(self->obj), visible);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_visible(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_set_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", NULL };
    PyGObject *window;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.set_window", kwlist, &PyGdkWindow_Type, &window))
        return NULL;
    
    gtk_widget_set_window(GTK_WIDGET(self->obj), GDK_WINDOW(window->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_has_default(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_has_default(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_has_focus(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_has_focus(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_has_grab(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_has_grab(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_is_sensitive(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_is_sensitive(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_is_toplevel(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_is_toplevel(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_is_drawable(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_is_drawable(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_set_realized(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "realized", NULL };
    int realized;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_realized", kwlist, &realized))
        return NULL;
    
    gtk_widget_set_realized(GTK_WIDGET(self->obj), realized);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_realized(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_realized(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_set_mapped(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mapped", NULL };
    int mapped;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Widget.set_mapped", kwlist, &mapped))
        return NULL;
    
    gtk_widget_set_mapped(GTK_WIDGET(self->obj), mapped);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_mapped(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_get_mapped(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_get_requisition(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "requisition", NULL };
    PyObject *py_requisition;
    GtkRequisition *requisition = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.get_requisition", kwlist, &py_requisition))
        return NULL;
    if (pyg_boxed_check(py_requisition, GTK_TYPE_REQUISITION))
        requisition = pyg_boxed_get(py_requisition, GtkRequisition);
    else {
        PyErr_SetString(PyExc_TypeError, "requisition should be a GtkRequisition");
        return NULL;
    }
    
    gtk_widget_get_requisition(GTK_WIDGET(self->obj), requisition);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_style_attach(PyGObject *self)
{
    
    gtk_widget_style_attach(GTK_WIDGET(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_has_rc_style(PyGObject *self)
{
    int ret;

    
    ret = gtk_widget_has_rc_style(GTK_WIDGET(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_widget_send_focus_change(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", NULL };
    GdkEvent *event = NULL;
    PyObject *py_event;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Widget.send_focus_change", kwlist, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    ret = gtk_widget_send_focus_change(GTK_WIDGET(self->obj), event);
    
    return PyBool_FromLong(ret);

}

#line 517 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_set_activate_signal(PyObject *cls,
                                     PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "signal_name", NULL };
    gchar *signal_name;
    guint signal_id;
    GType gtype;
    GtkWidgetClass *klass;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:gtk.Widget.set_activate_signal", kwlist,
				     &signal_name))
	return NULL;

     if ((gtype = pyg_type_from_object(cls)) == 0)
         return NULL;
     signal_id = g_signal_lookup(signal_name, gtype);
     if (signal_id == 0) {
         PyErr_Format(PyExc_ValueError,
		      "class has no signal named '%s'", signal_name);
         return NULL;
     }
     klass = (GtkWidgetClass *) g_type_class_ref(gtype);
     klass->activate_signal = signal_id;
     g_type_class_unref(klass);
     Py_INCREF(Py_None);
     return Py_None;
}

#line 10290 "gtk.c"


#line 550 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_get_activate_signal(PyObject *cls,
                                     PyObject *args,
                                     PyObject *kwargs)
{
    PyObject *signame;
    GType gtype;
    GtkWidgetClass *klass;
    GSignalQuery query;

     if ((gtype = pyg_type_from_object(cls)) == 0)
         return NULL;
     klass = (GtkWidgetClass *) g_type_class_ref(gtype);

     g_signal_query(klass->activate_signal, &query);
     if (query.signal_id == 0) {
         PyErr_SetString(PyExc_ValueError,
                         "class has invalid signal ID");
         signame = NULL;
         goto out;
     }
     signame = PyString_FromString(query.signal_name);
out:
     g_type_class_unref(klass);
     return signame;
}

#line 10321 "gtk.c"


#line 419 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_set_set_scroll_adjustments_signal(PyObject *cls,
						   PyObject *args,
                                                   PyObject *kwargs)
{
    static char *kwlist[] = { "signal_name", NULL };
    gchar *signal_name;
    guint signal_id;
    GType gtype;
    GtkWidgetClass *klass;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:gtk.Widget.set_set_scroll_adjustments_signal", kwlist,
				     &signal_name))
	return NULL;

     if ((gtype = pyg_type_from_object(cls)) == 0)
         return NULL;
     signal_id = g_signal_lookup(signal_name, gtype);
     if (signal_id == 0) {
         PyErr_Format(PyExc_ValueError,
		      "class has no signal named '%s'", signal_name);
         return NULL;
     }
     klass = (GtkWidgetClass *) g_type_class_ref(gtype);
     klass->set_scroll_adjustments_signal = signal_id;
     g_type_class_unref(klass);
     Py_INCREF(Py_None);
     return Py_None;
}
#line 10355 "gtk.c"


static PyObject *
_wrap_GtkWidget__do_show(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.show", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->show)
        GTK_WIDGET_CLASS(klass)->show(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.show not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_show_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.show_all", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->show_all)
        GTK_WIDGET_CLASS(klass)->show_all(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.show_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_hide(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.hide", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->hide)
        GTK_WIDGET_CLASS(klass)->hide(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.hide not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_hide_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.hide_all", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->hide_all)
        GTK_WIDGET_CLASS(klass)->hide_all(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.hide_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_map(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.map", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->map)
        GTK_WIDGET_CLASS(klass)->map(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.map not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_unmap(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.unmap", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->unmap)
        GTK_WIDGET_CLASS(klass)->unmap(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.unmap not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_realize(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.realize", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->realize)
        GTK_WIDGET_CLASS(klass)->realize(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.realize not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_unrealize(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.unrealize", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->unrealize)
        GTK_WIDGET_CLASS(klass)->unrealize(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.unrealize not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_size_request(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "requisition", NULL };
    PyGObject *self;
    PyObject *py_requisition;
    GtkRequisition *requisition = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.size_request", kwlist, &PyGtkWidget_Type, &self, &py_requisition))
        return NULL;
    if (pyg_boxed_check(py_requisition, GTK_TYPE_REQUISITION))
        requisition = pyg_boxed_get(py_requisition, GtkRequisition);
    else {
        PyErr_SetString(PyExc_TypeError, "requisition should be a GtkRequisition");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->size_request)
        GTK_WIDGET_CLASS(klass)->size_request(GTK_WIDGET(self->obj), requisition);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.size_request not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_size_allocate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "allocation", NULL };
    PyGObject *self;
    PyObject *py_allocation;
    GdkRectangle allocation = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.size_allocate", kwlist, &PyGtkWidget_Type, &self, &py_allocation))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_allocation, &allocation))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->size_allocate)
        GTK_WIDGET_CLASS(klass)->size_allocate(GTK_WIDGET(self->obj), &allocation);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.size_allocate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_state_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "previous_state", NULL };
    PyGObject *self;
    PyObject *py_previous_state = NULL;
    GtkStateType previous_state;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.state_changed", kwlist, &PyGtkWidget_Type, &self, &py_previous_state))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_previous_state, (gpointer)&previous_state))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->state_changed)
        GTK_WIDGET_CLASS(klass)->state_changed(GTK_WIDGET(self->obj), previous_state);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.state_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_parent_set(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "previous_parent", NULL };
    PyGObject *self, *previous_parent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Widget.parent_set", kwlist, &PyGtkWidget_Type, &self, &PyGtkWidget_Type, &previous_parent))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->parent_set)
        GTK_WIDGET_CLASS(klass)->parent_set(GTK_WIDGET(self->obj), GTK_WIDGET(previous_parent->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.parent_set not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_hierarchy_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "previous_toplevel", NULL };
    PyGObject *self, *previous_toplevel;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Widget.hierarchy_changed", kwlist, &PyGtkWidget_Type, &self, &PyGtkWidget_Type, &previous_toplevel))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->hierarchy_changed)
        GTK_WIDGET_CLASS(klass)->hierarchy_changed(GTK_WIDGET(self->obj), GTK_WIDGET(previous_toplevel->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.hierarchy_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_style_set(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "previous_style", NULL };
    PyGObject *self, *py_previous_style;
    GtkStyle *previous_style = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.style_set", kwlist, &PyGtkWidget_Type, &self, &py_previous_style))
        return NULL;
    if (py_previous_style && pygobject_check(py_previous_style, &PyGtkStyle_Type))
        previous_style = GTK_STYLE(py_previous_style->obj);
    else if ((PyObject *)py_previous_style != Py_None) {
        PyErr_SetString(PyExc_TypeError, "previous_style should be a GtkStyle or None");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->style_set)
        GTK_WIDGET_CLASS(klass)->style_set(GTK_WIDGET(self->obj), (GtkStyle *) previous_style);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.style_set not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_direction_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "previous_direction", NULL };
    PyGObject *self;
    GtkTextDirection previous_direction;
    PyObject *py_previous_direction = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.direction_changed", kwlist, &PyGtkWidget_Type, &self, &py_previous_direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, py_previous_direction, (gpointer)&previous_direction))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->direction_changed)
        GTK_WIDGET_CLASS(klass)->direction_changed(GTK_WIDGET(self->obj), previous_direction);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.direction_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_grab_notify(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "was_grabbed", NULL };
    PyGObject *self;
    int was_grabbed;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Widget.grab_notify", kwlist, &PyGtkWidget_Type, &self, &was_grabbed))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->grab_notify)
        GTK_WIDGET_CLASS(klass)->grab_notify(GTK_WIDGET(self->obj), was_grabbed);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.grab_notify not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_mnemonic_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "group_cycling", NULL };
    PyGObject *self;
    int group_cycling, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Widget.mnemonic_activate", kwlist, &PyGtkWidget_Type, &self, &group_cycling))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->mnemonic_activate)
        ret = GTK_WIDGET_CLASS(klass)->mnemonic_activate(GTK_WIDGET(self->obj), group_cycling);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.mnemonic_activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_grab_focus(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.grab_focus", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->grab_focus)
        GTK_WIDGET_CLASS(klass)->grab_focus(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.grab_focus not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_focus(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "direction", NULL };
    PyGObject *self;
    PyObject *py_direction = NULL;
    int ret;
    GtkDirectionType direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.focus", kwlist, &PyGtkWidget_Type, &self, &py_direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, py_direction, (gpointer)&direction))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->focus)
        ret = GTK_WIDGET_CLASS(klass)->focus(GTK_WIDGET(self->obj), direction);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.focus not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->event)
        ret = GTK_WIDGET_CLASS(klass)->event(GTK_WIDGET(self->obj), event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_button_press_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.button_press_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->button_press_event)
        ret = GTK_WIDGET_CLASS(klass)->button_press_event(GTK_WIDGET(self->obj), (GdkEventButton *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.button_press_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_button_release_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.button_release_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->button_release_event)
        ret = GTK_WIDGET_CLASS(klass)->button_release_event(GTK_WIDGET(self->obj), (GdkEventButton *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.button_release_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_scroll_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.scroll_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->scroll_event)
        ret = GTK_WIDGET_CLASS(klass)->scroll_event(GTK_WIDGET(self->obj), (GdkEventScroll *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.scroll_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_motion_notify_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.motion_notify_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->motion_notify_event)
        ret = GTK_WIDGET_CLASS(klass)->motion_notify_event(GTK_WIDGET(self->obj), (GdkEventMotion *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.motion_notify_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_delete_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.delete_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->delete_event)
        ret = GTK_WIDGET_CLASS(klass)->delete_event(GTK_WIDGET(self->obj), (GdkEventAny *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.delete_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_destroy_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.destroy_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->destroy_event)
        ret = GTK_WIDGET_CLASS(klass)->destroy_event(GTK_WIDGET(self->obj), (GdkEventAny *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.destroy_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_expose_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.expose_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->expose_event)
        ret = GTK_WIDGET_CLASS(klass)->expose_event(GTK_WIDGET(self->obj), (GdkEventExpose *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.expose_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_key_press_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.key_press_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->key_press_event)
        ret = GTK_WIDGET_CLASS(klass)->key_press_event(GTK_WIDGET(self->obj), (GdkEventKey *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.key_press_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_key_release_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.key_release_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->key_release_event)
        ret = GTK_WIDGET_CLASS(klass)->key_release_event(GTK_WIDGET(self->obj), (GdkEventKey *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.key_release_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_enter_notify_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.enter_notify_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->enter_notify_event)
        ret = GTK_WIDGET_CLASS(klass)->enter_notify_event(GTK_WIDGET(self->obj), (GdkEventCrossing *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.enter_notify_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_leave_notify_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.leave_notify_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->leave_notify_event)
        ret = GTK_WIDGET_CLASS(klass)->leave_notify_event(GTK_WIDGET(self->obj), (GdkEventCrossing *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.leave_notify_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_configure_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.configure_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->configure_event)
        ret = GTK_WIDGET_CLASS(klass)->configure_event(GTK_WIDGET(self->obj), (GdkEventConfigure *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.configure_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_focus_in_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.focus_in_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->focus_in_event)
        ret = GTK_WIDGET_CLASS(klass)->focus_in_event(GTK_WIDGET(self->obj), (GdkEventFocus *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.focus_in_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_focus_out_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.focus_out_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->focus_out_event)
        ret = GTK_WIDGET_CLASS(klass)->focus_out_event(GTK_WIDGET(self->obj), (GdkEventFocus *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.focus_out_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_map_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.map_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->map_event)
        ret = GTK_WIDGET_CLASS(klass)->map_event(GTK_WIDGET(self->obj), (GdkEventAny *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.map_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_unmap_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.unmap_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->unmap_event)
        ret = GTK_WIDGET_CLASS(klass)->unmap_event(GTK_WIDGET(self->obj), (GdkEventAny *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.unmap_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_property_notify_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.property_notify_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->property_notify_event)
        ret = GTK_WIDGET_CLASS(klass)->property_notify_event(GTK_WIDGET(self->obj), (GdkEventProperty *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.property_notify_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_selection_clear_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.selection_clear_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->selection_clear_event)
        ret = GTK_WIDGET_CLASS(klass)->selection_clear_event(GTK_WIDGET(self->obj), (GdkEventSelection *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.selection_clear_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_selection_request_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.selection_request_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->selection_request_event)
        ret = GTK_WIDGET_CLASS(klass)->selection_request_event(GTK_WIDGET(self->obj), (GdkEventSelection *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.selection_request_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_selection_notify_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.selection_notify_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->selection_notify_event)
        ret = GTK_WIDGET_CLASS(klass)->selection_notify_event(GTK_WIDGET(self->obj), (GdkEventSelection *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.selection_notify_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_proximity_in_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.proximity_in_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->proximity_in_event)
        ret = GTK_WIDGET_CLASS(klass)->proximity_in_event(GTK_WIDGET(self->obj), (GdkEventProximity *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.proximity_in_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_proximity_out_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.proximity_out_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->proximity_out_event)
        ret = GTK_WIDGET_CLASS(klass)->proximity_out_event(GTK_WIDGET(self->obj), (GdkEventProximity *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.proximity_out_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_visibility_notify_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.visibility_notify_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->visibility_notify_event)
        ret = GTK_WIDGET_CLASS(klass)->visibility_notify_event(GTK_WIDGET(self->obj), (GdkEventVisibility *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.visibility_notify_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_client_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.client_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->client_event)
        ret = GTK_WIDGET_CLASS(klass)->client_event(GTK_WIDGET(self->obj), (GdkEventClient *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.client_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_no_expose_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.no_expose_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->no_expose_event)
        ret = GTK_WIDGET_CLASS(klass)->no_expose_event(GTK_WIDGET(self->obj), (GdkEventAny *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.no_expose_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_window_state_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.window_state_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->window_state_event)
        ret = GTK_WIDGET_CLASS(klass)->window_state_event(GTK_WIDGET(self->obj), (GdkEventWindowState *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.window_state_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_selection_get(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "selection_data", "info", "time_", NULL };
    PyGObject *self;
    PyObject *py_selection_data, *py_info = NULL, *py_time_ = NULL;
    GtkSelectionData *selection_data = NULL;
    guint info = 0, time_ = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOO:Gtk.Widget.selection_get", kwlist, &PyGtkWidget_Type, &self, &py_selection_data, &py_info, &py_time_))
        return NULL;
    if (pyg_boxed_check(py_selection_data, GTK_TYPE_SELECTION_DATA))
        selection_data = pyg_boxed_get(py_selection_data, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection_data should be a GtkSelectionData");
        return NULL;
    }
    if (py_info) {
        if (PyLong_Check(py_info))
            info = PyLong_AsUnsignedLong(py_info);
        else if (PyInt_Check(py_info))
            info = PyInt_AsLong(py_info);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'info' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_time_) {
        if (PyLong_Check(py_time_))
            time_ = PyLong_AsUnsignedLong(py_time_);
        else if (PyInt_Check(py_time_))
            time_ = PyInt_AsLong(py_time_);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'time_' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->selection_get)
        GTK_WIDGET_CLASS(klass)->selection_get(GTK_WIDGET(self->obj), selection_data, info, time_);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.selection_get not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_selection_received(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "selection_data", "time_", NULL };
    PyGObject *self;
    PyObject *py_selection_data, *py_time_ = NULL;
    GtkSelectionData *selection_data = NULL;
    guint time_ = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.Widget.selection_received", kwlist, &PyGtkWidget_Type, &self, &py_selection_data, &py_time_))
        return NULL;
    if (pyg_boxed_check(py_selection_data, GTK_TYPE_SELECTION_DATA))
        selection_data = pyg_boxed_get(py_selection_data, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection_data should be a GtkSelectionData");
        return NULL;
    }
    if (py_time_) {
        if (PyLong_Check(py_time_))
            time_ = PyLong_AsUnsignedLong(py_time_);
        else if (PyInt_Check(py_time_))
            time_ = PyInt_AsLong(py_time_);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'time_' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->selection_received)
        GTK_WIDGET_CLASS(klass)->selection_received(GTK_WIDGET(self->obj), selection_data, time_);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.selection_received not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_drag_begin(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", NULL };
    PyGObject *self, *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Widget.drag_begin", kwlist, &PyGtkWidget_Type, &self, &PyGdkDragContext_Type, &context))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->drag_begin)
        GTK_WIDGET_CLASS(klass)->drag_begin(GTK_WIDGET(self->obj), GDK_DRAG_CONTEXT(context->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.drag_begin not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_drag_end(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", NULL };
    PyGObject *self, *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Widget.drag_end", kwlist, &PyGtkWidget_Type, &self, &PyGdkDragContext_Type, &context))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->drag_end)
        GTK_WIDGET_CLASS(klass)->drag_end(GTK_WIDGET(self->obj), GDK_DRAG_CONTEXT(context->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.drag_end not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_drag_data_get(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", "selection_data", "info", "time_", NULL };
    PyGObject *self, *context;
    PyObject *py_selection_data, *py_info = NULL, *py_time_ = NULL;
    GtkSelectionData *selection_data = NULL;
    guint info = 0, time_ = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOO:Gtk.Widget.drag_data_get", kwlist, &PyGtkWidget_Type, &self, &PyGdkDragContext_Type, &context, &py_selection_data, &py_info, &py_time_))
        return NULL;
    if (pyg_boxed_check(py_selection_data, GTK_TYPE_SELECTION_DATA))
        selection_data = pyg_boxed_get(py_selection_data, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection_data should be a GtkSelectionData");
        return NULL;
    }
    if (py_info) {
        if (PyLong_Check(py_info))
            info = PyLong_AsUnsignedLong(py_info);
        else if (PyInt_Check(py_info))
            info = PyInt_AsLong(py_info);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'info' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_time_) {
        if (PyLong_Check(py_time_))
            time_ = PyLong_AsUnsignedLong(py_time_);
        else if (PyInt_Check(py_time_))
            time_ = PyInt_AsLong(py_time_);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'time_' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->drag_data_get)
        GTK_WIDGET_CLASS(klass)->drag_data_get(GTK_WIDGET(self->obj), GDK_DRAG_CONTEXT(context->obj), selection_data, info, time_);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.drag_data_get not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_drag_data_delete(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", NULL };
    PyGObject *self, *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Widget.drag_data_delete", kwlist, &PyGtkWidget_Type, &self, &PyGdkDragContext_Type, &context))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->drag_data_delete)
        GTK_WIDGET_CLASS(klass)->drag_data_delete(GTK_WIDGET(self->obj), GDK_DRAG_CONTEXT(context->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.drag_data_delete not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_drag_leave(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", "time_", NULL };
    PyGObject *self, *context;
    PyObject *py_time_ = NULL;
    guint time_ = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O:Gtk.Widget.drag_leave", kwlist, &PyGtkWidget_Type, &self, &PyGdkDragContext_Type, &context, &py_time_))
        return NULL;
    if (py_time_) {
        if (PyLong_Check(py_time_))
            time_ = PyLong_AsUnsignedLong(py_time_);
        else if (PyInt_Check(py_time_))
            time_ = PyInt_AsLong(py_time_);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'time_' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->drag_leave)
        GTK_WIDGET_CLASS(klass)->drag_leave(GTK_WIDGET(self->obj), GDK_DRAG_CONTEXT(context->obj), time_);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.drag_leave not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_drag_motion(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", "x", "y", "time_", NULL };
    PyGObject *self, *context;
    int x, y, ret;
    PyObject *py_time_ = NULL;
    guint time_ = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!iiO:Gtk.Widget.drag_motion", kwlist, &PyGtkWidget_Type, &self, &PyGdkDragContext_Type, &context, &x, &y, &py_time_))
        return NULL;
    if (py_time_) {
        if (PyLong_Check(py_time_))
            time_ = PyLong_AsUnsignedLong(py_time_);
        else if (PyInt_Check(py_time_))
            time_ = PyInt_AsLong(py_time_);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'time_' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->drag_motion)
        ret = GTK_WIDGET_CLASS(klass)->drag_motion(GTK_WIDGET(self->obj), GDK_DRAG_CONTEXT(context->obj), x, y, time_);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.drag_motion not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_drag_drop(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", "x", "y", "time_", NULL };
    PyGObject *self, *context;
    int x, y, ret;
    PyObject *py_time_ = NULL;
    guint time_ = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!iiO:Gtk.Widget.drag_drop", kwlist, &PyGtkWidget_Type, &self, &PyGdkDragContext_Type, &context, &x, &y, &py_time_))
        return NULL;
    if (py_time_) {
        if (PyLong_Check(py_time_))
            time_ = PyLong_AsUnsignedLong(py_time_);
        else if (PyInt_Check(py_time_))
            time_ = PyInt_AsLong(py_time_);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'time_' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->drag_drop)
        ret = GTK_WIDGET_CLASS(klass)->drag_drop(GTK_WIDGET(self->obj), GDK_DRAG_CONTEXT(context->obj), x, y, time_);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.drag_drop not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_drag_data_received(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", "x", "y", "selection_data", "info", "time_", NULL };
    PyGObject *self, *context;
    int x, y;
    GtkSelectionData *selection_data = NULL;
    guint info = 0, time_ = 0;
    PyObject *py_selection_data, *py_info = NULL, *py_time_ = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!iiOOO:Gtk.Widget.drag_data_received", kwlist, &PyGtkWidget_Type, &self, &PyGdkDragContext_Type, &context, &x, &y, &py_selection_data, &py_info, &py_time_))
        return NULL;
    if (pyg_boxed_check(py_selection_data, GTK_TYPE_SELECTION_DATA))
        selection_data = pyg_boxed_get(py_selection_data, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection_data should be a GtkSelectionData");
        return NULL;
    }
    if (py_info) {
        if (PyLong_Check(py_info))
            info = PyLong_AsUnsignedLong(py_info);
        else if (PyInt_Check(py_info))
            info = PyInt_AsLong(py_info);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'info' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_time_) {
        if (PyLong_Check(py_time_))
            time_ = PyLong_AsUnsignedLong(py_time_);
        else if (PyInt_Check(py_time_))
            time_ = PyInt_AsLong(py_time_);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'time_' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->drag_data_received)
        GTK_WIDGET_CLASS(klass)->drag_data_received(GTK_WIDGET(self->obj), GDK_DRAG_CONTEXT(context->obj), x, y, selection_data, info, time_);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.drag_data_received not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_popup_menu(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.popup_menu", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->popup_menu)
        ret = GTK_WIDGET_CLASS(klass)->popup_menu(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.popup_menu not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_show_help(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "help_type", NULL };
    PyGObject *self;
    PyObject *py_help_type = NULL;
    int ret;
    GtkWidgetHelpType help_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.show_help", kwlist, &PyGtkWidget_Type, &self, &py_help_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_WIDGET_HELP_TYPE, py_help_type, (gpointer)&help_type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->show_help)
        ret = GTK_WIDGET_CLASS(klass)->show_help(GTK_WIDGET(self->obj), help_type);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.show_help not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_get_accessible(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    AtkObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.get_accessible", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->get_accessible)
        ret = GTK_WIDGET_CLASS(klass)->get_accessible(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.get_accessible not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkWidget__do_screen_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "previous_screen", NULL };
    PyGObject *self, *previous_screen;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Widget.screen_changed", kwlist, &PyGtkWidget_Type, &self, &PyGdkScreen_Type, &previous_screen))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->screen_changed)
        GTK_WIDGET_CLASS(klass)->screen_changed(GTK_WIDGET(self->obj), GDK_SCREEN(previous_screen->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.screen_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWidget__do_can_activate_accel(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "signal_id", NULL };
    PyGObject *self;
    PyObject *py_signal_id = NULL;
    int ret;
    guint signal_id = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.can_activate_accel", kwlist, &PyGtkWidget_Type, &self, &py_signal_id))
        return NULL;
    if (py_signal_id) {
        if (PyLong_Check(py_signal_id))
            signal_id = PyLong_AsUnsignedLong(py_signal_id);
        else if (PyInt_Check(py_signal_id))
            signal_id = PyInt_AsLong(py_signal_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'signal_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->can_activate_accel)
        ret = GTK_WIDGET_CLASS(klass)->can_activate_accel(GTK_WIDGET(self->obj), signal_id);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.can_activate_accel not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_grab_broken_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Widget.grab_broken_event", kwlist, &PyGtkWidget_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->grab_broken_event)
        ret = GTK_WIDGET_CLASS(klass)->grab_broken_event(GTK_WIDGET(self->obj), (GdkEventGrabBroken *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.grab_broken_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWidget__do_composited_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Widget.composited_changed", kwlist, &PyGtkWidget_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WIDGET_CLASS(klass)->composited_changed)
        GTK_WIDGET_CLASS(klass)->composited_changed(GTK_WIDGET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Widget.composited_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkWidget_methods[] = {
    { "get_allocation", (PyCFunction)_wrap_gtk_widget_get_allocation, METH_NOARGS,
      NULL },
    { "drag_check_threshold", (PyCFunction)_wrap_gtk_drag_check_threshold, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_get_data", (PyCFunction)_wrap_gtk_drag_get_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_highlight", (PyCFunction)_wrap_gtk_drag_highlight, METH_NOARGS,
      NULL },
    { "drag_unhighlight", (PyCFunction)_wrap_gtk_drag_unhighlight, METH_NOARGS,
      NULL },
    { "drag_dest_set", (PyCFunction)_wrap_gtk_drag_dest_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_dest_set_proxy", (PyCFunction)_wrap_gtk_drag_dest_set_proxy, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_dest_unset", (PyCFunction)_wrap_gtk_drag_dest_unset, METH_NOARGS,
      NULL },
    { "drag_dest_find_target", (PyCFunction)_wrap_gtk_drag_dest_find_target, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_dest_get_target_list", (PyCFunction)_wrap_gtk_drag_dest_get_target_list, METH_NOARGS,
      NULL },
    { "drag_dest_set_target_list", (PyCFunction)_wrap_gtk_drag_dest_set_target_list, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_source_set", (PyCFunction)_wrap_gtk_drag_source_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_source_unset", (PyCFunction)_wrap_gtk_drag_source_unset, METH_NOARGS,
      NULL },
    { "drag_source_set_icon", (PyCFunction)_wrap_gtk_drag_source_set_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_source_set_icon_pixbuf", (PyCFunction)_wrap_gtk_drag_source_set_icon_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_source_set_icon_stock", (PyCFunction)_wrap_gtk_drag_source_set_icon_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_source_set_icon_name", (PyCFunction)_wrap_gtk_drag_source_set_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_source_get_target_list", (PyCFunction)_wrap_gtk_drag_source_get_target_list, METH_NOARGS,
      NULL },
    { "drag_source_set_target_list", (PyCFunction)_wrap_gtk_drag_source_set_target_list, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_begin", (PyCFunction)_wrap_gtk_drag_begin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_dest_add_text_targets", (PyCFunction)_wrap_gtk_drag_dest_add_text_targets, METH_NOARGS,
      NULL },
    { "drag_dest_add_image_targets", (PyCFunction)_wrap_gtk_drag_dest_add_image_targets, METH_NOARGS,
      NULL },
    { "drag_dest_add_uri_targets", (PyCFunction)_wrap_gtk_drag_dest_add_uri_targets, METH_NOARGS,
      NULL },
    { "drag_source_add_text_targets", (PyCFunction)_wrap_gtk_drag_source_add_text_targets, METH_NOARGS,
      NULL },
    { "drag_source_add_image_targets", (PyCFunction)_wrap_gtk_drag_source_add_image_targets, METH_NOARGS,
      NULL },
    { "drag_source_add_uri_targets", (PyCFunction)_wrap_gtk_drag_source_add_uri_targets, METH_NOARGS,
      NULL },
    { "grab_add", (PyCFunction)_wrap_gtk_grab_add, METH_NOARGS,
      NULL },
    { "grab_remove", (PyCFunction)_wrap_gtk_grab_remove, METH_NOARGS,
      NULL },
    { "menu_get_for_attach_widget", (PyCFunction)_wrap_gtk_menu_get_for_attach_widget, METH_NOARGS,
      NULL },
    { "rc_get_style", (PyCFunction)_wrap_gtk_rc_get_style, METH_NOARGS,
      NULL },
    { "selection_owner_set", (PyCFunction)_wrap_gtk_selection_owner_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "selection_add_target", (PyCFunction)_wrap_gtk_selection_add_target, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "selection_add_targets", (PyCFunction)_wrap_gtk_selection_add_targets, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "selection_clear_targets", (PyCFunction)_wrap_gtk_selection_clear_targets, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "selection_convert", (PyCFunction)_wrap_gtk_selection_convert, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "selection_remove_all", (PyCFunction)_wrap_gtk_selection_remove_all, METH_NOARGS,
      NULL },
    { "destroy", (PyCFunction)_wrap_gtk_widget_destroy, METH_NOARGS,
      NULL },
    { "unparent", (PyCFunction)_wrap_gtk_widget_unparent, METH_NOARGS,
      NULL },
    { "show", (PyCFunction)_wrap_gtk_widget_show, METH_NOARGS,
      NULL },
    { "show_now", (PyCFunction)_wrap_gtk_widget_show_now, METH_NOARGS,
      NULL },
    { "hide", (PyCFunction)_wrap_gtk_widget_hide, METH_NOARGS,
      NULL },
    { "show_all", (PyCFunction)_wrap_gtk_widget_show_all, METH_NOARGS,
      NULL },
    { "hide_all", (PyCFunction)_wrap_gtk_widget_hide_all, METH_NOARGS,
      NULL },
    { "set_no_show_all", (PyCFunction)_wrap_gtk_widget_set_no_show_all, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_no_show_all", (PyCFunction)_wrap_gtk_widget_get_no_show_all, METH_NOARGS,
      NULL },
    { "map", (PyCFunction)_wrap_gtk_widget_map, METH_NOARGS,
      NULL },
    { "unmap", (PyCFunction)_wrap_gtk_widget_unmap, METH_NOARGS,
      NULL },
    { "realize", (PyCFunction)_wrap_gtk_widget_realize, METH_NOARGS,
      NULL },
    { "unrealize", (PyCFunction)_wrap_gtk_widget_unrealize, METH_NOARGS,
      NULL },
    { "queue_draw", (PyCFunction)_wrap_gtk_widget_queue_draw, METH_NOARGS,
      NULL },
    { "queue_draw_area", (PyCFunction)_wrap_gtk_widget_queue_draw_area, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "queue_clear", (PyCFunction)_wrap_gtk_widget_queue_clear, METH_NOARGS,
      NULL },
    { "queue_clear_area", (PyCFunction)_wrap_gtk_widget_queue_clear_area, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "queue_resize", (PyCFunction)_wrap_gtk_widget_queue_resize, METH_NOARGS,
      NULL },
    { "queue_resize_no_redraw", (PyCFunction)_wrap_gtk_widget_queue_resize_no_redraw, METH_NOARGS,
      NULL },
    { "draw", (PyCFunction)_wrap_gtk_widget_draw, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "size_request", (PyCFunction)_wrap_gtk_widget_size_request, METH_NOARGS,
      NULL },
    { "size_allocate", (PyCFunction)_wrap_gtk_widget_size_allocate, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_child_requisition", (PyCFunction)_wrap_gtk_widget_get_child_requisition, METH_NOARGS,
      NULL },
    { "add_accelerator", (PyCFunction)_wrap_gtk_widget_add_accelerator, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_accelerator", (PyCFunction)_wrap_gtk_widget_remove_accelerator, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_accel_path", (PyCFunction)_wrap_gtk_widget_set_accel_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "list_accel_closures", (PyCFunction)_wrap_gtk_widget_list_accel_closures, METH_NOARGS,
      NULL },
    { "can_activate_accel", (PyCFunction)_wrap_gtk_widget_can_activate_accel, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "mnemonic_activate", (PyCFunction)_wrap_gtk_widget_mnemonic_activate, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "event", (PyCFunction)_wrap_gtk_widget_event, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "send_expose", (PyCFunction)_wrap_gtk_widget_send_expose, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "activate", (PyCFunction)_wrap_gtk_widget_activate, METH_NOARGS,
      NULL },
    { "set_scroll_adjustments", (PyCFunction)_wrap_gtk_widget_set_scroll_adjustments, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reparent", (PyCFunction)_wrap_gtk_widget_reparent, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "intersect", (PyCFunction)_wrap_gtk_widget_intersect, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "region_intersect", (PyCFunction)_wrap_gtk_widget_region_intersect, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "freeze_child_notify", (PyCFunction)_wrap_gtk_widget_freeze_child_notify, METH_NOARGS,
      NULL },
    { "child_notify", (PyCFunction)_wrap_gtk_widget_child_notify, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "thaw_child_notify", (PyCFunction)_wrap_gtk_widget_thaw_child_notify, METH_NOARGS,
      NULL },
    { "is_focus", (PyCFunction)_wrap_gtk_widget_is_focus, METH_NOARGS,
      NULL },
    { "grab_focus", (PyCFunction)_wrap_gtk_widget_grab_focus, METH_NOARGS,
      NULL },
    { "grab_default", (PyCFunction)_wrap_gtk_widget_grab_default, METH_NOARGS,
      NULL },
    { "set_name", (PyCFunction)_wrap_gtk_widget_set_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_name", (PyCFunction)_wrap_gtk_widget_get_name, METH_NOARGS,
      NULL },
    { "set_state", (PyCFunction)_wrap_gtk_widget_set_state, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_sensitive", (PyCFunction)_wrap_gtk_widget_set_sensitive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_app_paintable", (PyCFunction)_wrap_gtk_widget_set_app_paintable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_double_buffered", (PyCFunction)_wrap_gtk_widget_set_double_buffered, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_redraw_on_allocate", (PyCFunction)_wrap_gtk_widget_set_redraw_on_allocate, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_parent", (PyCFunction)_wrap_gtk_widget_set_parent, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_parent_window", (PyCFunction)_wrap_gtk_widget_set_parent_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_child_visible", (PyCFunction)_wrap_gtk_widget_set_child_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_child_visible", (PyCFunction)_wrap_gtk_widget_get_child_visible, METH_NOARGS,
      NULL },
    { "get_parent", (PyCFunction)_wrap_gtk_widget_get_parent, METH_NOARGS,
      NULL },
    { "get_parent_window", (PyCFunction)_wrap_gtk_widget_get_parent_window, METH_NOARGS,
      NULL },
    { "child_focus", (PyCFunction)_wrap_gtk_widget_child_focus, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_size_request", (PyCFunction)_wrap_gtk_widget_set_size_request, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_size_request", (PyCFunction)_wrap_gtk_widget_get_size_request, METH_NOARGS,
      NULL },
    { "set_uposition", (PyCFunction)_wrap_gtk_widget_set_uposition, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_usize", (PyCFunction)_wrap_gtk_widget_set_usize, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_events", (PyCFunction)_wrap_gtk_widget_set_events, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_events", (PyCFunction)_wrap_gtk_widget_add_events, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_extension_events", (PyCFunction)_wrap_gtk_widget_set_extension_events, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_extension_events", (PyCFunction)_wrap_gtk_widget_get_extension_events, METH_NOARGS,
      NULL },
    { "get_toplevel", (PyCFunction)_wrap_gtk_widget_get_toplevel, METH_NOARGS,
      NULL },
    { "get_ancestor", (PyCFunction)_wrap_gtk_widget_get_ancestor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_colormap", (PyCFunction)_wrap_gtk_widget_get_colormap, METH_NOARGS,
      NULL },
    { "get_visual", (PyCFunction)_wrap_gtk_widget_get_visual, METH_NOARGS,
      NULL },
    { "get_screen", (PyCFunction)_wrap_gtk_widget_get_screen, METH_NOARGS,
      NULL },
    { "has_screen", (PyCFunction)_wrap_gtk_widget_has_screen, METH_NOARGS,
      NULL },
    { "get_display", (PyCFunction)_wrap_gtk_widget_get_display, METH_NOARGS,
      NULL },
    { "get_root_window", (PyCFunction)_wrap_gtk_widget_get_root_window, METH_NOARGS,
      NULL },
    { "get_settings", (PyCFunction)_wrap_gtk_widget_get_settings, METH_NOARGS,
      NULL },
    { "get_clipboard", (PyCFunction)_wrap_gtk_widget_get_clipboard, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_accessible", (PyCFunction)_wrap_gtk_widget_get_accessible, METH_NOARGS,
      NULL },
    { "set_colormap", (PyCFunction)_wrap_gtk_widget_set_colormap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_events", (PyCFunction)_wrap_gtk_widget_get_events, METH_NOARGS,
      NULL },
    { "get_pointer", (PyCFunction)_wrap_gtk_widget_get_pointer, METH_NOARGS,
      NULL },
    { "is_ancestor", (PyCFunction)_wrap_gtk_widget_is_ancestor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "translate_coordinates", (PyCFunction)_wrap_gtk_widget_translate_coordinates, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "hide_on_delete", (PyCFunction)_wrap_gtk_widget_hide_on_delete, METH_VARARGS,
      NULL },
    { "set_style", (PyCFunction)_wrap_gtk_widget_set_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "ensure_style", (PyCFunction)_wrap_gtk_widget_ensure_style, METH_NOARGS,
      NULL },
    { "get_style", (PyCFunction)_wrap_gtk_widget_get_style, METH_NOARGS,
      NULL },
    { "modify_style", (PyCFunction)_wrap_gtk_widget_modify_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_modifier_style", (PyCFunction)_wrap_gtk_widget_get_modifier_style, METH_NOARGS,
      NULL },
    { "modify_fg", (PyCFunction)_wrap_gtk_widget_modify_fg, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "modify_bg", (PyCFunction)_wrap_gtk_widget_modify_bg, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "modify_text", (PyCFunction)_wrap_gtk_widget_modify_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "modify_base", (PyCFunction)_wrap_gtk_widget_modify_base, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "modify_font", (PyCFunction)_wrap_gtk_widget_modify_font, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "create_pango_context", (PyCFunction)_wrap_gtk_widget_create_pango_context, METH_NOARGS,
      NULL },
    { "get_pango_context", (PyCFunction)_wrap_gtk_widget_get_pango_context, METH_NOARGS,
      NULL },
    { "create_pango_layout", (PyCFunction)_wrap_gtk_widget_create_pango_layout, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "render_icon", (PyCFunction)_wrap_gtk_widget_render_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_composite_name", (PyCFunction)_wrap_gtk_widget_set_composite_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_composite_name", (PyCFunction)_wrap_gtk_widget_get_composite_name, METH_NOARGS,
      NULL },
    { "reset_rc_styles", (PyCFunction)_wrap_gtk_widget_reset_rc_styles, METH_NOARGS,
      NULL },
    { "style_get_property", (PyCFunction)_wrap_gtk_widget_style_get_property, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_direction", (PyCFunction)_wrap_gtk_widget_set_direction, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_direction", (PyCFunction)_wrap_gtk_widget_get_direction, METH_NOARGS,
      NULL },
    { "shape_combine_mask", (PyCFunction)_wrap_gtk_widget_shape_combine_mask, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reset_shapes", (PyCFunction)_wrap_gtk_widget_reset_shapes, METH_NOARGS,
      NULL },
    { "path", (PyCFunction)_wrap_gtk_widget_path, METH_NOARGS,
      NULL },
    { "class_path", (PyCFunction)_wrap_gtk_widget_class_path, METH_NOARGS,
      NULL },
    { "list_mnemonic_labels", (PyCFunction)_wrap_gtk_widget_list_mnemonic_labels, METH_NOARGS,
      NULL },
    { "add_mnemonic_label", (PyCFunction)_wrap_gtk_widget_add_mnemonic_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_mnemonic_label", (PyCFunction)_wrap_gtk_widget_remove_mnemonic_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_action", (PyCFunction)_wrap_gtk_widget_get_action, METH_NOARGS,
      NULL },
    { "drag_dest_set_track_motion", (PyCFunction)_wrap_gtk_drag_dest_set_track_motion, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_dest_get_track_motion", (PyCFunction)_wrap_gtk_drag_dest_get_track_motion, METH_NOARGS,
      NULL },
    { "is_composited", (PyCFunction)_wrap_gtk_widget_is_composited, METH_NOARGS,
      NULL },
    { "input_shape_combine_mask", (PyCFunction)_wrap_gtk_widget_input_shape_combine_mask, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "keynav_failed", (PyCFunction)_wrap_gtk_widget_keynav_failed, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "error_bell", (PyCFunction)_wrap_gtk_widget_error_bell, METH_NOARGS,
      NULL },
    { "set_tooltip_window", (PyCFunction)_wrap_gtk_widget_set_tooltip_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tooltip_window", (PyCFunction)_wrap_gtk_widget_get_tooltip_window, METH_NOARGS,
      NULL },
    { "trigger_tooltip_query", (PyCFunction)_wrap_gtk_widget_trigger_tooltip_query, METH_NOARGS,
      NULL },
    { "set_tooltip_text", (PyCFunction)_wrap_gtk_widget_set_tooltip_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tooltip_text", (PyCFunction)_wrap_gtk_widget_get_tooltip_text, METH_NOARGS,
      NULL },
    { "set_tooltip_markup", (PyCFunction)_wrap_gtk_widget_set_tooltip_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tooltip_markup", (PyCFunction)_wrap_gtk_widget_get_tooltip_markup, METH_NOARGS,
      NULL },
    { "modify_cursor", (PyCFunction)_wrap_gtk_widget_modify_cursor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_has_tooltip", (PyCFunction)_wrap_gtk_widget_set_has_tooltip, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_tooltip", (PyCFunction)_wrap_gtk_widget_get_has_tooltip, METH_NOARGS,
      NULL },
    { "get_snapshot", (PyCFunction)_wrap_gtk_widget_get_snapshot, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_allocation", (PyCFunction)_wrap_gtk_widget_get_allocation, METH_NOARGS,
      NULL },
    { "get_window", (PyCFunction)_wrap_gtk_widget_get_window, METH_NOARGS,
      NULL },
    { "get_allocation", (PyCFunction)_wrap_gtk_widget_get_allocation, METH_NOARGS,
      NULL },
    { "set_allocation", (PyCFunction)_wrap_gtk_widget_set_allocation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_app_paintable", (PyCFunction)_wrap_gtk_widget_get_app_paintable, METH_NOARGS,
      NULL },
    { "set_can_default", (PyCFunction)_wrap_gtk_widget_set_can_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_can_default", (PyCFunction)_wrap_gtk_widget_get_can_default, METH_NOARGS,
      NULL },
    { "set_can_focus", (PyCFunction)_wrap_gtk_widget_set_can_focus, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_can_focus", (PyCFunction)_wrap_gtk_widget_get_can_focus, METH_NOARGS,
      NULL },
    { "get_double_buffered", (PyCFunction)_wrap_gtk_widget_get_double_buffered, METH_NOARGS,
      NULL },
    { "set_has_window", (PyCFunction)_wrap_gtk_widget_set_has_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_window", (PyCFunction)_wrap_gtk_widget_get_has_window, METH_NOARGS,
      NULL },
    { "set_receives_default", (PyCFunction)_wrap_gtk_widget_set_receives_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_receives_default", (PyCFunction)_wrap_gtk_widget_get_receives_default, METH_NOARGS,
      NULL },
    { "get_sensitive", (PyCFunction)_wrap_gtk_widget_get_sensitive, METH_NOARGS,
      NULL },
    { "get_state", (PyCFunction)_wrap_gtk_widget_get_state, METH_NOARGS,
      NULL },
    { "set_visible", (PyCFunction)_wrap_gtk_widget_set_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible", (PyCFunction)_wrap_gtk_widget_get_visible, METH_NOARGS,
      NULL },
    { "set_window", (PyCFunction)_wrap_gtk_widget_set_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "has_default", (PyCFunction)_wrap_gtk_widget_has_default, METH_NOARGS,
      NULL },
    { "has_focus", (PyCFunction)_wrap_gtk_widget_has_focus, METH_NOARGS,
      NULL },
    { "has_grab", (PyCFunction)_wrap_gtk_widget_has_grab, METH_NOARGS,
      NULL },
    { "is_sensitive", (PyCFunction)_wrap_gtk_widget_is_sensitive, METH_NOARGS,
      NULL },
    { "is_toplevel", (PyCFunction)_wrap_gtk_widget_is_toplevel, METH_NOARGS,
      NULL },
    { "is_drawable", (PyCFunction)_wrap_gtk_widget_is_drawable, METH_NOARGS,
      NULL },
    { "set_realized", (PyCFunction)_wrap_gtk_widget_set_realized, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_realized", (PyCFunction)_wrap_gtk_widget_get_realized, METH_NOARGS,
      NULL },
    { "set_mapped", (PyCFunction)_wrap_gtk_widget_set_mapped, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_mapped", (PyCFunction)_wrap_gtk_widget_get_mapped, METH_NOARGS,
      NULL },
    { "get_requisition", (PyCFunction)_wrap_gtk_widget_get_requisition, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "style_attach", (PyCFunction)_wrap_gtk_widget_style_attach, METH_NOARGS,
      NULL },
    { "has_rc_style", (PyCFunction)_wrap_gtk_widget_has_rc_style, METH_NOARGS,
      NULL },
    { "send_focus_change", (PyCFunction)_wrap_gtk_widget_send_focus_change, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_activate_signal", (PyCFunction)_wrap_gtk_widget_set_activate_signal, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "get_activate_signal", (PyCFunction)_wrap_gtk_widget_get_activate_signal, METH_NOARGS|METH_CLASS,
      NULL },
    { "set_set_scroll_adjustments_signal", (PyCFunction)_wrap_gtk_widget_set_set_scroll_adjustments_signal, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_show", (PyCFunction)_wrap_GtkWidget__do_show, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_show_all", (PyCFunction)_wrap_GtkWidget__do_show_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_hide", (PyCFunction)_wrap_GtkWidget__do_hide, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_hide_all", (PyCFunction)_wrap_GtkWidget__do_hide_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_map", (PyCFunction)_wrap_GtkWidget__do_map, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unmap", (PyCFunction)_wrap_GtkWidget__do_unmap, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_realize", (PyCFunction)_wrap_GtkWidget__do_realize, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unrealize", (PyCFunction)_wrap_GtkWidget__do_unrealize, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_size_request", (PyCFunction)_wrap_GtkWidget__do_size_request, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_size_allocate", (PyCFunction)_wrap_GtkWidget__do_size_allocate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_state_changed", (PyCFunction)_wrap_GtkWidget__do_state_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_parent_set", (PyCFunction)_wrap_GtkWidget__do_parent_set, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_hierarchy_changed", (PyCFunction)_wrap_GtkWidget__do_hierarchy_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_style_set", (PyCFunction)_wrap_GtkWidget__do_style_set, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_direction_changed", (PyCFunction)_wrap_GtkWidget__do_direction_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_grab_notify", (PyCFunction)_wrap_GtkWidget__do_grab_notify, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_mnemonic_activate", (PyCFunction)_wrap_GtkWidget__do_mnemonic_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_grab_focus", (PyCFunction)_wrap_GtkWidget__do_grab_focus, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_focus", (PyCFunction)_wrap_GtkWidget__do_focus, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_event", (PyCFunction)_wrap_GtkWidget__do_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_button_press_event", (PyCFunction)_wrap_GtkWidget__do_button_press_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_button_release_event", (PyCFunction)_wrap_GtkWidget__do_button_release_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_scroll_event", (PyCFunction)_wrap_GtkWidget__do_scroll_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_motion_notify_event", (PyCFunction)_wrap_GtkWidget__do_motion_notify_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_delete_event", (PyCFunction)_wrap_GtkWidget__do_delete_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_destroy_event", (PyCFunction)_wrap_GtkWidget__do_destroy_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_expose_event", (PyCFunction)_wrap_GtkWidget__do_expose_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_key_press_event", (PyCFunction)_wrap_GtkWidget__do_key_press_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_key_release_event", (PyCFunction)_wrap_GtkWidget__do_key_release_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_enter_notify_event", (PyCFunction)_wrap_GtkWidget__do_enter_notify_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_leave_notify_event", (PyCFunction)_wrap_GtkWidget__do_leave_notify_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_configure_event", (PyCFunction)_wrap_GtkWidget__do_configure_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_focus_in_event", (PyCFunction)_wrap_GtkWidget__do_focus_in_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_focus_out_event", (PyCFunction)_wrap_GtkWidget__do_focus_out_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_map_event", (PyCFunction)_wrap_GtkWidget__do_map_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unmap_event", (PyCFunction)_wrap_GtkWidget__do_unmap_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_property_notify_event", (PyCFunction)_wrap_GtkWidget__do_property_notify_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_selection_clear_event", (PyCFunction)_wrap_GtkWidget__do_selection_clear_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_selection_request_event", (PyCFunction)_wrap_GtkWidget__do_selection_request_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_selection_notify_event", (PyCFunction)_wrap_GtkWidget__do_selection_notify_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_proximity_in_event", (PyCFunction)_wrap_GtkWidget__do_proximity_in_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_proximity_out_event", (PyCFunction)_wrap_GtkWidget__do_proximity_out_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_visibility_notify_event", (PyCFunction)_wrap_GtkWidget__do_visibility_notify_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_client_event", (PyCFunction)_wrap_GtkWidget__do_client_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_no_expose_event", (PyCFunction)_wrap_GtkWidget__do_no_expose_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_window_state_event", (PyCFunction)_wrap_GtkWidget__do_window_state_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_selection_get", (PyCFunction)_wrap_GtkWidget__do_selection_get, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_selection_received", (PyCFunction)_wrap_GtkWidget__do_selection_received, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_drag_begin", (PyCFunction)_wrap_GtkWidget__do_drag_begin, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_drag_end", (PyCFunction)_wrap_GtkWidget__do_drag_end, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_drag_data_get", (PyCFunction)_wrap_GtkWidget__do_drag_data_get, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_drag_data_delete", (PyCFunction)_wrap_GtkWidget__do_drag_data_delete, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_drag_leave", (PyCFunction)_wrap_GtkWidget__do_drag_leave, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_drag_motion", (PyCFunction)_wrap_GtkWidget__do_drag_motion, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_drag_drop", (PyCFunction)_wrap_GtkWidget__do_drag_drop, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_drag_data_received", (PyCFunction)_wrap_GtkWidget__do_drag_data_received, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_popup_menu", (PyCFunction)_wrap_GtkWidget__do_popup_menu, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_show_help", (PyCFunction)_wrap_GtkWidget__do_show_help, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_accessible", (PyCFunction)_wrap_GtkWidget__do_get_accessible, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_screen_changed", (PyCFunction)_wrap_GtkWidget__do_screen_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_can_activate_accel", (PyCFunction)_wrap_GtkWidget__do_can_activate_accel, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_grab_broken_event", (PyCFunction)_wrap_GtkWidget__do_grab_broken_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_composited_changed", (PyCFunction)_wrap_GtkWidget__do_composited_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_widget__get_state(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_WIDGET(pygobject_get(self))->state;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_widget__get_saved_state(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_WIDGET(pygobject_get(self))->saved_state;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_widget__get_name(PyObject *self, void *closure)
{
    const gchar *ret;

    ret = GTK_WIDGET(pygobject_get(self))->name;
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget__get_style(PyObject *self, void *closure)
{
    GtkStyle *ret;

    ret = GTK_WIDGET(pygobject_get(self))->style;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 342 "gtkwidget.override"
static int
_wrap_gtk_widget__set_allocation(PyGObject *self, PyObject *value, void *closure)
{
    if (!pygobject_check(value, &PyGdkRectangle_Type)) {
	PyErr_SetString(PyExc_TypeError, "must be a GdkRectangle object");
	return -1;
    }

    pygdk_rectangle_from_pyobject(value, &GTK_WIDGET(self->obj)->allocation);

    return 0;
}
#line 12774 "gtk.c"


static PyObject *
_wrap_gtk_widget__get_allocation(PyObject *self, void *closure)
{
    GdkRectangle ret;

    ret = GTK_WIDGET(pygobject_get(self))->allocation;
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &ret, TRUE, TRUE);
}

#line 328 "gtkwidget.override"
static int
_wrap_gtk_widget__set_window(PyGObject *self, PyGObject *value, void *closure)
{
    if (!pygobject_check(value, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "must be a GdkWindow object");
	return -1;
    }

    GTK_WIDGET(self->obj)->window = g_object_ref(GDK_WINDOW(value->obj));

    return 0;
}
#line 12799 "gtk.c"


static PyObject *
_wrap_gtk_widget__get_window(PyObject *self, void *closure)
{
    GdkWindow *ret;

    ret = GTK_WIDGET(pygobject_get(self))->window;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget__get_parent(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_WIDGET(pygobject_get(self))->parent;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget__get_requisition(PyObject *self, void *closure)
{
    GtkRequisition ret;

    ret = GTK_WIDGET(pygobject_get(self))->requisition;
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_REQUISITION, &ret, TRUE, TRUE);
}

static const PyGetSetDef gtk_widget_getsets[] = {
    { "state", (getter)_wrap_gtk_widget__get_state, (setter)0 },
    { "saved_state", (getter)_wrap_gtk_widget__get_saved_state, (setter)0 },
    { "name", (getter)_wrap_gtk_widget__get_name, (setter)0 },
    { "style", (getter)_wrap_gtk_widget__get_style, (setter)0 },
    { "allocation", (getter)_wrap_gtk_widget__get_allocation, (setter)_wrap_gtk_widget__set_allocation },
    { "window", (getter)_wrap_gtk_widget__get_window, (setter)_wrap_gtk_widget__set_window },
    { "parent", (getter)_wrap_gtk_widget__get_parent, (setter)0 },
    { "requisition", (getter)_wrap_gtk_widget__get_requisition, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkWidget_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Widget",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkWidget_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_widget_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkWidget__proxy_do_show(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_show");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_show_all(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_show_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_hide(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_hide");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_hide_all(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_hide_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_map(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_map");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_unmap(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_unmap");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_realize(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_realize");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_unrealize(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_unrealize");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_size_request(GtkWidget *self, GtkRequisition*requisition)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_requisition;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_requisition = pyg_boxed_new(GTK_TYPE_REQUISITION, requisition, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_requisition);
    
    py_method = PyObject_GetAttrString(py_self, "do_size_request");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_size_allocate(GtkWidget *self, GtkAllocation*allocation)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_allocation;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_allocation = pyg_boxed_new(GDK_TYPE_RECTANGLE, allocation, TRUE, TRUE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_allocation);
    
    py_method = PyObject_GetAttrString(py_self, "do_size_allocate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_state_changed(GtkWidget *self, GtkStateType previous_state)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_previous_state;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_previous_state = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, previous_state);
    if (!py_previous_state) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_previous_state);
    
    py_method = PyObject_GetAttrString(py_self, "do_state_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_parent_set(GtkWidget *self, GtkWidget*previous_parent)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_previous_parent = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (previous_parent)
        py_previous_parent = pygobject_new((GObject *) previous_parent);
    else {
        Py_INCREF(Py_None);
        py_previous_parent = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_previous_parent);
    
    py_method = PyObject_GetAttrString(py_self, "do_parent_set");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_hierarchy_changed(GtkWidget *self, GtkWidget*previous_toplevel)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_previous_toplevel = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (previous_toplevel)
        py_previous_toplevel = pygobject_new((GObject *) previous_toplevel);
    else {
        Py_INCREF(Py_None);
        py_previous_toplevel = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_previous_toplevel);
    
    py_method = PyObject_GetAttrString(py_self, "do_hierarchy_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_style_set(GtkWidget *self, GtkStyle*previous_style)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_previous_style = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (previous_style)
        py_previous_style = pygobject_new((GObject *) previous_style);
    else {
        Py_INCREF(Py_None);
        py_previous_style = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_previous_style);
    
    py_method = PyObject_GetAttrString(py_self, "do_style_set");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_direction_changed(GtkWidget *self, GtkTextDirection previous_direction)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_previous_direction;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_previous_direction = pyg_enum_from_gtype(GTK_TYPE_TEXT_DIRECTION, previous_direction);
    if (!py_previous_direction) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_previous_direction);
    
    py_method = PyObject_GetAttrString(py_self, "do_direction_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_grab_notify(GtkWidget *self, gboolean was_grabbed)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_was_grabbed;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_was_grabbed = was_grabbed? Py_True : Py_False;
    
    py_args = PyTuple_New(1);
    Py_INCREF(py_was_grabbed);
    PyTuple_SET_ITEM(py_args, 0, py_was_grabbed);
    
    py_method = PyObject_GetAttrString(py_self, "do_grab_notify");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkWidget__proxy_do_mnemonic_activate(GtkWidget *self, gboolean group_cycling)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_group_cycling;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_group_cycling = group_cycling? Py_True : Py_False;
    
    py_args = PyTuple_New(1);
    Py_INCREF(py_group_cycling);
    PyTuple_SET_ITEM(py_args, 0, py_group_cycling);
    
    py_method = PyObject_GetAttrString(py_self, "do_mnemonic_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkWidget__proxy_do_grab_focus(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_grab_focus");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkWidget__proxy_do_focus(GtkWidget *self, GtkDirectionType direction)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_direction;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_direction = pyg_enum_from_gtype(GTK_TYPE_DIRECTION_TYPE, direction);
    if (!py_direction) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_direction);
    
    py_method = PyObject_GetAttrString(py_self, "do_focus");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_event(GtkWidget *self, GdkEvent*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_button_press_event(GtkWidget *self, GdkEventButton*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_button_press_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_button_release_event(GtkWidget *self, GdkEventButton*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_button_release_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_scroll_event(GtkWidget *self, GdkEventScroll*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_scroll_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_motion_notify_event(GtkWidget *self, GdkEventMotion*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_motion_notify_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_delete_event(GtkWidget *self, GdkEventAny*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_delete_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_destroy_event(GtkWidget *self, GdkEventAny*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_destroy_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_expose_event(GtkWidget *self, GdkEventExpose*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_expose_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_key_press_event(GtkWidget *self, GdkEventKey*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_key_press_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_key_release_event(GtkWidget *self, GdkEventKey*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_key_release_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_enter_notify_event(GtkWidget *self, GdkEventCrossing*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_enter_notify_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_leave_notify_event(GtkWidget *self, GdkEventCrossing*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_leave_notify_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_configure_event(GtkWidget *self, GdkEventConfigure*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_configure_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_focus_in_event(GtkWidget *self, GdkEventFocus*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_focus_in_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_focus_out_event(GtkWidget *self, GdkEventFocus*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_focus_out_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_map_event(GtkWidget *self, GdkEventAny*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_map_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_unmap_event(GtkWidget *self, GdkEventAny*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_unmap_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_property_notify_event(GtkWidget *self, GdkEventProperty*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_property_notify_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_selection_clear_event(GtkWidget *self, GdkEventSelection*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_selection_clear_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_selection_request_event(GtkWidget *self, GdkEventSelection*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_selection_request_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_selection_notify_event(GtkWidget *self, GdkEventSelection*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_selection_notify_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_proximity_in_event(GtkWidget *self, GdkEventProximity*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_proximity_in_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_proximity_out_event(GtkWidget *self, GdkEventProximity*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_proximity_out_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_visibility_notify_event(GtkWidget *self, GdkEventVisibility*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_visibility_notify_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_client_event(GtkWidget *self, GdkEventClient*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_client_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_no_expose_event(GtkWidget *self, GdkEventAny*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_no_expose_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_window_state_event(GtkWidget *self, GdkEventWindowState*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_window_state_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkWidget__proxy_do_selection_get(GtkWidget *self, GtkSelectionData*selection_data, guint info, guint time_)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_selection_data;
    PyObject *py_info;
    PyObject *py_time_;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_selection_data = pyg_boxed_new(GTK_TYPE_SELECTION_DATA, selection_data, FALSE, FALSE);
    py_info = PyInt_FromLong(info);
    py_time_ = PyInt_FromLong(time_);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_selection_data);
    PyTuple_SET_ITEM(py_args, 1, py_info);
    PyTuple_SET_ITEM(py_args, 2, py_time_);
    
    py_method = PyObject_GetAttrString(py_self, "do_selection_get");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_selection_received(GtkWidget *self, GtkSelectionData*selection_data, guint time_)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_selection_data;
    PyObject *py_time_;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_selection_data = pyg_boxed_new(GTK_TYPE_SELECTION_DATA, selection_data, FALSE, FALSE);
    py_time_ = PyInt_FromLong(time_);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_selection_data);
    PyTuple_SET_ITEM(py_args, 1, py_time_);
    
    py_method = PyObject_GetAttrString(py_self, "do_selection_received");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_drag_begin(GtkWidget *self, GdkDragContext*context)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_begin");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_drag_end(GtkWidget *self, GdkDragContext*context)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_end");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_drag_data_get(GtkWidget *self, GdkDragContext*context, GtkSelectionData*selection_data, guint info, guint time_)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_selection_data;
    PyObject *py_info;
    PyObject *py_time_;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    py_selection_data = pyg_boxed_new(GTK_TYPE_SELECTION_DATA, selection_data, FALSE, FALSE);
    py_info = PyInt_FromLong(info);
    py_time_ = PyInt_FromLong(time_);
    
    py_args = PyTuple_New(4);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    PyTuple_SET_ITEM(py_args, 1, py_selection_data);
    PyTuple_SET_ITEM(py_args, 2, py_info);
    PyTuple_SET_ITEM(py_args, 3, py_time_);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_data_get");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_drag_data_delete(GtkWidget *self, GdkDragContext*context)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_data_delete");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWidget__proxy_do_drag_leave(GtkWidget *self, GdkDragContext*context, guint time_)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_time_;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    py_time_ = PyInt_FromLong(time_);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    PyTuple_SET_ITEM(py_args, 1, py_time_);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_leave");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkWidget__proxy_do_drag_motion(GtkWidget *self, GdkDragContext*context, gint x, gint y, guint time_)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_time_;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_time_ = PyInt_FromLong(time_);
    
    py_args = PyTuple_New(4);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    PyTuple_SET_ITEM(py_args, 1, py_x);
    PyTuple_SET_ITEM(py_args, 2, py_y);
    PyTuple_SET_ITEM(py_args, 3, py_time_);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_motion");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_drag_drop(GtkWidget *self, GdkDragContext*context, gint x, gint y, guint time_)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_time_;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_time_ = PyInt_FromLong(time_);
    
    py_args = PyTuple_New(4);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    PyTuple_SET_ITEM(py_args, 1, py_x);
    PyTuple_SET_ITEM(py_args, 2, py_y);
    PyTuple_SET_ITEM(py_args, 3, py_time_);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_drop");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkWidget__proxy_do_drag_data_received(GtkWidget *self, GdkDragContext*context, gint x, gint y, GtkSelectionData*selection_data, guint info, guint time_)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_selection_data;
    PyObject *py_info;
    PyObject *py_time_;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_selection_data = pyg_boxed_new(GTK_TYPE_SELECTION_DATA, selection_data, FALSE, FALSE);
    py_info = PyInt_FromLong(info);
    py_time_ = PyInt_FromLong(time_);
    
    py_args = PyTuple_New(6);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    PyTuple_SET_ITEM(py_args, 1, py_x);
    PyTuple_SET_ITEM(py_args, 2, py_y);
    PyTuple_SET_ITEM(py_args, 3, py_selection_data);
    PyTuple_SET_ITEM(py_args, 4, py_info);
    PyTuple_SET_ITEM(py_args, 5, py_time_);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_data_received");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkWidget__proxy_do_popup_menu(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_popup_menu");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_show_help(GtkWidget *self, GtkWidgetHelpType help_type)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_help_type;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_help_type = pyg_enum_from_gtype(GTK_TYPE_WIDGET_HELP_TYPE, help_type);
    if (!py_help_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_help_type);
    
    py_method = PyObject_GetAttrString(py_self, "do_show_help");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static AtkObject*
_wrap_GtkWidget__proxy_do_get_accessible(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    AtkObject* retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_accessible");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (AtkObject*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkWidget__proxy_do_screen_changed(GtkWidget *self, GdkScreen*previous_screen)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_previous_screen = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (previous_screen)
        py_previous_screen = pygobject_new((GObject *) previous_screen);
    else {
        Py_INCREF(Py_None);
        py_previous_screen = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_previous_screen);
    
    py_method = PyObject_GetAttrString(py_self, "do_screen_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkWidget__proxy_do_can_activate_accel(GtkWidget *self, guint signal_id)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_signal_id;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_signal_id = PyInt_FromLong(signal_id);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_signal_id);
    
    py_method = PyObject_GetAttrString(py_self, "do_can_activate_accel");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkWidget__proxy_do_grab_broken_event(GtkWidget *self, GdkEventGrabBroken*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_grab_broken_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkWidget__proxy_do_composited_changed(GtkWidget *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_composited_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkWidget_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkWidgetClass *klass = GTK_WIDGET_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    /* overriding do_dispatch_child_properties_changed is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_show");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "show")))
            klass->show = _wrap_GtkWidget__proxy_do_show;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_show_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "show_all")))
            klass->show_all = _wrap_GtkWidget__proxy_do_show_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_hide");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "hide")))
            klass->hide = _wrap_GtkWidget__proxy_do_hide;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_hide_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "hide_all")))
            klass->hide_all = _wrap_GtkWidget__proxy_do_hide_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_map");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "map")))
            klass->map = _wrap_GtkWidget__proxy_do_map;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_unmap");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "unmap")))
            klass->unmap = _wrap_GtkWidget__proxy_do_unmap;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_realize");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "realize")))
            klass->realize = _wrap_GtkWidget__proxy_do_realize;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_unrealize");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "unrealize")))
            klass->unrealize = _wrap_GtkWidget__proxy_do_unrealize;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_size_request");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "size_request")))
            klass->size_request = _wrap_GtkWidget__proxy_do_size_request;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_size_allocate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "size_allocate")))
            klass->size_allocate = _wrap_GtkWidget__proxy_do_size_allocate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_state_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "state_changed")))
            klass->state_changed = _wrap_GtkWidget__proxy_do_state_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_parent_set");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "parent_set")))
            klass->parent_set = _wrap_GtkWidget__proxy_do_parent_set;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_hierarchy_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "hierarchy_changed")))
            klass->hierarchy_changed = _wrap_GtkWidget__proxy_do_hierarchy_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_style_set");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "style_set")))
            klass->style_set = _wrap_GtkWidget__proxy_do_style_set;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_direction_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "direction_changed")))
            klass->direction_changed = _wrap_GtkWidget__proxy_do_direction_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_grab_notify");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "grab_notify")))
            klass->grab_notify = _wrap_GtkWidget__proxy_do_grab_notify;
        Py_DECREF(o);
    }

    /* overriding do_child_notify is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_mnemonic_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "mnemonic_activate")))
            klass->mnemonic_activate = _wrap_GtkWidget__proxy_do_mnemonic_activate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_grab_focus");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "grab_focus")))
            klass->grab_focus = _wrap_GtkWidget__proxy_do_grab_focus;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_focus");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "focus")))
            klass->focus = _wrap_GtkWidget__proxy_do_focus;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "event")))
            klass->event = _wrap_GtkWidget__proxy_do_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_button_press_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "button_press_event")))
            klass->button_press_event = _wrap_GtkWidget__proxy_do_button_press_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_button_release_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "button_release_event")))
            klass->button_release_event = _wrap_GtkWidget__proxy_do_button_release_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_scroll_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "scroll_event")))
            klass->scroll_event = _wrap_GtkWidget__proxy_do_scroll_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_motion_notify_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "motion_notify_event")))
            klass->motion_notify_event = _wrap_GtkWidget__proxy_do_motion_notify_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_delete_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "delete_event")))
            klass->delete_event = _wrap_GtkWidget__proxy_do_delete_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_destroy_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "destroy_event")))
            klass->destroy_event = _wrap_GtkWidget__proxy_do_destroy_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_expose_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "expose_event")))
            klass->expose_event = _wrap_GtkWidget__proxy_do_expose_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_key_press_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "key_press_event")))
            klass->key_press_event = _wrap_GtkWidget__proxy_do_key_press_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_key_release_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "key_release_event")))
            klass->key_release_event = _wrap_GtkWidget__proxy_do_key_release_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_enter_notify_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "enter_notify_event")))
            klass->enter_notify_event = _wrap_GtkWidget__proxy_do_enter_notify_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_leave_notify_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "leave_notify_event")))
            klass->leave_notify_event = _wrap_GtkWidget__proxy_do_leave_notify_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_configure_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "configure_event")))
            klass->configure_event = _wrap_GtkWidget__proxy_do_configure_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_focus_in_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "focus_in_event")))
            klass->focus_in_event = _wrap_GtkWidget__proxy_do_focus_in_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_focus_out_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "focus_out_event")))
            klass->focus_out_event = _wrap_GtkWidget__proxy_do_focus_out_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_map_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "map_event")))
            klass->map_event = _wrap_GtkWidget__proxy_do_map_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_unmap_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "unmap_event")))
            klass->unmap_event = _wrap_GtkWidget__proxy_do_unmap_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_property_notify_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "property_notify_event")))
            klass->property_notify_event = _wrap_GtkWidget__proxy_do_property_notify_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_selection_clear_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "selection_clear_event")))
            klass->selection_clear_event = _wrap_GtkWidget__proxy_do_selection_clear_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_selection_request_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "selection_request_event")))
            klass->selection_request_event = _wrap_GtkWidget__proxy_do_selection_request_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_selection_notify_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "selection_notify_event")))
            klass->selection_notify_event = _wrap_GtkWidget__proxy_do_selection_notify_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_proximity_in_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "proximity_in_event")))
            klass->proximity_in_event = _wrap_GtkWidget__proxy_do_proximity_in_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_proximity_out_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "proximity_out_event")))
            klass->proximity_out_event = _wrap_GtkWidget__proxy_do_proximity_out_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_visibility_notify_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "visibility_notify_event")))
            klass->visibility_notify_event = _wrap_GtkWidget__proxy_do_visibility_notify_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_client_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "client_event")))
            klass->client_event = _wrap_GtkWidget__proxy_do_client_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_no_expose_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "no_expose_event")))
            klass->no_expose_event = _wrap_GtkWidget__proxy_do_no_expose_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_window_state_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "window_state_event")))
            klass->window_state_event = _wrap_GtkWidget__proxy_do_window_state_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_selection_get");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "selection_get")))
            klass->selection_get = _wrap_GtkWidget__proxy_do_selection_get;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_selection_received");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "selection_received")))
            klass->selection_received = _wrap_GtkWidget__proxy_do_selection_received;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_drag_begin");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "drag_begin")))
            klass->drag_begin = _wrap_GtkWidget__proxy_do_drag_begin;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_drag_end");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "drag_end")))
            klass->drag_end = _wrap_GtkWidget__proxy_do_drag_end;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_drag_data_get");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "drag_data_get")))
            klass->drag_data_get = _wrap_GtkWidget__proxy_do_drag_data_get;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_drag_data_delete");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "drag_data_delete")))
            klass->drag_data_delete = _wrap_GtkWidget__proxy_do_drag_data_delete;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_drag_leave");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "drag_leave")))
            klass->drag_leave = _wrap_GtkWidget__proxy_do_drag_leave;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_drag_motion");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "drag_motion")))
            klass->drag_motion = _wrap_GtkWidget__proxy_do_drag_motion;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_drag_drop");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "drag_drop")))
            klass->drag_drop = _wrap_GtkWidget__proxy_do_drag_drop;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_drag_data_received");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "drag_data_received")))
            klass->drag_data_received = _wrap_GtkWidget__proxy_do_drag_data_received;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_popup_menu");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "popup_menu")))
            klass->popup_menu = _wrap_GtkWidget__proxy_do_popup_menu;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_show_help");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "show_help")))
            klass->show_help = _wrap_GtkWidget__proxy_do_show_help;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_get_accessible");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "get_accessible")))
            klass->get_accessible = _wrap_GtkWidget__proxy_do_get_accessible;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_screen_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "screen_changed")))
            klass->screen_changed = _wrap_GtkWidget__proxy_do_screen_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_can_activate_accel");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "can_activate_accel")))
            klass->can_activate_accel = _wrap_GtkWidget__proxy_do_can_activate_accel;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_grab_broken_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "grab_broken_event")))
            klass->grab_broken_event = _wrap_GtkWidget__proxy_do_grab_broken_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_composited_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "composited_changed")))
            klass->composited_changed = _wrap_GtkWidget__proxy_do_composited_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkContainer ----------- */

static PyObject *
_wrap_gtk_container_set_border_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "border_width", NULL };
    PyObject *py_border_width = NULL;
    guint border_width = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Container.set_border_width", kwlist, &py_border_width))
        return NULL;
    if (py_border_width) {
        if (PyLong_Check(py_border_width))
            border_width = PyLong_AsUnsignedLong(py_border_width);
        else if (PyInt_Check(py_border_width))
            border_width = PyInt_AsLong(py_border_width);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'border_width' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_container_set_border_width(GTK_CONTAINER(self->obj), border_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_container_get_border_width(PyGObject *self)
{
    guint ret;

    
    ret = gtk_container_get_border_width(GTK_CONTAINER(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_container_add(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Container.add", kwlist, &PyGtkWidget_Type, &widget))
        return NULL;
    
    gtk_container_add(GTK_CONTAINER(self->obj), GTK_WIDGET(widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_container_remove(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Container.remove", kwlist, &PyGtkWidget_Type, &widget))
        return NULL;
    
    gtk_container_remove(GTK_CONTAINER(self->obj), GTK_WIDGET(widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_container_set_resize_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "resize_mode", NULL };
    PyObject *py_resize_mode = NULL;
    GtkResizeMode resize_mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Container.set_resize_mode", kwlist, &py_resize_mode))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_RESIZE_MODE, py_resize_mode, (gpointer)&resize_mode))
        return NULL;
    
    gtk_container_set_resize_mode(GTK_CONTAINER(self->obj), resize_mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_container_get_resize_mode(PyGObject *self)
{
    gint ret;

    
    ret = gtk_container_get_resize_mode(GTK_CONTAINER(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_RESIZE_MODE, ret);
}

static PyObject *
_wrap_gtk_container_check_resize(PyGObject *self)
{
    
    gtk_container_check_resize(GTK_CONTAINER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 484 "gtkcontainer.override"
static void
pygtk_container_for_common_marshal(GtkWidget *widget,
				   gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *py_widget, *retobj;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_widget = pygobject_new((GObject*)widget);
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NO)",
                                     py_widget, cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(N)",
                                     py_widget);

    if (retobj == NULL) {
        PyErr_Print();
    }

    Py_XDECREF(retobj);

    pyg_gil_state_release(state);
}
static PyObject *
pygtk_container_for_common(PyGObject *self, PyObject *args, unsigned for_index)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
    static struct {
        char *parse_arg;
        void (*for_func)(GtkContainer *container, GtkCallback callback,
                          gpointer callback_data);
    } table[] = {
            { "O|O:GtkContainer.foreach", gtk_container_foreach },
            { "O|O:GtkContainer.forall", gtk_container_forall }
    };

    if (for_index >= countof(table)) {
	PyErr_SetString(PyExc_TypeError, "for_index > 2");
	return NULL;
    }

    if (!PyArg_ParseTuple(args, table[for_index].parse_arg,
                          &pyfunc, &pyarg))
         return NULL;
 
    cunote.func = pyfunc;
    cunote.data = pyarg;
    table[for_index].for_func(GTK_CONTAINER(self->obj),
			      pygtk_container_for_common_marshal,
			      &cunote);
    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
_wrap_gtk_container_foreach(PyGObject *self, PyObject *args)
{
    return pygtk_container_for_common(self, args, PYGTK_CONTAINER_FOREACH);
}
#line 17801 "gtk.c"


#line 46 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_get_children(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *py_list;

    list = gtk_container_get_children(GTK_CONTAINER(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        g_list_free(list);
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        PyObject *gtk_obj = pygobject_new(G_OBJECT(tmp->data));

        if (gtk_obj == NULL) {
            g_list_free(list);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    g_list_free(list);
    return py_list;
}
#line 17831 "gtk.c"


#line 37 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_children(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkContainer.get_children"))
        return NULL;
    return _wrap_gtk_container_get_children(self);
}
#line 17842 "gtk.c"


static PyObject *
_wrap_gtk_container_propagate_expose(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "event", NULL };
    PyGObject *child;
    GdkEvent *event = NULL;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Container.propagate_expose", kwlist, &PyGtkWidget_Type, &child, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    gtk_container_propagate_expose(GTK_CONTAINER(self->obj), GTK_WIDGET(child->obj), (GdkEventExpose *)event);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 74 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_set_focus_chain(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "focusable_widgets", NULL };
    PyObject *py_focusable_widgets;
    gint len, i;
    GList *focusable_widgets = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkContainer.set_focus_chain", kwlist,
                                     &py_focusable_widgets))
        return NULL;
    if (!PySequence_Check(py_focusable_widgets)) {
        PyErr_SetString(PyExc_TypeError,
                        "focusable_widgets must be a sequence");
        return NULL;
    }
    len = PySequence_Length(py_focusable_widgets);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(py_focusable_widgets, i);

        if (!pygobject_check(item, &PyGtkWidget_Type)) {
            PyErr_SetString(PyExc_TypeError,
                            "focusable_widgets members must be GtkWidgets");
            Py_DECREF(item);
            return NULL;
        }
        focusable_widgets = g_list_prepend(focusable_widgets,
                                           pygobject_get(item));
        Py_DECREF(item);
    }
    focusable_widgets = g_list_reverse(focusable_widgets);
    gtk_container_set_focus_chain(GTK_CONTAINER(self->obj), focusable_widgets);
    g_list_free(focusable_widgets);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 17907 "gtk.c"


#line 114 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_get_focus_chain(PyGObject *self)
{
    GList *list = NULL;

    if (gtk_container_get_focus_chain(GTK_CONTAINER(self->obj), &list)) {
        PyObject *py_list;
        GList *tmp;

        if ((py_list = PyList_New(0)) == NULL) {
            g_list_free(list);
            return NULL;
        }
        for (tmp = list; tmp != NULL; tmp = tmp->next) {
            PyObject *gtk_obj = pygobject_new(G_OBJECT(tmp->data));

            if (gtk_obj == NULL) {
                g_list_free(list);
                Py_DECREF(py_list);
                return NULL;
            }
            PyList_Append(py_list, gtk_obj);
            Py_DECREF(gtk_obj);
        }
        g_list_free(list);
        return py_list;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 17941 "gtk.c"


static PyObject *
_wrap_gtk_container_unset_focus_chain(PyGObject *self)
{
    
    gtk_container_unset_focus_chain(GTK_CONTAINER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_container_set_reallocate_redraws(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "needs_redraws", NULL };
    int needs_redraws;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Container.set_reallocate_redraws", kwlist, &needs_redraws))
        return NULL;
    
    gtk_container_set_reallocate_redraws(GTK_CONTAINER(self->obj), needs_redraws);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_container_set_focus_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *py_child;
    GtkWidget *child = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Container.set_focus_child", kwlist, &py_child))
        return NULL;
    if (py_child && pygobject_check(py_child, &PyGtkWidget_Type))
        child = GTK_WIDGET(py_child->obj);
    else if ((PyObject *)py_child != Py_None) {
        PyErr_SetString(PyExc_TypeError, "child should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_container_set_focus_child(GTK_CONTAINER(self->obj), (GtkWidget *) child);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_container_set_focus_vadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *adjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Container.set_focus_vadjustment", kwlist, &PyGtkAdjustment_Type, &adjustment))
        return NULL;
    
    gtk_container_set_focus_vadjustment(GTK_CONTAINER(self->obj), GTK_ADJUSTMENT(adjustment->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_container_get_focus_vadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_container_get_focus_vadjustment(GTK_CONTAINER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_container_set_focus_hadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *adjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Container.set_focus_hadjustment", kwlist, &PyGtkAdjustment_Type, &adjustment))
        return NULL;
    
    gtk_container_set_focus_hadjustment(GTK_CONTAINER(self->obj), GTK_ADJUSTMENT(adjustment->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_container_get_focus_hadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_container_get_focus_hadjustment(GTK_CONTAINER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_container_resize_children(PyGObject *self)
{
    
    gtk_container_resize_children(GTK_CONTAINER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_container_child_type(PyGObject *self)
{
    GType ret;

    
    ret = gtk_container_child_type(GTK_CONTAINER(self->obj));
    
    return pyg_type_wrapper_new(ret);
}

#line 407 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_add_with_properties(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GObjectClass *class;
    int len, i;

    if ((len = PyTuple_Size(args)) < 1) {
        PyErr_SetString(PyExc_TypeError, "requires at least one argument");
        return NULL;
    }
    pychild = (PyGObject*)PyTuple_GetItem(args, 0);
    if (!pygobject_check(pychild, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument should be a GtkWidget");
        return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    if ((len - 1) % 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Argument list must be column, value pairs.  No -1 "
                        "termination is needed.");
        return NULL;
    }

    gtk_widget_freeze_child_notify(child);

    gtk_container_add(container, child);

    class = G_OBJECT_GET_CLASS(self->obj);
    for (i = 1; i < len; i+=2) {
        PyObject *py_property = PyTuple_GetItem(args, i);
        PyObject *py_value = PyTuple_GetItem(args, i + 1);
        gchar *property_name;
        GParamSpec *pspec;
        GValue value = { 0 };

        if (!PyString_Check(py_property)) {
            PyErr_SetString(PyExc_TypeError,
                            "Expected string argument for property.");
            return NULL;
        }

        property_name = PyString_AsString(py_property);

        pspec = gtk_container_class_find_child_property(class, property_name);
        if (!pspec) {
            gchar buf[512];
            g_snprintf(buf, sizeof(buf),
                       "container does not support property `%s'",
                       property_name);
            PyErr_SetString(PyExc_TypeError, buf);

            return NULL;
        }

        g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

        pyg_value_from_pyobject(&value, (PyObject*)py_value);

        gtk_container_child_set_property(container, child, property_name, &value);

        g_value_unset(&value);
    }

    gtk_widget_thaw_child_notify(child);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 18142 "gtk.c"


#line 256 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_child_set(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    GObjectClass *class;
    int len, i;

    if ((len = PyTuple_Size(args)) < 1) {
        PyErr_SetString(PyExc_TypeError, "requires at least one argument");
        return NULL;
    }
    pychild = (PyGObject*)PyTuple_GetItem(args, 0);
    if (!pygobject_check(pychild, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument should be a GtkWidget");
        return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }

    if ((len - 1) % 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Argument list must be column, value pairs.  No -1 "
                        "termination is needed.");
        return NULL;
    }

    class = G_OBJECT_GET_CLASS(self->obj);
    for (i = 1; i < len; i+=2) {
        PyObject *py_property = PyTuple_GetItem(args, i);
        PyObject *py_value = PyTuple_GetItem(args, i + 1);
        gchar *property_name;
        GParamSpec *pspec;
        GValue value = { 0 };

        if (!PyString_Check(py_property)) {
            PyErr_SetString(PyExc_TypeError,
                            "Expected string argument for property.");
            return NULL;
        }

        property_name = PyString_AsString(py_property);

        pspec = gtk_container_class_find_child_property(class, property_name);
        if (!pspec) {
            gchar buf[512];
            g_snprintf(buf, sizeof(buf),
                       "container does not support property `%s'",
                       property_name);
            PyErr_SetString(PyExc_TypeError, buf);

            return NULL;
        }

        g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

        pyg_value_from_pyobject(&value, (PyObject*)py_value);

        gtk_container_child_set_property(container, child, property_name, &value);

        g_value_unset(&value);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 18222 "gtk.c"


#line 334 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_child_get(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    GObjectClass *class;
    int len, i;
    PyObject *tuple;

    if ((len = PyTuple_Size(args)) < 1) {
        PyErr_SetString(PyExc_TypeError, "requires at least one argument");
        return NULL;
    }
    pychild = (PyGObject*)PyTuple_GetItem(args, 0);
    if (!pygobject_check(pychild, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument should be a GtkWidget");
        return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }

    tuple = PyTuple_New(len-1);
    class = G_OBJECT_GET_CLASS(self->obj);
    for (i = 1; i < len; i++) {
        PyObject *py_property = PyTuple_GetItem(args, i);
        gchar *property_name;
        GParamSpec *pspec;
        GValue value = { 0 };
        PyObject *item;

        if (!PyString_Check(py_property)) {
            PyErr_SetString(PyExc_TypeError,
                            "Expected string argument for property.");
            return NULL;
        }

        property_name = PyString_AsString(py_property);

        pspec = gtk_container_class_find_child_property(class, property_name);
        if (!pspec) {
            gchar buf[512];
            g_snprintf(buf, sizeof(buf),
                       "container does not support property `%s'",
                       property_name);
            PyErr_SetString(PyExc_TypeError, buf);

            return NULL;
        }

        g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

        gtk_container_child_get_property(container, child, property_name, &value);

        item = pyg_value_as_pyobject(&value, TRUE);
        PyTuple_SetItem(tuple, i-1, item);

        g_value_unset(&value);
    }
    return tuple;
}
#line 18297 "gtk.c"


#line 201 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_child_set_property(PyGObject *self, PyObject *args)
{
    gchar *property_name;
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    PyGObject *pyvalue;
    GObjectClass *class;
    GParamSpec *pspec;
    GValue value = { 0, } ;

    if (!PyArg_ParseTuple(args, "O!sO:GtkContainer.child_set_property",
                          &PyGtkWidget_Type, &pychild,
                          &property_name, &pyvalue)) {
        return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }

    class = G_OBJECT_GET_CLASS(self->obj);
    pspec = gtk_container_class_find_child_property(class, property_name);
    if (!pspec) {
        gchar buf[512];
        g_snprintf(buf, sizeof(buf),
                   "container does not support property `%s'",
                   property_name);
        PyErr_SetString(PyExc_TypeError, buf);

        return NULL;
    }

    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

    pyg_value_from_pyobject(&value, (PyObject*)pyvalue);

    gtk_container_child_set_property(container,
                                     child,
                                     property_name,
                                     &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 18354 "gtk.c"


#line 146 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_child_get_property(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    gchar *property_name;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    GObjectClass *class;
    GParamSpec *pspec;
    GValue value = { 0, } ;
    PyObject *ret;

    if (!PyArg_ParseTuple(args, "O!s:GtkContainer.child_get_property",
                          &PyGtkWidget_Type, &pychild,
                          &property_name)) {
        return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }

    class = G_OBJECT_GET_CLASS(container);
    pspec = gtk_container_class_find_child_property(class, property_name);
    if (!pspec) {
        gchar buf[512];
        g_snprintf(buf, sizeof(buf),
                   "container does not support property `%s'",
                   property_name);

        PyErr_SetString(PyExc_TypeError, buf);
        return NULL;
    }

    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

    gtk_container_child_get_property(container,
                                     child,
                                     property_name,
                                     &value);

    ret = pyg_value_as_pyobject(&value, TRUE);
    g_value_unset(&value);

    return ret;
}
#line 18411 "gtk.c"


#line 550 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_forall(PyGObject *self, PyObject *args)
{
    return pygtk_container_for_common(self, args, PYGTK_CONTAINER_FORALL);
}
#line 18420 "gtk.c"


static PyObject *
_wrap_gtk_container_get_focus_child(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_container_get_focus_child(GTK_CONTAINER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 709 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_install_child_property (PyObject *self,
                                            PyObject *args,
                                            PyObject* kwargs)
{
    static char *kwlist[] = { "property_id", "pspec", NULL };
    PyObject *property;
    GType itype;
    GtkContainerClass *class;
    guint property_id;
    GParamSpec *pspec;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "iO:container_class_install_child_property",
				     kwlist,
				     &property_id, &property))
	return NULL;


    if ((itype = pyg_type_from_object(self)) == 0)
	return NULL;

    class = g_type_class_ref(itype);
    if (!class) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not get a reference to type class");
	return NULL;
    }

    pspec = pyg_param_spec_from_object(property);
    if(!pspec) {
	g_type_class_unref(class);
	return NULL;
    }

    if (gtk_container_class_find_child_property(G_OBJECT_CLASS(class), pspec->name)) {
	PyErr_Format(PyExc_TypeError,
		     "there is already a '%s' property installed", pspec->name);
	g_type_class_unref(class);
	return NULL;
    }
    
    gtk_container_class_install_child_property(class, property_id, pspec);
	
    g_type_class_unref(class);

    Py_INCREF(Py_None);
    return Py_None;
}

#line 18486 "gtk.c"


#line 608 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_list_child_properties (PyObject *self, PyObject *args,
                                           PyObject*kwargs)
{
    GParamSpec **specs;
    PyObject *list;
    GType itype;
    GObjectClass *class;
    guint nprops;
    guint i;

    if ((itype = pyg_type_from_object(self)) == 0)
	return NULL;

    class = g_type_class_ref(itype);
    if (!class) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not get a reference to type class");
	return NULL;
    }

    specs = gtk_container_class_list_child_properties(class, &nprops);
    list = PyList_New(nprops);
    if (list == NULL) {
	g_free(specs);
	g_type_class_unref(class);
	return NULL;
    }
    
    for (i = 0; i < nprops; i++) {
	PyList_SetItem(list, i, pyg_param_spec_new(specs[i]));
    }
    
    g_free(specs);
    g_type_class_unref(class);

    return list;
}

#line 18529 "gtk.c"


static PyObject *
_wrap_GtkContainer__do_add(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "widget", NULL };
    PyGObject *self, *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Container.add", kwlist, &PyGtkContainer_Type, &self, &PyGtkWidget_Type, &widget))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CONTAINER_CLASS(klass)->add)
        GTK_CONTAINER_CLASS(klass)->add(GTK_CONTAINER(self->obj), GTK_WIDGET(widget->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Container.add not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkContainer__do_remove(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "widget", NULL };
    PyGObject *self, *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Container.remove", kwlist, &PyGtkContainer_Type, &self, &PyGtkWidget_Type, &widget))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CONTAINER_CLASS(klass)->remove)
        GTK_CONTAINER_CLASS(klass)->remove(GTK_CONTAINER(self->obj), GTK_WIDGET(widget->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Container.remove not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkContainer__do_check_resize(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Container.check_resize", kwlist, &PyGtkContainer_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CONTAINER_CLASS(klass)->check_resize)
        GTK_CONTAINER_CLASS(klass)->check_resize(GTK_CONTAINER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Container.check_resize not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1088 "gtkcontainer.override"

typedef struct {
    PyObject *callback;
    PyObject *callback_data;
} PyGtkContainerPyCallbackData;

static void
_wrap_GtkContainer__do_forall_callback(GtkWidget *child, PyGtkContainerPyCallbackData *data)
{
    PyObject *pychild = pygobject_new((GObject *) child);
    PyObject *result;

    result = PyObject_CallFunctionObjArgs(data->callback, pychild, data->callback_data, NULL);
    /* Just discard it. */
    Py_DECREF(result);
}

static PyObject *
_wrap_GtkContainer__do_forall(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "include_internals", "callback", "callback_data", NULL };
    PyGObject *self;
    char include_internals;
    PyObject *callback;
    PyObject *callback_data = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!bO|O:GtkContainer.forall", kwlist,
                                     &PyGtkContainer_Type, &self,
                                     &include_internals,
                                     &callback, &callback_data))
        return NULL;

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CONTAINER_CLASS(klass)->forall) {
	PyGtkContainerPyCallbackData *data = g_new(PyGtkContainerPyCallbackData, 1);
	data->callback = callback;
	data->callback_data = callback_data;

	GTK_CONTAINER_CLASS(klass)->forall(GTK_CONTAINER(self->obj),
					   include_internals,
					   (GtkCallback)_wrap_GtkContainer__do_forall_callback,
					   data);
	g_free(data);
        g_type_class_unref(klass);
	Py_INCREF(Py_None);
	return Py_None;
    }
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkContainer.forall not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
}
#line 18653 "gtk.c"


static PyObject *
_wrap_GtkContainer__do_set_focus_child(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "widget", NULL };
    PyGObject *self, *py_widget;
    GtkWidget *widget = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Container.set_focus_child", kwlist, &PyGtkContainer_Type, &self, &py_widget))
        return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CONTAINER_CLASS(klass)->set_focus_child)
        GTK_CONTAINER_CLASS(klass)->set_focus_child(GTK_CONTAINER(self->obj), (GtkWidget *) widget);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Container.set_focus_child not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkContainer__do_child_type(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    GType ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Container.child_type", kwlist, &PyGtkContainer_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CONTAINER_CLASS(klass)->child_type)
        ret = GTK_CONTAINER_CLASS(klass)->child_type(GTK_CONTAINER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Container.child_type not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return pyg_type_wrapper_new(ret);
}

static PyObject *
_wrap_GtkContainer__do_composite_name(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "child", NULL };
    PyGObject *self, *child;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Container.composite_name", kwlist, &PyGtkContainer_Type, &self, &PyGtkWidget_Type, &child))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CONTAINER_CLASS(klass)->composite_name)
        ret = GTK_CONTAINER_CLASS(klass)->composite_name(GTK_CONTAINER(self->obj), GTK_WIDGET(child->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Container.composite_name not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 994 "gtkcontainer.override"
static PyObject *
_wrap_GtkContainer__do_set_child_property(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "child", "property_id", "value", "pspec", NULL };
    PyGObject *self, *child;
    PyObject *py_property_id = NULL, *py_value, *py_pspec;
    guint property_id = 0;
    GValue value = {0, };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOO!:GtkContainer.set_child_property",
                                     kwlist, &PyGtkContainer_Type, &self,
                                     &PyGtkWidget_Type, &child,
                                     &py_property_id,
                                     &py_value,
                                     &PyGParamSpec_Type, &py_pspec))
        return NULL;

    if (pyg_value_from_pyobject(&value, py_value)) {
        PyErr_SetString(PyExc_TypeError, "unable to convert value");
        return NULL;
    }

    if (py_property_id) {
        if (PyLong_Check(py_property_id))
            property_id = PyLong_AsUnsignedLong(py_property_id);
        else if (PyInt_Check(py_property_id))
            property_id = PyInt_AsLong(py_property_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'property_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CONTAINER_CLASS(klass)->set_child_property)
        GTK_CONTAINER_CLASS(klass)->set_child_property(GTK_CONTAINER(self->obj), GTK_WIDGET(child->obj), property_id,
                                                       &value, ((PyGParamSpec *)py_pspec)->pspec);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkContainer.set_child_property not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 18783 "gtk.c"


#line 1043 "gtkcontainer.override"
static PyObject *
_wrap_GtkContainer__do_get_child_property(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "child", "property_id", "pspec", NULL };
    PyGObject *self, *child;
    PyObject *py_property_id = NULL;
    guint property_id = 0;
    GValue value = {0, };
    PyObject *py_value, *py_pspec;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OO!:GtkContainer.get_child_property", kwlist,
                                     &PyGtkContainer_Type, &self,
                                     &PyGtkWidget_Type, &child,
                                     &py_property_id,
                                     &PyGParamSpec_Type, &py_pspec))
        return NULL;
    if (py_property_id) {
        if (PyLong_Check(py_property_id))
            property_id = PyLong_AsUnsignedLong(py_property_id);
        else if (PyInt_Check(py_property_id))
            property_id = PyInt_AsLong(py_property_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'property_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CONTAINER_CLASS(klass)->get_child_property)
        GTK_CONTAINER_CLASS(klass)->get_child_property(GTK_CONTAINER(self->obj), GTK_WIDGET(child->obj), property_id,
                                                       &value, ((PyGParamSpec *)py_pspec)->pspec);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkContainer.get_child_property not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    
    py_value = pyg_value_as_pyobject(&value, TRUE);
    g_value_unset(&value);
    return py_value;
}

#line 18830 "gtk.c"


static const PyMethodDef _PyGtkContainer_methods[] = {
    { "set_border_width", (PyCFunction)_wrap_gtk_container_set_border_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_border_width", (PyCFunction)_wrap_gtk_container_get_border_width, METH_NOARGS,
      NULL },
    { "add", (PyCFunction)_wrap_gtk_container_add, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove", (PyCFunction)_wrap_gtk_container_remove, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_resize_mode", (PyCFunction)_wrap_gtk_container_set_resize_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_resize_mode", (PyCFunction)_wrap_gtk_container_get_resize_mode, METH_NOARGS,
      NULL },
    { "check_resize", (PyCFunction)_wrap_gtk_container_check_resize, METH_NOARGS,
      NULL },
    { "foreach", (PyCFunction)_wrap_gtk_container_foreach, METH_VARARGS,
      NULL },
    { "get_children", (PyCFunction)_wrap_gtk_container_get_children, METH_NOARGS,
      NULL },
    { "children", (PyCFunction)_wrap_gtk_container_children, METH_NOARGS,
      NULL },
    { "propagate_expose", (PyCFunction)_wrap_gtk_container_propagate_expose, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_focus_chain", (PyCFunction)_wrap_gtk_container_set_focus_chain, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_focus_chain", (PyCFunction)_wrap_gtk_container_get_focus_chain, METH_NOARGS,
      NULL },
    { "unset_focus_chain", (PyCFunction)_wrap_gtk_container_unset_focus_chain, METH_NOARGS,
      NULL },
    { "set_reallocate_redraws", (PyCFunction)_wrap_gtk_container_set_reallocate_redraws, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_focus_child", (PyCFunction)_wrap_gtk_container_set_focus_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_focus_vadjustment", (PyCFunction)_wrap_gtk_container_set_focus_vadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_focus_vadjustment", (PyCFunction)_wrap_gtk_container_get_focus_vadjustment, METH_NOARGS,
      NULL },
    { "set_focus_hadjustment", (PyCFunction)_wrap_gtk_container_set_focus_hadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_focus_hadjustment", (PyCFunction)_wrap_gtk_container_get_focus_hadjustment, METH_NOARGS,
      NULL },
    { "resize_children", (PyCFunction)_wrap_gtk_container_resize_children, METH_NOARGS,
      NULL },
    { "child_type", (PyCFunction)_wrap_gtk_container_child_type, METH_NOARGS,
      NULL },
    { "add_with_properties", (PyCFunction)_wrap_gtk_container_add_with_properties, METH_VARARGS,
      NULL },
    { "child_set", (PyCFunction)_wrap_gtk_container_child_set, METH_VARARGS,
      NULL },
    { "child_get", (PyCFunction)_wrap_gtk_container_child_get, METH_VARARGS,
      NULL },
    { "child_set_property", (PyCFunction)_wrap_gtk_container_child_set_property, METH_VARARGS,
      NULL },
    { "child_get_property", (PyCFunction)_wrap_gtk_container_child_get_property, METH_VARARGS,
      NULL },
    { "forall", (PyCFunction)_wrap_gtk_container_forall, METH_VARARGS,
      NULL },
    { "get_focus_child", (PyCFunction)_wrap_gtk_container_get_focus_child, METH_NOARGS,
      NULL },
    { "install_child_property", (PyCFunction)_wrap_gtk_container_install_child_property, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "list_child_properties", (PyCFunction)_wrap_gtk_container_list_child_properties, METH_NOARGS|METH_CLASS,
      NULL },
    { "do_add", (PyCFunction)_wrap_GtkContainer__do_add, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_remove", (PyCFunction)_wrap_GtkContainer__do_remove, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_check_resize", (PyCFunction)_wrap_GtkContainer__do_check_resize, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_forall", (PyCFunction)_wrap_GtkContainer__do_forall, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_focus_child", (PyCFunction)_wrap_GtkContainer__do_set_focus_child, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_child_type", (PyCFunction)_wrap_GtkContainer__do_child_type, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_composite_name", (PyCFunction)_wrap_GtkContainer__do_composite_name, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_child_property", (PyCFunction)_wrap_GtkContainer__do_set_child_property, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_child_property", (PyCFunction)_wrap_GtkContainer__do_get_child_property, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_container__get_focus_child(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_CONTAINER(pygobject_get(self))->focus_child;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_container__get_border_width(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_CONTAINER(pygobject_get(self))->border_width;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_container__get_need_resize(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_CONTAINER(pygobject_get(self))->need_resize;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_container__get_resize_mode(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_CONTAINER(pygobject_get(self))->resize_mode;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_container__get_reallocate_redraws(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_CONTAINER(pygobject_get(self))->reallocate_redraws;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_container__get_has_focus_chain(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_CONTAINER(pygobject_get(self))->has_focus_chain;
    return PyLong_FromUnsignedLong(ret);
}

static const PyGetSetDef gtk_container_getsets[] = {
    { "focus_child", (getter)_wrap_gtk_container__get_focus_child, (setter)0 },
    { "border_width", (getter)_wrap_gtk_container__get_border_width, (setter)0 },
    { "need_resize", (getter)_wrap_gtk_container__get_need_resize, (setter)0 },
    { "resize_mode", (getter)_wrap_gtk_container__get_resize_mode, (setter)0 },
    { "reallocate_redraws", (getter)_wrap_gtk_container__get_reallocate_redraws, (setter)0 },
    { "has_focus_chain", (getter)_wrap_gtk_container__get_has_focus_chain, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

#line 847 "gtkcontainer.override"
static int
_wrap_gtk_container_nb_nonzero(PyGObject *self)
{
    return 1;
}

static PyNumberMethods _wrap_gtk_container_tp_as_number = {
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (ternaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (inquiry)_wrap_gtk_container_nb_nonzero
};

#line 19003 "gtk.c"


#line 830 "gtkcontainer.override"
static Py_ssize_t
_wrap_gtk_container_sq_length(PyGObject *self)
{
    return g_list_length(gtk_container_get_children(GTK_CONTAINER(self->obj)));
}

static PySequenceMethods _wrap_gtk_container_tp_as_sequence = {
    (lenfunc)_wrap_gtk_container_sq_length,
    0,
    0,
    0,
    0,
    0,
    0,
};
#line 19022 "gtk.c"


#line 761 "gtkcontainer.override"

typedef struct {
    PyObject_HEAD
    GList *list;
} PyGContainerIter;

static void
pyg_container_iter_dealloc(PyGContainerIter *self)
{
    g_list_free(self->list);
    PyObject_Del((PyObject*) self);
}

static PyObject*
pygobject_container_iter_next(PyGContainerIter *iter)
{
    PyObject *child;
    
    if (!iter->list) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
	
    child = pygobject_new((GObject*)iter->list->data);
    iter->list = g_list_next(iter->list);
    return child;
}

static PyTypeObject PyGContainerIter_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/* ob_size */
	"gobject.GContainerIter",		/* tp_name */
	sizeof(PyGContainerIter),		/* tp_basicsize */
	0,					/* tp_itemsize */
	(destructor)pyg_container_iter_dealloc,	/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,		       			/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,			/* tp_flags */
 	"GtkContainer child iterator",		/* tp_doc */
	0,					/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	(iternextfunc)pygobject_container_iter_next, /* tp_iternext */
};

static PyObject*
_wrap_gtk_container_tp_iter(PyGObject *self)
{
    PyGContainerIter *iter;
    iter = PyObject_NEW(PyGContainerIter, &PyGContainerIter_Type);
    iter->list = gtk_container_get_children(GTK_CONTAINER(self->obj));
    return (PyObject *) iter;
}
#line 19093 "gtk.c"


PyTypeObject G_GNUC_INTERNAL PyGtkContainer_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Container",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)&_wrap_gtk_container_tp_as_number,     /* tp_as_number */
    (PySequenceMethods*)&_wrap_gtk_container_tp_as_sequence, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)_wrap_gtk_container_tp_iter,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkContainer_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_container_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkContainer__proxy_do_add(GtkContainer *self, GtkWidget*widget)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_widget = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_widget);
    
    py_method = PyObject_GetAttrString(py_self, "do_add");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkContainer__proxy_do_remove(GtkContainer *self, GtkWidget*widget)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_widget = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_widget);
    
    py_method = PyObject_GetAttrString(py_self, "do_remove");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkContainer__proxy_do_check_resize(GtkContainer *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_check_resize");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
#line 869 "gtkcontainer.override"

typedef struct {
    GtkCallback    func;
    gpointer       func_data;
} PyGtkContainerDataFuncData;


static PyObject *
_wrap_GtkContainerDataFunc(PyObject *self, PyObject *args)
{
    PyObject *py_widget;
    PyObject *py_data;
    PyGtkContainerDataFuncData *data;

    if (!PyArg_ParseTuple(args, "O!O!",
			  &PyGtkWidget_Type, &py_widget,
                          &PyCObject_Type, &py_data))
        return NULL;
    
    data = PyCObject_AsVoidPtr(py_data);
    data->func(GTK_WIDGET(pygobject_get(py_widget)), data->func_data);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static void
_wrap_GtkContainer__proxy_do_forall (GtkContainer *container,
				     gboolean      include_internals,
				     GtkCallback   callback,
				     gpointer      callback_data)
{
    PyGILState_STATE state;
    PyObject *self, *py_func, *py_func_data;
    PyMethodDef pyfunc_def = { "GtkContainer.do_forall callback",
			       (PyCFunction)_wrap_GtkContainerDataFunc,
                               METH_VARARGS|METH_KEYWORDS };
    PyGtkContainerDataFuncData *data;

    state = pyg_gil_state_ensure();
    
    self = pygobject_new((GObject *)container);
    py_func = PyCFunction_NewEx(&pyfunc_def, NULL, NULL);
    
    data = g_new(PyGtkContainerDataFuncData, 1);
    data->func = callback;
    data->func_data = callback_data;
    PyObject_Repr(self);
    PyObject_Repr(py_func);
    py_func_data = PyCObject_FromVoidPtr(data, g_free);
    if (!PyObject_CallMethod(self, "do_forall", "ONN", 
			     include_internals ? Py_True : Py_False, py_func,
			     py_func_data))
	PyErr_Print();
    
    pyg_gil_state_release(state);
}
#line 19383 "gtk.c"


static void
_wrap_GtkContainer__proxy_do_set_focus_child(GtkContainer *self, GtkWidget*widget)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_widget = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_widget);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_focus_child");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gchar*
_wrap_GtkContainer__proxy_do_composite_name(GtkContainer *self, GtkWidget*child)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_child = NULL;
    gchar* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (child)
        py_child = pygobject_new((GObject *) child);
    else {
        Py_INCREF(Py_None);
        py_child = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_child);
    
    py_method = PyObject_GetAttrString(py_self, "do_composite_name");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "s", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    retval = g_strdup(retval);
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
#line 928 "gtkcontainer.override"
static void
_wrap_GtkContainer__proxy_do_set_child_property (GtkContainer *container,
                                                 GtkWidget *child,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
    PyGILState_STATE state;
    PyObject *self, *py_ret;

    state = pyg_gil_state_ensure();
    self = pygobject_new((GObject *) container);

    py_ret = PyObject_CallMethod(self, "do_set_child_property", "NNNN",
                                 pygobject_new((GObject *) child),
                                 PyLong_FromUnsignedLong(property_id),
                                 pyg_value_as_pyobject(value, FALSE),
                                 pyg_param_spec_new(pspec));
    if (!py_ret) {
	PyErr_Print();
	Py_DECREF(self);
	pyg_gil_state_release(state);
	return;
    }
    Py_DECREF(self);
    if (py_ret != Py_None)
        PyErr_Warn(PyExc_Warning, "do_set_child_property must return None");
    Py_DECREF(py_ret);

    pyg_gil_state_release(state);
}

#line 19556 "gtk.c"


#line 962 "gtkcontainer.override"
static void
_wrap_GtkContainer__proxy_do_get_child_property (GtkContainer *container,
                                                 GtkWidget *child,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
    PyGILState_STATE state;
    PyObject *self, *py_ret;

    state = pyg_gil_state_ensure();

    self = pygobject_new((GObject*)container);
    py_ret = PyObject_CallMethod(self, "do_get_child_property", "NNN",
                                 pygobject_new((GObject *) child),
                                 PyLong_FromUnsignedLong(property_id),
                                 pyg_param_spec_new(pspec));
    if (!py_ret) {
	PyErr_Print();
	Py_DECREF(self);
	pyg_gil_state_release(state);
	return;
    }
    Py_DECREF(self);
    pyg_value_from_pyobject(value, py_ret);
    Py_DECREF(py_ret);

    pyg_gil_state_release(state);
}

#line 19590 "gtk.c"



static int
__GtkContainer_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkContainerClass *klass = GTK_CONTAINER_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_add");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "add")))
            klass->add = _wrap_GtkContainer__proxy_do_add;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_remove");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "remove")))
            klass->remove = _wrap_GtkContainer__proxy_do_remove;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_check_resize");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "check_resize")))
            klass->check_resize = _wrap_GtkContainer__proxy_do_check_resize;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_forall");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "forall")))
            klass->forall = _wrap_GtkContainer__proxy_do_forall;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_focus_child");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_focus_child")))
            klass->set_focus_child = _wrap_GtkContainer__proxy_do_set_focus_child;
        Py_DECREF(o);
    }

    /* overriding do_child_type is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_composite_name");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "composite_name")))
            klass->composite_name = _wrap_GtkContainer__proxy_do_composite_name;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_child_property");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_child_property")))
            klass->set_child_property = _wrap_GtkContainer__proxy_do_set_child_property;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_get_child_property");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "get_child_property")))
            klass->get_child_property = _wrap_GtkContainer__proxy_do_get_child_property;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkBin ----------- */

static PyObject *
_wrap_gtk_bin_get_child(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_bin_get_child(GTK_BIN(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkBin_methods[] = {
    { "get_child", (PyCFunction)_wrap_gtk_bin_get_child, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 8681 "./gtk.override"
static int
_wrap_gtk_bin__set_child(PyGObject *self, PyGObject *value, void *closure)
{
    if (!pygobject_check(value, &PyGtkWidget_Type) &&
	(PyObject*)value != Py_None) {
	PyErr_SetString(PyExc_TypeError, "must be a GtkWidget object");
	return -1;
    }

    if ((PyObject*)value == Py_None)
	GTK_BIN(self->obj)->child = NULL;
    else
	GTK_BIN(self->obj)->child = g_object_ref(GTK_WIDGET(value->obj));

    return 0;
}
#line 19723 "gtk.c"


static PyObject *
_wrap_gtk_bin__get_child(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_BIN(pygobject_get(self))->child;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyGetSetDef gtk_bin_getsets[] = {
    { "child", (getter)_wrap_gtk_bin__get_child, (setter)_wrap_gtk_bin__set_child },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkBin_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Bin",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkBin_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_bin_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkWindow ----------- */

static int
_wrap_gtk_window_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"type", NULL };
    char *prop_names[] = {"type", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.Window.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Window object");
        return -1;
    }
    return 0;
}

#line 5411 "./gtk.override"
static PyObject *
_wrap_gtk_tooltips_get_info_from_tip_window(PyGObject *self)
{
    gboolean ret;
    GtkWidget *widget;
    GtkTooltips *tooltips;

    ret = gtk_tooltips_get_info_from_tip_window(GTK_WINDOW(self->obj),
						&tooltips, &widget);
    if (ret)
	return Py_BuildValue("(NN)",
			     pygobject_new((GObject *)tooltips),
			     pygobject_new((GObject *)widget));
    Py_INCREF(Py_None);
    return Py_None;
}
#line 19837 "gtk.c"


static PyObject *
_wrap_gtk_window_set_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "title", NULL };
    char *title;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Window.set_title", kwlist, &title))
        return NULL;
    
    gtk_window_set_title(GTK_WINDOW(self->obj), title);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_title(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_window_get_title(GTK_WINDOW(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_wmclass(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "wmclass_name", "wmclass_class", NULL };
    char *wmclass_name, *wmclass_class;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ss:Gtk.Window.set_wmclass", kwlist, &wmclass_name, &wmclass_class))
        return NULL;
    
    gtk_window_set_wmclass(GTK_WINDOW(self->obj), wmclass_name, wmclass_class);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_role(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "role", NULL };
    char *role;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Window.set_role", kwlist, &role))
        return NULL;
    
    gtk_window_set_role(GTK_WINDOW(self->obj), role);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_role(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_window_get_role(GTK_WINDOW(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_add_accel_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_group", NULL };
    PyGObject *accel_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Window.add_accel_group", kwlist, &PyGtkAccelGroup_Type, &accel_group))
        return NULL;
    
    gtk_window_add_accel_group(GTK_WINDOW(self->obj), GTK_ACCEL_GROUP(accel_group->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_remove_accel_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_group", NULL };
    PyGObject *accel_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Window.remove_accel_group", kwlist, &PyGtkAccelGroup_Type, &accel_group))
        return NULL;
    
    gtk_window_remove_accel_group(GTK_WINDOW(self->obj), GTK_ACCEL_GROUP(accel_group->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    PyObject *py_position = NULL;
    GtkWindowPosition position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Window.set_position", kwlist, &py_position))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_WINDOW_POSITION, py_position, (gpointer)&position))
        return NULL;
    
    gtk_window_set_position(GTK_WINDOW(self->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_activate_focus(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_activate_focus(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_focus(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "focus", NULL };
    PyGObject *py_focus;
    GtkWidget *focus = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Window.set_focus", kwlist, &py_focus))
        return NULL;
    if (py_focus && pygobject_check(py_focus, &PyGtkWidget_Type))
        focus = GTK_WIDGET(py_focus->obj);
    else if ((PyObject *)py_focus != Py_None) {
        PyErr_SetString(PyExc_TypeError, "focus should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_window_set_focus(GTK_WINDOW(self->obj), (GtkWidget *) focus);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_focus(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_window_get_focus(GTK_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window_set_default(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "default_widget", NULL };
    PyGObject *py_default_widget;
    GtkWidget *default_widget = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Window.set_default", kwlist, &py_default_widget))
        return NULL;
    if (py_default_widget && pygobject_check(py_default_widget, &PyGtkWidget_Type))
        default_widget = GTK_WIDGET(py_default_widget->obj);
    else if ((PyObject *)py_default_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "default_widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_window_set_default(GTK_WINDOW(self->obj), (GtkWidget *) default_widget);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_activate_default(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_activate_default(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_transient_for(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyGObject *py_parent;
    GtkWindow *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Window.set_transient_for", kwlist, &py_parent))
        return NULL;
    if (py_parent && pygobject_check(py_parent, &PyGtkWindow_Type))
        parent = GTK_WINDOW(py_parent->obj);
    else if ((PyObject *)py_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkWindow or None");
        return NULL;
    }
    
    gtk_window_set_transient_for(GTK_WINDOW(self->obj), (GtkWindow *) parent);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_transient_for(PyGObject *self)
{
    GtkWindow *ret;

    
    ret = gtk_window_get_transient_for(GTK_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window_set_type_hint(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "hint", NULL };
    PyObject *py_hint = NULL;
    GdkWindowTypeHint hint;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Window.set_type_hint", kwlist, &py_hint))
        return NULL;
    if (pyg_enum_get_value(GDK_TYPE_WINDOW_TYPE_HINT, py_hint, (gpointer)&hint))
        return NULL;
    
    gtk_window_set_type_hint(GTK_WINDOW(self->obj), hint);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_type_hint(PyGObject *self)
{
    gint ret;

    
    ret = gtk_window_get_type_hint(GTK_WINDOW(self->obj));
    
    return pyg_enum_from_gtype(GDK_TYPE_WINDOW_TYPE_HINT, ret);
}

static PyObject *
_wrap_gtk_window_set_skip_taskbar_hint(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_skip_taskbar_hint", kwlist, &setting))
        return NULL;
    
    gtk_window_set_skip_taskbar_hint(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_skip_taskbar_hint(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_skip_taskbar_hint(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_skip_pager_hint(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_skip_pager_hint", kwlist, &setting))
        return NULL;
    
    gtk_window_set_skip_pager_hint(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_skip_pager_hint(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_skip_pager_hint(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_urgency_hint(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_urgency_hint", kwlist, &setting))
        return NULL;
    
    gtk_window_set_urgency_hint(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_urgency_hint(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_urgency_hint(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_accept_focus(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_accept_focus", kwlist, &setting))
        return NULL;
    
    gtk_window_set_accept_focus(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_accept_focus(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_accept_focus(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_destroy_with_parent(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_destroy_with_parent", kwlist, &setting))
        return NULL;
    
    gtk_window_set_destroy_with_parent(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_destroy_with_parent(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_destroy_with_parent(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_resizable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "resizable", NULL };
    int resizable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_resizable", kwlist, &resizable))
        return NULL;
    
    gtk_window_set_resizable(GTK_WINDOW(self->obj), resizable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_resizable(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_resizable(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_gravity(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gravity", NULL };
    GdkGravity gravity;
    PyObject *py_gravity = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Window.set_gravity", kwlist, &py_gravity))
        return NULL;
    if (pyg_enum_get_value(GDK_TYPE_GRAVITY, py_gravity, (gpointer)&gravity))
        return NULL;
    
    gtk_window_set_gravity(GTK_WINDOW(self->obj), gravity);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_gravity(PyGObject *self)
{
    gint ret;

    
    ret = gtk_window_get_gravity(GTK_WINDOW(self->obj));
    
    return pyg_enum_from_gtype(GDK_TYPE_GRAVITY, ret);
}

#line 65 "gtkwindow.override"
static PyObject *
_wrap_gtk_window_set_geometry_hints(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "geometry_widget", "min_width", "min_height",
                              "max_width", "max_height", "base_width",
                              "base_height", "width_inc", "height_inc",
                              "min_aspect", "max_aspect", NULL };
    PyObject *py_geometry_widget = Py_None;
    GtkWidget *geometry_widget = NULL;
    gint min_width = -1, min_height = -1, max_width = -1, max_height = -1;
    gint base_width = -1, base_height = -1, width_inc = -1, height_inc = -1;
    gdouble min_aspect = -1.0, max_aspect = -1.0;
    GdkGeometry geometry = { 0 };
    GdkWindowHints geom_mask = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                        "|Oiiiiiiiidd:GtkWindow.set_geometry_hints", kwlist,
                                     &py_geometry_widget, &min_width,
                                     &min_height, &max_width, &max_height,
                                     &base_width, &base_height, &width_inc,
                                     &height_inc, &min_aspect, &max_aspect))
        return NULL;
    if (pygobject_check(py_geometry_widget, &PyGtkWidget_Type))
        geometry_widget = GTK_WIDGET(pygobject_get(py_geometry_widget));
    else if (py_geometry_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "geometry_widget must be a GtkWidget or None");
        return NULL;
    }
    if (min_width >= 0 || min_height >= 0) {
        geometry.min_width = MAX(min_width, 0);
        geometry.min_height = MAX(min_height, 0);
        geom_mask |= GDK_HINT_MIN_SIZE;
    }
    if (max_width >= 0 || max_height >= 0) {
        geometry.max_width = MAX(max_width, 0);
        geometry.max_height = MAX(max_height, 0);
        geom_mask |= GDK_HINT_MAX_SIZE;
    }
    if (base_width >= 0 || base_height >= 0) {
        geometry.base_width = MAX(base_width, 0);
        geometry.base_height = MAX(base_height, 0);
        geom_mask |= GDK_HINT_BASE_SIZE;
    }
    if (width_inc >= 0 || height_inc >= 0) {
        geometry.width_inc = MAX(width_inc, 0);
        geometry.height_inc = MAX(height_inc, 0);
        geom_mask |= GDK_HINT_RESIZE_INC;
    }
    if (min_aspect >= 0.0 || max_aspect >= 0.0) {
        if (min_aspect <= 0.0 || max_aspect <= 0.0) {
            PyErr_SetString(PyExc_TypeError, "aspect ratios must be positive");
            return NULL;
        }
        geometry.min_aspect = min_aspect;
        geometry.max_aspect = max_aspect;
        geom_mask |= GDK_HINT_ASPECT;
    }
    gtk_window_set_geometry_hints(GTK_WINDOW(self->obj), geometry_widget,
                                  &geometry, geom_mask);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 20360 "gtk.c"


static PyObject *
_wrap_gtk_window_set_screen(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *screen;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Window.set_screen", kwlist, &PyGdkScreen_Type, &screen))
        return NULL;
    
    gtk_window_set_screen(GTK_WINDOW(self->obj), GDK_SCREEN(screen->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_screen(PyGObject *self)
{
    GdkScreen *ret;

    
    ret = gtk_window_get_screen(GTK_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window_is_active(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_is_active(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_has_toplevel_focus(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_has_toplevel_focus(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_has_frame(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_has_frame", kwlist, &setting))
        return NULL;
    
    gtk_window_set_has_frame(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_has_frame(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_has_frame(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_frame_dimensions(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "left", "top", "right", "bottom", NULL };
    int left, top, right, bottom;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iiii:Gtk.Window.set_frame_dimensions", kwlist, &left, &top, &right, &bottom))
        return NULL;
    
    gtk_window_set_frame_dimensions(GTK_WINDOW(self->obj), left, top, right, bottom);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 161 "gtkwindow.override"
static PyObject *
_wrap_gtk_window_get_frame_dimensions(PyGObject *self)
{
    int left, top, right, bottom;

    gtk_window_get_frame_dimensions(GTK_WINDOW(self->obj),
				    &left, &top, &right, &bottom);
    return Py_BuildValue("(iiii)", left, top, right, bottom);
}
#line 20466 "gtk.c"


static PyObject *
_wrap_gtk_window_set_decorated(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_decorated", kwlist, &setting))
        return NULL;
    
    gtk_window_set_decorated(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_decorated(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_decorated(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 182 "gtkwindow.override"
static PyObject *
_wrap_gtk_window_set_icon_list(PyGObject *self, PyObject *args)
{
    GList *icon_list = NULL;
    PyObject *pyicon;
    gint len, i;

    len = PyTuple_Size(args);
    for (i = 0; i < len; i++) {
	pyicon = PyTuple_GetItem(args, i);
	if (!pygobject_check(pyicon, &PyGdkPixbuf_Type)) {
            PyErr_SetString(PyExc_TypeError,
                            "icons must be GdkPixbufs");
	    g_list_free(icon_list);
            return NULL;
        }
	icon_list = g_list_prepend(icon_list, pygobject_get(pyicon));
    }
    gtk_window_set_icon_list(GTK_WINDOW(self->obj), icon_list);
    g_list_free(icon_list);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 20520 "gtk.c"


#line 207 "gtkwindow.override"
static PyObject *
_wrap_gtk_window_get_icon_list(PyGObject *self)
{
    GList *icon_list = NULL;
    PyObject *pyicon;

    if ((icon_list = gtk_window_get_icon_list(GTK_WINDOW(self->obj)))) {
        PyObject *py_list;
        GList *tmp;

        if ((py_list = PyList_New(0)) == NULL) {
            g_list_free(icon_list);
            return NULL;
        }
        for (tmp = icon_list; tmp != NULL; tmp = tmp->next) {
            pyicon = pygobject_new(G_OBJECT(tmp->data));

            if (pyicon == NULL) {
                g_list_free(icon_list);
                Py_DECREF(py_list);
                return NULL;
            }
            PyList_Append(py_list, pyicon);
            Py_DECREF(pyicon);
        }
        g_list_free(icon_list);
        return py_list;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 20555 "gtk.c"


static PyObject *
_wrap_gtk_window_set_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon", NULL };
    PyGObject *py_icon;
    GdkPixbuf *icon = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Window.set_icon", kwlist, &py_icon))
        return NULL;
    if (py_icon && pygobject_check(py_icon, &PyGdkPixbuf_Type))
        icon = GDK_PIXBUF(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError, "icon should be a GdkPixbuf or None");
        return NULL;
    }
    
    gtk_window_set_icon(GTK_WINDOW(self->obj), (GdkPixbuf *) icon);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_icon_from_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Window.set_icon_from_file", kwlist, &filename))
        return NULL;
    
    gtk_window_set_icon_from_file(GTK_WINDOW(self->obj), filename, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_icon(PyGObject *self)
{
    GdkPixbuf *ret;

    
    ret = gtk_window_get_icon(GTK_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window_set_modal(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "modal", NULL };
    int modal;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_modal", kwlist, &modal))
        return NULL;
    
    gtk_window_set_modal(GTK_WINDOW(self->obj), modal);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_modal(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_modal(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_add_mnemonic(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "keyval", "target", NULL };
    PyObject *py_keyval = NULL;
    PyGObject *target;
    guint keyval = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO!:Gtk.Window.add_mnemonic", kwlist, &py_keyval, &PyGtkWidget_Type, &target))
        return NULL;
    if (py_keyval) {
        if (PyLong_Check(py_keyval))
            keyval = PyLong_AsUnsignedLong(py_keyval);
        else if (PyInt_Check(py_keyval))
            keyval = PyInt_AsLong(py_keyval);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'keyval' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_window_add_mnemonic(GTK_WINDOW(self->obj), keyval, GTK_WIDGET(target->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_remove_mnemonic(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "keyval", "target", NULL };
    PyObject *py_keyval = NULL;
    PyGObject *target;
    guint keyval = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO!:Gtk.Window.remove_mnemonic", kwlist, &py_keyval, &PyGtkWidget_Type, &target))
        return NULL;
    if (py_keyval) {
        if (PyLong_Check(py_keyval))
            keyval = PyLong_AsUnsignedLong(py_keyval);
        else if (PyInt_Check(py_keyval))
            keyval = PyInt_AsLong(py_keyval);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'keyval' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_window_remove_mnemonic(GTK_WINDOW(self->obj), keyval, GTK_WIDGET(target->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_mnemonic_activate(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "keyval", "modifier", NULL };
    PyObject *py_keyval = NULL, *py_modifier = NULL;
    int ret;
    GdkModifierType modifier;
    guint keyval = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Window.mnemonic_activate", kwlist, &py_keyval, &py_modifier))
        return NULL;
    if (py_keyval) {
        if (PyLong_Check(py_keyval))
            keyval = PyLong_AsUnsignedLong(py_keyval);
        else if (PyInt_Check(py_keyval))
            keyval = PyInt_AsLong(py_keyval);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'keyval' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_modifier, (gpointer)&modifier))
        return NULL;
    
    ret = gtk_window_mnemonic_activate(GTK_WINDOW(self->obj), keyval, modifier);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_mnemonic_modifier(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "modifier", NULL };
    PyObject *py_modifier = NULL;
    GdkModifierType modifier;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Window.set_mnemonic_modifier", kwlist, &py_modifier))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_modifier, (gpointer)&modifier))
        return NULL;
    
    gtk_window_set_mnemonic_modifier(GTK_WINDOW(self->obj), modifier);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_mnemonic_modifier(PyGObject *self)
{
    guint ret;

    
    ret = gtk_window_get_mnemonic_modifier(GTK_WINDOW(self->obj));
    
    return pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, ret);
}

static PyObject *
_wrap_gtk_window_activate_key(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", NULL };
    GdkEvent *event = NULL;
    PyObject *py_event;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Window.activate_key", kwlist, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    ret = gtk_window_activate_key(GTK_WINDOW(self->obj), (GdkEventKey *)event);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_propagate_key_event(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", NULL };
    GdkEvent *event = NULL;
    PyObject *py_event;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Window.propagate_key_event", kwlist, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    ret = gtk_window_propagate_key_event(GTK_WINDOW(self->obj), (GdkEventKey *)event);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_present(PyGObject *self)
{
    
    gtk_window_present(GTK_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_present_with_time(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "timestamp", NULL };
    unsigned long timestamp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"k:Gtk.Window.present_with_time", kwlist, &timestamp))
        return NULL;
    
    gtk_window_present_with_time(GTK_WINDOW(self->obj), timestamp);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_iconify(PyGObject *self)
{
    
    gtk_window_iconify(GTK_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_deiconify(PyGObject *self)
{
    
    gtk_window_deiconify(GTK_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_stick(PyGObject *self)
{
    
    gtk_window_stick(GTK_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_unstick(PyGObject *self)
{
    
    gtk_window_unstick(GTK_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_maximize(PyGObject *self)
{
    
    gtk_window_maximize(GTK_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_unmaximize(PyGObject *self)
{
    
    gtk_window_unmaximize(GTK_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_fullscreen(PyGObject *self)
{
    
    gtk_window_fullscreen(GTK_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_unfullscreen(PyGObject *self)
{
    
    gtk_window_unfullscreen(GTK_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_keep_above(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_keep_above", kwlist, &setting))
        return NULL;
    
    gtk_window_set_keep_above(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_keep_below(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_keep_below", kwlist, &setting))
        return NULL;
    
    gtk_window_set_keep_below(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_begin_resize_drag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "edge", "button", "root_x", "root_y", "timestamp", NULL };
    PyObject *py_edge = NULL;
    int button, root_x, root_y;
    unsigned long timestamp;
    GdkWindowEdge edge;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oiiik:Gtk.Window.begin_resize_drag", kwlist, &py_edge, &button, &root_x, &root_y, &timestamp))
        return NULL;
    if (pyg_enum_get_value(GDK_TYPE_WINDOW_EDGE, py_edge, (gpointer)&edge))
        return NULL;
    
    gtk_window_begin_resize_drag(GTK_WINDOW(self->obj), edge, button, root_x, root_y, timestamp);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_begin_move_drag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "button", "root_x", "root_y", "timestamp", NULL };
    int button, root_x, root_y;
    unsigned long timestamp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iiik:Gtk.Window.begin_move_drag", kwlist, &button, &root_x, &root_y, &timestamp))
        return NULL;
    
    gtk_window_begin_move_drag(GTK_WINDOW(self->obj), button, root_x, root_y, timestamp);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_policy(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "allow_shrink", "allow_grow", "auto_shrink", NULL };
    int allow_shrink, allow_grow, auto_shrink;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iii:Gtk.Window.set_policy", kwlist, &allow_shrink, &allow_grow, &auto_shrink))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkWindow.set_resizable") < 0)
        return NULL;
    
    gtk_window_set_policy(GTK_WINDOW(self->obj), allow_shrink, allow_grow, auto_shrink);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_default_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", "height", NULL };
    int width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Window.set_default_size", kwlist, &width, &height))
        return NULL;
    
    gtk_window_set_default_size(GTK_WINDOW(self->obj), width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 151 "gtkwindow.override"
static PyObject *
_wrap_gtk_window_get_default_size(PyGObject *self)
{
    gint width, height;

    gtk_window_get_default_size(GTK_WINDOW(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
#line 21008 "gtk.c"


static PyObject *
_wrap_gtk_window_resize(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", "height", NULL };
    int width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Window.resize", kwlist, &width, &height))
        return NULL;
    
    gtk_window_resize(GTK_WINDOW(self->obj), width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 141 "gtkwindow.override"
static PyObject *
_wrap_gtk_window_get_size(PyGObject *self)
{
    gint width, height;

    gtk_window_get_size(GTK_WINDOW(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
#line 21035 "gtk.c"


static PyObject *
_wrap_gtk_window_move(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    int x, y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Window.move", kwlist, &x, &y))
        return NULL;
    
    gtk_window_move(GTK_WINDOW(self->obj), x, y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 131 "gtkwindow.override"
static PyObject *
_wrap_gtk_window_get_position(PyGObject *self)
{
    gint root_x, root_y;

    gtk_window_get_position(GTK_WINDOW(self->obj), &root_x, &root_y);
    return Py_BuildValue("(ii)", root_x, root_y);
}
#line 21062 "gtk.c"


static PyObject *
_wrap_gtk_window_parse_geometry(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "geometry", NULL };
    char *geometry;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Window.parse_geometry", kwlist, &geometry))
        return NULL;
    
    ret = gtk_window_parse_geometry(GTK_WINDOW(self->obj), geometry);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_reshow_with_initial_size(PyGObject *self)
{
    
    gtk_window_reshow_with_initial_size(GTK_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_focus_on_map(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_focus_on_map", kwlist, &setting))
        return NULL;
    
    gtk_window_set_focus_on_map(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_focus_on_map(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_focus_on_map(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_set_icon_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.Window.set_icon_name", kwlist, &name))
        return NULL;
    
    gtk_window_set_icon_name(GTK_WINDOW(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_icon_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_window_get_icon_name(GTK_WINDOW(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_deletable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_deletable", kwlist, &setting))
        return NULL;
    
    gtk_window_set_deletable(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_deletable(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_deletable(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_get_group(PyGObject *self)
{
    GtkWindowGroup *ret;

    
    ret = gtk_window_get_group(GTK_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window_set_opacity(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "opacity", NULL };
    double opacity;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Window.set_opacity", kwlist, &opacity))
        return NULL;
    
    gtk_window_set_opacity(GTK_WINDOW(self->obj), opacity);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_opacity(PyGObject *self)
{
    double ret;

    
    ret = gtk_window_get_opacity(GTK_WINDOW(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_window_set_startup_id(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "startup_id", NULL };
    char *startup_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Window.set_startup_id", kwlist, &startup_id))
        return NULL;
    
    gtk_window_set_startup_id(GTK_WINDOW(self->obj), startup_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_default_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_window_get_default_widget(GTK_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window_set_mnemonics_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Window.set_mnemonics_visible", kwlist, &setting))
        return NULL;
    
    gtk_window_set_mnemonics_visible(GTK_WINDOW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_get_mnemonics_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_get_mnemonics_visible(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_window_get_window_type(PyGObject *self)
{
    gint ret;

    
    ret = gtk_window_get_window_type(GTK_WINDOW(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_WINDOW_TYPE, ret);
}

static PyObject *
_wrap_gtk_window_has_group(PyGObject *self)
{
    int ret;

    
    ret = gtk_window_has_group(GTK_WINDOW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWindow__do_set_focus(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "focus", NULL };
    PyGObject *self, *py_focus;
    GtkWidget *focus = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Window.set_focus", kwlist, &PyGtkWindow_Type, &self, &py_focus))
        return NULL;
    if (py_focus && pygobject_check(py_focus, &PyGtkWidget_Type))
        focus = GTK_WIDGET(py_focus->obj);
    else if ((PyObject *)py_focus != Py_None) {
        PyErr_SetString(PyExc_TypeError, "focus should be a GtkWidget or None");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WINDOW_CLASS(klass)->set_focus)
        GTK_WINDOW_CLASS(klass)->set_focus(GTK_WINDOW(self->obj), (GtkWidget *) focus);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Window.set_focus not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWindow__do_frame_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Window.frame_event", kwlist, &PyGtkWindow_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WINDOW_CLASS(klass)->frame_event)
        ret = GTK_WINDOW_CLASS(klass)->frame_event(GTK_WINDOW(self->obj), event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Window.frame_event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkWindow__do_activate_focus(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Window.activate_focus", kwlist, &PyGtkWindow_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WINDOW_CLASS(klass)->activate_focus)
        GTK_WINDOW_CLASS(klass)->activate_focus(GTK_WINDOW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Window.activate_focus not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWindow__do_activate_default(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Window.activate_default", kwlist, &PyGtkWindow_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WINDOW_CLASS(klass)->activate_default)
        GTK_WINDOW_CLASS(klass)->activate_default(GTK_WINDOW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Window.activate_default not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWindow__do_move_focus(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "direction", NULL };
    PyGObject *self;
    PyObject *py_direction = NULL;
    GtkDirectionType direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Window.move_focus", kwlist, &PyGtkWindow_Type, &self, &py_direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, py_direction, (gpointer)&direction))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WINDOW_CLASS(klass)->move_focus)
        GTK_WINDOW_CLASS(klass)->move_focus(GTK_WINDOW(self->obj), direction);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Window.move_focus not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkWindow__do_keys_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Window.keys_changed", kwlist, &PyGtkWindow_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_WINDOW_CLASS(klass)->keys_changed)
        GTK_WINDOW_CLASS(klass)->keys_changed(GTK_WINDOW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Window.keys_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkWindow_methods[] = {
    { "tooltips_get_info_from_tip_window", (PyCFunction)_wrap_gtk_tooltips_get_info_from_tip_window, METH_NOARGS,
      NULL },
    { "set_title", (PyCFunction)_wrap_gtk_window_set_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_title", (PyCFunction)_wrap_gtk_window_get_title, METH_NOARGS,
      NULL },
    { "set_wmclass", (PyCFunction)_wrap_gtk_window_set_wmclass, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_role", (PyCFunction)_wrap_gtk_window_set_role, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_role", (PyCFunction)_wrap_gtk_window_get_role, METH_NOARGS,
      NULL },
    { "add_accel_group", (PyCFunction)_wrap_gtk_window_add_accel_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_accel_group", (PyCFunction)_wrap_gtk_window_remove_accel_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_position", (PyCFunction)_wrap_gtk_window_set_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "activate_focus", (PyCFunction)_wrap_gtk_window_activate_focus, METH_NOARGS,
      NULL },
    { "set_focus", (PyCFunction)_wrap_gtk_window_set_focus, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_focus", (PyCFunction)_wrap_gtk_window_get_focus, METH_NOARGS,
      NULL },
    { "set_default", (PyCFunction)_wrap_gtk_window_set_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "activate_default", (PyCFunction)_wrap_gtk_window_activate_default, METH_NOARGS,
      NULL },
    { "set_transient_for", (PyCFunction)_wrap_gtk_window_set_transient_for, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_transient_for", (PyCFunction)_wrap_gtk_window_get_transient_for, METH_NOARGS,
      NULL },
    { "set_type_hint", (PyCFunction)_wrap_gtk_window_set_type_hint, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_type_hint", (PyCFunction)_wrap_gtk_window_get_type_hint, METH_NOARGS,
      NULL },
    { "set_skip_taskbar_hint", (PyCFunction)_wrap_gtk_window_set_skip_taskbar_hint, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_skip_taskbar_hint", (PyCFunction)_wrap_gtk_window_get_skip_taskbar_hint, METH_NOARGS,
      NULL },
    { "set_skip_pager_hint", (PyCFunction)_wrap_gtk_window_set_skip_pager_hint, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_skip_pager_hint", (PyCFunction)_wrap_gtk_window_get_skip_pager_hint, METH_NOARGS,
      NULL },
    { "set_urgency_hint", (PyCFunction)_wrap_gtk_window_set_urgency_hint, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_urgency_hint", (PyCFunction)_wrap_gtk_window_get_urgency_hint, METH_NOARGS,
      NULL },
    { "set_accept_focus", (PyCFunction)_wrap_gtk_window_set_accept_focus, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_accept_focus", (PyCFunction)_wrap_gtk_window_get_accept_focus, METH_NOARGS,
      NULL },
    { "set_destroy_with_parent", (PyCFunction)_wrap_gtk_window_set_destroy_with_parent, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_destroy_with_parent", (PyCFunction)_wrap_gtk_window_get_destroy_with_parent, METH_NOARGS,
      NULL },
    { "set_resizable", (PyCFunction)_wrap_gtk_window_set_resizable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_resizable", (PyCFunction)_wrap_gtk_window_get_resizable, METH_NOARGS,
      NULL },
    { "set_gravity", (PyCFunction)_wrap_gtk_window_set_gravity, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_gravity", (PyCFunction)_wrap_gtk_window_get_gravity, METH_NOARGS,
      NULL },
    { "set_geometry_hints", (PyCFunction)_wrap_gtk_window_set_geometry_hints, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_screen", (PyCFunction)_wrap_gtk_window_set_screen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_screen", (PyCFunction)_wrap_gtk_window_get_screen, METH_NOARGS,
      NULL },
    { "is_active", (PyCFunction)_wrap_gtk_window_is_active, METH_NOARGS,
      NULL },
    { "has_toplevel_focus", (PyCFunction)_wrap_gtk_window_has_toplevel_focus, METH_NOARGS,
      NULL },
    { "set_has_frame", (PyCFunction)_wrap_gtk_window_set_has_frame, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_frame", (PyCFunction)_wrap_gtk_window_get_has_frame, METH_NOARGS,
      NULL },
    { "set_frame_dimensions", (PyCFunction)_wrap_gtk_window_set_frame_dimensions, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_frame_dimensions", (PyCFunction)_wrap_gtk_window_get_frame_dimensions, METH_NOARGS,
      NULL },
    { "set_decorated", (PyCFunction)_wrap_gtk_window_set_decorated, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_decorated", (PyCFunction)_wrap_gtk_window_get_decorated, METH_NOARGS,
      NULL },
    { "set_icon_list", (PyCFunction)_wrap_gtk_window_set_icon_list, METH_VARARGS,
      NULL },
    { "get_icon_list", (PyCFunction)_wrap_gtk_window_get_icon_list, METH_NOARGS,
      NULL },
    { "set_icon", (PyCFunction)_wrap_gtk_window_set_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_from_file", (PyCFunction)_wrap_gtk_window_set_icon_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon", (PyCFunction)_wrap_gtk_window_get_icon, METH_NOARGS,
      NULL },
    { "set_modal", (PyCFunction)_wrap_gtk_window_set_modal, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_modal", (PyCFunction)_wrap_gtk_window_get_modal, METH_NOARGS,
      NULL },
    { "add_mnemonic", (PyCFunction)_wrap_gtk_window_add_mnemonic, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_mnemonic", (PyCFunction)_wrap_gtk_window_remove_mnemonic, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "mnemonic_activate", (PyCFunction)_wrap_gtk_window_mnemonic_activate, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_mnemonic_modifier", (PyCFunction)_wrap_gtk_window_set_mnemonic_modifier, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_mnemonic_modifier", (PyCFunction)_wrap_gtk_window_get_mnemonic_modifier, METH_NOARGS,
      NULL },
    { "activate_key", (PyCFunction)_wrap_gtk_window_activate_key, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "propagate_key_event", (PyCFunction)_wrap_gtk_window_propagate_key_event, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "present", (PyCFunction)_wrap_gtk_window_present, METH_NOARGS,
      NULL },
    { "present_with_time", (PyCFunction)_wrap_gtk_window_present_with_time, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "iconify", (PyCFunction)_wrap_gtk_window_iconify, METH_NOARGS,
      NULL },
    { "deiconify", (PyCFunction)_wrap_gtk_window_deiconify, METH_NOARGS,
      NULL },
    { "stick", (PyCFunction)_wrap_gtk_window_stick, METH_NOARGS,
      NULL },
    { "unstick", (PyCFunction)_wrap_gtk_window_unstick, METH_NOARGS,
      NULL },
    { "maximize", (PyCFunction)_wrap_gtk_window_maximize, METH_NOARGS,
      NULL },
    { "unmaximize", (PyCFunction)_wrap_gtk_window_unmaximize, METH_NOARGS,
      NULL },
    { "fullscreen", (PyCFunction)_wrap_gtk_window_fullscreen, METH_NOARGS,
      NULL },
    { "unfullscreen", (PyCFunction)_wrap_gtk_window_unfullscreen, METH_NOARGS,
      NULL },
    { "set_keep_above", (PyCFunction)_wrap_gtk_window_set_keep_above, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_keep_below", (PyCFunction)_wrap_gtk_window_set_keep_below, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "begin_resize_drag", (PyCFunction)_wrap_gtk_window_begin_resize_drag, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "begin_move_drag", (PyCFunction)_wrap_gtk_window_begin_move_drag, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_policy", (PyCFunction)_wrap_gtk_window_set_policy, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_default_size", (PyCFunction)_wrap_gtk_window_set_default_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_default_size", (PyCFunction)_wrap_gtk_window_get_default_size, METH_VARARGS,
      NULL },
    { "resize", (PyCFunction)_wrap_gtk_window_resize, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_size", (PyCFunction)_wrap_gtk_window_get_size, METH_VARARGS,
      NULL },
    { "move", (PyCFunction)_wrap_gtk_window_move, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_position", (PyCFunction)_wrap_gtk_window_get_position, METH_VARARGS,
      NULL },
    { "parse_geometry", (PyCFunction)_wrap_gtk_window_parse_geometry, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reshow_with_initial_size", (PyCFunction)_wrap_gtk_window_reshow_with_initial_size, METH_NOARGS,
      NULL },
    { "set_focus_on_map", (PyCFunction)_wrap_gtk_window_set_focus_on_map, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_focus_on_map", (PyCFunction)_wrap_gtk_window_get_focus_on_map, METH_NOARGS,
      NULL },
    { "set_icon_name", (PyCFunction)_wrap_gtk_window_set_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_name", (PyCFunction)_wrap_gtk_window_get_icon_name, METH_NOARGS,
      NULL },
    { "set_deletable", (PyCFunction)_wrap_gtk_window_set_deletable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_deletable", (PyCFunction)_wrap_gtk_window_get_deletable, METH_NOARGS,
      NULL },
    { "get_group", (PyCFunction)_wrap_gtk_window_get_group, METH_NOARGS,
      NULL },
    { "set_opacity", (PyCFunction)_wrap_gtk_window_set_opacity, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_opacity", (PyCFunction)_wrap_gtk_window_get_opacity, METH_NOARGS,
      NULL },
    { "set_startup_id", (PyCFunction)_wrap_gtk_window_set_startup_id, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_default_widget", (PyCFunction)_wrap_gtk_window_get_default_widget, METH_NOARGS,
      NULL },
    { "set_mnemonics_visible", (PyCFunction)_wrap_gtk_window_set_mnemonics_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_mnemonics_visible", (PyCFunction)_wrap_gtk_window_get_mnemonics_visible, METH_NOARGS,
      NULL },
    { "get_window_type", (PyCFunction)_wrap_gtk_window_get_window_type, METH_NOARGS,
      NULL },
    { "has_group", (PyCFunction)_wrap_gtk_window_has_group, METH_NOARGS,
      NULL },
    { "do_set_focus", (PyCFunction)_wrap_GtkWindow__do_set_focus, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_frame_event", (PyCFunction)_wrap_GtkWindow__do_frame_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_activate_focus", (PyCFunction)_wrap_GtkWindow__do_activate_focus, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_activate_default", (PyCFunction)_wrap_GtkWindow__do_activate_default, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_focus", (PyCFunction)_wrap_GtkWindow__do_move_focus, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_keys_changed", (PyCFunction)_wrap_GtkWindow__do_keys_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_window__get_title(PyObject *self, void *closure)
{
    const gchar *ret;

    ret = GTK_WINDOW(pygobject_get(self))->title;
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window__get_wmclass_name(PyObject *self, void *closure)
{
    const gchar *ret;

    ret = GTK_WINDOW(pygobject_get(self))->wmclass_name;
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window__get_wmclass_class(PyObject *self, void *closure)
{
    const gchar *ret;

    ret = GTK_WINDOW(pygobject_get(self))->wmclass_class;
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window__get_wm_role(PyObject *self, void *closure)
{
    const gchar *ret;

    ret = GTK_WINDOW(pygobject_get(self))->wm_role;
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window__get_focus_widget(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_WINDOW(pygobject_get(self))->focus_widget;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window__get_default_widget(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_WINDOW(pygobject_get(self))->default_widget;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window__get_transient_parent(PyObject *self, void *closure)
{
    GtkWindow *ret;

    ret = GTK_WINDOW(pygobject_get(self))->transient_parent;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window__get_frame(PyObject *self, void *closure)
{
    GdkWindow *ret;

    ret = GTK_WINDOW(pygobject_get(self))->frame;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window__get_group(PyObject *self, void *closure)
{
    GtkWindowGroup *ret;

    ret = GTK_WINDOW(pygobject_get(self))->group;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window__get_configure_request_count(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_WINDOW(pygobject_get(self))->configure_request_count;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_window__get_allow_shrink(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->allow_shrink;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_allow_grow(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->allow_grow;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_configure_notify_received(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->configure_notify_received;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_need_default_position(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->need_default_position;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_need_default_size(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->need_default_size;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_position(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->position;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_type(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->type;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_has_user_ref_count(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->has_user_ref_count;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_has_focus(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->has_focus;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_modal(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->modal;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_destroy_with_parent(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->destroy_with_parent;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_has_frame(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->has_frame;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_iconify_initially(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->iconify_initially;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_stick_initially(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->stick_initially;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_maximize_initially(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->maximize_initially;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_decorated(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->decorated;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_type_hint(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->type_hint;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_gravity(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->gravity;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_frame_left(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->frame_left;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_frame_top(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->frame_top;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_frame_right(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->frame_right;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_frame_bottom(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->frame_bottom;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_keys_changed_handler(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->keys_changed_handler;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_window__get_mnemonic_modifier(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_WINDOW(pygobject_get(self))->mnemonic_modifier;
    return pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, ret);
}

static const PyGetSetDef gtk_window_getsets[] = {
    { "title", (getter)_wrap_gtk_window__get_title, (setter)0 },
    { "wmclass_name", (getter)_wrap_gtk_window__get_wmclass_name, (setter)0 },
    { "wmclass_class", (getter)_wrap_gtk_window__get_wmclass_class, (setter)0 },
    { "wm_role", (getter)_wrap_gtk_window__get_wm_role, (setter)0 },
    { "focus_widget", (getter)_wrap_gtk_window__get_focus_widget, (setter)0 },
    { "default_widget", (getter)_wrap_gtk_window__get_default_widget, (setter)0 },
    { "transient_parent", (getter)_wrap_gtk_window__get_transient_parent, (setter)0 },
    { "frame", (getter)_wrap_gtk_window__get_frame, (setter)0 },
    { "group", (getter)_wrap_gtk_window__get_group, (setter)0 },
    { "configure_request_count", (getter)_wrap_gtk_window__get_configure_request_count, (setter)0 },
    { "allow_shrink", (getter)_wrap_gtk_window__get_allow_shrink, (setter)0 },
    { "allow_grow", (getter)_wrap_gtk_window__get_allow_grow, (setter)0 },
    { "configure_notify_received", (getter)_wrap_gtk_window__get_configure_notify_received, (setter)0 },
    { "need_default_position", (getter)_wrap_gtk_window__get_need_default_position, (setter)0 },
    { "need_default_size", (getter)_wrap_gtk_window__get_need_default_size, (setter)0 },
    { "position", (getter)_wrap_gtk_window__get_position, (setter)0 },
    { "type", (getter)_wrap_gtk_window__get_type, (setter)0 },
    { "has_user_ref_count", (getter)_wrap_gtk_window__get_has_user_ref_count, (setter)0 },
    { "has_focus", (getter)_wrap_gtk_window__get_has_focus, (setter)0 },
    { "modal", (getter)_wrap_gtk_window__get_modal, (setter)0 },
    { "destroy_with_parent", (getter)_wrap_gtk_window__get_destroy_with_parent, (setter)0 },
    { "has_frame", (getter)_wrap_gtk_window__get_has_frame, (setter)0 },
    { "iconify_initially", (getter)_wrap_gtk_window__get_iconify_initially, (setter)0 },
    { "stick_initially", (getter)_wrap_gtk_window__get_stick_initially, (setter)0 },
    { "maximize_initially", (getter)_wrap_gtk_window__get_maximize_initially, (setter)0 },
    { "decorated", (getter)_wrap_gtk_window__get_decorated, (setter)0 },
    { "type_hint", (getter)_wrap_gtk_window__get_type_hint, (setter)0 },
    { "gravity", (getter)_wrap_gtk_window__get_gravity, (setter)0 },
    { "frame_left", (getter)_wrap_gtk_window__get_frame_left, (setter)0 },
    { "frame_top", (getter)_wrap_gtk_window__get_frame_top, (setter)0 },
    { "frame_right", (getter)_wrap_gtk_window__get_frame_right, (setter)0 },
    { "frame_bottom", (getter)_wrap_gtk_window__get_frame_bottom, (setter)0 },
    { "keys_changed_handler", (getter)_wrap_gtk_window__get_keys_changed_handler, (setter)0 },
    { "mnemonic_modifier", (getter)_wrap_gtk_window__get_mnemonic_modifier, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkWindow_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Window",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkWindow_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_window_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_window_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkWindow__proxy_do_set_focus(GtkWindow *self, GtkWidget*focus)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_focus = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (focus)
        py_focus = pygobject_new((GObject *) focus);
    else {
        Py_INCREF(Py_None);
        py_focus = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_focus);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_focus");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkWindow__proxy_do_frame_event(GtkWindow *self, GdkEvent*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_frame_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkWindow__proxy_do_activate_focus(GtkWindow *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate_focus");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWindow__proxy_do_activate_default(GtkWindow *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate_default");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWindow__proxy_do_move_focus(GtkWindow *self, GtkDirectionType direction)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_direction;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_direction = pyg_enum_from_gtype(GTK_TYPE_DIRECTION_TYPE, direction);
    if (!py_direction) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_direction);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_focus");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkWindow__proxy_do_keys_changed(GtkWindow *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_keys_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkWindow_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkWindowClass *klass = GTK_WINDOW_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_focus");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_focus")))
            klass->set_focus = _wrap_GtkWindow__proxy_do_set_focus;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_frame_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "frame_event")))
            klass->frame_event = _wrap_GtkWindow__proxy_do_frame_event;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate_focus");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate_focus")))
            klass->activate_focus = _wrap_GtkWindow__proxy_do_activate_focus;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate_default");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate_default")))
            klass->activate_default = _wrap_GtkWindow__proxy_do_activate_default;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_focus");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_focus")))
            klass->move_focus = _wrap_GtkWindow__proxy_do_move_focus;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_keys_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "keys_changed")))
            klass->keys_changed = _wrap_GtkWindow__proxy_do_keys_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkDialog ----------- */

#line 2634 "./gtk.override"
static int
_wrap_gtk_dialog_new_with_buttons(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    gchar *title = NULL;
    PyGObject *py_window = NULL;
    PyObject *py_flags = NULL, *py_buttons = Py_None;
    GtkDialogFlags flags = 0;
    int len, i;
    GtkWindow *parent;
    
    static char *kwlist[] = { "title", "parent", "flags", "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zOOO:GtkDialog.__init__", kwlist,
                                     &title, &py_window, &py_flags,
                                     &py_buttons))
        return -1;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
	parent = NULL;
    else if (pygobject_check(py_window, &PyGtkWindow_Type))
	parent = GTK_WINDOW(py_window->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "parent must be a GtkWindow or None");
        return -1;
    }

    if (pyg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;
    if (py_buttons == Py_None)
        len = 0;
    else if (PyTuple_Check(py_buttons))
        len = PyTuple_Size(py_buttons);
    else {
        PyErr_SetString(PyExc_TypeError, "buttons must be a tuple containing text/response pairs or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    if (pygobject_constructv(self, 0, NULL)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkDialog object");
        return -1;
    }

  if (title)
    gtk_window_set_title (GTK_WINDOW (self->obj), title);

  if (parent)
    gtk_window_set_transient_for (GTK_WINDOW (self->obj), parent);

  if (flags & GTK_DIALOG_MODAL)
    gtk_window_set_modal (GTK_WINDOW (self->obj), TRUE);
  
  if (flags & GTK_DIALOG_DESTROY_WITH_PARENT)
    gtk_window_set_destroy_with_parent (GTK_WINDOW (self->obj), TRUE);

  if (flags & GTK_DIALOG_NO_SEPARATOR)
    gtk_dialog_set_has_separator (GTK_DIALOG (self->obj), FALSE);
    
    for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyString_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyInt_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }
        gtk_dialog_add_button(GTK_DIALOG(self->obj), PyString_AsString(text),
                              PyInt_AsLong(id));
    }
    
    return 0;
}
#line 22575 "gtk.c"


static PyObject *
_wrap_gtk_dialog_add_action_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "response_id", NULL };
    PyGObject *child;
    int response_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Dialog.add_action_widget", kwlist, &PyGtkWidget_Type, &child, &response_id))
        return NULL;
    
    gtk_dialog_add_action_widget(GTK_DIALOG(self->obj), GTK_WIDGET(child->obj), response_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_dialog_add_button(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "button_text", "response_id", NULL };
    char *button_text;
    int response_id;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"si:Gtk.Dialog.add_button", kwlist, &button_text, &response_id))
        return NULL;
    
    ret = gtk_dialog_add_button(GTK_DIALOG(self->obj), button_text, response_id);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 2741 "./gtk.override"
static PyObject *
_wrap_gtk_dialog_add_buttons(PyGObject *self, PyObject *args)
{
    GtkDialog *dialog;
    int i, len;

    dialog = GTK_DIALOG(self->obj);

    len = PyTuple_Size(args);
    if (len % 2 != 0) {
	PyErr_SetString(PyExc_TypeError,
			"must pass an even number of arguments");
	return NULL;
    }
    
    for (i = 0; i < len; i+= 2) {
	PyObject *curr_args = PyTuple_GetSlice(args, i, i + 2);
	gchar *text;
	gint response_id;
	
	if (!PyArg_ParseTuple(curr_args, "si", &text, &response_id))
	    return NULL;
	
	gtk_dialog_add_button(dialog, text, response_id);
    }
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 22641 "gtk.c"


static PyObject *
_wrap_gtk_dialog_set_response_sensitive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "response_id", "setting", NULL };
    int response_id, setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Dialog.set_response_sensitive", kwlist, &response_id, &setting))
        return NULL;
    
    gtk_dialog_set_response_sensitive(GTK_DIALOG(self->obj), response_id, setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_dialog_set_default_response(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "response_id", NULL };
    int response_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Dialog.set_default_response", kwlist, &response_id))
        return NULL;
    
    gtk_dialog_set_default_response(GTK_DIALOG(self->obj), response_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_dialog_get_response_for_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Dialog.get_response_for_widget", kwlist, &PyGtkWidget_Type, &widget))
        return NULL;
    
    ret = gtk_dialog_get_response_for_widget(GTK_DIALOG(self->obj), GTK_WIDGET(widget->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_dialog_set_has_separator(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Dialog.set_has_separator", kwlist, &setting))
        return NULL;
    
    gtk_dialog_set_has_separator(GTK_DIALOG(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_dialog_get_has_separator(PyGObject *self)
{
    int ret;

    
    ret = gtk_dialog_get_has_separator(GTK_DIALOG(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_dialog_response(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "response_id", NULL };
    int response_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Dialog.response", kwlist, &response_id))
        return NULL;
    
    gtk_dialog_response(GTK_DIALOG(self->obj), response_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2729 "./gtk.override"
static PyObject *
_wrap_gtk_dialog_run(PyGObject *self)
{
    gint retval;

    pyg_begin_allow_threads;
    retval = gtk_dialog_run(GTK_DIALOG(self->obj));
    pyg_end_allow_threads;
    return PyInt_FromLong(retval);
}
#line 22742 "gtk.c"


#line 6741 "./gtk.override"
static PyObject *
_wrap_gtk_dialog_set_alternative_button_order(PyGObject *self, PyObject *args,
                                              PyObject *kwargs)
{
    static char *kwlist[] = { "new_order", NULL };
    gint *new_order, n_params;
    PyObject *py_new_order;
    int i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkDialog.set_alternative_button_order",
                                     kwlist, &py_new_order))
        return NULL;

    n_params = PySequence_Size(py_new_order);
    if (!PySequence_Check(py_new_order) || n_params < 1) {
        PyErr_SetString(PyExc_TypeError,
                        "new_order must be a sequence with"
                        "at least one response id int");
        return NULL;
    }
    new_order = (gint *)g_new0(gint, n_params);
    for (i = 0; i < n_params; i++) {
        PyObject *item = PySequence_GetItem(py_new_order, i);

        if (!PyInt_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "each new_order item must be an integer");
            g_free(new_order);
            Py_XDECREF(item);
            return NULL;
        }
        new_order[i] = PyInt_AsLong(item);
        Py_DECREF(item);
    }
    gtk_dialog_set_alternative_button_order_from_array(GTK_DIALOG(self->obj),
                                                       n_params, new_order);
    g_free(new_order);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 22787 "gtk.c"


static PyObject *
_wrap_gtk_dialog_get_action_area(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_dialog_get_action_area(GTK_DIALOG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_dialog_get_content_area(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_dialog_get_content_area(GTK_DIALOG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_dialog_get_widget_for_response(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "response_id", NULL };
    int response_id;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Dialog.get_widget_for_response", kwlist, &response_id))
        return NULL;
    
    ret = gtk_dialog_get_widget_for_response(GTK_DIALOG(self->obj), response_id);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkDialog__do_response(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "response_id", NULL };
    PyGObject *self;
    int response_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Dialog.response", kwlist, &PyGtkDialog_Type, &self, &response_id))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_DIALOG_CLASS(klass)->response)
        GTK_DIALOG_CLASS(klass)->response(GTK_DIALOG(self->obj), response_id);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Dialog.response not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkDialog__do_close(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Dialog.close", kwlist, &PyGtkDialog_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_DIALOG_CLASS(klass)->close)
        GTK_DIALOG_CLASS(klass)->close(GTK_DIALOG(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Dialog.close not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkDialog_methods[] = {
    { "add_action_widget", (PyCFunction)_wrap_gtk_dialog_add_action_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_button", (PyCFunction)_wrap_gtk_dialog_add_button, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_buttons", (PyCFunction)_wrap_gtk_dialog_add_buttons, METH_VARARGS,
      NULL },
    { "set_response_sensitive", (PyCFunction)_wrap_gtk_dialog_set_response_sensitive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_default_response", (PyCFunction)_wrap_gtk_dialog_set_default_response, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_response_for_widget", (PyCFunction)_wrap_gtk_dialog_get_response_for_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_has_separator", (PyCFunction)_wrap_gtk_dialog_set_has_separator, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_separator", (PyCFunction)_wrap_gtk_dialog_get_has_separator, METH_NOARGS,
      NULL },
    { "response", (PyCFunction)_wrap_gtk_dialog_response, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "run", (PyCFunction)_wrap_gtk_dialog_run, METH_NOARGS,
      NULL },
    { "set_alternative_button_order", (PyCFunction)_wrap_gtk_dialog_set_alternative_button_order, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_action_area", (PyCFunction)_wrap_gtk_dialog_get_action_area, METH_NOARGS,
      NULL },
    { "get_content_area", (PyCFunction)_wrap_gtk_dialog_get_content_area, METH_NOARGS,
      NULL },
    { "get_widget_for_response", (PyCFunction)_wrap_gtk_dialog_get_widget_for_response, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_response", (PyCFunction)_wrap_GtkDialog__do_response, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_close", (PyCFunction)_wrap_GtkDialog__do_close, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_dialog__get_vbox(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_DIALOG(pygobject_get(self))->vbox;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_dialog__get_action_area(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_DIALOG(pygobject_get(self))->action_area;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyGetSetDef gtk_dialog_getsets[] = {
    { "vbox", (getter)_wrap_gtk_dialog__get_vbox, (setter)0 },
    { "action_area", (getter)_wrap_gtk_dialog__get_action_area, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkDialog_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Dialog",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkDialog_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_dialog_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_dialog_new_with_buttons,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkDialog__proxy_do_response(GtkDialog *self, gint response_id)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_response_id;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_response_id = PyInt_FromLong(response_id);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_response_id);
    
    py_method = PyObject_GetAttrString(py_self, "do_response");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkDialog__proxy_do_close(GtkDialog *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_close");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkDialog_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkDialogClass *klass = GTK_DIALOG_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_response");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "response")))
            klass->response = _wrap_GtkDialog__proxy_do_response;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_close");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "close")))
            klass->close = _wrap_GtkDialog__proxy_do_close;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkAboutDialog ----------- */

 static int
_wrap_gtk_about_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.AboutDialog.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.AboutDialog object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_about_dialog_get_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_about_dialog_get_name(GTK_ABOUT_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_set_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.AboutDialog.set_name", kwlist, &name))
        return NULL;
    
    gtk_about_dialog_set_name(GTK_ABOUT_DIALOG(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_get_version(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_about_dialog_get_version(GTK_ABOUT_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_set_version(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "version", NULL };
    char *version;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.AboutDialog.set_version", kwlist, &version))
        return NULL;
    
    gtk_about_dialog_set_version(GTK_ABOUT_DIALOG(self->obj), version);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_get_copyright(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_about_dialog_get_copyright(GTK_ABOUT_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_set_copyright(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "copyright", NULL };
    char *copyright;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.AboutDialog.set_copyright", kwlist, &copyright))
        return NULL;
    
    gtk_about_dialog_set_copyright(GTK_ABOUT_DIALOG(self->obj), copyright);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_get_comments(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_about_dialog_get_comments(GTK_ABOUT_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_set_comments(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "comments", NULL };
    char *comments;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.AboutDialog.set_comments", kwlist, &comments))
        return NULL;
    
    gtk_about_dialog_set_comments(GTK_ABOUT_DIALOG(self->obj), comments);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_get_license(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_about_dialog_get_license(GTK_ABOUT_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_set_license(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "license", NULL };
    char *license;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.AboutDialog.set_license", kwlist, &license))
        return NULL;
    
    gtk_about_dialog_set_license(GTK_ABOUT_DIALOG(self->obj), license);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_get_wrap_license(PyGObject *self)
{
    int ret;

    
    ret = gtk_about_dialog_get_wrap_license(GTK_ABOUT_DIALOG(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_about_dialog_set_wrap_license(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "wrap_license", NULL };
    int wrap_license;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.AboutDialog.set_wrap_license", kwlist, &wrap_license))
        return NULL;
    
    gtk_about_dialog_set_wrap_license(GTK_ABOUT_DIALOG(self->obj), wrap_license);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_get_website(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_about_dialog_get_website(GTK_ABOUT_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_set_website(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "website", NULL };
    char *website;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.AboutDialog.set_website", kwlist, &website))
        return NULL;
    
    gtk_about_dialog_set_website(GTK_ABOUT_DIALOG(self->obj), website);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_get_website_label(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_about_dialog_get_website_label(GTK_ABOUT_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_set_website_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "website_label", NULL };
    char *website_label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.AboutDialog.set_website_label", kwlist, &website_label))
        return NULL;
    
    gtk_about_dialog_set_website_label(GTK_ABOUT_DIALOG(self->obj), website_label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 5675 "./gtk.override"
static PyObject *
_wrap_gtk_about_dialog_get_authors(PyGObject *self)
{
    gchar **authors, **tmp;
    int i = 0, j;
    PyObject *ret;

    authors = (gchar **)gtk_about_dialog_get_authors(GTK_ABOUT_DIALOG(self->obj));
    if (!authors)
	return PyTuple_New(0);
    
    tmp = authors;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(authors[j]));

    return ret;
}
#line 23400 "gtk.c"


#line 5637 "./gtk.override"
static PyObject *
_wrap_gtk_about_dialog_set_authors(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    gchar **authors = NULL;
    static char *kwlist[] = { "authors", NULL };
    PyObject *py_authors = NULL;
    int i, n_authors;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkAboutDialog.set_authors",
                                     kwlist, &py_authors))
        return NULL;

    if (!PySequence_Check(py_authors)) {
        PyErr_SetString(PyExc_TypeError, "authors must be a sequence");
        return NULL;
    }

    n_authors = PySequence_Length(py_authors);
    authors = g_new(gchar *, n_authors + 1);
    for (i = 0; i < n_authors; i++) {
        PyObject *item = PySequence_GetItem(py_authors, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        authors[i] = PyString_AsString(item);
    }
    authors[n_authors] = NULL;

    gtk_about_dialog_set_authors(GTK_ABOUT_DIALOG(self->obj),
                                 (const char **)authors);

    g_free(authors);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 23440 "gtk.c"


#line 5736 "./gtk.override"
static PyObject *
_wrap_gtk_about_dialog_get_documenters(PyGObject *self)
{
    gchar **documenters, **tmp;
    int i = 0, j;
    PyObject *ret;

    documenters = (gchar **)gtk_about_dialog_get_documenters(GTK_ABOUT_DIALOG(self->obj));
    if (!documenters)
	return PyTuple_New(0);
    
    tmp = documenters;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(documenters[j]));

    return ret;
}
#line 23465 "gtk.c"


#line 5698 "./gtk.override"
static PyObject *
_wrap_gtk_about_dialog_set_documenters(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    gchar **documenters = NULL;
    static char *kwlist[] = { "documenters", NULL };
    PyObject *py_documenters = NULL;
    int i, n_documenters;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkAboutDialog.set_documenters",
                                     kwlist, &py_documenters))
        return NULL;

    if (!PySequence_Check(py_documenters)) {
        PyErr_SetString(PyExc_TypeError, "documenters must be a sequence");
        return NULL;
    }

    n_documenters = PySequence_Length(py_documenters);
    documenters = g_new(gchar *, n_documenters + 1);
    for (i = 0; i < n_documenters; i++) {
        PyObject *item = PySequence_GetItem(py_documenters, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        documenters[i] = PyString_AsString(item);
    }
    documenters[n_documenters] = NULL;

    gtk_about_dialog_set_documenters(GTK_ABOUT_DIALOG(self->obj),
                                     (const char **)documenters);

    g_free(documenters);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 23505 "gtk.c"


#line 5797 "./gtk.override"
static PyObject *
_wrap_gtk_about_dialog_get_artists(PyGObject *self)
{
    gchar **artists, **tmp;
    int i = 0, j;
    PyObject *ret;

    artists = (gchar **)gtk_about_dialog_get_artists(GTK_ABOUT_DIALOG(self->obj));
    if (!artists)
	return PyTuple_New(0);
    
    tmp = artists;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(artists[j]));

    return ret;
}
#line 23530 "gtk.c"


#line 5759 "./gtk.override"
static PyObject *
_wrap_gtk_about_dialog_set_artists(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    gchar **artists = NULL;
    static char *kwlist[] = { "artists", NULL };
    PyObject *py_artists = NULL;
    int i, n_artists;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "O:GtkAboutDialog.set_artists",
                                     kwlist, &py_artists))
        return NULL;

    if (!PySequence_Check(py_artists)) {
        PyErr_SetString(PyExc_TypeError, "artists must be a sequence");
        return NULL;
    }

    n_artists = PySequence_Length(py_artists);
    artists = g_new(gchar *, n_artists + 1);
    for (i = 0; i < n_artists; i++) {
        PyObject *item = PySequence_GetItem(py_artists, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        artists[i] = PyString_AsString(item);
    }
    artists[n_artists] = NULL;

    gtk_about_dialog_set_artists(GTK_ABOUT_DIALOG(self->obj),
                                 (const char **)artists);

    g_free(artists);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 23570 "gtk.c"


static PyObject *
_wrap_gtk_about_dialog_get_translator_credits(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_about_dialog_get_translator_credits(GTK_ABOUT_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_set_translator_credits(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "translator_credits", NULL };
    char *translator_credits;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.AboutDialog.set_translator_credits", kwlist, &translator_credits))
        return NULL;
    
    gtk_about_dialog_set_translator_credits(GTK_ABOUT_DIALOG(self->obj), translator_credits);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_get_logo(PyGObject *self)
{
    GdkPixbuf *ret;

    
    ret = gtk_about_dialog_get_logo(GTK_ABOUT_DIALOG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_about_dialog_set_logo(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "logo", NULL };
    PyGObject *py_logo;
    GdkPixbuf *logo = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.AboutDialog.set_logo", kwlist, &py_logo))
        return NULL;
    if (py_logo && pygobject_check(py_logo, &PyGdkPixbuf_Type))
        logo = GDK_PIXBUF(py_logo->obj);
    else if ((PyObject *)py_logo != Py_None) {
        PyErr_SetString(PyExc_TypeError, "logo should be a GdkPixbuf or None");
        return NULL;
    }
    
    gtk_about_dialog_set_logo(GTK_ABOUT_DIALOG(self->obj), (GdkPixbuf *) logo);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_get_logo_icon_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_about_dialog_get_logo_icon_name(GTK_ABOUT_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_set_logo_icon_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    char *icon_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.AboutDialog.set_logo_icon_name", kwlist, &icon_name))
        return NULL;
    
    gtk_about_dialog_set_logo_icon_name(GTK_ABOUT_DIALOG(self->obj), icon_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_get_program_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_about_dialog_get_program_name(GTK_ABOUT_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_about_dialog_set_program_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.AboutDialog.set_program_name", kwlist, &name))
        return NULL;
    
    gtk_about_dialog_set_program_name(GTK_ABOUT_DIALOG(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkAboutDialog_methods[] = {
    { "get_name", (PyCFunction)_wrap_gtk_about_dialog_get_name, METH_NOARGS,
      NULL },
    { "set_name", (PyCFunction)_wrap_gtk_about_dialog_set_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_version", (PyCFunction)_wrap_gtk_about_dialog_get_version, METH_NOARGS,
      NULL },
    { "set_version", (PyCFunction)_wrap_gtk_about_dialog_set_version, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_copyright", (PyCFunction)_wrap_gtk_about_dialog_get_copyright, METH_NOARGS,
      NULL },
    { "set_copyright", (PyCFunction)_wrap_gtk_about_dialog_set_copyright, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_comments", (PyCFunction)_wrap_gtk_about_dialog_get_comments, METH_NOARGS,
      NULL },
    { "set_comments", (PyCFunction)_wrap_gtk_about_dialog_set_comments, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_license", (PyCFunction)_wrap_gtk_about_dialog_get_license, METH_NOARGS,
      NULL },
    { "set_license", (PyCFunction)_wrap_gtk_about_dialog_set_license, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_wrap_license", (PyCFunction)_wrap_gtk_about_dialog_get_wrap_license, METH_NOARGS,
      NULL },
    { "set_wrap_license", (PyCFunction)_wrap_gtk_about_dialog_set_wrap_license, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_website", (PyCFunction)_wrap_gtk_about_dialog_get_website, METH_NOARGS,
      NULL },
    { "set_website", (PyCFunction)_wrap_gtk_about_dialog_set_website, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_website_label", (PyCFunction)_wrap_gtk_about_dialog_get_website_label, METH_NOARGS,
      NULL },
    { "set_website_label", (PyCFunction)_wrap_gtk_about_dialog_set_website_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_authors", (PyCFunction)_wrap_gtk_about_dialog_get_authors, METH_NOARGS,
      NULL },
    { "set_authors", (PyCFunction)_wrap_gtk_about_dialog_set_authors, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_documenters", (PyCFunction)_wrap_gtk_about_dialog_get_documenters, METH_NOARGS,
      NULL },
    { "set_documenters", (PyCFunction)_wrap_gtk_about_dialog_set_documenters, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_artists", (PyCFunction)_wrap_gtk_about_dialog_get_artists, METH_NOARGS,
      NULL },
    { "set_artists", (PyCFunction)_wrap_gtk_about_dialog_set_artists, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_translator_credits", (PyCFunction)_wrap_gtk_about_dialog_get_translator_credits, METH_NOARGS,
      NULL },
    { "set_translator_credits", (PyCFunction)_wrap_gtk_about_dialog_set_translator_credits, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_logo", (PyCFunction)_wrap_gtk_about_dialog_get_logo, METH_NOARGS,
      NULL },
    { "set_logo", (PyCFunction)_wrap_gtk_about_dialog_set_logo, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_logo_icon_name", (PyCFunction)_wrap_gtk_about_dialog_get_logo_icon_name, METH_NOARGS,
      NULL },
    { "set_logo_icon_name", (PyCFunction)_wrap_gtk_about_dialog_set_logo_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_program_name", (PyCFunction)_wrap_gtk_about_dialog_get_program_name, METH_NOARGS,
      NULL },
    { "set_program_name", (PyCFunction)_wrap_gtk_about_dialog_set_program_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkAboutDialog_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.AboutDialog",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkAboutDialog_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_about_dialog_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkAccelGroup ----------- */

static int
_wrap_gtk_accel_group_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.AccelGroup.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.AccelGroup object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_accel_group_lock(PyGObject *self)
{
    
    gtk_accel_group_lock(GTK_ACCEL_GROUP(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accel_group_unlock(PyGObject *self)
{
    
    gtk_accel_group_unlock(GTK_ACCEL_GROUP(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4334 "./gtk.override"
static PyObject *
_wrap_gtk_accel_group_connect_by_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", "callback", NULL };
    gchar *accel_path;
    PyObject *py_callback;
    GClosure *closure;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "sO:GtkAccelGroup.connect_by_path", kwlist,
				     &accel_path, &py_callback))
        return NULL;
    if (!PyCallable_Check(py_callback)) {
	PyErr_SetString(PyExc_TypeError, "callback argument not callable");
	return NULL;
    }
    closure = pyg_closure_new(py_callback, NULL, NULL);
    pygobject_watch_closure((PyObject *)self, closure);
    gtk_accel_group_connect_by_path(GTK_ACCEL_GROUP(self->obj), accel_path,
				    closure);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 23870 "gtk.c"


static PyObject *
_wrap_gtk_accel_group_disconnect_key(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_key", "accel_mods", NULL };
    PyObject *py_accel_key = NULL, *py_accel_mods = NULL;
    int ret;
    GdkModifierType accel_mods;
    guint accel_key = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.AccelGroup.disconnect_key", kwlist, &py_accel_key, &py_accel_mods))
        return NULL;
    if (py_accel_key) {
        if (PyLong_Check(py_accel_key))
            accel_key = PyLong_AsUnsignedLong(py_accel_key);
        else if (PyInt_Check(py_accel_key))
            accel_key = PyInt_AsLong(py_accel_key);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'accel_key' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gpointer)&accel_mods))
        return NULL;
    
    ret = gtk_accel_group_disconnect_key(GTK_ACCEL_GROUP(self->obj), accel_key, accel_mods);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_accel_group_get_is_locked(PyGObject *self)
{
    int ret;

    
    ret = gtk_accel_group_get_is_locked(GTK_ACCEL_GROUP(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_accel_group_get_modifier_mask(PyGObject *self)
{
    guint ret;

    
    ret = gtk_accel_group_get_modifier_mask(GTK_ACCEL_GROUP(self->obj));
    
    return pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, ret);
}

#line 3865 "./gtk.override"
static PyObject *
_wrap_gtk_accel_group_connect_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_key", "accel_mods", "accel_flags", "callback", NULL };
    int accel_key;
    PyObject *py_accel_mods = NULL, *py_accel_flags = NULL, *py_callback;
    GdkModifierType accel_mods;
    GtkAccelFlags accel_flags;
    GClosure *closure;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iOOO:GtkAccelGroup.connect", kwlist,
				     &accel_key, &py_accel_mods, &py_accel_flags,
				     &py_callback))
        return NULL;
    if (!PyCallable_Check(py_callback)) {
	PyErr_SetString(PyExc_TypeError, "callback argument not callable");
	return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gint *)&accel_mods))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_ACCEL_FLAGS, py_accel_flags, (gint *)&accel_flags))
        return NULL;
    closure = pyg_closure_new(py_callback, NULL, NULL);
    pygobject_watch_closure((PyObject *)self, closure);
    gtk_accel_group_connect(GTK_ACCEL_GROUP(self->obj), accel_key,
			    accel_mods, accel_flags, closure);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 23956 "gtk.c"


static PyObject *
_wrap_GtkAccelGroup__do_accel_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "keyval", "modifier", "accel_closure", NULL };
    PyGObject *self;
    PyObject *py_keyval = NULL, *py_modifier = NULL, *py_accel_closure;
    GdkModifierType modifier;
    GClosure *accel_closure = NULL;
    guint keyval = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOO:Gtk.AccelGroup.accel_changed", kwlist, &PyGtkAccelGroup_Type, &self, &py_keyval, &py_modifier, &py_accel_closure))
        return NULL;
    if (py_keyval) {
        if (PyLong_Check(py_keyval))
            keyval = PyLong_AsUnsignedLong(py_keyval);
        else if (PyInt_Check(py_keyval))
            keyval = PyInt_AsLong(py_keyval);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'keyval' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_modifier, (gpointer)&modifier))
        return NULL;
    if (pyg_boxed_check(py_accel_closure, G_TYPE_CLOSURE))
        accel_closure = pyg_boxed_get(py_accel_closure, GClosure);
    else {
        PyErr_SetString(PyExc_TypeError, "accel_closure should be a GClosure");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ACCEL_GROUP_CLASS(klass)->accel_changed)
        GTK_ACCEL_GROUP_CLASS(klass)->accel_changed(GTK_ACCEL_GROUP(self->obj), keyval, modifier, accel_closure);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.AccelGroup.accel_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkAccelGroup_methods[] = {
    { "lock", (PyCFunction)_wrap_gtk_accel_group_lock, METH_NOARGS,
      NULL },
    { "unlock", (PyCFunction)_wrap_gtk_accel_group_unlock, METH_NOARGS,
      NULL },
    { "connect_by_path", (PyCFunction)_wrap_gtk_accel_group_connect_by_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "disconnect_key", (PyCFunction)_wrap_gtk_accel_group_disconnect_key, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_is_locked", (PyCFunction)_wrap_gtk_accel_group_get_is_locked, METH_NOARGS,
      NULL },
    { "get_modifier_mask", (PyCFunction)_wrap_gtk_accel_group_get_modifier_mask, METH_NOARGS,
      NULL },
    { "connect_group", (PyCFunction)_wrap_gtk_accel_group_connect_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_accel_changed", (PyCFunction)_wrap_GtkAccelGroup__do_accel_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkAccelGroup_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.AccelGroup",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkAccelGroup_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_accel_group_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkAccelGroup__proxy_do_accel_changed(GtkAccelGroup *self, guint keyval, GdkModifierType modifier, GClosure*accel_closure)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_keyval;
    PyObject *py_modifier;
    PyObject *py_accel_closure;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_keyval = PyInt_FromLong(keyval);
    py_modifier = pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, modifier);
    if (!py_modifier) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_keyval);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_accel_closure = pyg_boxed_new(G_TYPE_CLOSURE, accel_closure, FALSE, FALSE);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_keyval);
    PyTuple_SET_ITEM(py_args, 1, py_modifier);
    PyTuple_SET_ITEM(py_args, 2, py_accel_closure);
    
    py_method = PyObject_GetAttrString(py_self, "do_accel_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkAccelGroup_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkAccelGroupClass *klass = GTK_ACCEL_GROUP_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_accel_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "accel_changed")))
            klass->accel_changed = _wrap_GtkAccelGroup__proxy_do_accel_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkMisc ----------- */

static PyObject *
_wrap_gtk_misc_set_alignment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "xalign", "yalign", NULL };
    double xalign, yalign;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dd:Gtk.Misc.set_alignment", kwlist, &xalign, &yalign))
        return NULL;
    
    gtk_misc_set_alignment(GTK_MISC(self->obj), xalign, yalign);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3118 "./gtk.override"
static PyObject *
_wrap_gtk_misc_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_misc_get_alignment(GTK_MISC(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
#line 24190 "gtk.c"


static PyObject *
_wrap_gtk_misc_set_padding(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "xpad", "ypad", NULL };
    int xpad, ypad;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Misc.set_padding", kwlist, &xpad, &ypad))
        return NULL;
    
    gtk_misc_set_padding(GTK_MISC(self->obj), xpad, ypad);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3128 "./gtk.override"
static PyObject *
_wrap_gtk_misc_get_padding(PyGObject *self)
{
    gint xpad, ypad;

    gtk_misc_get_padding(GTK_MISC(self->obj), &xpad, &ypad);
    return Py_BuildValue("(ii)", xpad, ypad);
}
#line 24217 "gtk.c"


static const PyMethodDef _PyGtkMisc_methods[] = {
    { "set_alignment", (PyCFunction)_wrap_gtk_misc_set_alignment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_alignment", (PyCFunction)_wrap_gtk_misc_get_alignment, METH_NOARGS,
      NULL },
    { "set_padding", (PyCFunction)_wrap_gtk_misc_set_padding, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_padding", (PyCFunction)_wrap_gtk_misc_get_padding, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkMisc_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Misc",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkMisc_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkLabel ----------- */

static int
_wrap_gtk_label_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"str", NULL };
    char *prop_names[] = {"label", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.Label.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Label object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_label_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    char *str;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Label.set_text", kwlist, &str))
        return NULL;
    
    gtk_label_set_text(GTK_LABEL(self->obj), str);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_text(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_label_get_text(GTK_LABEL(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_set_attributes(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "attrs", NULL };
    PyObject *py_attrs;
    PangoAttrList *attrs = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Label.set_attributes", kwlist, &py_attrs))
        return NULL;
    if (pyg_boxed_check(py_attrs, PANGO_TYPE_ATTR_LIST))
        attrs = pyg_boxed_get(py_attrs, PangoAttrList);
    else {
        PyErr_SetString(PyExc_TypeError, "attrs should be a PangoAttrList");
        return NULL;
    }
    
    gtk_label_set_attributes(GTK_LABEL(self->obj), attrs);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_attributes(PyGObject *self)
{
    PangoAttrList *ret;

    
    ret = gtk_label_get_attributes(GTK_LABEL(self->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PANGO_TYPE_ATTR_LIST, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_label_set_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    char *str;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Label.set_label", kwlist, &str))
        return NULL;
    
    gtk_label_set_label(GTK_LABEL(self->obj), str);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_label(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_label_get_label(GTK_LABEL(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_set_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    char *str;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Label.set_markup", kwlist, &str))
        return NULL;
    
    gtk_label_set_markup(GTK_LABEL(self->obj), str);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_set_use_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Label.set_use_markup", kwlist, &setting))
        return NULL;
    
    gtk_label_set_use_markup(GTK_LABEL(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_use_markup(PyGObject *self)
{
    int ret;

    
    ret = gtk_label_get_use_markup(GTK_LABEL(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_label_set_use_underline(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Label.set_use_underline", kwlist, &setting))
        return NULL;
    
    gtk_label_set_use_underline(GTK_LABEL(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_use_underline(PyGObject *self)
{
    int ret;

    
    ret = gtk_label_get_use_underline(GTK_LABEL(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_label_set_markup_with_mnemonic(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    char *str;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Label.set_markup_with_mnemonic", kwlist, &str))
        return NULL;
    
    gtk_label_set_markup_with_mnemonic(GTK_LABEL(self->obj), str);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_mnemonic_keyval(PyGObject *self)
{
    guint ret;

    
    ret = gtk_label_get_mnemonic_keyval(GTK_LABEL(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_label_set_mnemonic_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *py_widget;
    GtkWidget *widget = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Label.set_mnemonic_widget", kwlist, &py_widget))
        return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_label_set_mnemonic_widget(GTK_LABEL(self->obj), (GtkWidget *) widget);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_mnemonic_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_label_get_mnemonic_widget(GTK_LABEL(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_label_set_text_with_mnemonic(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    char *str;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Label.set_text_with_mnemonic", kwlist, &str))
        return NULL;
    
    gtk_label_set_text_with_mnemonic(GTK_LABEL(self->obj), str);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_set_justify(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "jtype", NULL };
    PyObject *py_jtype = NULL;
    GtkJustification jtype;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Label.set_justify", kwlist, &py_jtype))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_JUSTIFICATION, py_jtype, (gpointer)&jtype))
        return NULL;
    
    gtk_label_set_justify(GTK_LABEL(self->obj), jtype);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_justify(PyGObject *self)
{
    gint ret;

    
    ret = gtk_label_get_justify(GTK_LABEL(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_JUSTIFICATION, ret);
}

static PyObject *
_wrap_gtk_label_set_pattern(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pattern", NULL };
    char *pattern;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Label.set_pattern", kwlist, &pattern))
        return NULL;
    
    gtk_label_set_pattern(GTK_LABEL(self->obj), pattern);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_set_line_wrap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "wrap", NULL };
    int wrap;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Label.set_line_wrap", kwlist, &wrap))
        return NULL;
    
    gtk_label_set_line_wrap(GTK_LABEL(self->obj), wrap);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_line_wrap(PyGObject *self)
{
    int ret;

    
    ret = gtk_label_get_line_wrap(GTK_LABEL(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_label_set_selectable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Label.set_selectable", kwlist, &setting))
        return NULL;
    
    gtk_label_set_selectable(GTK_LABEL(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_selectable(PyGObject *self)
{
    int ret;

    
    ret = gtk_label_get_selectable(GTK_LABEL(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_label_select_region(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_offset", "end_offset", NULL };
    int start_offset, end_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Label.select_region", kwlist, &start_offset, &end_offset))
        return NULL;
    
    gtk_label_select_region(GTK_LABEL(self->obj), start_offset, end_offset);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 785 "./gtk.override"
static PyObject *
_wrap_gtk_label_get_selection_bounds(PyGObject *self)
{
    int start, end;

    if (!gtk_label_get_selection_bounds(GTK_LABEL(self->obj), &start, &end)) {
       return Py_BuildValue ("()");
    }

    return Py_BuildValue("(ii)", start, end);
}
#line 24672 "gtk.c"


static PyObject *
_wrap_gtk_label_get_layout(PyGObject *self)
{
    PangoLayout *ret;

    
    ret = gtk_label_get_layout(GTK_LABEL(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 798 "./gtk.override"
static PyObject *
_wrap_gtk_label_get_layout_offsets(PyGObject *self)
{
    gint x;
    gint y;

    gtk_label_get_layout_offsets(GTK_LABEL(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
#line 24697 "gtk.c"


static PyObject *
_wrap_gtk_label_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    char *str;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Label.set", kwlist, &str))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkLabel.set_text") < 0)
        return NULL;
    
    gtk_label_set(GTK_LABEL(self->obj), str);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 772 "./gtk.override"
static PyObject *
_wrap_gtk_label_get(PyGObject *self)
{
    gchar *text = NULL;

    gtk_label_get(GTK_LABEL(self->obj), &text);
    if (text)
        return PyString_FromString(text);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 24729 "gtk.c"


static PyObject *
_wrap_gtk_label_parse_uline(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "string", NULL };
    char *string;
    guint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Label.parse_uline", kwlist, &string))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    ret = gtk_label_parse_uline(GTK_LABEL(self->obj), string);
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_label_set_ellipsize(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mode", NULL };
    PyObject *py_mode = NULL;
    PangoEllipsizeMode mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Label.set_ellipsize", kwlist, &py_mode))
        return NULL;
    if (pyg_enum_get_value(PANGO_TYPE_ELLIPSIZE_MODE, py_mode, (gpointer)&mode))
        return NULL;
    
    gtk_label_set_ellipsize(GTK_LABEL(self->obj), mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_ellipsize(PyGObject *self)
{
    gint ret;

    
    ret = gtk_label_get_ellipsize(GTK_LABEL(self->obj));
    
    return pyg_enum_from_gtype(PANGO_TYPE_ELLIPSIZE_MODE, ret);
}

static PyObject *
_wrap_gtk_label_set_angle(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "angle", NULL };
    int angle;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Label.set_angle", kwlist, &angle))
        return NULL;
    
    gtk_label_set_angle(GTK_LABEL(self->obj), angle);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_angle(PyGObject *self)
{
    int ret;

    
    ret = gtk_label_get_angle(GTK_LABEL(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_label_set_width_chars(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "n_chars", NULL };
    int n_chars;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Label.set_width_chars", kwlist, &n_chars))
        return NULL;
    
    gtk_label_set_width_chars(GTK_LABEL(self->obj), n_chars);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_width_chars(PyGObject *self)
{
    int ret;

    
    ret = gtk_label_get_width_chars(GTK_LABEL(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_label_set_max_width_chars(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "n_chars", NULL };
    int n_chars;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Label.set_max_width_chars", kwlist, &n_chars))
        return NULL;
    
    gtk_label_set_max_width_chars(GTK_LABEL(self->obj), n_chars);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_max_width_chars(PyGObject *self)
{
    int ret;

    
    ret = gtk_label_get_max_width_chars(GTK_LABEL(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_label_set_single_line_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "single_line_mode", NULL };
    int single_line_mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Label.set_single_line_mode", kwlist, &single_line_mode))
        return NULL;
    
    gtk_label_set_single_line_mode(GTK_LABEL(self->obj), single_line_mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_single_line_mode(PyGObject *self)
{
    int ret;

    
    ret = gtk_label_get_single_line_mode(GTK_LABEL(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_label_set_line_wrap_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "wrap_mode", NULL };
    PyObject *py_wrap_mode = NULL;
    PangoWrapMode wrap_mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Label.set_line_wrap_mode", kwlist, &py_wrap_mode))
        return NULL;
    if (pyg_enum_get_value(PANGO_TYPE_WRAP_MODE, py_wrap_mode, (gpointer)&wrap_mode))
        return NULL;
    
    gtk_label_set_line_wrap_mode(GTK_LABEL(self->obj), wrap_mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_line_wrap_mode(PyGObject *self)
{
    gint ret;

    
    ret = gtk_label_get_line_wrap_mode(GTK_LABEL(self->obj));
    
    return pyg_enum_from_gtype(PANGO_TYPE_WRAP_MODE, ret);
}

static PyObject *
_wrap_gtk_label_get_current_uri(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_label_get_current_uri(GTK_LABEL(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_set_track_visited_links(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "track_links", NULL };
    int track_links;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Label.set_track_visited_links", kwlist, &track_links))
        return NULL;
    
    gtk_label_set_track_visited_links(GTK_LABEL(self->obj), track_links);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_label_get_track_visited_links(PyGObject *self)
{
    int ret;

    
    ret = gtk_label_get_track_visited_links(GTK_LABEL(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkLabel__do_move_cursor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "step", "count", "extend_selection", NULL };
    PyGObject *self;
    PyObject *py_step = NULL;
    GtkMovementStep step;
    int count, extend_selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oii:Gtk.Label.move_cursor", kwlist, &PyGtkLabel_Type, &self, &py_step, &count, &extend_selection))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_MOVEMENT_STEP, py_step, (gpointer)&step))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LABEL_CLASS(klass)->move_cursor)
        GTK_LABEL_CLASS(klass)->move_cursor(GTK_LABEL(self->obj), step, count, extend_selection);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Label.move_cursor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkLabel__do_copy_clipboard(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Label.copy_clipboard", kwlist, &PyGtkLabel_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LABEL_CLASS(klass)->copy_clipboard)
        GTK_LABEL_CLASS(klass)->copy_clipboard(GTK_LABEL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Label.copy_clipboard not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkLabel__do_populate_popup(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "menu", NULL };
    PyGObject *self, *menu;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Label.populate_popup", kwlist, &PyGtkLabel_Type, &self, &PyGtkMenu_Type, &menu))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LABEL_CLASS(klass)->populate_popup)
        GTK_LABEL_CLASS(klass)->populate_popup(GTK_LABEL(self->obj), GTK_MENU(menu->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Label.populate_popup not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkLabel_methods[] = {
    { "set_text", (PyCFunction)_wrap_gtk_label_set_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text", (PyCFunction)_wrap_gtk_label_get_text, METH_NOARGS,
      NULL },
    { "set_attributes", (PyCFunction)_wrap_gtk_label_set_attributes, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_attributes", (PyCFunction)_wrap_gtk_label_get_attributes, METH_NOARGS,
      NULL },
    { "set_label", (PyCFunction)_wrap_gtk_label_set_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label", (PyCFunction)_wrap_gtk_label_get_label, METH_NOARGS,
      NULL },
    { "set_markup", (PyCFunction)_wrap_gtk_label_set_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_use_markup", (PyCFunction)_wrap_gtk_label_set_use_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_markup", (PyCFunction)_wrap_gtk_label_get_use_markup, METH_NOARGS,
      NULL },
    { "set_use_underline", (PyCFunction)_wrap_gtk_label_set_use_underline, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_underline", (PyCFunction)_wrap_gtk_label_get_use_underline, METH_NOARGS,
      NULL },
    { "set_markup_with_mnemonic", (PyCFunction)_wrap_gtk_label_set_markup_with_mnemonic, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_mnemonic_keyval", (PyCFunction)_wrap_gtk_label_get_mnemonic_keyval, METH_NOARGS,
      NULL },
    { "set_mnemonic_widget", (PyCFunction)_wrap_gtk_label_set_mnemonic_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_mnemonic_widget", (PyCFunction)_wrap_gtk_label_get_mnemonic_widget, METH_NOARGS,
      NULL },
    { "set_text_with_mnemonic", (PyCFunction)_wrap_gtk_label_set_text_with_mnemonic, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_justify", (PyCFunction)_wrap_gtk_label_set_justify, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_justify", (PyCFunction)_wrap_gtk_label_get_justify, METH_NOARGS,
      NULL },
    { "set_pattern", (PyCFunction)_wrap_gtk_label_set_pattern, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_line_wrap", (PyCFunction)_wrap_gtk_label_set_line_wrap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_line_wrap", (PyCFunction)_wrap_gtk_label_get_line_wrap, METH_NOARGS,
      NULL },
    { "set_selectable", (PyCFunction)_wrap_gtk_label_set_selectable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_selectable", (PyCFunction)_wrap_gtk_label_get_selectable, METH_NOARGS,
      NULL },
    { "select_region", (PyCFunction)_wrap_gtk_label_select_region, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_selection_bounds", (PyCFunction)_wrap_gtk_label_get_selection_bounds, METH_NOARGS,
      NULL },
    { "get_layout", (PyCFunction)_wrap_gtk_label_get_layout, METH_NOARGS,
      NULL },
    { "get_layout_offsets", (PyCFunction)_wrap_gtk_label_get_layout_offsets, METH_NOARGS,
      NULL },
    { "set", (PyCFunction)_wrap_gtk_label_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get", (PyCFunction)_wrap_gtk_label_get, METH_NOARGS,
      NULL },
    { "parse_uline", (PyCFunction)_wrap_gtk_label_parse_uline, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_ellipsize", (PyCFunction)_wrap_gtk_label_set_ellipsize, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_ellipsize", (PyCFunction)_wrap_gtk_label_get_ellipsize, METH_NOARGS,
      NULL },
    { "set_angle", (PyCFunction)_wrap_gtk_label_set_angle, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_angle", (PyCFunction)_wrap_gtk_label_get_angle, METH_NOARGS,
      NULL },
    { "set_width_chars", (PyCFunction)_wrap_gtk_label_set_width_chars, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_width_chars", (PyCFunction)_wrap_gtk_label_get_width_chars, METH_NOARGS,
      NULL },
    { "set_max_width_chars", (PyCFunction)_wrap_gtk_label_set_max_width_chars, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_max_width_chars", (PyCFunction)_wrap_gtk_label_get_max_width_chars, METH_NOARGS,
      NULL },
    { "set_single_line_mode", (PyCFunction)_wrap_gtk_label_set_single_line_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_single_line_mode", (PyCFunction)_wrap_gtk_label_get_single_line_mode, METH_NOARGS,
      NULL },
    { "set_line_wrap_mode", (PyCFunction)_wrap_gtk_label_set_line_wrap_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_line_wrap_mode", (PyCFunction)_wrap_gtk_label_get_line_wrap_mode, METH_NOARGS,
      NULL },
    { "get_current_uri", (PyCFunction)_wrap_gtk_label_get_current_uri, METH_NOARGS,
      NULL },
    { "set_track_visited_links", (PyCFunction)_wrap_gtk_label_set_track_visited_links, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_track_visited_links", (PyCFunction)_wrap_gtk_label_get_track_visited_links, METH_NOARGS,
      NULL },
    { "do_move_cursor", (PyCFunction)_wrap_GtkLabel__do_move_cursor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_copy_clipboard", (PyCFunction)_wrap_GtkLabel__do_copy_clipboard, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_populate_popup", (PyCFunction)_wrap_GtkLabel__do_populate_popup, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkLabel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Label",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkLabel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_label_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkLabel__proxy_do_move_cursor(GtkLabel *self, GtkMovementStep step, gint count, gboolean extend_selection)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_step;
    PyObject *py_count;
    PyObject *py_extend_selection;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_step = pyg_enum_from_gtype(GTK_TYPE_MOVEMENT_STEP, step);
    if (!py_step) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_count = PyInt_FromLong(count);
    py_extend_selection = extend_selection? Py_True : Py_False;
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_step);
    PyTuple_SET_ITEM(py_args, 1, py_count);
    Py_INCREF(py_extend_selection);
    PyTuple_SET_ITEM(py_args, 2, py_extend_selection);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_cursor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkLabel__proxy_do_copy_clipboard(GtkLabel *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_copy_clipboard");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkLabel__proxy_do_populate_popup(GtkLabel *self, GtkMenu*menu)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_menu = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (menu)
        py_menu = pygobject_new((GObject *) menu);
    else {
        Py_INCREF(Py_None);
        py_menu = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_menu);
    
    py_method = PyObject_GetAttrString(py_self, "do_populate_popup");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkLabel_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkLabelClass *klass = GTK_LABEL_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_cursor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_cursor")))
            klass->move_cursor = _wrap_GtkLabel__proxy_do_move_cursor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_copy_clipboard");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "copy_clipboard")))
            klass->copy_clipboard = _wrap_GtkLabel__proxy_do_copy_clipboard;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_populate_popup");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "populate_popup")))
            klass->populate_popup = _wrap_GtkLabel__proxy_do_populate_popup;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkAccelLabel ----------- */

 static int
_wrap_gtk_accel_label_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"string", NULL };
    char *prop_names[] = {"label", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:gtk.AccelLabel.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.AccelLabel object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_accel_label_accelerator_width(PyGObject *self)
{
    guint ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkAccelLabel.get_accel_width") < 0)
        return NULL;
    
    ret = gtk_accel_label_accelerator_width(GTK_ACCEL_LABEL(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_accel_label_get_accel_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_accel_label_get_accel_widget(GTK_ACCEL_LABEL(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_accel_label_get_accel_width(PyGObject *self)
{
    guint ret;

    
    ret = gtk_accel_label_get_accel_width(GTK_ACCEL_LABEL(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_accel_label_set_accel_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_widget", NULL };
    PyGObject *accel_widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.AccelLabel.set_accel_widget", kwlist, &PyGtkWidget_Type, &accel_widget))
        return NULL;
    
    gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(self->obj), GTK_WIDGET(accel_widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accel_label_set_accel_closure(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_closure", NULL };
    PyObject *py_accel_closure;
    GClosure *accel_closure = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.AccelLabel.set_accel_closure", kwlist, &py_accel_closure))
        return NULL;
    if (pyg_boxed_check(py_accel_closure, G_TYPE_CLOSURE))
        accel_closure = pyg_boxed_get(py_accel_closure, GClosure);
    else {
        PyErr_SetString(PyExc_TypeError, "accel_closure should be a GClosure");
        return NULL;
    }
    
    gtk_accel_label_set_accel_closure(GTK_ACCEL_LABEL(self->obj), accel_closure);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accel_label_refetch(PyGObject *self)
{
    int ret;

    
    ret = gtk_accel_label_refetch(GTK_ACCEL_LABEL(self->obj));
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkAccelLabel_methods[] = {
    { "accelerator_width", (PyCFunction)_wrap_gtk_accel_label_accelerator_width, METH_NOARGS,
      NULL },
    { "get_accel_widget", (PyCFunction)_wrap_gtk_accel_label_get_accel_widget, METH_NOARGS,
      NULL },
    { "get_accel_width", (PyCFunction)_wrap_gtk_accel_label_get_accel_width, METH_NOARGS,
      NULL },
    { "set_accel_widget", (PyCFunction)_wrap_gtk_accel_label_set_accel_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_accel_closure", (PyCFunction)_wrap_gtk_accel_label_set_accel_closure, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "refetch", (PyCFunction)_wrap_gtk_accel_label_refetch, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkAccelLabel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.AccelLabel",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkAccelLabel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_accel_label_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkAccelMap ----------- */

PyTypeObject G_GNUC_INTERNAL PyGtkAccelMap_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.AccelMap",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkAccessible ----------- */

static PyObject *
_wrap_gtk_accessible_connect_widget_destroyed(PyGObject *self)
{
    
    gtk_accessible_connect_widget_destroyed(GTK_ACCESSIBLE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accessible_set_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Accessible.set_widget", kwlist, &PyGtkWidget_Type, &widget))
        return NULL;
    
    gtk_accessible_set_widget(GTK_ACCESSIBLE(self->obj), GTK_WIDGET(widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accessible_get_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_accessible_get_widget(GTK_ACCESSIBLE(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkAccessible__do_connect_widget_destroyed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Accessible.connect_widget_destroyed", kwlist, &PyGtkAccessible_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ACCESSIBLE_CLASS(klass)->connect_widget_destroyed)
        GTK_ACCESSIBLE_CLASS(klass)->connect_widget_destroyed(GTK_ACCESSIBLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Accessible.connect_widget_destroyed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkAccessible_methods[] = {
    { "connect_widget_destroyed", (PyCFunction)_wrap_gtk_accessible_connect_widget_destroyed, METH_NOARGS,
      NULL },
    { "set_widget", (PyCFunction)_wrap_gtk_accessible_set_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_widget", (PyCFunction)_wrap_gtk_accessible_get_widget, METH_NOARGS,
      NULL },
    { "do_connect_widget_destroyed", (PyCFunction)_wrap_GtkAccessible__do_connect_widget_destroyed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkAccessible_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Accessible",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkAccessible_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkAccessible__proxy_do_connect_widget_destroyed(GtkAccessible *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_connect_widget_destroyed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkAccessible_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkAccessibleClass *klass = GTK_ACCESSIBLE_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_connect_widget_destroyed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "connect_widget_destroyed")))
            klass->connect_widget_destroyed = _wrap_GtkAccessible__proxy_do_connect_widget_destroyed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkAction ----------- */

 static int
_wrap_gtk_action_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[4];
    PyObject *parsed_args[4] = {NULL, };
    char *arg_names[] = {"name", "label", "tooltip", "stock_id", NULL };
    char *prop_names[] = {"name", "label", "tooltip", "stock_id", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOO:gtk.Action.__init__" , arg_names , &parsed_args[0] , &parsed_args[1] , &parsed_args[2] , &parsed_args[3]))
        return -1;

    memset(params, 0, sizeof(GParameter)*4);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Action object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_action_get_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_action_get_name(GTK_ACTION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_is_sensitive(PyGObject *self)
{
    int ret;

    
    ret = gtk_action_is_sensitive(GTK_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_action_get_sensitive(PyGObject *self)
{
    int ret;

    
    ret = gtk_action_get_sensitive(GTK_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_action_is_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_action_is_visible(GTK_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_action_get_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_action_get_visible(GTK_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_action_activate(PyGObject *self)
{
    
    gtk_action_activate(GTK_ACTION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_create_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_size", NULL };
    PyObject *py_icon_size = NULL;
    GtkIconSize icon_size;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Action.create_icon", kwlist, &py_icon_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_icon_size, (gpointer)&icon_size))
        return NULL;
    
    ret = gtk_action_create_icon(GTK_ACTION(self->obj), icon_size);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_action_create_menu_item(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_action_create_menu_item(GTK_ACTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_action_create_tool_item(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_action_create_tool_item(GTK_ACTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_action_connect_proxy(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "proxy", NULL };
    PyGObject *proxy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Action.connect_proxy", kwlist, &PyGtkWidget_Type, &proxy))
        return NULL;
    
    gtk_action_connect_proxy(GTK_ACTION(self->obj), GTK_WIDGET(proxy->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_disconnect_proxy(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "proxy", NULL };
    PyGObject *proxy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Action.disconnect_proxy", kwlist, &PyGtkWidget_Type, &proxy))
        return NULL;
    
    gtk_action_disconnect_proxy(GTK_ACTION(self->obj), GTK_WIDGET(proxy->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4941 "./gtk.override"
static PyObject *
_wrap_gtk_action_get_proxies(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_action_get_proxies(GTK_ACTION(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = pygobject_new(G_OBJECT(tmp->data));
        if (obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    return py_list;
}
#line 26023 "gtk.c"


static PyObject *
_wrap_gtk_action_connect_accelerator(PyGObject *self)
{
    
    gtk_action_connect_accelerator(GTK_ACTION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_disconnect_accelerator(PyGObject *self)
{
    
    gtk_action_disconnect_accelerator(GTK_ACTION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_accel_path(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_action_get_accel_path(GTK_ACTION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_block_activate_from(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "proxy", NULL };
    PyGObject *proxy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Action.block_activate_from", kwlist, &PyGtkWidget_Type, &proxy))
        return NULL;
    
    gtk_action_block_activate_from(GTK_ACTION(self->obj), GTK_WIDGET(proxy->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_unblock_activate_from(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "proxy", NULL };
    PyGObject *proxy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Action.unblock_activate_from", kwlist, &PyGtkWidget_Type, &proxy))
        return NULL;
    
    gtk_action_unblock_activate_from(GTK_ACTION(self->obj), GTK_WIDGET(proxy->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_set_accel_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", NULL };
    char *accel_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Action.set_accel_path", kwlist, &accel_path))
        return NULL;
    
    gtk_action_set_accel_path(GTK_ACTION(self->obj), accel_path);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_set_accel_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_group", NULL };
    PyGObject *py_accel_group;
    GtkAccelGroup *accel_group = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Action.set_accel_group", kwlist, &py_accel_group))
        return NULL;
    if (py_accel_group && pygobject_check(py_accel_group, &PyGtkAccelGroup_Type))
        accel_group = GTK_ACCEL_GROUP(py_accel_group->obj);
    else if ((PyObject *)py_accel_group != Py_None) {
        PyErr_SetString(PyExc_TypeError, "accel_group should be a GtkAccelGroup or None");
        return NULL;
    }
    
    gtk_action_set_accel_group(GTK_ACTION(self->obj), (GtkAccelGroup *) accel_group);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_set_sensitive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sensitive", NULL };
    int sensitive;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Action.set_sensitive", kwlist, &sensitive))
        return NULL;
    
    gtk_action_set_sensitive(GTK_ACTION(self->obj), sensitive);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_set_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible", NULL };
    int visible;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Action.set_visible", kwlist, &visible))
        return NULL;
    
    gtk_action_set_visible(GTK_ACTION(self->obj), visible);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_accel_closure(PyGObject *self)
{
    GClosure *ret;

    
    ret = gtk_action_get_accel_closure(GTK_ACTION(self->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(G_TYPE_CLOSURE, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_action_create_menu(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_action_create_menu(GTK_ACTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_action_block_activate(PyGObject *self)
{
    
    gtk_action_block_activate(GTK_ACTION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_unblock_activate(PyGObject *self)
{
    
    gtk_action_unblock_activate(GTK_ACTION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_set_gicon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon", NULL };
    PyGObject *icon;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Action.set_gicon", kwlist, &PyGIcon_Type, &icon))
        return NULL;
    
    gtk_action_set_gicon(GTK_ACTION(self->obj), G_ICON(icon->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_gicon(PyGObject *self)
{
    GIcon *ret;

    
    ret = gtk_action_get_gicon(GTK_ACTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_action_set_icon_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    char *icon_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Action.set_icon_name", kwlist, &icon_name))
        return NULL;
    
    gtk_action_set_icon_name(GTK_ACTION(self->obj), icon_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_icon_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_action_get_icon_name(GTK_ACTION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_set_visible_horizontal(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible_horizontal", NULL };
    int visible_horizontal;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Action.set_visible_horizontal", kwlist, &visible_horizontal))
        return NULL;
    
    gtk_action_set_visible_horizontal(GTK_ACTION(self->obj), visible_horizontal);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_visible_horizontal(PyGObject *self)
{
    int ret;

    
    ret = gtk_action_get_visible_horizontal(GTK_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_action_set_visible_vertical(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible_vertical", NULL };
    int visible_vertical;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Action.set_visible_vertical", kwlist, &visible_vertical))
        return NULL;
    
    gtk_action_set_visible_vertical(GTK_ACTION(self->obj), visible_vertical);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_visible_vertical(PyGObject *self)
{
    int ret;

    
    ret = gtk_action_get_visible_vertical(GTK_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_action_set_is_important(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "is_important", NULL };
    int is_important;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Action.set_is_important", kwlist, &is_important))
        return NULL;
    
    gtk_action_set_is_important(GTK_ACTION(self->obj), is_important);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_is_important(PyGObject *self)
{
    int ret;

    
    ret = gtk_action_get_is_important(GTK_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_action_set_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Action.set_label", kwlist, &label))
        return NULL;
    
    gtk_action_set_label(GTK_ACTION(self->obj), label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_label(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_action_get_label(GTK_ACTION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_set_short_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "short_label", NULL };
    char *short_label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Action.set_short_label", kwlist, &short_label))
        return NULL;
    
    gtk_action_set_short_label(GTK_ACTION(self->obj), short_label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_short_label(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_action_get_short_label(GTK_ACTION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_set_tooltip(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tooltip", NULL };
    char *tooltip;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Action.set_tooltip", kwlist, &tooltip))
        return NULL;
    
    gtk_action_set_tooltip(GTK_ACTION(self->obj), tooltip);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_tooltip(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_action_get_tooltip(GTK_ACTION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_set_stock_id(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", NULL };
    char *stock_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Action.set_stock_id", kwlist, &stock_id))
        return NULL;
    
    gtk_action_set_stock_id(GTK_ACTION(self->obj), stock_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_stock_id(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_action_get_stock_id(GTK_ACTION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_get_always_show_image(PyGObject *self)
{
    int ret;

    
    ret = gtk_action_get_always_show_image(GTK_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_action_set_always_show_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "always_show", NULL };
    int always_show;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Action.set_always_show_image", kwlist, &always_show))
        return NULL;
    
    gtk_action_set_always_show_image(GTK_ACTION(self->obj), always_show);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 8363 "./gtk.override"
static PyObject *
_wrap_gtk_action_set_tool_item_type(PyObject *cls,
                                    PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "tool_item_type", NULL };
    GType gtype, tool_item_type;
    GtkActionClass *klass;
    PyObject *py_tool_item_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.Action.set_tool_item_type", kwlist,
				     &py_tool_item_type))
	return NULL;

    if ((gtype = pyg_type_from_object(cls)) == 0)
        return NULL;

    if (!PyType_Check(py_tool_item_type)
        || !PyType_IsSubtype((PyTypeObject *) py_tool_item_type, &PyGtkToolItem_Type)) {
        PyErr_SetString(PyExc_TypeError, "argument must be a subtype of gtk.ToolItem");
        return NULL;
    }

    if ((tool_item_type = pyg_type_from_object(py_tool_item_type)) == 0)
        return NULL;

    klass = (GtkActionClass *) g_type_class_ref(gtype);
    klass->toolbar_item_type = tool_item_type;
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 26515 "gtk.c"


#line 8327 "./gtk.override"
static PyObject *
_wrap_gtk_action_set_menu_item_type(PyObject *cls,
                                    PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "menu_item_type", NULL };
    GType gtype, menu_item_type;
    GtkActionClass *klass;
    PyObject *py_menu_item_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.Action.set_menu_item_type", kwlist,
				     &py_menu_item_type))
	return NULL;

    if ((gtype = pyg_type_from_object(cls)) == 0)
        return NULL;

    if (!PyType_Check(py_menu_item_type)
        || !PyType_IsSubtype((PyTypeObject *) py_menu_item_type, &PyGtkMenuItem_Type)) {
        PyErr_SetString(PyExc_TypeError, "argument must be a subtype of gtk.MenuItem");
        return NULL;
    }

    if ((menu_item_type = pyg_type_from_object(py_menu_item_type)) == 0)
        return NULL;

    klass = (GtkActionClass *) g_type_class_ref(gtype);
    klass->menu_item_type = menu_item_type;
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 26553 "gtk.c"


static PyObject *
_wrap_GtkAction__do_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Action.activate", kwlist, &PyGtkAction_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ACTION_CLASS(klass)->activate)
        GTK_ACTION_CLASS(klass)->activate(GTK_ACTION(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Action.activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkAction__do_connect_proxy(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "proxy", NULL };
    PyGObject *self, *proxy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Action.connect_proxy", kwlist, &PyGtkAction_Type, &self, &PyGtkWidget_Type, &proxy))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ACTION_CLASS(klass)->connect_proxy)
        GTK_ACTION_CLASS(klass)->connect_proxy(GTK_ACTION(self->obj), GTK_WIDGET(proxy->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Action.connect_proxy not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkAction__do_create_menu_item(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Action.create_menu_item", kwlist, &PyGtkAction_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ACTION_CLASS(klass)->create_menu_item)
        ret = GTK_ACTION_CLASS(klass)->create_menu_item(GTK_ACTION(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Action.create_menu_item not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkAction__do_create_tool_item(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Action.create_tool_item", kwlist, &PyGtkAction_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ACTION_CLASS(klass)->create_tool_item)
        ret = GTK_ACTION_CLASS(klass)->create_tool_item(GTK_ACTION(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Action.create_tool_item not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkAction__do_disconnect_proxy(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "proxy", NULL };
    PyGObject *self, *proxy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Action.disconnect_proxy", kwlist, &PyGtkAction_Type, &self, &PyGtkWidget_Type, &proxy))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ACTION_CLASS(klass)->disconnect_proxy)
        GTK_ACTION_CLASS(klass)->disconnect_proxy(GTK_ACTION(self->obj), GTK_WIDGET(proxy->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Action.disconnect_proxy not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkAction_methods[] = {
    { "get_name", (PyCFunction)_wrap_gtk_action_get_name, METH_NOARGS,
      NULL },
    { "is_sensitive", (PyCFunction)_wrap_gtk_action_is_sensitive, METH_NOARGS,
      NULL },
    { "get_sensitive", (PyCFunction)_wrap_gtk_action_get_sensitive, METH_NOARGS,
      NULL },
    { "is_visible", (PyCFunction)_wrap_gtk_action_is_visible, METH_NOARGS,
      NULL },
    { "get_visible", (PyCFunction)_wrap_gtk_action_get_visible, METH_NOARGS,
      NULL },
    { "activate", (PyCFunction)_wrap_gtk_action_activate, METH_NOARGS,
      NULL },
    { "create_icon", (PyCFunction)_wrap_gtk_action_create_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "create_menu_item", (PyCFunction)_wrap_gtk_action_create_menu_item, METH_NOARGS,
      NULL },
    { "create_tool_item", (PyCFunction)_wrap_gtk_action_create_tool_item, METH_NOARGS,
      NULL },
    { "connect_proxy", (PyCFunction)_wrap_gtk_action_connect_proxy, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "disconnect_proxy", (PyCFunction)_wrap_gtk_action_disconnect_proxy, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_proxies", (PyCFunction)_wrap_gtk_action_get_proxies, METH_NOARGS,
      NULL },
    { "connect_accelerator", (PyCFunction)_wrap_gtk_action_connect_accelerator, METH_NOARGS,
      NULL },
    { "disconnect_accelerator", (PyCFunction)_wrap_gtk_action_disconnect_accelerator, METH_NOARGS,
      NULL },
    { "get_accel_path", (PyCFunction)_wrap_gtk_action_get_accel_path, METH_NOARGS,
      NULL },
    { "block_activate_from", (PyCFunction)_wrap_gtk_action_block_activate_from, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unblock_activate_from", (PyCFunction)_wrap_gtk_action_unblock_activate_from, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_accel_path", (PyCFunction)_wrap_gtk_action_set_accel_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_accel_group", (PyCFunction)_wrap_gtk_action_set_accel_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_sensitive", (PyCFunction)_wrap_gtk_action_set_sensitive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_visible", (PyCFunction)_wrap_gtk_action_set_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_accel_closure", (PyCFunction)_wrap_gtk_action_get_accel_closure, METH_NOARGS,
      NULL },
    { "create_menu", (PyCFunction)_wrap_gtk_action_create_menu, METH_NOARGS,
      NULL },
    { "block_activate", (PyCFunction)_wrap_gtk_action_block_activate, METH_NOARGS,
      NULL },
    { "unblock_activate", (PyCFunction)_wrap_gtk_action_unblock_activate, METH_NOARGS,
      NULL },
    { "set_gicon", (PyCFunction)_wrap_gtk_action_set_gicon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_gicon", (PyCFunction)_wrap_gtk_action_get_gicon, METH_NOARGS,
      NULL },
    { "set_icon_name", (PyCFunction)_wrap_gtk_action_set_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_name", (PyCFunction)_wrap_gtk_action_get_icon_name, METH_NOARGS,
      NULL },
    { "set_visible_horizontal", (PyCFunction)_wrap_gtk_action_set_visible_horizontal, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible_horizontal", (PyCFunction)_wrap_gtk_action_get_visible_horizontal, METH_NOARGS,
      NULL },
    { "set_visible_vertical", (PyCFunction)_wrap_gtk_action_set_visible_vertical, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible_vertical", (PyCFunction)_wrap_gtk_action_get_visible_vertical, METH_NOARGS,
      NULL },
    { "set_is_important", (PyCFunction)_wrap_gtk_action_set_is_important, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_is_important", (PyCFunction)_wrap_gtk_action_get_is_important, METH_NOARGS,
      NULL },
    { "set_label", (PyCFunction)_wrap_gtk_action_set_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label", (PyCFunction)_wrap_gtk_action_get_label, METH_NOARGS,
      NULL },
    { "set_short_label", (PyCFunction)_wrap_gtk_action_set_short_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_short_label", (PyCFunction)_wrap_gtk_action_get_short_label, METH_NOARGS,
      NULL },
    { "set_tooltip", (PyCFunction)_wrap_gtk_action_set_tooltip, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tooltip", (PyCFunction)_wrap_gtk_action_get_tooltip, METH_NOARGS,
      NULL },
    { "set_stock_id", (PyCFunction)_wrap_gtk_action_set_stock_id, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_stock_id", (PyCFunction)_wrap_gtk_action_get_stock_id, METH_NOARGS,
      NULL },
    { "get_always_show_image", (PyCFunction)_wrap_gtk_action_get_always_show_image, METH_NOARGS,
      NULL },
    { "set_always_show_image", (PyCFunction)_wrap_gtk_action_set_always_show_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tool_item_type", (PyCFunction)_wrap_gtk_action_set_tool_item_type, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "set_menu_item_type", (PyCFunction)_wrap_gtk_action_set_menu_item_type, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_activate", (PyCFunction)_wrap_GtkAction__do_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_connect_proxy", (PyCFunction)_wrap_GtkAction__do_connect_proxy, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_create_menu_item", (PyCFunction)_wrap_GtkAction__do_create_menu_item, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_create_tool_item", (PyCFunction)_wrap_GtkAction__do_create_tool_item, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_disconnect_proxy", (PyCFunction)_wrap_GtkAction__do_disconnect_proxy, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkAction_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Action",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkAction_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_action_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkAction__proxy_do_activate(GtkAction *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkAction__proxy_do_connect_proxy(GtkAction *self, GtkWidget*proxy)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_proxy = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (proxy)
        py_proxy = pygobject_new((GObject *) proxy);
    else {
        Py_INCREF(Py_None);
        py_proxy = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_proxy);
    
    py_method = PyObject_GetAttrString(py_self, "do_connect_proxy");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GtkWidget*
_wrap_GtkAction__proxy_do_create_menu_item(GtkAction *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkWidget* retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_create_menu_item");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkWidget*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static GtkWidget*
_wrap_GtkAction__proxy_do_create_tool_item(GtkAction *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkWidget* retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_create_tool_item");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkWidget*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkAction__proxy_do_disconnect_proxy(GtkAction *self, GtkWidget*proxy)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_proxy = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (proxy)
        py_proxy = pygobject_new((GObject *) proxy);
    else {
        Py_INCREF(Py_None);
        py_proxy = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_proxy);
    
    py_method = PyObject_GetAttrString(py_self, "do_disconnect_proxy");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkAction_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkActionClass *klass = GTK_ACTION_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate")))
            klass->activate = _wrap_GtkAction__proxy_do_activate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_connect_proxy");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "connect_proxy")))
            klass->connect_proxy = _wrap_GtkAction__proxy_do_connect_proxy;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_create_menu_item");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "create_menu_item")))
            klass->create_menu_item = _wrap_GtkAction__proxy_do_create_menu_item;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_create_tool_item");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "create_tool_item")))
            klass->create_tool_item = _wrap_GtkAction__proxy_do_create_tool_item;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_disconnect_proxy");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "disconnect_proxy")))
            klass->disconnect_proxy = _wrap_GtkAction__proxy_do_disconnect_proxy;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkActionGroup ----------- */

 static int
_wrap_gtk_action_group_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"name", NULL };
    char *prop_names[] = {"name", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:gtk.ActionGroup.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.ActionGroup object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_action_group_get_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_action_group_get_name(GTK_ACTION_GROUP(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_group_get_sensitive(PyGObject *self)
{
    int ret;

    
    ret = gtk_action_group_get_sensitive(GTK_ACTION_GROUP(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_action_group_set_sensitive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sensitive", NULL };
    int sensitive;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ActionGroup.set_sensitive", kwlist, &sensitive))
        return NULL;
    
    gtk_action_group_set_sensitive(GTK_ACTION_GROUP(self->obj), sensitive);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_group_get_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_action_group_get_visible(GTK_ACTION_GROUP(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_action_group_set_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible", NULL };
    int visible;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ActionGroup.set_visible", kwlist, &visible))
        return NULL;
    
    gtk_action_group_set_visible(GTK_ACTION_GROUP(self->obj), visible);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_group_get_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action_name", NULL };
    char *action_name;
    GtkAction *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ActionGroup.get_action", kwlist, &action_name))
        return NULL;
    
    ret = gtk_action_group_get_action(GTK_ACTION_GROUP(self->obj), action_name);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 4293 "./gtk.override"
static PyObject *
_wrap_gtk_action_group_list_actions(PyGObject *self)
{
    GList *l, *actions;
    PyObject *item, *ret;

    ret = PyList_New(0);
    if (ret == NULL)
	return NULL;
    
    actions = gtk_action_group_list_actions(GTK_ACTION_GROUP(self->obj));

    for (l = actions; l; l = l->next) {
        item = pygobject_new((GObject *) GTK_ACTION(l->data));

        if (!item) {
            Py_DECREF(ret);
            return NULL;
        }

        PyList_Append(ret, item);
        Py_DECREF(item);
    }

    g_list_free(actions);
    
    return ret;
}
#line 27325 "gtk.c"


static PyObject *
_wrap_gtk_action_group_add_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", NULL };
    PyGObject *action;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ActionGroup.add_action", kwlist, &PyGtkAction_Type, &action))
        return NULL;
    
    gtk_action_group_add_action(GTK_ACTION_GROUP(self->obj), GTK_ACTION(action->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_group_add_action_with_accel(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", "accelerator", NULL };
    PyGObject *action;
    char *accelerator;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!z:Gtk.ActionGroup.add_action_with_accel", kwlist, &PyGtkAction_Type, &action, &accelerator))
        return NULL;
    
    gtk_action_group_add_action_with_accel(GTK_ACTION_GROUP(self->obj), GTK_ACTION(action->obj), accelerator);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_group_remove_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", NULL };
    PyGObject *action;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ActionGroup.remove_action", kwlist, &PyGtkAction_Type, &action))
        return NULL;
    
    gtk_action_group_remove_action(GTK_ACTION_GROUP(self->obj), GTK_ACTION(action->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4042 "./gtk.override"
static PyObject *
_wrap_gtk_action_group_add_actions (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "user_data", NULL };
    PyGILState_STATE state;
    PyObject *entries, *extra_args = NULL;
    int len, i;
    PyObject *item;
    GtkActionEntry entry;
    GtkAction *action;
    PyObject *callback, *py_action;
    GClosure *closure;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:GtkActionGroup.add_actions",
				     kwlist, &entries, &extra_args))
        return NULL;
    
    if (!PySequence_Check(entries)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    state = pyg_gil_state_ensure();
    
    len = PySequence_Size(entries);
    for (i = 0; i < len; i++) {
	item = PySequence_GetItem(entries, i);
        Py_DECREF(item);

        memset(&entry, 0, sizeof(entry));
        callback = Py_None;
	
        if (!PyArg_ParseTuple(item, "s|zzzzO", &(entry.name), &(entry.stock_id),
			      &(entry.label), &(entry.accelerator), &(entry.tooltip),
			      &callback)) {
            return NULL;
        }

	action = gtk_action_new(entry.name, entry.label, entry.tooltip,
				entry.stock_id);
	if (action == NULL) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GtkAction object");
	    return NULL;
	}
	    
	py_action = pygobject_new((GObject *)action);
	if (callback != Py_None) {
	    if (PyCallable_Check(callback)) {
		closure = pyg_closure_new(callback, extra_args, NULL);
		g_signal_connect_closure(action, "activate", closure, FALSE);
		pygobject_watch_closure(py_action, closure);
	    } else {
		PyErr_SetString(PyExc_TypeError,
				"One or more entry is missing a callback type");
		g_object_unref (action);
		Py_DECREF (py_action);
		return NULL;
	    }
	}
	
	gtk_action_group_add_action_with_accel (GTK_ACTION_GROUP(self->obj),
						GTK_ACTION(action),
						entry.accelerator);
	
	g_object_unref(action);
	Py_DECREF (py_action);
    }

    pyg_gil_state_release(state);
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 27449 "gtk.c"


#line 4118 "./gtk.override"
static PyObject *
_wrap_gtk_action_group_add_toggle_actions (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "user_data", NULL };
    PyGILState_STATE state;
    PyObject *entries, *extra_args = NULL;
    int len, i;
    PyObject *item;
    GtkToggleActionEntry entry;
    GtkToggleAction *action;
    PyObject *callback, *py_action;
    GClosure *closure;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:GtkActionGroup.add_toggle_actions",
				     kwlist, &entries, &extra_args))
        return NULL;
    
    if (!PySequence_Check(entries)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    state = pyg_gil_state_ensure();

    len = PySequence_Size(entries);
    for (i = 0; i < len; i++) {
	item = PySequence_GetItem(entries, i);
        Py_DECREF(item);

        memset(&entry, 0, sizeof(entry));
        callback = Py_None;
	
        if (!PyArg_ParseTuple(item, "s|zzzzOi", &(entry.name), &(entry.stock_id),
			      &(entry.label), &(entry.accelerator), &(entry.tooltip),
			      &callback, &(entry.is_active))) {
            return NULL;
        }

	action = gtk_toggle_action_new(entry.name, entry.label, entry.tooltip,
				       entry.stock_id);
	if (action == NULL) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GtkToggleAction object");
	    return NULL;
	}

	gtk_toggle_action_set_active(action, entry.is_active);
	py_action = pygobject_new((GObject *)action);
	if (callback != Py_None && PyCallable_Check(callback)) {
	    closure = pyg_closure_new(callback, extra_args, NULL);
	    g_signal_connect_closure(action, "activate", closure, FALSE);
	    pygobject_watch_closure(py_action, closure);
	}
	
	gtk_action_group_add_action_with_accel (GTK_ACTION_GROUP(self->obj),
						GTK_ACTION(action),
						entry.accelerator);
	
	g_object_unref (action);
	Py_DECREF (py_action);
    }

    pyg_gil_state_release(state);
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 27520 "gtk.c"


#line 4187 "./gtk.override"
static PyObject *
_wrap_gtk_action_group_add_radio_actions (PyGObject *self, PyObject *args,
					  PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "value", "on_change", "user_data", NULL };
    PyGILState_STATE state;
    PyObject *entries, *extra_args = NULL;
    int len, i;
    PyObject *item;
    GtkRadioActionEntry entry;
    GtkRadioAction *action, *first_action = NULL;
    PyObject *callback = Py_None;
    GClosure *closure;
    GSList * group = NULL;
    gint value = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|iOO:GtkActionGroup.add_radio_actions",
				     kwlist, &entries, &value, &callback, &extra_args))
        return NULL;
    
    if (!PySequence_Check(entries)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    state = pyg_gil_state_ensure();
    
    len = PySequence_Size(entries);
    for (i = 0; i < len; i++) {
	item = PySequence_GetItem(entries, i);
        Py_DECREF(item);

        memset(&entry, 0, sizeof(entry));
	
        if (!PyArg_ParseTuple(item, "s|zzzzi", &(entry.name),
			      &(entry.stock_id),
			      &(entry.label), &(entry.accelerator),
			      &(entry.tooltip),
			      &(entry.value))) {
            return NULL;
        }

	action = gtk_radio_action_new(entry.name, entry.label, entry.tooltip,
				      entry.stock_id, entry.value);
	if (action == NULL) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GtkRadioAction object");
	    return NULL;
	}

	gtk_radio_action_set_group(action, group);
	group = gtk_radio_action_get_group(action);

	if (value == entry.value)
	    gtk_toggle_action_set_active(GTK_TOGGLE_ACTION(action), TRUE);

	gtk_action_group_add_action_with_accel (GTK_ACTION_GROUP(self->obj),
						GTK_ACTION(action),
						entry.accelerator);
	
	if (i == 0)
	    first_action = action;
	else
	    g_object_unref (action);
    }

    if (first_action && callback != Py_None && PyCallable_Check(callback)) {
	PyObject *py_action;

	closure = pyg_closure_new(callback, extra_args, NULL);
	g_signal_connect_closure(first_action, "changed", closure, FALSE);
	py_action = pygobject_new((GObject *)first_action);
	pygobject_watch_closure(py_action, closure);
	g_object_unref(first_action);
	Py_DECREF (py_action);
    }
    
    pyg_gil_state_release(state);
	
    Py_INCREF(Py_None);
    return Py_None;
}
#line 27607 "gtk.c"


static PyObject *
_wrap_gtk_action_group_set_translation_domain(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "domain", NULL };
    char *domain;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ActionGroup.set_translation_domain", kwlist, &domain))
        return NULL;
    
    gtk_action_group_set_translation_domain(GTK_ACTION_GROUP(self->obj), domain);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_action_group_translate_string(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "string", NULL };
    char *string;
    const gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ActionGroup.translate_string", kwlist, &string))
        return NULL;
    
    ret = gtk_action_group_translate_string(GTK_ACTION_GROUP(self->obj), string);
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkActionGroup__do_get_action(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "action_name", NULL };
    PyGObject *self;
    char *action_name;
    GtkAction *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.ActionGroup.get_action", kwlist, &PyGtkActionGroup_Type, &self, &action_name))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ACTION_GROUP_CLASS(klass)->get_action)
        ret = GTK_ACTION_GROUP_CLASS(klass)->get_action(GTK_ACTION_GROUP(self->obj), action_name);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ActionGroup.get_action not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkActionGroup_methods[] = {
    { "get_name", (PyCFunction)_wrap_gtk_action_group_get_name, METH_NOARGS,
      NULL },
    { "get_sensitive", (PyCFunction)_wrap_gtk_action_group_get_sensitive, METH_NOARGS,
      NULL },
    { "set_sensitive", (PyCFunction)_wrap_gtk_action_group_set_sensitive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible", (PyCFunction)_wrap_gtk_action_group_get_visible, METH_NOARGS,
      NULL },
    { "set_visible", (PyCFunction)_wrap_gtk_action_group_set_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_action", (PyCFunction)_wrap_gtk_action_group_get_action, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "list_actions", (PyCFunction)_wrap_gtk_action_group_list_actions, METH_NOARGS,
      NULL },
    { "add_action", (PyCFunction)_wrap_gtk_action_group_add_action, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_action_with_accel", (PyCFunction)_wrap_gtk_action_group_add_action_with_accel, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_action", (PyCFunction)_wrap_gtk_action_group_remove_action, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_actions", (PyCFunction)_wrap_gtk_action_group_add_actions, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_toggle_actions", (PyCFunction)_wrap_gtk_action_group_add_toggle_actions, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_radio_actions", (PyCFunction)_wrap_gtk_action_group_add_radio_actions, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_translation_domain", (PyCFunction)_wrap_gtk_action_group_set_translation_domain, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "translate_string", (PyCFunction)_wrap_gtk_action_group_translate_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_get_action", (PyCFunction)_wrap_GtkActionGroup__do_get_action, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkActionGroup_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ActionGroup",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkActionGroup_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_action_group_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static GtkAction*
_wrap_GtkActionGroup__proxy_do_get_action(GtkActionGroup *self, const gchar*action_name)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_action_name = NULL;
    GtkAction* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (action_name)
        py_action_name = PyString_FromString(action_name);
    if (!py_action_name) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_action_name);
    
    py_method = PyObject_GetAttrString(py_self, "do_get_action");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkAction*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkActionGroup_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkActionGroupClass *klass = GTK_ACTION_GROUP_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_get_action");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "get_action")))
            klass->get_action = _wrap_GtkActionGroup__proxy_do_get_action;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkAdjustment ----------- */

#line 5576 "./gtk.override"
static int
_wrap_gtk_adjustment_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *kwlist[] = {"value", "lower", "upper", "step_incr",
                      "page_incr", "page_size", NULL };
    gdouble value = 0;
    gdouble lower = 0;
    gdouble upper = 0;
    gdouble step_incr = 0;
    gdouble page_incr = 0;
    gdouble page_size = 0;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|dddddd:gtk.Adjustment.__init__" ,
                                     kwlist, &value, &lower, &upper, &step_incr,
                                     &page_incr, &page_size))
        return -1;

    pygobject_construct(self, "lower", lower, "upper", upper,
                        "step_increment", step_incr,
                        "page_increment", page_incr,
                        "page_size", page_size,
                        "value", value, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create gtk.Adjustment object");
        return -1;
    }
    return 0;
}
#line 27876 "gtk.c"


#line 3317 "./gtk.override"
static PyObject *
_wrap_gtk_adjustment_set_all(PyGObject *self,
			     PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "value", "lower", "upper", "step_increment",
			      "page_increment", "page_size", NULL };
    GtkAdjustment *adj = GTK_ADJUSTMENT(self->obj);
    double *value = &adj->value, *lower = &adj->lower, *upper = &adj->upper;
    double *step_increment = &adj->step_increment;
    double *page_increment = &adj->page_increment;
    double *page_size = &adj->page_size;
    double old_value = *value, old_lower = *lower, old_upper = *upper;
    double old_step_increment = *step_increment;
    double old_page_increment = *page_increment;
    double old_page_size = *page_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|dddddd:gtk_adjustment_set_all",
				     kwlist,
				     value, lower, upper, step_increment,
				     page_increment, page_size)) {
        adj->value = old_value;
        adj->lower = old_lower;
        adj->upper = old_upper;
        adj->step_increment = old_step_increment;
        adj->page_increment = old_page_increment;
        adj->page_size = old_page_size;
        return NULL;
    }
    
    if (adj->value != old_value)
        gtk_adjustment_value_changed(adj);
    if (adj->lower != old_lower || adj->upper != old_upper
	|| adj->step_increment != old_step_increment
	|| adj->page_increment != old_page_increment
	|| adj->page_size != old_page_size)
        gtk_adjustment_changed(adj);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 27922 "gtk.c"


static PyObject *
_wrap_gtk_adjustment_changed(PyGObject *self)
{
    
    gtk_adjustment_changed(GTK_ADJUSTMENT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_adjustment_value_changed(PyGObject *self)
{
    
    gtk_adjustment_value_changed(GTK_ADJUSTMENT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_adjustment_clamp_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "lower", "upper", NULL };
    double lower, upper;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dd:Gtk.Adjustment.clamp_page", kwlist, &lower, &upper))
        return NULL;
    
    gtk_adjustment_clamp_page(GTK_ADJUSTMENT(self->obj), lower, upper);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_adjustment_get_value(PyGObject *self)
{
    double ret;

    
    ret = gtk_adjustment_get_value(GTK_ADJUSTMENT(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_adjustment_set_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    double value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Adjustment.set_value", kwlist, &value))
        return NULL;
    
    gtk_adjustment_set_value(GTK_ADJUSTMENT(self->obj), value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_adjustment_get_lower(PyGObject *self)
{
    double ret;

    
    ret = gtk_adjustment_get_lower(GTK_ADJUSTMENT(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_adjustment_set_lower(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "lower", NULL };
    double lower;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Adjustment.set_lower", kwlist, &lower))
        return NULL;
    
    gtk_adjustment_set_lower(GTK_ADJUSTMENT(self->obj), lower);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_adjustment_get_upper(PyGObject *self)
{
    double ret;

    
    ret = gtk_adjustment_get_upper(GTK_ADJUSTMENT(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_adjustment_set_upper(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "upper", NULL };
    double upper;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Adjustment.set_upper", kwlist, &upper))
        return NULL;
    
    gtk_adjustment_set_upper(GTK_ADJUSTMENT(self->obj), upper);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_adjustment_get_step_increment(PyGObject *self)
{
    double ret;

    
    ret = gtk_adjustment_get_step_increment(GTK_ADJUSTMENT(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_adjustment_set_step_increment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "step_increment", NULL };
    double step_increment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Adjustment.set_step_increment", kwlist, &step_increment))
        return NULL;
    
    gtk_adjustment_set_step_increment(GTK_ADJUSTMENT(self->obj), step_increment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_adjustment_get_page_increment(PyGObject *self)
{
    double ret;

    
    ret = gtk_adjustment_get_page_increment(GTK_ADJUSTMENT(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_adjustment_set_page_increment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_increment", NULL };
    double page_increment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Adjustment.set_page_increment", kwlist, &page_increment))
        return NULL;
    
    gtk_adjustment_set_page_increment(GTK_ADJUSTMENT(self->obj), page_increment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_adjustment_get_page_size(PyGObject *self)
{
    double ret;

    
    ret = gtk_adjustment_get_page_size(GTK_ADJUSTMENT(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_adjustment_set_page_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_size", NULL };
    double page_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Adjustment.set_page_size", kwlist, &page_size))
        return NULL;
    
    gtk_adjustment_set_page_size(GTK_ADJUSTMENT(self->obj), page_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_adjustment_configure(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", "lower", "upper", "step_increment", "page_increment", "page_size", NULL };
    double value, lower, upper, step_increment, page_increment, page_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dddddd:Gtk.Adjustment.configure", kwlist, &value, &lower, &upper, &step_increment, &page_increment, &page_size))
        return NULL;
    
    gtk_adjustment_configure(GTK_ADJUSTMENT(self->obj), value, lower, upper, step_increment, page_increment, page_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkAdjustment__do_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Adjustment.changed", kwlist, &PyGtkAdjustment_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ADJUSTMENT_CLASS(klass)->changed)
        GTK_ADJUSTMENT_CLASS(klass)->changed(GTK_ADJUSTMENT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Adjustment.changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkAdjustment__do_value_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Adjustment.value_changed", kwlist, &PyGtkAdjustment_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ADJUSTMENT_CLASS(klass)->value_changed)
        GTK_ADJUSTMENT_CLASS(klass)->value_changed(GTK_ADJUSTMENT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Adjustment.value_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkAdjustment_methods[] = {
    { "set_all", (PyCFunction)_wrap_gtk_adjustment_set_all, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "changed", (PyCFunction)_wrap_gtk_adjustment_changed, METH_NOARGS,
      NULL },
    { "value_changed", (PyCFunction)_wrap_gtk_adjustment_value_changed, METH_NOARGS,
      NULL },
    { "clamp_page", (PyCFunction)_wrap_gtk_adjustment_clamp_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_value", (PyCFunction)_wrap_gtk_adjustment_get_value, METH_NOARGS,
      NULL },
    { "set_value", (PyCFunction)_wrap_gtk_adjustment_set_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_lower", (PyCFunction)_wrap_gtk_adjustment_get_lower, METH_NOARGS,
      NULL },
    { "set_lower", (PyCFunction)_wrap_gtk_adjustment_set_lower, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_upper", (PyCFunction)_wrap_gtk_adjustment_get_upper, METH_NOARGS,
      NULL },
    { "set_upper", (PyCFunction)_wrap_gtk_adjustment_set_upper, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_step_increment", (PyCFunction)_wrap_gtk_adjustment_get_step_increment, METH_NOARGS,
      NULL },
    { "set_step_increment", (PyCFunction)_wrap_gtk_adjustment_set_step_increment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_increment", (PyCFunction)_wrap_gtk_adjustment_get_page_increment, METH_NOARGS,
      NULL },
    { "set_page_increment", (PyCFunction)_wrap_gtk_adjustment_set_page_increment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_size", (PyCFunction)_wrap_gtk_adjustment_get_page_size, METH_NOARGS,
      NULL },
    { "set_page_size", (PyCFunction)_wrap_gtk_adjustment_set_page_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "configure", (PyCFunction)_wrap_gtk_adjustment_configure, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_changed", (PyCFunction)_wrap_GtkAdjustment__do_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_value_changed", (PyCFunction)_wrap_GtkAdjustment__do_value_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 3237 "./gtk.override"
static int
_wrap_gtk_adjustment__set_value(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->value, "value"))
        return -1;
    gtk_adjustment_value_changed(adjustment);
    return 0;
}
#line 28229 "gtk.c"


static PyObject *
_wrap_gtk_adjustment__get_value(PyObject *self, void *closure)
{
    double ret;

    ret = GTK_ADJUSTMENT(pygobject_get(self))->value;
    return PyFloat_FromDouble(ret);
}

#line 3250 "./gtk.override"
static int
_wrap_gtk_adjustment__set_lower(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->lower, "lower"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
#line 28253 "gtk.c"


static PyObject *
_wrap_gtk_adjustment__get_lower(PyObject *self, void *closure)
{
    double ret;

    ret = GTK_ADJUSTMENT(pygobject_get(self))->lower;
    return PyFloat_FromDouble(ret);
}

#line 3263 "./gtk.override"
static int
_wrap_gtk_adjustment__set_upper(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->upper, "upper"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
#line 28277 "gtk.c"


static PyObject *
_wrap_gtk_adjustment__get_upper(PyObject *self, void *closure)
{
    double ret;

    ret = GTK_ADJUSTMENT(pygobject_get(self))->upper;
    return PyFloat_FromDouble(ret);
}

#line 3276 "./gtk.override"
static int
_wrap_gtk_adjustment__set_step_increment(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->step_increment,
                                       "step_increment"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
#line 28302 "gtk.c"


static PyObject *
_wrap_gtk_adjustment__get_step_increment(PyObject *self, void *closure)
{
    double ret;

    ret = GTK_ADJUSTMENT(pygobject_get(self))->step_increment;
    return PyFloat_FromDouble(ret);
}

#line 3290 "./gtk.override"
static int
_wrap_gtk_adjustment__set_page_increment(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->page_increment,
                                       "page_increment"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
#line 28327 "gtk.c"


static PyObject *
_wrap_gtk_adjustment__get_page_increment(PyObject *self, void *closure)
{
    double ret;

    ret = GTK_ADJUSTMENT(pygobject_get(self))->page_increment;
    return PyFloat_FromDouble(ret);
}

#line 3304 "./gtk.override"
static int
_wrap_gtk_adjustment__set_page_size(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!pygtk_util_pyobject_as_double(value, &adjustment->page_size, "page_size"))
        return -1;
    gtk_adjustment_changed(adjustment);
    return 0;
}
#line 28351 "gtk.c"


static PyObject *
_wrap_gtk_adjustment__get_page_size(PyObject *self, void *closure)
{
    double ret;

    ret = GTK_ADJUSTMENT(pygobject_get(self))->page_size;
    return PyFloat_FromDouble(ret);
}

static const PyGetSetDef gtk_adjustment_getsets[] = {
    { "value", (getter)_wrap_gtk_adjustment__get_value, (setter)_wrap_gtk_adjustment__set_value },
    { "lower", (getter)_wrap_gtk_adjustment__get_lower, (setter)_wrap_gtk_adjustment__set_lower },
    { "upper", (getter)_wrap_gtk_adjustment__get_upper, (setter)_wrap_gtk_adjustment__set_upper },
    { "step_increment", (getter)_wrap_gtk_adjustment__get_step_increment, (setter)_wrap_gtk_adjustment__set_step_increment },
    { "page_increment", (getter)_wrap_gtk_adjustment__get_page_increment, (setter)_wrap_gtk_adjustment__set_page_increment },
    { "page_size", (getter)_wrap_gtk_adjustment__get_page_size, (setter)_wrap_gtk_adjustment__set_page_size },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkAdjustment_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Adjustment",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkAdjustment_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_adjustment_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_adjustment_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkAdjustment__proxy_do_changed(GtkAdjustment *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkAdjustment__proxy_do_value_changed(GtkAdjustment *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_value_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkAdjustment_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkAdjustmentClass *klass = GTK_ADJUSTMENT_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "changed")))
            klass->changed = _wrap_GtkAdjustment__proxy_do_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_value_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "value_changed")))
            klass->value_changed = _wrap_GtkAdjustment__proxy_do_value_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkAlignment ----------- */

#line 5610 "./gtk.override"
static int
_wrap_gtk_alignment_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *kwlist[] = {"xalign", "yalign", "xscale", "yscale", NULL };
    gdouble xalign = 0;
    gdouble yalign = 0;
    gdouble xscale = 0;
    gdouble yscale = 0;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|dddd:gtk.Alignment.__init__" ,
                                     kwlist, &xalign, &yalign, &xscale, &yscale))
        return -1;

    pygobject_construct(self, "xalign", xalign, "yalign", yalign,
                        "xscale", xscale, "yscale", yscale, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create gtk.Alignment object");
        return -1;
    }
    return 0;
}
#line 28579 "gtk.c"


static PyObject *
_wrap_gtk_alignment_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "xalign", "yalign", "xscale", "yscale", NULL };
    double xalign, yalign, xscale, yscale;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dddd:Gtk.Alignment.set", kwlist, &xalign, &yalign, &xscale, &yscale))
        return NULL;
    
    gtk_alignment_set(GTK_ALIGNMENT(self->obj), xalign, yalign, xscale, yscale);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_alignment_set_padding(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "padding_top", "padding_bottom", "padding_left", "padding_right", NULL };
    PyObject *py_padding_top = NULL, *py_padding_bottom = NULL, *py_padding_left = NULL, *py_padding_right = NULL;
    guint padding_top = 0, padding_bottom = 0, padding_left = 0, padding_right = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOOO:Gtk.Alignment.set_padding", kwlist, &py_padding_top, &py_padding_bottom, &py_padding_left, &py_padding_right))
        return NULL;
    if (py_padding_top) {
        if (PyLong_Check(py_padding_top))
            padding_top = PyLong_AsUnsignedLong(py_padding_top);
        else if (PyInt_Check(py_padding_top))
            padding_top = PyInt_AsLong(py_padding_top);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'padding_top' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_padding_bottom) {
        if (PyLong_Check(py_padding_bottom))
            padding_bottom = PyLong_AsUnsignedLong(py_padding_bottom);
        else if (PyInt_Check(py_padding_bottom))
            padding_bottom = PyInt_AsLong(py_padding_bottom);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'padding_bottom' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_padding_left) {
        if (PyLong_Check(py_padding_left))
            padding_left = PyLong_AsUnsignedLong(py_padding_left);
        else if (PyInt_Check(py_padding_left))
            padding_left = PyInt_AsLong(py_padding_left);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'padding_left' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_padding_right) {
        if (PyLong_Check(py_padding_right))
            padding_right = PyLong_AsUnsignedLong(py_padding_right);
        else if (PyInt_Check(py_padding_right))
            padding_right = PyInt_AsLong(py_padding_right);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'padding_right' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_alignment_set_padding(GTK_ALIGNMENT(self->obj), padding_top, padding_bottom, padding_left, padding_right);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4323 "./gtk.override"
static PyObject *
_wrap_gtk_alignment_get_padding(PyGObject *self)
{
    guint top, bottom, left, right;

    gtk_alignment_get_padding(GTK_ALIGNMENT(self->obj), &top, &bottom, &left,
			      &right);
    return Py_BuildValue("(iiii)", top, bottom, left, right);
}
#line 28663 "gtk.c"


static const PyMethodDef _PyGtkAlignment_methods[] = {
    { "set", (PyCFunction)_wrap_gtk_alignment_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_padding", (PyCFunction)_wrap_gtk_alignment_set_padding, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_padding", (PyCFunction)_wrap_gtk_alignment_get_padding, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkAlignment_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Alignment",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkAlignment_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_alignment_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkArrow ----------- */

 static int
_wrap_gtk_arrow_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[2];
    PyObject *parsed_args[2] = {NULL, };
    char *arg_names[] = {"arrow_type", "shadow_type", NULL };
    char *prop_names[] = {"arrow_type", "shadow_type", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:gtk.Arrow.__init__" , arg_names , &parsed_args[0] , &parsed_args[1]))
        return -1;

    memset(params, 0, sizeof(GParameter)*2);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Arrow object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_arrow_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "arrow_type", "shadow_type", NULL };
    PyObject *py_arrow_type = NULL, *py_shadow_type = NULL;
    GtkShadowType shadow_type;
    GtkArrowType arrow_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Arrow.set", kwlist, &py_arrow_type, &py_shadow_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ARROW_TYPE, py_arrow_type, (gpointer)&arrow_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    
    gtk_arrow_set(GTK_ARROW(self->obj), arrow_type, shadow_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkArrow_methods[] = {
    { "set", (PyCFunction)_wrap_gtk_arrow_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkArrow_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Arrow",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkArrow_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_arrow_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkFrame ----------- */

 static int
_wrap_gtk_frame_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"label", NULL };
    char *prop_names[] = {"label", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.Frame.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Frame object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_frame_set_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.Frame.set_label", kwlist, &label))
        return NULL;
    
    gtk_frame_set_label(GTK_FRAME(self->obj), label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_frame_get_label(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_frame_get_label(GTK_FRAME(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_frame_set_label_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label_widget", NULL };
    PyGObject *label_widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Frame.set_label_widget", kwlist, &PyGtkWidget_Type, &label_widget))
        return NULL;
    
    gtk_frame_set_label_widget(GTK_FRAME(self->obj), GTK_WIDGET(label_widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_frame_get_label_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_frame_get_label_widget(GTK_FRAME(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_frame_set_label_align(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "xalign", "yalign", NULL };
    double xalign, yalign;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dd:Gtk.Frame.set_label_align", kwlist, &xalign, &yalign))
        return NULL;
    
    gtk_frame_set_label_align(GTK_FRAME(self->obj), xalign, yalign);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3108 "./gtk.override"
static PyObject *
_wrap_gtk_frame_get_label_align(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_frame_get_label_align(GTK_FRAME(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
#line 28941 "gtk.c"


static PyObject *
_wrap_gtk_frame_set_shadow_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    PyObject *py_type = NULL;
    GtkShadowType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Frame.set_shadow_type", kwlist, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_type, (gpointer)&type))
        return NULL;
    
    gtk_frame_set_shadow_type(GTK_FRAME(self->obj), type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_frame_get_shadow_type(PyGObject *self)
{
    gint ret;

    
    ret = gtk_frame_get_shadow_type(GTK_FRAME(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, ret);
}

static PyObject *
_wrap_GtkFrame__do_compute_child_allocation(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "allocation", NULL };
    PyGObject *self;
    PyObject *py_allocation;
    GdkRectangle allocation = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Frame.compute_child_allocation", kwlist, &PyGtkFrame_Type, &self, &py_allocation))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_allocation, &allocation))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_FRAME_CLASS(klass)->compute_child_allocation)
        GTK_FRAME_CLASS(klass)->compute_child_allocation(GTK_FRAME(self->obj), &allocation);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Frame.compute_child_allocation not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkFrame_methods[] = {
    { "set_label", (PyCFunction)_wrap_gtk_frame_set_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label", (PyCFunction)_wrap_gtk_frame_get_label, METH_NOARGS,
      NULL },
    { "set_label_widget", (PyCFunction)_wrap_gtk_frame_set_label_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label_widget", (PyCFunction)_wrap_gtk_frame_get_label_widget, METH_NOARGS,
      NULL },
    { "set_label_align", (PyCFunction)_wrap_gtk_frame_set_label_align, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label_align", (PyCFunction)_wrap_gtk_frame_get_label_align, METH_NOARGS,
      NULL },
    { "set_shadow_type", (PyCFunction)_wrap_gtk_frame_set_shadow_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_shadow_type", (PyCFunction)_wrap_gtk_frame_get_shadow_type, METH_NOARGS,
      NULL },
    { "do_compute_child_allocation", (PyCFunction)_wrap_GtkFrame__do_compute_child_allocation, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkFrame_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Frame",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkFrame_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_frame_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkFrame__proxy_do_compute_child_allocation(GtkFrame *self, GtkAllocation*allocation)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_allocation;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_allocation = pyg_boxed_new(GDK_TYPE_RECTANGLE, allocation, TRUE, TRUE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_allocation);
    
    py_method = PyObject_GetAttrString(py_self, "do_compute_child_allocation");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkFrame_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkFrameClass *klass = GTK_FRAME_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_compute_child_allocation");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "compute_child_allocation")))
            klass->compute_child_allocation = _wrap_GtkFrame__proxy_do_compute_child_allocation;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkAspectFrame ----------- */

 static int
_wrap_gtk_aspect_frame_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[5];
    PyObject *parsed_args[5] = {NULL, };
    char *arg_names[] = {"label", "xalign", "yalign", "ratio", "obey_child", NULL };
    char *prop_names[] = {"label", "xalign", "yalign", "ratio", "obey_child", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOOO:gtk.AspectFrame.__init__" , arg_names , &parsed_args[0] , &parsed_args[1] , &parsed_args[2] , &parsed_args[3] , &parsed_args[4]))
        return -1;

    memset(params, 0, sizeof(GParameter)*5);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.AspectFrame object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_aspect_frame_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "xalign", "yalign", "ratio", "obey_child", NULL };
    int obey_child = 1;
    double xalign = 0.0, yalign = 0.0, ratio = 1.0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|dddi:Gtk.AspectFrame.set", kwlist, &xalign, &yalign, &ratio, &obey_child))
        return NULL;
    
    gtk_aspect_frame_set(GTK_ASPECT_FRAME(self->obj), xalign, yalign, ratio, obey_child);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkAspectFrame_methods[] = {
    { "set", (PyCFunction)_wrap_gtk_aspect_frame_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkAspectFrame_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.AspectFrame",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkAspectFrame_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_aspect_frame_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkBox ----------- */

static PyObject *
_wrap_gtk_box_pack_start(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "expand", "fill", "padding", NULL };
    PyGObject *child;
    int expand = TRUE, fill = TRUE;
    PyObject *py_padding = NULL;
    guint padding = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|iiO:Gtk.Box.pack_start", kwlist, &PyGtkWidget_Type, &child, &expand, &fill, &py_padding))
        return NULL;
    if (py_padding) {
        if (PyLong_Check(py_padding))
            padding = PyLong_AsUnsignedLong(py_padding);
        else if (PyInt_Check(py_padding))
            padding = PyInt_AsLong(py_padding);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'padding' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_box_pack_start(GTK_BOX(self->obj), GTK_WIDGET(child->obj), expand, fill, padding);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_box_pack_end(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "expand", "fill", "padding", NULL };
    PyGObject *child;
    int expand = TRUE, fill = TRUE;
    PyObject *py_padding = NULL;
    guint padding = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|iiO:Gtk.Box.pack_end", kwlist, &PyGtkWidget_Type, &child, &expand, &fill, &py_padding))
        return NULL;
    if (py_padding) {
        if (PyLong_Check(py_padding))
            padding = PyLong_AsUnsignedLong(py_padding);
        else if (PyInt_Check(py_padding))
            padding = PyInt_AsLong(py_padding);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'padding' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_box_pack_end(GTK_BOX(self->obj), GTK_WIDGET(child->obj), expand, fill, padding);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_box_pack_start_defaults(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Box.pack_start_defaults", kwlist, &PyGtkWidget_Type, &widget))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use pack_start instead") < 0)
        return NULL;
    
    gtk_box_pack_start_defaults(GTK_BOX(self->obj), GTK_WIDGET(widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_box_pack_end_defaults(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Box.pack_end_defaults", kwlist, &PyGtkWidget_Type, &widget))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use pack_end instead") < 0)
        return NULL;
    
    gtk_box_pack_end_defaults(GTK_BOX(self->obj), GTK_WIDGET(widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_box_set_homogeneous(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "homogeneous", NULL };
    int homogeneous;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Box.set_homogeneous", kwlist, &homogeneous))
        return NULL;
    
    gtk_box_set_homogeneous(GTK_BOX(self->obj), homogeneous);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_box_get_homogeneous(PyGObject *self)
{
    int ret;

    
    ret = gtk_box_get_homogeneous(GTK_BOX(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_box_set_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "spacing", NULL };
    int spacing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Box.set_spacing", kwlist, &spacing))
        return NULL;
    
    gtk_box_set_spacing(GTK_BOX(self->obj), spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_box_get_spacing(PyGObject *self)
{
    int ret;

    
    ret = gtk_box_get_spacing(GTK_BOX(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_box_reorder_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "position", NULL };
    PyGObject *child;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Box.reorder_child", kwlist, &PyGtkWidget_Type, &child, &position))
        return NULL;
    
    gtk_box_reorder_child(GTK_BOX(self->obj), GTK_WIDGET(child->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 831 "./gtk.override"
static PyObject *
_wrap_gtk_box_query_child_packing(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *pychild;
    GtkWidget *child;
    GList *children;
    gboolean expand, fill;
    guint padding;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!:GtkBox.query_child_packing", kwlist,
                                     &PyGtkWidget_Type, &pychild)) {
        return NULL;
    }

    child = GTK_WIDGET(pychild->obj);
    children = gtk_container_get_children(GTK_CONTAINER(self->obj));
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }
    gtk_box_query_child_packing(GTK_BOX(self->obj),
                                child, &expand, &fill,
                                &padding, &pack_type);
    return Py_BuildValue("(iiiN)", (int)expand, (int)fill, padding,
			 pyg_enum_from_gtype(GTK_TYPE_PACK_TYPE, pack_type));
}
#line 29442 "gtk.c"


static PyObject *
_wrap_gtk_box_set_child_packing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "expand", "fill", "padding", "pack_type", NULL };
    PyGObject *child;
    int expand, fill;
    GtkPackType pack_type;
    PyObject *py_padding = NULL, *py_pack_type = NULL;
    guint padding = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iiOO:Gtk.Box.set_child_packing", kwlist, &PyGtkWidget_Type, &child, &expand, &fill, &py_padding, &py_pack_type))
        return NULL;
    if (py_padding) {
        if (PyLong_Check(py_padding))
            padding = PyLong_AsUnsignedLong(py_padding);
        else if (PyInt_Check(py_padding))
            padding = PyInt_AsLong(py_padding);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'padding' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_PACK_TYPE, py_pack_type, (gpointer)&pack_type))
        return NULL;
    
    gtk_box_set_child_packing(GTK_BOX(self->obj), GTK_WIDGET(child->obj), expand, fill, padding, pack_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkBox_methods[] = {
    { "pack_start", (PyCFunction)_wrap_gtk_box_pack_start, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "pack_end", (PyCFunction)_wrap_gtk_box_pack_end, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "pack_start_defaults", (PyCFunction)_wrap_gtk_box_pack_start_defaults, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "pack_end_defaults", (PyCFunction)_wrap_gtk_box_pack_end_defaults, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_homogeneous", (PyCFunction)_wrap_gtk_box_set_homogeneous, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_homogeneous", (PyCFunction)_wrap_gtk_box_get_homogeneous, METH_NOARGS,
      NULL },
    { "set_spacing", (PyCFunction)_wrap_gtk_box_set_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_spacing", (PyCFunction)_wrap_gtk_box_get_spacing, METH_NOARGS,
      NULL },
    { "reorder_child", (PyCFunction)_wrap_gtk_box_reorder_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "query_child_packing", (PyCFunction)_wrap_gtk_box_query_child_packing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_child_packing", (PyCFunction)_wrap_gtk_box_set_child_packing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkBox_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Box",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkBox_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkButton ----------- */

#line 1644 "./gtk.override"
static int
_wrap_gtk_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "stock", "use_underline", NULL };
    gchar *text = NULL, *stock = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zzO:OGtkButton.__init__",
                                     kwlist, &text, &stock, &py_use_underline))
        return -1;
    if (stock)
        pygobject_construct(self,
                            "label", stock, "use-stock", TRUE,
                            "use-underline", TRUE, NULL);
    else
        pygobject_construct(self,
                            "label", text, "use-underline",
                            PyObject_IsTrue(py_use_underline), NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkButton object");
        return -1;
    }
    return 0;
}
#line 29576 "gtk.c"


static PyObject *
_wrap_gtk_button_pressed(PyGObject *self)
{
    
    gtk_button_pressed(GTK_BUTTON(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_released(PyGObject *self)
{
    
    gtk_button_released(GTK_BUTTON(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_clicked(PyGObject *self)
{
    
    gtk_button_clicked(GTK_BUTTON(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_enter(PyGObject *self)
{
    
    gtk_button_enter(GTK_BUTTON(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_leave(PyGObject *self)
{
    
    gtk_button_leave(GTK_BUTTON(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_set_relief(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "newstyle", NULL };
    GtkReliefStyle newstyle;
    PyObject *py_newstyle = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Button.set_relief", kwlist, &py_newstyle))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_RELIEF_STYLE, py_newstyle, (gpointer)&newstyle))
        return NULL;
    
    gtk_button_set_relief(GTK_BUTTON(self->obj), newstyle);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_get_relief(PyGObject *self)
{
    gint ret;

    
    ret = gtk_button_get_relief(GTK_BUTTON(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_RELIEF_STYLE, ret);
}

static PyObject *
_wrap_gtk_button_set_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Button.set_label", kwlist, &label))
        return NULL;
    
    gtk_button_set_label(GTK_BUTTON(self->obj), label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_get_label(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_button_get_label(GTK_BUTTON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_set_use_underline(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_underline", NULL };
    int use_underline;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Button.set_use_underline", kwlist, &use_underline))
        return NULL;
    
    gtk_button_set_use_underline(GTK_BUTTON(self->obj), use_underline);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_get_use_underline(PyGObject *self)
{
    int ret;

    
    ret = gtk_button_get_use_underline(GTK_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_button_set_use_stock(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_stock", NULL };
    int use_stock;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Button.set_use_stock", kwlist, &use_stock))
        return NULL;
    
    gtk_button_set_use_stock(GTK_BUTTON(self->obj), use_stock);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_get_use_stock(PyGObject *self)
{
    int ret;

    
    ret = gtk_button_get_use_stock(GTK_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_button_set_focus_on_click(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "focus_on_click", NULL };
    int focus_on_click;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Button.set_focus_on_click", kwlist, &focus_on_click))
        return NULL;
    
    gtk_button_set_focus_on_click(GTK_BUTTON(self->obj), focus_on_click);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_get_focus_on_click(PyGObject *self)
{
    int ret;

    
    ret = gtk_button_get_focus_on_click(GTK_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_button_set_alignment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "xalign", "yalign", NULL };
    double xalign, yalign;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dd:Gtk.Button.set_alignment", kwlist, &xalign, &yalign))
        return NULL;
    
    gtk_button_set_alignment(GTK_BUTTON(self->obj), xalign, yalign);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1672 "./gtk.override"
static PyObject *
_wrap_gtk_button_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_button_get_alignment(GTK_BUTTON(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
#line 29792 "gtk.c"


static PyObject *
_wrap_gtk_button_set_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "image", NULL };
    PyGObject *image;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Button.set_image", kwlist, &PyGtkWidget_Type, &image))
        return NULL;
    
    gtk_button_set_image(GTK_BUTTON(self->obj), GTK_WIDGET(image->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_get_image(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_button_get_image(GTK_BUTTON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_button_set_image_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    PyObject *py_position = NULL;
    GtkPositionType position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Button.set_image_position", kwlist, &py_position))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_position, (gpointer)&position))
        return NULL;
    
    gtk_button_set_image_position(GTK_BUTTON(self->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_get_image_position(PyGObject *self)
{
    gint ret;

    
    ret = gtk_button_get_image_position(GTK_BUTTON(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_POSITION_TYPE, ret);
}

static PyObject *
_wrap_gtk_button_get_event_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_button_get_event_window(GTK_BUTTON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkButton__do_pressed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Button.pressed", kwlist, &PyGtkButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_BUTTON_CLASS(klass)->pressed)
        GTK_BUTTON_CLASS(klass)->pressed(GTK_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Button.pressed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkButton__do_released(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Button.released", kwlist, &PyGtkButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_BUTTON_CLASS(klass)->released)
        GTK_BUTTON_CLASS(klass)->released(GTK_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Button.released not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkButton__do_clicked(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Button.clicked", kwlist, &PyGtkButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_BUTTON_CLASS(klass)->clicked)
        GTK_BUTTON_CLASS(klass)->clicked(GTK_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Button.clicked not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkButton__do_enter(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Button.enter", kwlist, &PyGtkButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_BUTTON_CLASS(klass)->enter)
        GTK_BUTTON_CLASS(klass)->enter(GTK_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Button.enter not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkButton__do_leave(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Button.leave", kwlist, &PyGtkButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_BUTTON_CLASS(klass)->leave)
        GTK_BUTTON_CLASS(klass)->leave(GTK_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Button.leave not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkButton__do_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Button.activate", kwlist, &PyGtkButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_BUTTON_CLASS(klass)->activate)
        GTK_BUTTON_CLASS(klass)->activate(GTK_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Button.activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkButton_methods[] = {
    { "pressed", (PyCFunction)_wrap_gtk_button_pressed, METH_NOARGS,
      NULL },
    { "released", (PyCFunction)_wrap_gtk_button_released, METH_NOARGS,
      NULL },
    { "clicked", (PyCFunction)_wrap_gtk_button_clicked, METH_NOARGS,
      NULL },
    { "enter", (PyCFunction)_wrap_gtk_button_enter, METH_NOARGS,
      NULL },
    { "leave", (PyCFunction)_wrap_gtk_button_leave, METH_NOARGS,
      NULL },
    { "set_relief", (PyCFunction)_wrap_gtk_button_set_relief, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_relief", (PyCFunction)_wrap_gtk_button_get_relief, METH_NOARGS,
      NULL },
    { "set_label", (PyCFunction)_wrap_gtk_button_set_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label", (PyCFunction)_wrap_gtk_button_get_label, METH_NOARGS,
      NULL },
    { "set_use_underline", (PyCFunction)_wrap_gtk_button_set_use_underline, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_underline", (PyCFunction)_wrap_gtk_button_get_use_underline, METH_NOARGS,
      NULL },
    { "set_use_stock", (PyCFunction)_wrap_gtk_button_set_use_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_stock", (PyCFunction)_wrap_gtk_button_get_use_stock, METH_NOARGS,
      NULL },
    { "set_focus_on_click", (PyCFunction)_wrap_gtk_button_set_focus_on_click, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_focus_on_click", (PyCFunction)_wrap_gtk_button_get_focus_on_click, METH_NOARGS,
      NULL },
    { "set_alignment", (PyCFunction)_wrap_gtk_button_set_alignment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_alignment", (PyCFunction)_wrap_gtk_button_get_alignment, METH_NOARGS,
      NULL },
    { "set_image", (PyCFunction)_wrap_gtk_button_set_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_image", (PyCFunction)_wrap_gtk_button_get_image, METH_NOARGS,
      NULL },
    { "set_image_position", (PyCFunction)_wrap_gtk_button_set_image_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_image_position", (PyCFunction)_wrap_gtk_button_get_image_position, METH_NOARGS,
      NULL },
    { "get_event_window", (PyCFunction)_wrap_gtk_button_get_event_window, METH_NOARGS,
      NULL },
    { "do_pressed", (PyCFunction)_wrap_GtkButton__do_pressed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_released", (PyCFunction)_wrap_GtkButton__do_released, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_clicked", (PyCFunction)_wrap_GtkButton__do_clicked, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_enter", (PyCFunction)_wrap_GtkButton__do_enter, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_leave", (PyCFunction)_wrap_GtkButton__do_leave, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_activate", (PyCFunction)_wrap_GtkButton__do_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Button",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkButton__proxy_do_pressed(GtkButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_pressed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkButton__proxy_do_released(GtkButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_released");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkButton__proxy_do_clicked(GtkButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_clicked");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkButton__proxy_do_enter(GtkButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_enter");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkButton__proxy_do_leave(GtkButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_leave");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkButton__proxy_do_activate(GtkButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkButton_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkButtonClass *klass = GTK_BUTTON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_pressed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "pressed")))
            klass->pressed = _wrap_GtkButton__proxy_do_pressed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_released");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "released")))
            klass->released = _wrap_GtkButton__proxy_do_released;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_clicked");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "clicked")))
            klass->clicked = _wrap_GtkButton__proxy_do_clicked;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_enter");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "enter")))
            klass->enter = _wrap_GtkButton__proxy_do_enter;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_leave");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "leave")))
            klass->leave = _wrap_GtkButton__proxy_do_leave;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate")))
            klass->activate = _wrap_GtkButton__proxy_do_activate;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkButtonBox ----------- */

static PyObject *
_wrap_gtk_button_box_get_layout(PyGObject *self)
{
    gint ret;

    
    ret = gtk_button_box_get_layout(GTK_BUTTON_BOX(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_BUTTON_BOX_STYLE, ret);
}

static PyObject *
_wrap_gtk_button_box_set_layout(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "layout_style", NULL };
    PyObject *py_layout_style = NULL;
    GtkButtonBoxStyle layout_style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ButtonBox.set_layout", kwlist, &py_layout_style))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_BUTTON_BOX_STYLE, py_layout_style, (gpointer)&layout_style))
        return NULL;
    
    gtk_button_box_set_layout(GTK_BUTTON_BOX(self->obj), layout_style);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_box_get_child_secondary(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ButtonBox.get_child_secondary", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    ret = gtk_button_box_get_child_secondary(GTK_BUTTON_BOX(self->obj), GTK_WIDGET(child->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_button_box_set_child_secondary(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "is_secondary", NULL };
    PyGObject *child;
    int is_secondary;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.ButtonBox.set_child_secondary", kwlist, &PyGtkWidget_Type, &child, &is_secondary))
        return NULL;
    
    gtk_button_box_set_child_secondary(GTK_BUTTON_BOX(self->obj), GTK_WIDGET(child->obj), is_secondary);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_box_set_child_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "min_width", "min_height", NULL };
    int min_width, min_height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.ButtonBox.set_child_size", kwlist, &min_width, &min_height))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this") < 0)
        return NULL;
    
    gtk_button_box_set_child_size(GTK_BUTTON_BOX(self->obj), min_width, min_height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_button_box_set_child_ipadding(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "ipad_x", "ipad_y", NULL };
    int ipad_x, ipad_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.ButtonBox.set_child_ipadding", kwlist, &ipad_x, &ipad_y))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this") < 0)
        return NULL;
    
    gtk_button_box_set_child_ipadding(GTK_BUTTON_BOX(self->obj), ipad_x, ipad_y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1682 "./gtk.override"
static PyObject *
_wrap_gtk_button_box_get_child_size(PyGObject *self)
{
    gint min_width;
    gint min_height;

    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this") < 0)
        return NULL;
    gtk_button_box_get_child_size(GTK_BUTTON_BOX(self->obj), &min_width, &min_height);
    return Py_BuildValue("(ii)", min_width, min_height);
}
#line 30592 "gtk.c"


#line 1695 "./gtk.override"
static PyObject *
_wrap_gtk_button_box_get_child_ipadding(PyGObject *self)
{
    gint ipad_x;
    gint ipad_y;

    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this") < 0)
        return NULL;
    gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(self->obj), &ipad_x, &ipad_y);
    return Py_BuildValue("(ii)", ipad_x, ipad_y);
}
#line 30607 "gtk.c"


static const PyMethodDef _PyGtkButtonBox_methods[] = {
    { "get_layout", (PyCFunction)_wrap_gtk_button_box_get_layout, METH_NOARGS,
      NULL },
    { "set_layout", (PyCFunction)_wrap_gtk_button_box_set_layout, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_child_secondary", (PyCFunction)_wrap_gtk_button_box_get_child_secondary, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_child_secondary", (PyCFunction)_wrap_gtk_button_box_set_child_secondary, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_child_size", (PyCFunction)_wrap_gtk_button_box_set_child_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_child_ipadding", (PyCFunction)_wrap_gtk_button_box_set_child_ipadding, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_child_size", (PyCFunction)_wrap_gtk_button_box_get_child_size, METH_NOARGS,
      NULL },
    { "get_child_ipadding", (PyCFunction)_wrap_gtk_button_box_get_child_ipadding, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkButtonBox_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ButtonBox",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkButtonBox_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkCalendar ----------- */

 static int
_wrap_gtk_calendar_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Calendar.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Calendar object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_calendar_select_month(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "month", "year", NULL };
    PyObject *py_month = NULL, *py_year = NULL;
    int ret;
    guint month = 0, year = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Calendar.select_month", kwlist, &py_month, &py_year))
        return NULL;
    if (py_month) {
        if (PyLong_Check(py_month))
            month = PyLong_AsUnsignedLong(py_month);
        else if (PyInt_Check(py_month))
            month = PyInt_AsLong(py_month);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'month' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_year) {
        if (PyLong_Check(py_year))
            year = PyLong_AsUnsignedLong(py_year);
        else if (PyInt_Check(py_year))
            year = PyInt_AsLong(py_year);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'year' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_calendar_select_month(GTK_CALENDAR(self->obj), month, year);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_calendar_select_day(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "day", NULL };
    PyObject *py_day = NULL;
    guint day = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Calendar.select_day", kwlist, &py_day))
        return NULL;
    if (py_day) {
        if (PyLong_Check(py_day))
            day = PyLong_AsUnsignedLong(py_day);
        else if (PyInt_Check(py_day))
            day = PyInt_AsLong(py_day);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'day' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_calendar_select_day(GTK_CALENDAR(self->obj), day);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_calendar_mark_day(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "day", NULL };
    PyObject *py_day = NULL;
    int ret;
    guint day = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Calendar.mark_day", kwlist, &py_day))
        return NULL;
    if (py_day) {
        if (PyLong_Check(py_day))
            day = PyLong_AsUnsignedLong(py_day);
        else if (PyInt_Check(py_day))
            day = PyInt_AsLong(py_day);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'day' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_calendar_mark_day(GTK_CALENDAR(self->obj), day);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_calendar_unmark_day(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "day", NULL };
    PyObject *py_day = NULL;
    int ret;
    guint day = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Calendar.unmark_day", kwlist, &py_day))
        return NULL;
    if (py_day) {
        if (PyLong_Check(py_day))
            day = PyLong_AsUnsignedLong(py_day);
        else if (PyInt_Check(py_day))
            day = PyInt_AsLong(py_day);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'day' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_calendar_unmark_day(GTK_CALENDAR(self->obj), day);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_calendar_clear_marks(PyGObject *self)
{
    
    gtk_calendar_clear_marks(GTK_CALENDAR(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_calendar_set_display_options(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", NULL };
    PyObject *py_flags = NULL;
    GtkCalendarDisplayOptions flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Calendar.set_display_options", kwlist, &py_flags))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_CALENDAR_DISPLAY_OPTIONS, py_flags, (gpointer)&flags))
        return NULL;
    
    gtk_calendar_set_display_options(GTK_CALENDAR(self->obj), flags);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_calendar_get_display_options(PyGObject *self)
{
    guint ret;

    
    ret = gtk_calendar_get_display_options(GTK_CALENDAR(self->obj));
    
    return pyg_flags_from_gtype(GTK_TYPE_CALENDAR_DISPLAY_OPTIONS, ret);
}

static PyObject *
_wrap_gtk_calendar_display_options(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", NULL };
    PyObject *py_flags = NULL;
    GtkCalendarDisplayOptions flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Calendar.display_options", kwlist, &py_flags))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_CALENDAR_DISPLAY_OPTIONS, py_flags, (gpointer)&flags))
        return NULL;
    
    gtk_calendar_display_options(GTK_CALENDAR(self->obj), flags);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2367 "./gtk.override"
static PyObject *
_wrap_gtk_calendar_get_date(PyGObject *self)
{
    guint year, month, day;

    gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
    return Py_BuildValue("(iii)", year, month, day);
}
#line 30882 "gtk.c"


static PyObject *
_wrap_gtk_calendar_freeze(PyGObject *self)
{
    
    gtk_calendar_freeze(GTK_CALENDAR(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_calendar_thaw(PyGObject *self)
{
    
    gtk_calendar_thaw(GTK_CALENDAR(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_calendar_set_detail_width_chars(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "chars", NULL };
    int chars;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Calendar.set_detail_width_chars", kwlist, &chars))
        return NULL;
    
    gtk_calendar_set_detail_width_chars(GTK_CALENDAR(self->obj), chars);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_calendar_set_detail_height_rows(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "rows", NULL };
    int rows;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Calendar.set_detail_height_rows", kwlist, &rows))
        return NULL;
    
    gtk_calendar_set_detail_height_rows(GTK_CALENDAR(self->obj), rows);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_calendar_get_detail_width_chars(PyGObject *self)
{
    int ret;

    
    ret = gtk_calendar_get_detail_width_chars(GTK_CALENDAR(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_calendar_get_detail_height_rows(PyGObject *self)
{
    int ret;

    
    ret = gtk_calendar_get_detail_height_rows(GTK_CALENDAR(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_GtkCalendar__do_month_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Calendar.month_changed", kwlist, &PyGtkCalendar_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CALENDAR_CLASS(klass)->month_changed)
        GTK_CALENDAR_CLASS(klass)->month_changed(GTK_CALENDAR(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Calendar.month_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCalendar__do_day_selected(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Calendar.day_selected", kwlist, &PyGtkCalendar_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CALENDAR_CLASS(klass)->day_selected)
        GTK_CALENDAR_CLASS(klass)->day_selected(GTK_CALENDAR(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Calendar.day_selected not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCalendar__do_day_selected_double_click(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Calendar.day_selected_double_click", kwlist, &PyGtkCalendar_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CALENDAR_CLASS(klass)->day_selected_double_click)
        GTK_CALENDAR_CLASS(klass)->day_selected_double_click(GTK_CALENDAR(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Calendar.day_selected_double_click not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCalendar__do_prev_month(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Calendar.prev_month", kwlist, &PyGtkCalendar_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CALENDAR_CLASS(klass)->prev_month)
        GTK_CALENDAR_CLASS(klass)->prev_month(GTK_CALENDAR(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Calendar.prev_month not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCalendar__do_next_month(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Calendar.next_month", kwlist, &PyGtkCalendar_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CALENDAR_CLASS(klass)->next_month)
        GTK_CALENDAR_CLASS(klass)->next_month(GTK_CALENDAR(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Calendar.next_month not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCalendar__do_prev_year(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Calendar.prev_year", kwlist, &PyGtkCalendar_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CALENDAR_CLASS(klass)->prev_year)
        GTK_CALENDAR_CLASS(klass)->prev_year(GTK_CALENDAR(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Calendar.prev_year not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCalendar__do_next_year(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Calendar.next_year", kwlist, &PyGtkCalendar_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CALENDAR_CLASS(klass)->next_year)
        GTK_CALENDAR_CLASS(klass)->next_year(GTK_CALENDAR(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Calendar.next_year not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCalendar_methods[] = {
    { "select_month", (PyCFunction)_wrap_gtk_calendar_select_month, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_day", (PyCFunction)_wrap_gtk_calendar_select_day, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "mark_day", (PyCFunction)_wrap_gtk_calendar_mark_day, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unmark_day", (PyCFunction)_wrap_gtk_calendar_unmark_day, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "clear_marks", (PyCFunction)_wrap_gtk_calendar_clear_marks, METH_NOARGS,
      NULL },
    { "set_display_options", (PyCFunction)_wrap_gtk_calendar_set_display_options, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_display_options", (PyCFunction)_wrap_gtk_calendar_get_display_options, METH_NOARGS,
      NULL },
    { "display_options", (PyCFunction)_wrap_gtk_calendar_display_options, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_date", (PyCFunction)_wrap_gtk_calendar_get_date, METH_NOARGS,
      NULL },
    { "freeze", (PyCFunction)_wrap_gtk_calendar_freeze, METH_NOARGS,
      NULL },
    { "thaw", (PyCFunction)_wrap_gtk_calendar_thaw, METH_NOARGS,
      NULL },
    { "set_detail_width_chars", (PyCFunction)_wrap_gtk_calendar_set_detail_width_chars, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_detail_height_rows", (PyCFunction)_wrap_gtk_calendar_set_detail_height_rows, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_detail_width_chars", (PyCFunction)_wrap_gtk_calendar_get_detail_width_chars, METH_NOARGS,
      NULL },
    { "get_detail_height_rows", (PyCFunction)_wrap_gtk_calendar_get_detail_height_rows, METH_NOARGS,
      NULL },
    { "do_month_changed", (PyCFunction)_wrap_GtkCalendar__do_month_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_day_selected", (PyCFunction)_wrap_GtkCalendar__do_day_selected, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_day_selected_double_click", (PyCFunction)_wrap_GtkCalendar__do_day_selected_double_click, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_prev_month", (PyCFunction)_wrap_GtkCalendar__do_prev_month, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_next_month", (PyCFunction)_wrap_GtkCalendar__do_next_month, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_prev_year", (PyCFunction)_wrap_GtkCalendar__do_prev_year, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_next_year", (PyCFunction)_wrap_GtkCalendar__do_next_year, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkCalendar_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Calendar",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCalendar_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_calendar_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCalendar__proxy_do_month_changed(GtkCalendar *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_month_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCalendar__proxy_do_day_selected(GtkCalendar *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_day_selected");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCalendar__proxy_do_day_selected_double_click(GtkCalendar *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_day_selected_double_click");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCalendar__proxy_do_prev_month(GtkCalendar *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_prev_month");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCalendar__proxy_do_next_month(GtkCalendar *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_next_month");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCalendar__proxy_do_prev_year(GtkCalendar *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_prev_year");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCalendar__proxy_do_next_year(GtkCalendar *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_next_year");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkCalendar_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkCalendarClass *klass = GTK_CALENDAR_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_month_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "month_changed")))
            klass->month_changed = _wrap_GtkCalendar__proxy_do_month_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_day_selected");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "day_selected")))
            klass->day_selected = _wrap_GtkCalendar__proxy_do_day_selected;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_day_selected_double_click");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "day_selected_double_click")))
            klass->day_selected_double_click = _wrap_GtkCalendar__proxy_do_day_selected_double_click;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_prev_month");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "prev_month")))
            klass->prev_month = _wrap_GtkCalendar__proxy_do_prev_month;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_next_month");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "next_month")))
            klass->next_month = _wrap_GtkCalendar__proxy_do_next_month;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_prev_year");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "prev_year")))
            klass->prev_year = _wrap_GtkCalendar__proxy_do_prev_year;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_next_year");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "next_year")))
            klass->next_year = _wrap_GtkCalendar__proxy_do_next_year;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkCellRendererText ----------- */

static int
_wrap_gtk_cell_renderer_text_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.CellRendererText.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.CellRendererText object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_cell_renderer_text_set_fixed_height_from_font(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "number_of_rows", NULL };
    int number_of_rows;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CellRendererText.set_fixed_height_from_font", kwlist, &number_of_rows))
        return NULL;
    
    gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(self->obj), number_of_rows);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellRendererText__do_edited(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "path", "new_text", NULL };
    PyGObject *self;
    char *path, *new_text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ss:Gtk.CellRendererText.edited", kwlist, &PyGtkCellRendererText_Type, &self, &path, &new_text))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_TEXT_CLASS(klass)->edited)
        GTK_CELL_RENDERER_TEXT_CLASS(klass)->edited(GTK_CELL_RENDERER_TEXT(self->obj), path, new_text);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CellRendererText.edited not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCellRendererText_methods[] = {
    { "set_fixed_height_from_font", (PyCFunction)_wrap_gtk_cell_renderer_text_set_fixed_height_from_font, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_edited", (PyCFunction)_wrap_GtkCellRendererText__do_edited, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererText_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellRendererText",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCellRendererText_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_cell_renderer_text_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCellRendererText__proxy_do_edited(GtkCellRendererText *self, const gchar*path, const gchar*new_text)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path = NULL;
    PyObject *py_new_text = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (path)
        py_path = PyString_FromString(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (new_text)
        py_new_text = PyString_FromString(new_text);
    if (!py_new_text) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_path);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    PyTuple_SET_ITEM(py_args, 1, py_new_text);
    
    py_method = PyObject_GetAttrString(py_self, "do_edited");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkCellRendererText_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkCellRendererTextClass *klass = GTK_CELL_RENDERER_TEXT_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_edited");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "edited")))
            klass->edited = _wrap_GtkCellRendererText__proxy_do_edited;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkCellRendererCombo ----------- */

static int
_wrap_gtk_cell_renderer_combo_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.CellRendererCombo.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.CellRendererCombo object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererCombo_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellRendererCombo",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_cell_renderer_combo_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkCellRendererPixbuf ----------- */

static int
_wrap_gtk_cell_renderer_pixbuf_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.CellRendererPixbuf.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.CellRendererPixbuf object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererPixbuf_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellRendererPixbuf",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_cell_renderer_pixbuf_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkCellRendererProgress ----------- */

static int
_wrap_gtk_cell_renderer_progress_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.CellRendererProgress.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.CellRendererProgress object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererProgress_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellRendererProgress",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_cell_renderer_progress_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkCellRendererToggle ----------- */

static int
_wrap_gtk_cell_renderer_toggle_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.CellRendererToggle.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.CellRendererToggle object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_cell_renderer_toggle_get_radio(PyGObject *self)
{
    int ret;

    
    ret = gtk_cell_renderer_toggle_get_radio(GTK_CELL_RENDERER_TOGGLE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_cell_renderer_toggle_set_radio(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "radio", NULL };
    int radio;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CellRendererToggle.set_radio", kwlist, &radio))
        return NULL;
    
    gtk_cell_renderer_toggle_set_radio(GTK_CELL_RENDERER_TOGGLE(self->obj), radio);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_renderer_toggle_get_active(PyGObject *self)
{
    int ret;

    
    ret = gtk_cell_renderer_toggle_get_active(GTK_CELL_RENDERER_TOGGLE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_cell_renderer_toggle_set_active(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CellRendererToggle.set_active", kwlist, &setting))
        return NULL;
    
    gtk_cell_renderer_toggle_set_active(GTK_CELL_RENDERER_TOGGLE(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_renderer_toggle_get_activatable(PyGObject *self)
{
    int ret;

    
    ret = gtk_cell_renderer_toggle_get_activatable(GTK_CELL_RENDERER_TOGGLE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_cell_renderer_toggle_set_activatable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CellRendererToggle.set_activatable", kwlist, &setting))
        return NULL;
    
    gtk_cell_renderer_toggle_set_activatable(GTK_CELL_RENDERER_TOGGLE(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellRendererToggle__do_toggled(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "path", NULL };
    PyGObject *self;
    char *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.CellRendererToggle.toggled", kwlist, &PyGtkCellRendererToggle_Type, &self, &path))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_TOGGLE_CLASS(klass)->toggled)
        GTK_CELL_RENDERER_TOGGLE_CLASS(klass)->toggled(GTK_CELL_RENDERER_TOGGLE(self->obj), path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CellRendererToggle.toggled not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCellRendererToggle_methods[] = {
    { "get_radio", (PyCFunction)_wrap_gtk_cell_renderer_toggle_get_radio, METH_NOARGS,
      NULL },
    { "set_radio", (PyCFunction)_wrap_gtk_cell_renderer_toggle_set_radio, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_active", (PyCFunction)_wrap_gtk_cell_renderer_toggle_get_active, METH_NOARGS,
      NULL },
    { "set_active", (PyCFunction)_wrap_gtk_cell_renderer_toggle_set_active, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_activatable", (PyCFunction)_wrap_gtk_cell_renderer_toggle_get_activatable, METH_NOARGS,
      NULL },
    { "set_activatable", (PyCFunction)_wrap_gtk_cell_renderer_toggle_set_activatable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_toggled", (PyCFunction)_wrap_GtkCellRendererToggle__do_toggled, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererToggle_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellRendererToggle",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCellRendererToggle_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_cell_renderer_toggle_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCellRendererToggle__proxy_do_toggled(GtkCellRendererToggle *self, const gchar*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (path)
        py_path = PyString_FromString(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_toggled");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkCellRendererToggle_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkCellRendererToggleClass *klass = GTK_CELL_RENDERER_TOGGLE_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggled");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggled")))
            klass->toggled = _wrap_GtkCellRendererToggle__proxy_do_toggled;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkCellView ----------- */

static int
_wrap_gtk_cell_view_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.CellView.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.CellView object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_cell_view_set_model(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *py_model;
    GtkTreeModel *model = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CellView.set_model", kwlist, &py_model))
        return NULL;
    if (py_model && pygobject_check(py_model, &PyGtkTreeModel_Type))
        model = GTK_TREE_MODEL(py_model->obj);
    else if ((PyObject *)py_model != Py_None) {
        PyErr_SetString(PyExc_TypeError, "model should be a GtkTreeModel or None");
        return NULL;
    }
    
    gtk_cell_view_set_model(GTK_CELL_VIEW(self->obj), (GtkTreeModel *) model);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_view_set_displayed_row(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path = Py_None;
    GtkTreePath *path = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CellView.set_displayed_row", kwlist, &py_path))
        return NULL;
    if (py_path != Py_None) {
        path = pygtk_tree_path_from_pyobject(py_path);
        if (!path) {
            PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
            return NULL;
        }
    }
    
    gtk_cell_view_set_displayed_row(GTK_CELL_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_view_get_displayed_row(PyGObject *self)
{
    GtkTreePath *ret;

    
    ret = gtk_cell_view_get_displayed_row(GTK_CELL_VIEW(self->obj));
    
    if (ret) {
        PyObject *py_ret = pygtk_tree_path_to_pyobject(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 6112 "./gtk.override"
static PyObject *
_wrap_gtk_cell_view_get_size_of_row(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;
    GtkRequisition requisition;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkCellView.get_size_of_row",
                                     kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError,
                        "could not convert path to a GtkTreePath");
        return NULL;
    }
    gtk_cell_view_get_size_of_row(GTK_CELL_VIEW(self->obj), path,
                                  &requisition);
    gtk_tree_path_free(path);
    return pyg_boxed_new(GTK_TYPE_REQUISITION, &requisition, TRUE, TRUE);
}
#line 32460 "gtk.c"


static PyObject *
_wrap_gtk_cell_view_set_background_color(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "color", NULL };
    PyObject *py_color = Py_None;
    GdkColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CellView.set_background_color", kwlist, &py_color))
        return NULL;
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else if (py_color != Py_None) {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor or None");
        return NULL;
    }
    
    gtk_cell_view_set_background_color(GTK_CELL_VIEW(self->obj), color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 6086 "./gtk.override"
static PyObject *
_wrap_gtk_cell_view_get_cell_renderers(PyGObject *self)
{
    GList *cell_list;
    PyObject *py_cell_list, *py_cell;
    GtkCellRenderer *cell;
    guint len;
    int i;

    cell_list = gtk_cell_view_get_cell_renderers(GTK_CELL_VIEW(self->obj));
    len = g_list_length(cell_list);
    py_cell_list = PyList_New(len);
    for (i = 0; i < len; i++) {
        cell = GTK_CELL_RENDERER(g_list_nth_data(cell_list, i));
        if (!cell || !(py_cell = pygobject_new(G_OBJECT(cell)))) {
            g_list_free(cell_list);
            Py_DECREF(py_cell_list);
            return NULL;
        }
        PyList_SetItem(py_cell_list, i, py_cell);
    }
    g_list_free(cell_list);
    return py_cell_list;
}
#line 32510 "gtk.c"


static PyObject *
_wrap_gtk_cell_view_get_model(PyGObject *self)
{
    GtkTreeModel *ret;

    
    ret = gtk_cell_view_get_model(GTK_CELL_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkCellView_methods[] = {
    { "set_model", (PyCFunction)_wrap_gtk_cell_view_set_model, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_displayed_row", (PyCFunction)_wrap_gtk_cell_view_set_displayed_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_displayed_row", (PyCFunction)_wrap_gtk_cell_view_get_displayed_row, METH_NOARGS,
      NULL },
    { "get_size_of_row", (PyCFunction)_wrap_gtk_cell_view_get_size_of_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_background_color", (PyCFunction)_wrap_gtk_cell_view_set_background_color, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_cell_renderers", (PyCFunction)_wrap_gtk_cell_view_get_cell_renderers, METH_NOARGS,
      NULL },
    { "get_model", (PyCFunction)_wrap_gtk_cell_view_get_model, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkCellView_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellView",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCellView_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_cell_view_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkToggleButton ----------- */

#line 1708 "./gtk.override"
static int
_wrap_gtk_toggle_button_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zO:GtkToggleButton.__init__", kwlist,
                                     &text, &py_use_underline))
        return -1;
    if (text)
        pygobject_construct(self,
                            "label", text, "use-underline",
                            PyObject_IsTrue(py_use_underline), NULL);
    else
        pygobject_construct(self, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkToggleButton object");
        return -1;
    }
    return 0;
}
#line 32617 "gtk.c"


static PyObject *
_wrap_gtk_toggle_button_set_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "draw_indicator", NULL };
    int draw_indicator;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToggleButton.set_mode", kwlist, &draw_indicator))
        return NULL;
    
    gtk_toggle_button_set_mode(GTK_TOGGLE_BUTTON(self->obj), draw_indicator);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toggle_button_get_mode(PyGObject *self)
{
    int ret;

    
    ret = gtk_toggle_button_get_mode(GTK_TOGGLE_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_toggle_button_set_active(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "is_active", NULL };
    int is_active;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToggleButton.set_active", kwlist, &is_active))
        return NULL;
    
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self->obj), is_active);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toggle_button_get_active(PyGObject *self)
{
    int ret;

    
    ret = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_toggle_button_toggled(PyGObject *self)
{
    
    gtk_toggle_button_toggled(GTK_TOGGLE_BUTTON(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toggle_button_set_inconsistent(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToggleButton.set_inconsistent", kwlist, &setting))
        return NULL;
    
    gtk_toggle_button_set_inconsistent(GTK_TOGGLE_BUTTON(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toggle_button_get_inconsistent(PyGObject *self)
{
    int ret;

    
    ret = gtk_toggle_button_get_inconsistent(GTK_TOGGLE_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_toggle_button_set_state(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "is_active", NULL };
    int is_active;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToggleButton.set_state", kwlist, &is_active))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkToggleButton.set_active") < 0)
        return NULL;
    
    gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(self->obj), is_active);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkToggleButton__do_toggled(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToggleButton.toggled", kwlist, &PyGtkToggleButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TOGGLE_BUTTON_CLASS(klass)->toggled)
        GTK_TOGGLE_BUTTON_CLASS(klass)->toggled(GTK_TOGGLE_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ToggleButton.toggled not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkToggleButton_methods[] = {
    { "set_mode", (PyCFunction)_wrap_gtk_toggle_button_set_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_mode", (PyCFunction)_wrap_gtk_toggle_button_get_mode, METH_NOARGS,
      NULL },
    { "set_active", (PyCFunction)_wrap_gtk_toggle_button_set_active, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_active", (PyCFunction)_wrap_gtk_toggle_button_get_active, METH_NOARGS,
      NULL },
    { "toggled", (PyCFunction)_wrap_gtk_toggle_button_toggled, METH_NOARGS,
      NULL },
    { "set_inconsistent", (PyCFunction)_wrap_gtk_toggle_button_set_inconsistent, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_inconsistent", (PyCFunction)_wrap_gtk_toggle_button_get_inconsistent, METH_NOARGS,
      NULL },
    { "set_state", (PyCFunction)_wrap_gtk_toggle_button_set_state, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_toggled", (PyCFunction)_wrap_GtkToggleButton__do_toggled, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_toggle_button__get_draw_indicator(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_TOGGLE_BUTTON(pygobject_get(self))->draw_indicator;
    return PyBool_FromLong(ret);

}

static const PyGetSetDef gtk_toggle_button_getsets[] = {
    { "draw_indicator", (getter)_wrap_gtk_toggle_button__get_draw_indicator, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkToggleButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ToggleButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkToggleButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_toggle_button_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_toggle_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkToggleButton__proxy_do_toggled(GtkToggleButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggled");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkToggleButton_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkToggleButtonClass *klass = GTK_TOGGLE_BUTTON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggled");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggled")))
            klass->toggled = _wrap_GtkToggleButton__proxy_do_toggled;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkCheckButton ----------- */

#line 1736 "./gtk.override"
static int
_wrap_gtk_check_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|zO:GtkCheckButton.__init__",
                                     kwlist, &text, &py_use_underline))
        return -1;
    if (text)
        pygobject_construct(self,
                            "label", text, "use-underline",
                            PyObject_IsTrue(py_use_underline), NULL);
    else
        pygobject_construct(self, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkCheckButton object");
        return -1;
    }
    return 0;
}
#line 32931 "gtk.c"


static PyObject *
_wrap_GtkCheckButton__do_draw_indicator(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "area", NULL };
    PyGObject *self;
    PyObject *py_area;
    GdkRectangle area = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.CheckButton.draw_indicator", kwlist, &PyGtkCheckButton_Type, &self, &py_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CHECK_BUTTON_CLASS(klass)->draw_indicator)
        GTK_CHECK_BUTTON_CLASS(klass)->draw_indicator(GTK_CHECK_BUTTON(self->obj), &area);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CheckButton.draw_indicator not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCheckButton_methods[] = {
    { "do_draw_indicator", (PyCFunction)_wrap_GtkCheckButton__do_draw_indicator, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkCheckButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CheckButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCheckButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_check_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCheckButton__proxy_do_draw_indicator(GtkCheckButton *self, GdkRectangle*area)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_area;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_area);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_indicator");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkCheckButton_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkCheckButtonClass *klass = GTK_CHECK_BUTTON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_indicator");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_indicator")))
            klass->draw_indicator = _wrap_GtkCheckButton__proxy_do_draw_indicator;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkItem ----------- */

static PyObject *
_wrap_gtk_item_select(PyGObject *self)
{
    
    gtk_item_select(GTK_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_item_deselect(PyGObject *self)
{
    
    gtk_item_deselect(GTK_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_item_toggle(PyGObject *self)
{
    
    gtk_item_toggle(GTK_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkItem__do_select(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Item.select", kwlist, &PyGtkItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ITEM_CLASS(klass)->select)
        GTK_ITEM_CLASS(klass)->select(GTK_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Item.select not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkItem__do_deselect(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Item.deselect", kwlist, &PyGtkItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ITEM_CLASS(klass)->deselect)
        GTK_ITEM_CLASS(klass)->deselect(GTK_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Item.deselect not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkItem__do_toggle(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Item.toggle", kwlist, &PyGtkItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ITEM_CLASS(klass)->toggle)
        GTK_ITEM_CLASS(klass)->toggle(GTK_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Item.toggle not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkItem_methods[] = {
    { "select", (PyCFunction)_wrap_gtk_item_select, METH_NOARGS,
      NULL },
    { "deselect", (PyCFunction)_wrap_gtk_item_deselect, METH_NOARGS,
      NULL },
    { "toggle", (PyCFunction)_wrap_gtk_item_toggle, METH_NOARGS,
      NULL },
    { "do_select", (PyCFunction)_wrap_GtkItem__do_select, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_deselect", (PyCFunction)_wrap_GtkItem__do_deselect, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toggle", (PyCFunction)_wrap_GtkItem__do_toggle, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Item",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkItem_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkItem__proxy_do_select(GtkItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_select");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkItem__proxy_do_deselect(GtkItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_deselect");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkItem__proxy_do_toggle(GtkItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkItem_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkItemClass *klass = GTK_ITEM_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select")))
            klass->select = _wrap_GtkItem__proxy_do_select;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_deselect");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "deselect")))
            klass->deselect = _wrap_GtkItem__proxy_do_deselect;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle")))
            klass->toggle = _wrap_GtkItem__proxy_do_toggle;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkMenuItem ----------- */

#line 1861 "./gtk.override"
static int
_wrap_gtk_menu_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zO:GtkMenuItem.__init__",
                                     kwlist, &text, &py_use_underline))
        return -1;
    pygobject_construct(self, NULL);
    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(self->obj), accel_label);
        if (PyObject_IsTrue(py_use_underline))
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label),
                                         GTK_WIDGET(self->obj));
        gtk_widget_show(accel_label);
     }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkMenuItem object");
        return -1;
    }
    return 0;
}
#line 33483 "gtk.c"


static PyObject *
_wrap_gtk_menu_item_set_submenu(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "submenu", NULL };
    PyGObject *py_submenu;
    GtkWidget *submenu = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.MenuItem.set_submenu", kwlist, &py_submenu))
        return NULL;
    if (py_submenu && pygobject_check(py_submenu, &PyGtkWidget_Type))
        submenu = GTK_WIDGET(py_submenu->obj);
    else if ((PyObject *)py_submenu != Py_None) {
        PyErr_SetString(PyExc_TypeError, "submenu should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_menu_item_set_submenu(GTK_MENU_ITEM(self->obj), (GtkWidget *) submenu);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_get_submenu(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_menu_item_get_submenu(GTK_MENU_ITEM(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_menu_item_remove_submenu(PyGObject *self)
{
    
    gtk_menu_item_remove_submenu(GTK_MENU_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_select(PyGObject *self)
{
    
    gtk_menu_item_select(GTK_MENU_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_deselect(PyGObject *self)
{
    
    gtk_menu_item_deselect(GTK_MENU_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_activate(PyGObject *self)
{
    
    gtk_menu_item_activate(GTK_MENU_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 5429 "./gtk.override"
static PyObject *
_wrap_gtk_menu_item_toggle_size_request(PyGObject *self)
{
    gint requisition;

    gtk_menu_item_toggle_size_request(GTK_MENU_ITEM(self->obj), &requisition);

    return PyInt_FromLong(requisition);
}
#line 33570 "gtk.c"


static PyObject *
_wrap_gtk_menu_item_toggle_size_allocate(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "allocation", NULL };
    int allocation;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.MenuItem.toggle_size_allocate", kwlist, &allocation))
        return NULL;
    
    gtk_menu_item_toggle_size_allocate(GTK_MENU_ITEM(self->obj), allocation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_set_right_justified(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "right_justified", NULL };
    int right_justified;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.MenuItem.set_right_justified", kwlist, &right_justified))
        return NULL;
    
    gtk_menu_item_set_right_justified(GTK_MENU_ITEM(self->obj), right_justified);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_get_right_justified(PyGObject *self)
{
    int ret;

    
    ret = gtk_menu_item_get_right_justified(GTK_MENU_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_menu_item_set_accel_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", NULL };
    char *accel_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.MenuItem.set_accel_path", kwlist, &accel_path))
        return NULL;
    
    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(self->obj), accel_path);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_right_justify(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkMenuItem.set_right_justified") < 0)
        return NULL;
    
    gtk_menu_item_right_justify(GTK_MENU_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_get_accel_path(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_menu_item_get_accel_path(GTK_MENU_ITEM(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_set_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.MenuItem.set_label", kwlist, &label))
        return NULL;
    
    gtk_menu_item_set_label(GTK_MENU_ITEM(self->obj), label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_get_label(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_menu_item_get_label(GTK_MENU_ITEM(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_set_use_underline(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.MenuItem.set_use_underline", kwlist, &setting))
        return NULL;
    
    gtk_menu_item_set_use_underline(GTK_MENU_ITEM(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_item_get_use_underline(PyGObject *self)
{
    int ret;

    
    ret = gtk_menu_item_get_use_underline(GTK_MENU_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkMenuItem__do_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuItem.activate", kwlist, &PyGtkMenuItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_ITEM_CLASS(klass)->activate)
        GTK_MENU_ITEM_CLASS(klass)->activate(GTK_MENU_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuItem.activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuItem__do_activate_item(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuItem.activate_item", kwlist, &PyGtkMenuItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_ITEM_CLASS(klass)->activate_item)
        GTK_MENU_ITEM_CLASS(klass)->activate_item(GTK_MENU_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuItem.activate_item not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuItem__do_toggle_size_allocate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "allocation", NULL };
    PyGObject *self;
    int allocation;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.MenuItem.toggle_size_allocate", kwlist, &PyGtkMenuItem_Type, &self, &allocation))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_ITEM_CLASS(klass)->toggle_size_allocate)
        GTK_MENU_ITEM_CLASS(klass)->toggle_size_allocate(GTK_MENU_ITEM(self->obj), allocation);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuItem.toggle_size_allocate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkMenuItem_methods[] = {
    { "set_submenu", (PyCFunction)_wrap_gtk_menu_item_set_submenu, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_submenu", (PyCFunction)_wrap_gtk_menu_item_get_submenu, METH_NOARGS,
      NULL },
    { "remove_submenu", (PyCFunction)_wrap_gtk_menu_item_remove_submenu, METH_NOARGS,
      NULL },
    { "select", (PyCFunction)_wrap_gtk_menu_item_select, METH_NOARGS,
      NULL },
    { "deselect", (PyCFunction)_wrap_gtk_menu_item_deselect, METH_NOARGS,
      NULL },
    { "activate", (PyCFunction)_wrap_gtk_menu_item_activate, METH_NOARGS,
      NULL },
    { "toggle_size_request", (PyCFunction)_wrap_gtk_menu_item_toggle_size_request, METH_NOARGS,
      NULL },
    { "toggle_size_allocate", (PyCFunction)_wrap_gtk_menu_item_toggle_size_allocate, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_right_justified", (PyCFunction)_wrap_gtk_menu_item_set_right_justified, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_right_justified", (PyCFunction)_wrap_gtk_menu_item_get_right_justified, METH_NOARGS,
      NULL },
    { "set_accel_path", (PyCFunction)_wrap_gtk_menu_item_set_accel_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "right_justify", (PyCFunction)_wrap_gtk_menu_item_right_justify, METH_NOARGS,
      NULL },
    { "get_accel_path", (PyCFunction)_wrap_gtk_menu_item_get_accel_path, METH_NOARGS,
      NULL },
    { "set_label", (PyCFunction)_wrap_gtk_menu_item_set_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label", (PyCFunction)_wrap_gtk_menu_item_get_label, METH_NOARGS,
      NULL },
    { "set_use_underline", (PyCFunction)_wrap_gtk_menu_item_set_use_underline, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_underline", (PyCFunction)_wrap_gtk_menu_item_get_use_underline, METH_NOARGS,
      NULL },
    { "do_activate", (PyCFunction)_wrap_GtkMenuItem__do_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_activate_item", (PyCFunction)_wrap_GtkMenuItem__do_activate_item, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toggle_size_allocate", (PyCFunction)_wrap_GtkMenuItem__do_toggle_size_allocate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkMenuItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.MenuItem",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkMenuItem_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_menu_item_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkMenuItem__proxy_do_activate(GtkMenuItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkMenuItem__proxy_do_activate_item(GtkMenuItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate_item");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkMenuItem__proxy_do_toggle_size_request(GtkMenuItem *self, gint*requisition)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_size_request");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (!PyArg_ParseTuple(py_retval, "i", requisition)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkMenuItem__proxy_do_toggle_size_allocate(GtkMenuItem *self, gint allocation)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_allocation;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_allocation = PyInt_FromLong(allocation);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_allocation);
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_size_allocate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkMenuItem_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkMenuItemClass *klass = GTK_MENU_ITEM_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate")))
            klass->activate = _wrap_GtkMenuItem__proxy_do_activate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate_item");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate_item")))
            klass->activate_item = _wrap_GtkMenuItem__proxy_do_activate_item;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_size_request");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_size_request")))
            klass->toggle_size_request = _wrap_GtkMenuItem__proxy_do_toggle_size_request;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_size_allocate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_size_allocate")))
            klass->toggle_size_allocate = _wrap_GtkMenuItem__proxy_do_toggle_size_allocate;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkCheckMenuItem ----------- */

#line 1962 "./gtk.override"
static int
_wrap_gtk_check_menu_item_new(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zO:GtkCheckMenuItem.__init__", kwlist,
                                     &text, &py_use_underline))
        return -1;
    pygobject_construct(self, NULL);
    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(self->obj), accel_label);
        if (PyObject_IsTrue(py_use_underline))
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label),
                                         GTK_WIDGET(self->obj));
        gtk_widget_show(accel_label);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkCheckMenuItem object");
        return -1;
    }
    return 0;
}
#line 34172 "gtk.c"


static PyObject *
_wrap_gtk_check_menu_item_set_active(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "is_active", NULL };
    int is_active;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CheckMenuItem.set_active", kwlist, &is_active))
        return NULL;
    
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(self->obj), is_active);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_check_menu_item_get_active(PyGObject *self)
{
    int ret;

    
    ret = gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_check_menu_item_toggled(PyGObject *self)
{
    
    gtk_check_menu_item_toggled(GTK_CHECK_MENU_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_check_menu_item_set_inconsistent(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CheckMenuItem.set_inconsistent", kwlist, &setting))
        return NULL;
    
    gtk_check_menu_item_set_inconsistent(GTK_CHECK_MENU_ITEM(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_check_menu_item_get_inconsistent(PyGObject *self)
{
    int ret;

    
    ret = gtk_check_menu_item_get_inconsistent(GTK_CHECK_MENU_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_check_menu_item_set_draw_as_radio(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "draw_as_radio", NULL };
    int draw_as_radio;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CheckMenuItem.set_draw_as_radio", kwlist, &draw_as_radio))
        return NULL;
    
    gtk_check_menu_item_set_draw_as_radio(GTK_CHECK_MENU_ITEM(self->obj), draw_as_radio);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_check_menu_item_get_draw_as_radio(PyGObject *self)
{
    int ret;

    
    ret = gtk_check_menu_item_get_draw_as_radio(GTK_CHECK_MENU_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_check_menu_item_set_show_toggle(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "always", NULL };
    int always;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CheckMenuItem.set_show_toggle", kwlist, &always))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this method") < 0)
        return NULL;
    
    gtk_check_menu_item_set_show_toggle(GTK_CHECK_MENU_ITEM(self->obj), always);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_check_menu_item_set_state(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "is_active", NULL };
    int is_active;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CheckMenuItem.set_state", kwlist, &is_active))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkCheckMenuItem.set_active") < 0)
        return NULL;
    
    gtk_check_menu_item_set_state(GTK_CHECK_MENU_ITEM(self->obj), is_active);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCheckMenuItem__do_toggled(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CheckMenuItem.toggled", kwlist, &PyGtkCheckMenuItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CHECK_MENU_ITEM_CLASS(klass)->toggled)
        GTK_CHECK_MENU_ITEM_CLASS(klass)->toggled(GTK_CHECK_MENU_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CheckMenuItem.toggled not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCheckMenuItem__do_draw_indicator(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "area", NULL };
    PyGObject *self;
    PyObject *py_area;
    GdkRectangle area = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.CheckMenuItem.draw_indicator", kwlist, &PyGtkCheckMenuItem_Type, &self, &py_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CHECK_MENU_ITEM_CLASS(klass)->draw_indicator)
        GTK_CHECK_MENU_ITEM_CLASS(klass)->draw_indicator(GTK_CHECK_MENU_ITEM(self->obj), &area);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CheckMenuItem.draw_indicator not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCheckMenuItem_methods[] = {
    { "set_active", (PyCFunction)_wrap_gtk_check_menu_item_set_active, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_active", (PyCFunction)_wrap_gtk_check_menu_item_get_active, METH_NOARGS,
      NULL },
    { "toggled", (PyCFunction)_wrap_gtk_check_menu_item_toggled, METH_NOARGS,
      NULL },
    { "set_inconsistent", (PyCFunction)_wrap_gtk_check_menu_item_set_inconsistent, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_inconsistent", (PyCFunction)_wrap_gtk_check_menu_item_get_inconsistent, METH_NOARGS,
      NULL },
    { "set_draw_as_radio", (PyCFunction)_wrap_gtk_check_menu_item_set_draw_as_radio, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_draw_as_radio", (PyCFunction)_wrap_gtk_check_menu_item_get_draw_as_radio, METH_NOARGS,
      NULL },
    { "set_show_toggle", (PyCFunction)_wrap_gtk_check_menu_item_set_show_toggle, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_state", (PyCFunction)_wrap_gtk_check_menu_item_set_state, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_toggled", (PyCFunction)_wrap_GtkCheckMenuItem__do_toggled, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_indicator", (PyCFunction)_wrap_GtkCheckMenuItem__do_draw_indicator, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_check_menu_item__get_active(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_CHECK_MENU_ITEM(pygobject_get(self))->active;
    return PyBool_FromLong(ret);

}

static const PyGetSetDef gtk_check_menu_item_getsets[] = {
    { "active", (getter)_wrap_gtk_check_menu_item__get_active, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkCheckMenuItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CheckMenuItem",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCheckMenuItem_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_check_menu_item_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_check_menu_item_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCheckMenuItem__proxy_do_toggled(GtkCheckMenuItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggled");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCheckMenuItem__proxy_do_draw_indicator(GtkCheckMenuItem *self, GdkRectangle*area)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_area;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_area);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_indicator");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkCheckMenuItem_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkCheckMenuItemClass *klass = GTK_CHECK_MENU_ITEM_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggled");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggled")))
            klass->toggled = _wrap_GtkCheckMenuItem__proxy_do_toggled;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_indicator");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_indicator")))
            klass->draw_indicator = _wrap_GtkCheckMenuItem__proxy_do_draw_indicator;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkClipboard ----------- */

static int
_wrap_gtk_clipboard_get_for_display(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "display", "selection", NULL };
    GdkDisplay *display = gdk_display_get_default();
    PyGObject *py_display = NULL;
    GdkAtom selection = GDK_SELECTION_CLIPBOARD;
    PyObject *py_selection = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O!O:Gtk.Clipboard.__init__", kwlist, &PyGdkDisplay_Type, &py_display, &py_selection))
        return -1;
    if (py_display)
        display = GDK_DISPLAY(py_display->obj);
    if (py_selection) {
        selection = pygdk_atom_from_pyobject(py_selection);
        if (PyErr_Occurred())
            return -1;
    }
    self->obj = (GObject *)gtk_clipboard_get_for_display(display, selection);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkClipboard object");
        return -1;
    }
    g_object_ref(self->obj);
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}

static PyObject *
_wrap_gtk_clipboard_wait_is_target_available(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "target", NULL };
    PyObject *py_target = NULL;
    int ret;
    GdkAtom target;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Clipboard.wait_is_target_available", kwlist, &py_target))
        return NULL;
    target = pygdk_atom_from_pyobject(py_target);
    if (PyErr_Occurred())
        return NULL;
    
    ret = gtk_clipboard_wait_is_target_available(GTK_CLIPBOARD(self->obj), target);
    
    return PyBool_FromLong(ret);

}

#line 6138 "./gtk.override"
static PyObject *
_wrap_gtk_clipboard_set_can_store(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    GtkTargetEntry *targets;
    PyObject *py_targets;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkClipboard.set_can_store",
                                     kwlist, &py_targets))
        return NULL;
    if (py_targets == Py_None) {
        targets = NULL;
        n_targets = 0;
    } else {
        if (!(py_targets = PySequence_Fast(py_targets,
                                       "targets must be a sequence")))
            return NULL;
        n_targets = PySequence_Fast_GET_SIZE(py_targets);
        targets = g_new(GtkTargetEntry, n_targets);
        for (i = 0; i < n_targets; i++) {
            PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
            if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                                  &targets[i].flags, &targets[i].info)) {
                PyErr_Clear();
                PyErr_SetString(PyExc_TypeError,
                                "list items should be of form (string,int,int)");
                g_free(targets);
                Py_DECREF(py_targets);
                return NULL;
            }
        }
        Py_DECREF(py_targets);
    }
    gtk_clipboard_set_can_store(GTK_CLIPBOARD(self->obj), targets, n_targets);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 34671 "gtk.c"


static PyObject *
_wrap_gtk_clipboard_store(PyGObject *self)
{
    
    gtk_clipboard_store(GTK_CLIPBOARD(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clipboard_get_display(PyGObject *self)
{
    GdkDisplay *ret;

    
    ret = gtk_clipboard_get_display(GTK_CLIPBOARD(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 678 "./gtk.override"
static void
clipboard_get_func(GtkClipboard *clipboard, GtkSelectionData *selection_data,
		   guint info, gpointer user_data)
{
    PyObject *callback, *args, *ret;
    PyGILState_STATE state;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNiO)",
			 pygobject_new((GObject *)clipboard),
			 pyg_boxed_new(GTK_TYPE_SELECTION_DATA,
				       selection_data, FALSE, FALSE),
			 info, PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    pyg_gil_state_release(state);
}
static void
clipboard_clear_func(GtkClipboard *clipboard, gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 1);
    args = Py_BuildValue("(NO)",
			 pygobject_new((GObject *)clipboard),
			 PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_set_with_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "get_func", "clear_func", "user_data", NULL };
    PyObject *py_targets, *get_func, *clear_func = Py_None, *user_data = Py_None;
    GtkTargetEntry *targets;
    gint n_targets, i;
    gboolean ret;
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|OO:GtkClipboard.set_with_data",kwlist,
                                     &py_targets, &get_func, &clear_func,
				     &user_data))
        return NULL;
    if (!PyCallable_Check(get_func)) {
	PyErr_SetString(PyExc_TypeError, "get_func must be callable");
	return NULL;
    }
    if (clear_func != Py_None && !PyCallable_Check(clear_func)) {
	PyErr_SetString(PyExc_TypeError,"clear_func must be callable or None");
	return NULL;
    }
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "sii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    data = Py_BuildValue("(OOO)", get_func, clear_func, user_data);
    ret = gtk_clipboard_set_with_data(GTK_CLIPBOARD(self->obj),
				      targets, n_targets,
				      clipboard_get_func, clipboard_clear_func,
				      data);
    g_free(targets);
    Py_DECREF(py_targets);
    if (!ret) {
	Py_DECREF(data);
    }

    return PyBool_FromLong(ret);
}
#line 34789 "gtk.c"


static PyObject *
_wrap_gtk_clipboard_get_owner(PyGObject *self)
{
    GObject *ret;

    
    ret = gtk_clipboard_get_owner(GTK_CLIPBOARD(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_clipboard_clear(PyGObject *self)
{
    
    gtk_clipboard_clear(GTK_CLIPBOARD(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clipboard_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", "len", NULL };
    char *text;
    int len = -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s|i:Gtk.Clipboard.set_text", kwlist, &text, &len))
        return NULL;
    
    gtk_clipboard_set_text(GTK_CLIPBOARD(self->obj), text, len);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 5001 "./gtk.override"
static void
clipboard_request_contents_cb(GtkClipboard *clipboard,
			      GtkSelectionData *selection_data,
			      gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
			 pyg_boxed_new(GTK_TYPE_SELECTION_DATA,
				       selection_data, TRUE, TRUE),
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_contents(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "target", "callback", "user_data", NULL };
    PyObject *py_target, *callback, *data, *user_data = Py_None;
    GdkAtom target;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|O:GtkClipboard.request_contents",
				     kwlist, &py_target, &callback,
				     &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }
    target = pygdk_atom_from_pyobject(py_target);
    if (PyErr_Occurred())
        return NULL;

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_contents(GTK_CLIPBOARD(self->obj), target,
				   clipboard_request_contents_cb,
				   (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 34882 "gtk.c"


#line 5054 "./gtk.override"
static void
clipboard_request_text_cb(GtkClipboard *clipboard,
			  const gchar *text,
			  gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret, *py_text, *data;
 
    data = (PyObject *) user_data;

    if (text) {
        py_text = PyString_FromString(text);
    } else {
        py_text = Py_None;
        Py_INCREF(Py_None);
    }

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem(data, 0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
                         py_text,
			 PyTuple_GetItem(data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(data);
    Py_DECREF(args);
    pyg_gil_state_release(state);
}

static PyObject *
_wrap_gtk_clipboard_request_text(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "callback", "user_data", NULL };
    PyObject *callback, *data, *user_data = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkClipboard.request_text",
				     kwlist, &callback, &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_text(GTK_CLIPBOARD(self->obj),
			       clipboard_request_text_cb,
			       (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 34941 "gtk.c"


#line 5111 "./gtk.override"
static void
clipboard_request_targets_cb(GtkClipboard *clipboard,
			     GdkAtom *atoms,
			     gint n_atoms,
			     gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret, *py_atoms;
    int i;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    if (atoms) {
        py_atoms = PyTuple_New(n_atoms);
        for (i = 0; i < n_atoms; i++) {
            gchar *name;

            name = gdk_atom_name(atoms[i]);
            PyTuple_SetItem(py_atoms, i, PyString_FromString(name));
            g_free(name);
        }
    } else
        py_atoms = PyTuple_New(0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
			 py_atoms,
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_targets(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "callback", "user_data", NULL };
    PyObject *callback, *data, *user_data = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkClipboard.request_targets",
				     kwlist, &callback, &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_targets(GTK_CLIPBOARD(self->obj),
				   clipboard_request_targets_cb,
				   (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 35003 "gtk.c"


static PyObject *
_wrap_gtk_clipboard_wait_for_contents(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "target", NULL };
    PyObject *py_target = NULL;
    GtkSelectionData *ret;
    GdkAtom target;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Clipboard.wait_for_contents", kwlist, &py_target))
        return NULL;
    target = pygdk_atom_from_pyobject(py_target);
    if (PyErr_Occurred())
        return NULL;
    
    ret = gtk_clipboard_wait_for_contents(GTK_CLIPBOARD(self->obj), target);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_SELECTION_DATA, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_clipboard_wait_for_text(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_clipboard_wait_for_text(GTK_CLIPBOARD(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clipboard_wait_is_text_available(PyGObject *self)
{
    int ret;

    
    ret = gtk_clipboard_wait_is_text_available(GTK_CLIPBOARD(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 4965 "./gtk.override"
static PyObject *
_wrap_gtk_clipboard_wait_for_targets(PyGObject *self)
{
    GtkSelectionData *data;

    /* have to work around GTK+ bug #139883 */
    data = gtk_clipboard_wait_for_contents(GTK_CLIPBOARD(self->obj),
					   gdk_atom_intern("TARGETS", FALSE));

    if (data) {
	gint n_targets = 0;
	GdkAtom *targets = NULL;
    
	if (gtk_selection_data_get_targets(data, &targets, &n_targets)) {
	    PyObject *ret;
	    int i;

	    ret = PyTuple_New(n_targets);
	    for (i = 0; i < n_targets; i++) {
                gchar *name;

                name = gdk_atom_name(targets[i]);
		PyTuple_SetItem(ret, i, PyString_FromString(name));
                g_free(name);
            }
	    g_free(targets);
	    gtk_selection_data_free(data);
	    return ret;
	}
	gtk_selection_data_free(data);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 35090 "gtk.c"


#line 6844 "./gtk.override"
static void
clipboard_request_image_cb(GtkClipboard *clipboard,
			  GdkPixbuf *pixbuf,
			  gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret, *py_image;

    if (pixbuf) {
        py_image = pygobject_new((GObject *)pixbuf);
    } else {
        py_image = Py_None;
        Py_INCREF(Py_None);
    }

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNO)",
			 pygobject_new((GObject *)clipboard),
                         py_image,
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_image(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "callback", "user_data", NULL };
    PyObject *callback, *data, *user_data = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkClipboard.request_image",
				     kwlist, &callback, &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_image(GTK_CLIPBOARD(self->obj),
			       clipboard_request_image_cb,
			       (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 35147 "gtk.c"


static PyObject *
_wrap_gtk_clipboard_wait_for_image(PyGObject *self)
{
    GdkPixbuf *ret;

    
    ret = gtk_clipboard_wait_for_image(GTK_CLIPBOARD(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_clipboard_set_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Clipboard.set_image", kwlist, &PyGdkPixbuf_Type, &pixbuf))
        return NULL;
    
    gtk_clipboard_set_image(GTK_CLIPBOARD(self->obj), GDK_PIXBUF(pixbuf->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clipboard_wait_is_image_available(PyGObject *self)
{
    int ret;

    
    ret = gtk_clipboard_wait_is_image_available(GTK_CLIPBOARD(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 6980 "./gtk.override"
static void
clipboard_request_rich_text_cb(GtkClipboard *clipboard,
                               GdkAtom format,
                               const guint8 *text,
                               gsize length,
                               gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret, *py_format, *py_text, *data;
    gchar *name;

    data = (PyObject *) user_data;

    if (text) {
        py_text = PyString_FromString((char *) text);
    } else {
        py_text = Py_None;
        Py_INCREF(Py_None);
    }

    name = gdk_atom_name(format);
    py_format = PyString_FromString(name);
    g_free(name);
 
    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem(data, 0);
    args = Py_BuildValue("(NNNiO)",
			 pygobject_new((GObject *)clipboard),
                         py_format, py_text, length,
			 PyTuple_GetItem(data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    Py_DECREF((PyObject *)user_data);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_clipboard_request_rich_text(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", "callback", "user_data", NULL };
    PyObject *callback, *data, *user_data = Py_None;
    GtkTextBuffer *buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O|O:GtkClipboard.request_rich_text",
				     kwlist, &PyGtkTextBuffer_Type, &buffer,
                                     &callback, &user_data))
        return NULL;
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", callback, user_data);
    gtk_clipboard_request_rich_text(GTK_CLIPBOARD(self->obj), buffer,
                                    clipboard_request_rich_text_cb,
                                    (gpointer)data);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 35253 "gtk.c"


#line 7045 "./gtk.override"
static PyObject *
_wrap_gtk_clipboard_wait_for_rich_text(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    GtkTextBuffer *buffer;
    GdkAtom format;
    gchar *name;
    gsize length;
    guint8 *ret;
 
     
    if (!PyArg_ParseTupleAndKeywords(args,kwargs,
				     "O:GtkClipboard.wait_for_rich_text",
                                     kwlist, &PyGtkTextBuffer_Type, &buffer))
        return NULL;

    ret = gtk_clipboard_wait_for_rich_text(GTK_CLIPBOARD(self->obj),
                                           buffer, &format, &length);
     
    if (ret) {
        PyObject *py_ret;
        name = gdk_atom_name(format);
        py_ret = Py_BuildValue("(s#s)", ret, (Py_ssize_t) length, name);
        g_free(ret);
        g_free(name);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 35288 "gtk.c"


static PyObject *
_wrap_gtk_clipboard_wait_is_rich_text_available(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    PyGObject *buffer;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Clipboard.wait_is_rich_text_available", kwlist, &PyGtkTextBuffer_Type, &buffer))
        return NULL;
    
    ret = gtk_clipboard_wait_is_rich_text_available(GTK_CLIPBOARD(self->obj), GTK_TEXT_BUFFER(buffer->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_clipboard_wait_is_uris_available(PyGObject *self)
{
    int ret;

    
    ret = gtk_clipboard_wait_is_uris_available(GTK_CLIPBOARD(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 8831 "./gtk.override"
static PyObject *
_wrap_gtk_clipboard_wait_for_uris(PyGObject *self)
{
    gchar **uris = NULL, **tmp;
    PyObject *ret;
    int i = 0, j;

    uris = gtk_clipboard_wait_for_uris(GTK_CLIPBOARD(self->obj));

    if (uris) {
        tmp = uris;
        while (*tmp)
            tmp++, i++;

        ret = PyTuple_New(i);
        for (j = 0; j < i; j++)
            PyTuple_SetItem(ret, j, PyString_FromString(uris[j]));

        g_strfreev(uris);

        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 35345 "gtk.c"


static const PyMethodDef _PyGtkClipboard_methods[] = {
    { "wait_is_target_available", (PyCFunction)_wrap_gtk_clipboard_wait_is_target_available, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_can_store", (PyCFunction)_wrap_gtk_clipboard_set_can_store, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "store", (PyCFunction)_wrap_gtk_clipboard_store, METH_NOARGS,
      NULL },
    { "get_display", (PyCFunction)_wrap_gtk_clipboard_get_display, METH_NOARGS,
      NULL },
    { "set_with_data", (PyCFunction)_wrap_gtk_clipboard_set_with_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_owner", (PyCFunction)_wrap_gtk_clipboard_get_owner, METH_NOARGS,
      NULL },
    { "clear", (PyCFunction)_wrap_gtk_clipboard_clear, METH_NOARGS,
      NULL },
    { "set_text", (PyCFunction)_wrap_gtk_clipboard_set_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "request_contents", (PyCFunction)_wrap_gtk_clipboard_request_contents, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "request_text", (PyCFunction)_wrap_gtk_clipboard_request_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "request_targets", (PyCFunction)_wrap_gtk_clipboard_request_targets, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "wait_for_contents", (PyCFunction)_wrap_gtk_clipboard_wait_for_contents, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "wait_for_text", (PyCFunction)_wrap_gtk_clipboard_wait_for_text, METH_NOARGS,
      NULL },
    { "wait_is_text_available", (PyCFunction)_wrap_gtk_clipboard_wait_is_text_available, METH_NOARGS,
      NULL },
    { "wait_for_targets", (PyCFunction)_wrap_gtk_clipboard_wait_for_targets, METH_NOARGS,
      NULL },
    { "request_image", (PyCFunction)_wrap_gtk_clipboard_request_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "wait_for_image", (PyCFunction)_wrap_gtk_clipboard_wait_for_image, METH_NOARGS,
      NULL },
    { "set_image", (PyCFunction)_wrap_gtk_clipboard_set_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "wait_is_image_available", (PyCFunction)_wrap_gtk_clipboard_wait_is_image_available, METH_NOARGS,
      NULL },
    { "request_rich_text", (PyCFunction)_wrap_gtk_clipboard_request_rich_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "wait_for_rich_text", (PyCFunction)_wrap_gtk_clipboard_wait_for_rich_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "wait_is_rich_text_available", (PyCFunction)_wrap_gtk_clipboard_wait_is_rich_text_available, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "wait_is_uris_available", (PyCFunction)_wrap_gtk_clipboard_wait_is_uris_available, METH_NOARGS,
      NULL },
    { "wait_for_uris", (PyCFunction)_wrap_gtk_clipboard_wait_for_uris, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkClipboard_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Clipboard",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkClipboard_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_clipboard_get_for_display,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkCList ----------- */

#line 29 "gtkclist.override"
static int
_wrap_gtk_clist_new_with_titles(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "count", "titles", NULL };
    int count = 1, i;
    PyObject *py_list = NULL;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.TreeView") < 0)
        return -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iO:GtkCList.__init__",
                                     kwlist, &count, &py_list))
        return -1;
    if (py_list) {
        gchar **list;

        if (!PySequence_Check(py_list)) {
            PyErr_SetString(PyExc_TypeError,"2nd argument not a sequence");
            return -1;
        }
        if (PySequence_Length(py_list) < count) {
            PyErr_SetString(PyExc_TypeError, "sequence not long enough");
            return -1;
        }
        list = g_new(gchar *, count);
        for (i = 0; i < count; i++) {
            PyObject *item = PySequence_GetItem(py_list, i);

            Py_DECREF(item); /* PySequence_GetItem INCREF's */
            if (!PyString_Check(item) && !PyUnicode_Check(item)) {
                PyErr_SetString(PyExc_TypeError,
                                "sequence item not a string or unicode object");
                g_free(list);
                return -1;
            }
            list[i] = PyString_AsString(item);
        }
        self->obj = (GObject *)gtk_clist_new_with_titles(count, list);
        g_free(list);
    } else
        self->obj = (GObject *)gtk_clist_new(count);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,"could not create GtkCList object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
#line 35499 "gtk.c"


static PyObject *
_wrap_gtk_clist_set_hadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *adjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.set_hadjustment", kwlist, &PyGtkAdjustment_Type, &adjustment))
        return NULL;
    
    gtk_clist_set_hadjustment(GTK_CLIST(self->obj), GTK_ADJUSTMENT(adjustment->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_vadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *adjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.set_vadjustment", kwlist, &PyGtkAdjustment_Type, &adjustment))
        return NULL;
    
    gtk_clist_set_vadjustment(GTK_CLIST(self->obj), GTK_ADJUSTMENT(adjustment->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_get_hadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_clist_get_hadjustment(GTK_CLIST(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_clist_get_vadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_clist_get_vadjustment(GTK_CLIST(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_clist_set_shadow_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    PyObject *py_type = NULL;
    GtkShadowType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CList.set_shadow_type", kwlist, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_type, (gpointer)&type))
        return NULL;
    
    gtk_clist_set_shadow_type(GTK_CLIST(self->obj), type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_selection_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mode", NULL };
    PyObject *py_mode = NULL;
    GtkSelectionMode mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CList.set_selection_mode", kwlist, &py_mode))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SELECTION_MODE, py_mode, (gpointer)&mode))
        return NULL;
    
    gtk_clist_set_selection_mode(GTK_CLIST(self->obj), mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_reorderable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "reorderable", NULL };
    int reorderable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.set_reorderable", kwlist, &reorderable))
        return NULL;
    
    gtk_clist_set_reorderable(GTK_CLIST(self->obj), reorderable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_use_drag_icons(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_icons", NULL };
    int use_icons;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.set_use_drag_icons", kwlist, &use_icons))
        return NULL;
    
    gtk_clist_set_use_drag_icons(GTK_CLIST(self->obj), use_icons);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_button_actions(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "button", "button_actions", NULL };
    PyObject *py_button = NULL;
    int button_actions;
    guint button = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.CList.set_button_actions", kwlist, &py_button, &button_actions))
        return NULL;
    if (py_button) {
        if (PyLong_Check(py_button))
            button = PyLong_AsUnsignedLong(py_button);
        else if (PyInt_Check(py_button))
            button = PyInt_AsLong(py_button);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'button' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_clist_set_button_actions(GTK_CLIST(self->obj), button, button_actions);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_freeze(PyGObject *self)
{
    
    gtk_clist_freeze(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_thaw(PyGObject *self)
{
    
    gtk_clist_thaw(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_column_titles_show(PyGObject *self)
{
    
    gtk_clist_column_titles_show(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_column_titles_hide(PyGObject *self)
{
    
    gtk_clist_column_titles_hide(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_column_title_active(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.column_title_active", kwlist, &column))
        return NULL;
    
    gtk_clist_column_title_active(GTK_CLIST(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_column_title_passive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.column_title_passive", kwlist, &column))
        return NULL;
    
    gtk_clist_column_title_passive(GTK_CLIST(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_column_titles_active(PyGObject *self)
{
    
    gtk_clist_column_titles_active(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_column_titles_passive(PyGObject *self)
{
    
    gtk_clist_column_titles_passive(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_column_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "title", NULL };
    int column;
    char *title;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"is:Gtk.CList.set_column_title", kwlist, &column, &title))
        return NULL;
    
    gtk_clist_set_column_title(GTK_CLIST(self->obj), column, title);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_get_column_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.get_column_title", kwlist, &column))
        return NULL;
    
    ret = gtk_clist_get_column_title(GTK_CLIST(self->obj), column);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_column_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "widget", NULL };
    int column;
    PyGObject *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iO!:Gtk.CList.set_column_widget", kwlist, &column, &PyGtkWidget_Type, &widget))
        return NULL;
    
    gtk_clist_set_column_widget(GTK_CLIST(self->obj), column, GTK_WIDGET(widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_get_column_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.get_column_widget", kwlist, &column))
        return NULL;
    
    ret = gtk_clist_get_column_widget(GTK_CLIST(self->obj), column);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_clist_set_column_justification(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "justification", NULL };
    int column;
    PyObject *py_justification = NULL;
    GtkJustification justification;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iO:Gtk.CList.set_column_justification", kwlist, &column, &py_justification))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_JUSTIFICATION, py_justification, (gpointer)&justification))
        return NULL;
    
    gtk_clist_set_column_justification(GTK_CLIST(self->obj), column, justification);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_column_visibility(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "visible", NULL };
    int column, visible;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.set_column_visibility", kwlist, &column, &visible))
        return NULL;
    
    gtk_clist_set_column_visibility(GTK_CLIST(self->obj), column, visible);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_column_resizeable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "resizeable", NULL };
    int column, resizeable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.set_column_resizeable", kwlist, &column, &resizeable))
        return NULL;
    
    gtk_clist_set_column_resizeable(GTK_CLIST(self->obj), column, resizeable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_column_auto_resize(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "auto_resize", NULL };
    int column, auto_resize;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.set_column_auto_resize", kwlist, &column, &auto_resize))
        return NULL;
    
    gtk_clist_set_column_auto_resize(GTK_CLIST(self->obj), column, auto_resize);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_columns_autosize(PyGObject *self)
{
    int ret;

    
    ret = gtk_clist_columns_autosize(GTK_CLIST(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_clist_optimal_column_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.optimal_column_width", kwlist, &column))
        return NULL;
    
    ret = gtk_clist_optimal_column_width(GTK_CLIST(self->obj), column);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_clist_set_column_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "width", NULL };
    int column, width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.set_column_width", kwlist, &column, &width))
        return NULL;
    
    gtk_clist_set_column_width(GTK_CLIST(self->obj), column, width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_column_min_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "min_width", NULL };
    int column, min_width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.set_column_min_width", kwlist, &column, &min_width))
        return NULL;
    
    gtk_clist_set_column_min_width(GTK_CLIST(self->obj), column, min_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_column_max_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "max_width", NULL };
    int column, max_width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.set_column_max_width", kwlist, &column, &max_width))
        return NULL;
    
    gtk_clist_set_column_max_width(GTK_CLIST(self->obj), column, max_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_row_height(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "height", NULL };
    PyObject *py_height = NULL;
    guint height = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CList.set_row_height", kwlist, &py_height))
        return NULL;
    if (py_height) {
        if (PyLong_Check(py_height))
            height = PyLong_AsUnsignedLong(py_height);
        else if (PyInt_Check(py_height))
            height = PyInt_AsLong(py_height);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'height' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_clist_set_row_height(GTK_CLIST(self->obj), height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_moveto(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", "row_align", "col_align", NULL };
    int row, column;
    double row_align, col_align;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iidd:Gtk.CList.moveto", kwlist, &row, &column, &row_align, &col_align))
        return NULL;
    
    gtk_clist_moveto(GTK_CLIST(self->obj), row, column, row_align, col_align);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_row_is_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    int row;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.row_is_visible", kwlist, &row))
        return NULL;
    
    ret = gtk_clist_row_is_visible(GTK_CLIST(self->obj), row);
    
    return pyg_enum_from_gtype(GTK_TYPE_VISIBILITY, ret);
}

static PyObject *
_wrap_gtk_clist_get_cell_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int row, column;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.get_cell_type", kwlist, &row, &column))
        return NULL;
    
    ret = gtk_clist_get_cell_type(GTK_CLIST(self->obj), row, column);
    
    return pyg_enum_from_gtype(GTK_TYPE_CELL_TYPE, ret);
}

static PyObject *
_wrap_gtk_clist_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", "text", NULL };
    int row, column;
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iis:Gtk.CList.set_text", kwlist, &row, &column, &text))
        return NULL;
    
    gtk_clist_set_text(GTK_CLIST(self->obj), row, column, text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 80 "gtkclist.override"
static PyObject *
_wrap_gtk_clist_get_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    char *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_text",
                                     kwlist, &r, &c))
        return NULL;
    if (!gtk_clist_get_text(GTK_CLIST(self->obj), r, c, &text) || text==NULL) {
        PyErr_SetString(PyExc_ValueError, "can't get text value");
        return NULL;
    }
    return PyString_FromString(text);
}
#line 36047 "gtk.c"


static PyObject *
_wrap_gtk_clist_set_pixmap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", "pixmap", "mask", NULL };
    int row, column;
    PyGObject *pixmap, *py_mask = NULL;
    GdkPixmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iiO!|O:Gtk.CList.set_pixmap", kwlist, &row, &column, &PyGdkPixmap_Type, &pixmap, &py_mask))
        return NULL;
    if ((PyObject *)py_mask == Py_None)
        mask = NULL;
    else if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if (py_mask) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return NULL;
    }
    
    gtk_clist_set_pixmap(GTK_CLIST(self->obj), row, column, GDK_PIXMAP(pixmap->obj), (GdkBitmap *) mask);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 98 "gtkclist.override"
static PyObject *
_wrap_gtk_clist_get_pixmap(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_pixmap",
                                     kwlist, &r, &c))
        return NULL;
    if (!gtk_clist_get_pixmap(GTK_CLIST(self->obj), r, c,
                              &pixmap, &mask)) {
        PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
        return NULL;
    }
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
                         pygobject_new((GObject *)mask));
}
#line 36095 "gtk.c"


static PyObject *
_wrap_gtk_clist_set_pixtext(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", "text", "spacing", "pixmap", "mask", NULL };
    int row, column, spacing;
    char *text;
    PyGObject *pixmap, *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iisiO!O!:Gtk.CList.set_pixtext", kwlist, &row, &column, &text, &spacing, &PyGdkPixmap_Type, &pixmap, &PyGdkPixmap_Type, &mask))
        return NULL;
    
    gtk_clist_set_pixtext(GTK_CLIST(self->obj), row, column, text, spacing, GDK_PIXMAP(pixmap->obj), GDK_PIXMAP(mask->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 119 "gtkclist.override"
static PyObject *
_wrap_gtk_clist_get_pixtext(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    gchar *text;
    guint8 spacing;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_pixtext",
                                     kwlist, &r, &c))
        return NULL;
    if (!gtk_clist_get_pixtext(GTK_CLIST(self->obj), r, c,
                              &text, &spacing, &pixmap, &mask)) {
        PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
        return NULL;
    }
    return Py_BuildValue("(ziNN)", text, (gint)spacing,
                         pygobject_new((GObject *)pixmap),
                         pygobject_new((GObject *)mask));
}
#line 36138 "gtk.c"


static PyObject *
_wrap_gtk_clist_set_foreground(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "color", NULL };
    int row;
    PyObject *py_color;
    GdkColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iO:Gtk.CList.set_foreground", kwlist, &row, &py_color))
        return NULL;
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor");
        return NULL;
    }
    
    gtk_clist_set_foreground(GTK_CLIST(self->obj), row, color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_background(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "color", NULL };
    int row;
    PyObject *py_color;
    GdkColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iO:Gtk.CList.set_background", kwlist, &row, &py_color))
        return NULL;
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor");
        return NULL;
    }
    
    gtk_clist_set_background(GTK_CLIST(self->obj), row, color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_cell_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", "style", NULL };
    int row, column;
    PyGObject *style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iiO!:Gtk.CList.set_cell_style", kwlist, &row, &column, &PyGtkStyle_Type, &style))
        return NULL;
    
    gtk_clist_set_cell_style(GTK_CLIST(self->obj), row, column, GTK_STYLE(style->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_get_cell_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int row, column;
    GtkStyle *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.get_cell_style", kwlist, &row, &column))
        return NULL;
    
    ret = gtk_clist_get_cell_style(GTK_CLIST(self->obj), row, column);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_clist_set_row_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "style", NULL };
    int row;
    PyGObject *style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iO!:Gtk.CList.set_row_style", kwlist, &row, &PyGtkStyle_Type, &style))
        return NULL;
    
    gtk_clist_set_row_style(GTK_CLIST(self->obj), row, GTK_STYLE(style->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_get_row_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    int row;
    GtkStyle *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.get_row_style", kwlist, &row))
        return NULL;
    
    ret = gtk_clist_get_row_style(GTK_CLIST(self->obj), row);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_clist_set_shift(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", "vertical", "horizontal", NULL };
    int row, column, vertical, horizontal;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iiii:Gtk.CList.set_shift", kwlist, &row, &column, &vertical, &horizontal))
        return NULL;
    
    gtk_clist_set_shift(GTK_CLIST(self->obj), row, column, vertical, horizontal);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_selectable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "selectable", NULL };
    int row, selectable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.set_selectable", kwlist, &row, &selectable))
        return NULL;
    
    gtk_clist_set_selectable(GTK_CLIST(self->obj), row, selectable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_get_selectable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    int row, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.get_selectable", kwlist, &row))
        return NULL;
    
    ret = gtk_clist_get_selectable(GTK_CLIST(self->obj), row);
    
    return PyBool_FromLong(ret);

}

#line 143 "gtkclist.override"
static PyObject *
_wrap_gtk_clist_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCList.prepend",
                                     kwlist, &py_list))
        return NULL;
    if (!PySequence_Check(py_list)) {
        PyErr_SetString(PyExc_TypeError, "argument not a sequence");
        return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
        PyErr_SetString(PyExc_TypeError, "sequence too short");
        return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
        PyObject *item = PySequence_GetItem(py_list, i);

        Py_DECREF(item);
        if (!PyString_Check(item) && !PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "sequence item not a string or unicode object");
            g_free(list);
            return NULL;
        }
        list[i] = PyString_AsString(item);
    }
    i = gtk_clist_prepend(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
#line 36334 "gtk.c"


#line 182 "gtkclist.override"
static PyObject *
_wrap_gtk_clist_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCList.append",
                                     kwlist, &py_list))
        return NULL;
    if (!PySequence_Check(py_list)) {
        PyErr_SetString(PyExc_TypeError, "argument not a sequence");
        return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
        PyErr_SetString(PyExc_TypeError, "sequence too short");
        return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
        PyObject *item = PySequence_GetItem(py_list, i);

        Py_DECREF(item);
        if (!PyString_Check(item) && !PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "sequence item not a string or unicode object");
            g_free(list);
            return NULL;
        }
        list[i] = PyString_AsString(item);
    }
    i = gtk_clist_append(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
#line 36375 "gtk.c"


#line 221 "gtkclist.override"
static PyObject *
_wrap_gtk_clist_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "text", NULL };
    int col, row, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:GtkCList.insert",
                                     kwlist, &row, &py_list))
        return NULL;
    if (!PySequence_Check(py_list)) {
        PyErr_SetString(PyExc_TypeError, "argument not a sequence");
        return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
        PyErr_SetString(PyExc_TypeError, "sequence too short");
        return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
        PyObject *item = PySequence_GetItem(py_list, i);

        Py_DECREF(item);
        if (!PyString_Check(item) && !PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "sequence item not a string or unicode object");
            g_free(list);
            return NULL;
        }
        list[i] = PyString_AsString(item);
    }
    i = gtk_clist_insert(GTK_CLIST(self->obj), row, list);
    g_free(list);
    return PyInt_FromLong(i);
}
#line 36416 "gtk.c"


static PyObject *
_wrap_gtk_clist_remove(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    int row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.remove", kwlist, &row))
        return NULL;
    
    gtk_clist_remove(GTK_CLIST(self->obj), row);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 260 "gtkclist.override"
static PyObject *
_wrap_gtk_clist_set_row_data(PyGObject *self, PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "row", "data", NULL };
    int row;
    PyObject *data;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:GtkCList.set_row_data",
                                     kwlist, &row, &data))
        return NULL;
    Py_INCREF(data);
    gtk_clist_set_row_data_full(GTK_CLIST(self->obj), row, data,
                                (GtkDestroyNotify)pyg_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 36451 "gtk.c"


#line 278 "gtkclist.override"
static PyObject *
_wrap_gtk_clist_get_row_data(PyGObject *self, PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    PyObject *ret;
    int row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkCList.get_row_data",
                                     kwlist, &row))
        return NULL;
    ret = gtk_clist_get_row_data(GTK_CLIST(self->obj), row);
    if (!ret) ret = Py_None;
    Py_INCREF(ret);
    return ret;
}
#line 36471 "gtk.c"


#line 296 "gtkclist.override"
static PyObject *
_wrap_gtk_clist_find_row_from_data(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "data", NULL };
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkCList.find_row_from_data", kwlist,
                                     &data))
        return NULL;
    return PyInt_FromLong(gtk_clist_find_row_from_data(
                                GTK_CLIST(self->obj), data));
}
#line 36489 "gtk.c"


static PyObject *
_wrap_gtk_clist_select_row(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int row, column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.select_row", kwlist, &row, &column))
        return NULL;
    
    gtk_clist_select_row(GTK_CLIST(self->obj), row, column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_unselect_row(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int row, column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.unselect_row", kwlist, &row, &column))
        return NULL;
    
    gtk_clist_unselect_row(GTK_CLIST(self->obj), row, column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_undo_selection(PyGObject *self)
{
    
    gtk_clist_undo_selection(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_clear(PyGObject *self)
{
    
    gtk_clist_clear(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 312 "gtkclist.override"
static PyObject *
_wrap_gtk_clist_get_selection_info(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    gint x, y, row, column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "ii:GtkCList.get_selection_info", kwlist,
                                     &x, &y))
        return NULL;
    if (gtk_clist_get_selection_info(GTK_CLIST(self->obj), x, y,
                                     &row, &column))
        return Py_BuildValue("(ii)", row, column);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
#line 36562 "gtk.c"


static PyObject *
_wrap_gtk_clist_select_all(PyGObject *self)
{
    
    gtk_clist_select_all(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_unselect_all(PyGObject *self)
{
    
    gtk_clist_unselect_all(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_swap_rows(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row1", "row2", NULL };
    int row1, row2;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.swap_rows", kwlist, &row1, &row2))
        return NULL;
    
    gtk_clist_swap_rows(GTK_CLIST(self->obj), row1, row2);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_row_move(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "source_row", "dest_row", NULL };
    int source_row, dest_row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CList.row_move", kwlist, &source_row, &dest_row))
        return NULL;
    
    gtk_clist_row_move(GTK_CLIST(self->obj), source_row, dest_row);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_sort_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.set_sort_column", kwlist, &column))
        return NULL;
    
    gtk_clist_set_sort_column(GTK_CLIST(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_sort_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sort_type", NULL };
    PyObject *py_sort_type = NULL;
    GtkSortType sort_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CList.set_sort_type", kwlist, &py_sort_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SORT_TYPE, py_sort_type, (gpointer)&sort_type))
        return NULL;
    
    gtk_clist_set_sort_type(GTK_CLIST(self->obj), sort_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_sort(PyGObject *self)
{
    
    gtk_clist_sort(GTK_CLIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_clist_set_auto_sort(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "auto_sort", NULL };
    int auto_sort;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CList.set_auto_sort", kwlist, &auto_sort))
        return NULL;
    
    gtk_clist_set_auto_sort(GTK_CLIST(self->obj), auto_sort);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_set_scroll_adjustments(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "hadjustment", "vadjustment", NULL };
    PyGObject *self, *hadjustment, *vadjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!:Gtk.CList.set_scroll_adjustments", kwlist, &PyGtkCList_Type, &self, &PyGtkAdjustment_Type, &hadjustment, &PyGtkAdjustment_Type, &vadjustment))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->set_scroll_adjustments)
        GTK_CLIST_CLASS(klass)->set_scroll_adjustments(GTK_CLIST(self->obj), GTK_ADJUSTMENT(hadjustment->obj), GTK_ADJUSTMENT(vadjustment->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.set_scroll_adjustments not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_refresh(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.refresh", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->refresh)
        GTK_CLIST_CLASS(klass)->refresh(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.refresh not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_select_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "row", "column", "event", NULL };
    PyGObject *self;
    int row, column;
    PyObject *py_event;
    GdkEvent *event = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iiO:Gtk.CList.select_row", kwlist, &PyGtkCList_Type, &self, &row, &column, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->select_row)
        GTK_CLIST_CLASS(klass)->select_row(GTK_CLIST(self->obj), row, column, event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.select_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_unselect_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "row", "column", "event", NULL };
    PyGObject *self;
    int row, column;
    PyObject *py_event;
    GdkEvent *event = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iiO:Gtk.CList.unselect_row", kwlist, &PyGtkCList_Type, &self, &row, &column, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->unselect_row)
        GTK_CLIST_CLASS(klass)->unselect_row(GTK_CLIST(self->obj), row, column, event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.unselect_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_row_move(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "source_row", "dest_row", NULL };
    PyGObject *self;
    int source_row, dest_row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.CList.row_move", kwlist, &PyGtkCList_Type, &self, &source_row, &dest_row))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->row_move)
        GTK_CLIST_CLASS(klass)->row_move(GTK_CLIST(self->obj), source_row, dest_row);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.row_move not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_click_column(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "column", NULL };
    PyGObject *self;
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.CList.click_column", kwlist, &PyGtkCList_Type, &self, &column))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->click_column)
        GTK_CLIST_CLASS(klass)->click_column(GTK_CLIST(self->obj), column);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.click_column not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_resize_column(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "column", "width", NULL };
    PyGObject *self;
    int column, width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.CList.resize_column", kwlist, &PyGtkCList_Type, &self, &column, &width))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->resize_column)
        GTK_CLIST_CLASS(klass)->resize_column(GTK_CLIST(self->obj), column, width);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.resize_column not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_toggle_focus_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.toggle_focus_row", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->toggle_focus_row)
        GTK_CLIST_CLASS(klass)->toggle_focus_row(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.toggle_focus_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_select_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.select_all", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->select_all)
        GTK_CLIST_CLASS(klass)->select_all(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.select_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_unselect_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.unselect_all", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->unselect_all)
        GTK_CLIST_CLASS(klass)->unselect_all(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.unselect_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_undo_selection(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.undo_selection", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->undo_selection)
        GTK_CLIST_CLASS(klass)->undo_selection(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.undo_selection not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_start_selection(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.start_selection", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->start_selection)
        GTK_CLIST_CLASS(klass)->start_selection(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.start_selection not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_end_selection(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.end_selection", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->end_selection)
        GTK_CLIST_CLASS(klass)->end_selection(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.end_selection not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_extend_selection(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll_type", "position", "auto_start_selection", NULL };
    PyGObject *self;
    PyObject *py_scroll_type = NULL;
    int auto_start_selection;
    GtkScrollType scroll_type;
    double position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Odi:Gtk.CList.extend_selection", kwlist, &PyGtkCList_Type, &self, &py_scroll_type, &position, &auto_start_selection))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll_type, (gpointer)&scroll_type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->extend_selection)
        GTK_CLIST_CLASS(klass)->extend_selection(GTK_CLIST(self->obj), scroll_type, position, auto_start_selection);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.extend_selection not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_scroll_horizontal(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll_type", "position", NULL };
    PyGObject *self;
    PyObject *py_scroll_type = NULL;
    GtkScrollType scroll_type;
    double position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Od:Gtk.CList.scroll_horizontal", kwlist, &PyGtkCList_Type, &self, &py_scroll_type, &position))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll_type, (gpointer)&scroll_type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->scroll_horizontal)
        GTK_CLIST_CLASS(klass)->scroll_horizontal(GTK_CLIST(self->obj), scroll_type, position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.scroll_horizontal not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_scroll_vertical(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll_type", "position", NULL };
    PyGObject *self;
    PyObject *py_scroll_type = NULL;
    GtkScrollType scroll_type;
    double position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Od:Gtk.CList.scroll_vertical", kwlist, &PyGtkCList_Type, &self, &py_scroll_type, &position))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll_type, (gpointer)&scroll_type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->scroll_vertical)
        GTK_CLIST_CLASS(klass)->scroll_vertical(GTK_CLIST(self->obj), scroll_type, position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.scroll_vertical not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_toggle_add_mode(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.toggle_add_mode", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->toggle_add_mode)
        GTK_CLIST_CLASS(klass)->toggle_add_mode(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.toggle_add_mode not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_abort_column_resize(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.abort_column_resize", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->abort_column_resize)
        GTK_CLIST_CLASS(klass)->abort_column_resize(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.abort_column_resize not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_resync_selection(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.CList.resync_selection", kwlist, &PyGtkCList_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->resync_selection)
        GTK_CLIST_CLASS(klass)->resync_selection(GTK_CLIST(self->obj), event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.resync_selection not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_clear(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.clear", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->clear)
        GTK_CLIST_CLASS(klass)->clear(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.clear not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_fake_unselect_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "row", NULL };
    PyGObject *self;
    int row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.CList.fake_unselect_all", kwlist, &PyGtkCList_Type, &self, &row))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->fake_unselect_all)
        GTK_CLIST_CLASS(klass)->fake_unselect_all(GTK_CLIST(self->obj), row);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.fake_unselect_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_sort_list(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CList.sort_list", kwlist, &PyGtkCList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->sort_list)
        GTK_CLIST_CLASS(klass)->sort_list(GTK_CLIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.sort_list not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCList__do_remove_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "row", NULL };
    PyGObject *self;
    int row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.CList.remove_row", kwlist, &PyGtkCList_Type, &self, &row))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CLIST_CLASS(klass)->remove_row)
        GTK_CLIST_CLASS(klass)->remove_row(GTK_CLIST(self->obj), row);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CList.remove_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCList_methods[] = {
    { "set_hadjustment", (PyCFunction)_wrap_gtk_clist_set_hadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_vadjustment", (PyCFunction)_wrap_gtk_clist_set_vadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_hadjustment", (PyCFunction)_wrap_gtk_clist_get_hadjustment, METH_NOARGS,
      NULL },
    { "get_vadjustment", (PyCFunction)_wrap_gtk_clist_get_vadjustment, METH_NOARGS,
      NULL },
    { "set_shadow_type", (PyCFunction)_wrap_gtk_clist_set_shadow_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_selection_mode", (PyCFunction)_wrap_gtk_clist_set_selection_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_reorderable", (PyCFunction)_wrap_gtk_clist_set_reorderable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_use_drag_icons", (PyCFunction)_wrap_gtk_clist_set_use_drag_icons, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_button_actions", (PyCFunction)_wrap_gtk_clist_set_button_actions, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "freeze", (PyCFunction)_wrap_gtk_clist_freeze, METH_NOARGS,
      NULL },
    { "thaw", (PyCFunction)_wrap_gtk_clist_thaw, METH_NOARGS,
      NULL },
    { "column_titles_show", (PyCFunction)_wrap_gtk_clist_column_titles_show, METH_NOARGS,
      NULL },
    { "column_titles_hide", (PyCFunction)_wrap_gtk_clist_column_titles_hide, METH_NOARGS,
      NULL },
    { "column_title_active", (PyCFunction)_wrap_gtk_clist_column_title_active, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "column_title_passive", (PyCFunction)_wrap_gtk_clist_column_title_passive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "column_titles_active", (PyCFunction)_wrap_gtk_clist_column_titles_active, METH_NOARGS,
      NULL },
    { "column_titles_passive", (PyCFunction)_wrap_gtk_clist_column_titles_passive, METH_NOARGS,
      NULL },
    { "set_column_title", (PyCFunction)_wrap_gtk_clist_set_column_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_column_title", (PyCFunction)_wrap_gtk_clist_get_column_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_column_widget", (PyCFunction)_wrap_gtk_clist_set_column_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_column_widget", (PyCFunction)_wrap_gtk_clist_get_column_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_column_justification", (PyCFunction)_wrap_gtk_clist_set_column_justification, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_column_visibility", (PyCFunction)_wrap_gtk_clist_set_column_visibility, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_column_resizeable", (PyCFunction)_wrap_gtk_clist_set_column_resizeable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_column_auto_resize", (PyCFunction)_wrap_gtk_clist_set_column_auto_resize, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "columns_autosize", (PyCFunction)_wrap_gtk_clist_columns_autosize, METH_NOARGS,
      NULL },
    { "optimal_column_width", (PyCFunction)_wrap_gtk_clist_optimal_column_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_column_width", (PyCFunction)_wrap_gtk_clist_set_column_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_column_min_width", (PyCFunction)_wrap_gtk_clist_set_column_min_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_column_max_width", (PyCFunction)_wrap_gtk_clist_set_column_max_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_row_height", (PyCFunction)_wrap_gtk_clist_set_row_height, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "moveto", (PyCFunction)_wrap_gtk_clist_moveto, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "row_is_visible", (PyCFunction)_wrap_gtk_clist_row_is_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_cell_type", (PyCFunction)_wrap_gtk_clist_get_cell_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_text", (PyCFunction)_wrap_gtk_clist_set_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text", (PyCFunction)_wrap_gtk_clist_get_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_pixmap", (PyCFunction)_wrap_gtk_clist_set_pixmap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_pixmap", (PyCFunction)_wrap_gtk_clist_get_pixmap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_pixtext", (PyCFunction)_wrap_gtk_clist_set_pixtext, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_pixtext", (PyCFunction)_wrap_gtk_clist_get_pixtext, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_foreground", (PyCFunction)_wrap_gtk_clist_set_foreground, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_background", (PyCFunction)_wrap_gtk_clist_set_background, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_cell_style", (PyCFunction)_wrap_gtk_clist_set_cell_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_cell_style", (PyCFunction)_wrap_gtk_clist_get_cell_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_row_style", (PyCFunction)_wrap_gtk_clist_set_row_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_row_style", (PyCFunction)_wrap_gtk_clist_get_row_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_shift", (PyCFunction)_wrap_gtk_clist_set_shift, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_selectable", (PyCFunction)_wrap_gtk_clist_set_selectable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_selectable", (PyCFunction)_wrap_gtk_clist_get_selectable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend", (PyCFunction)_wrap_gtk_clist_prepend, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "append", (PyCFunction)_wrap_gtk_clist_append, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert", (PyCFunction)_wrap_gtk_clist_insert, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove", (PyCFunction)_wrap_gtk_clist_remove, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_row_data", (PyCFunction)_wrap_gtk_clist_set_row_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_row_data", (PyCFunction)_wrap_gtk_clist_get_row_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "find_row_from_data", (PyCFunction)_wrap_gtk_clist_find_row_from_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_row", (PyCFunction)_wrap_gtk_clist_select_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_row", (PyCFunction)_wrap_gtk_clist_unselect_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "undo_selection", (PyCFunction)_wrap_gtk_clist_undo_selection, METH_NOARGS,
      NULL },
    { "clear", (PyCFunction)_wrap_gtk_clist_clear, METH_NOARGS,
      NULL },
    { "get_selection_info", (PyCFunction)_wrap_gtk_clist_get_selection_info, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_all", (PyCFunction)_wrap_gtk_clist_select_all, METH_NOARGS,
      NULL },
    { "unselect_all", (PyCFunction)_wrap_gtk_clist_unselect_all, METH_NOARGS,
      NULL },
    { "swap_rows", (PyCFunction)_wrap_gtk_clist_swap_rows, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "row_move", (PyCFunction)_wrap_gtk_clist_row_move, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_sort_column", (PyCFunction)_wrap_gtk_clist_set_sort_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_sort_type", (PyCFunction)_wrap_gtk_clist_set_sort_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "sort", (PyCFunction)_wrap_gtk_clist_sort, METH_NOARGS,
      NULL },
    { "set_auto_sort", (PyCFunction)_wrap_gtk_clist_set_auto_sort, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_set_scroll_adjustments", (PyCFunction)_wrap_GtkCList__do_set_scroll_adjustments, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_refresh", (PyCFunction)_wrap_GtkCList__do_refresh, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_row", (PyCFunction)_wrap_GtkCList__do_select_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unselect_row", (PyCFunction)_wrap_GtkCList__do_unselect_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_row_move", (PyCFunction)_wrap_GtkCList__do_row_move, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_click_column", (PyCFunction)_wrap_GtkCList__do_click_column, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_resize_column", (PyCFunction)_wrap_GtkCList__do_resize_column, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toggle_focus_row", (PyCFunction)_wrap_GtkCList__do_toggle_focus_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_all", (PyCFunction)_wrap_GtkCList__do_select_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unselect_all", (PyCFunction)_wrap_GtkCList__do_unselect_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_undo_selection", (PyCFunction)_wrap_GtkCList__do_undo_selection, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_start_selection", (PyCFunction)_wrap_GtkCList__do_start_selection, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_end_selection", (PyCFunction)_wrap_GtkCList__do_end_selection, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_extend_selection", (PyCFunction)_wrap_GtkCList__do_extend_selection, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_scroll_horizontal", (PyCFunction)_wrap_GtkCList__do_scroll_horizontal, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_scroll_vertical", (PyCFunction)_wrap_GtkCList__do_scroll_vertical, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toggle_add_mode", (PyCFunction)_wrap_GtkCList__do_toggle_add_mode, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_abort_column_resize", (PyCFunction)_wrap_GtkCList__do_abort_column_resize, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_resync_selection", (PyCFunction)_wrap_GtkCList__do_resync_selection, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_clear", (PyCFunction)_wrap_GtkCList__do_clear, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_fake_unselect_all", (PyCFunction)_wrap_GtkCList__do_fake_unselect_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_sort_list", (PyCFunction)_wrap_GtkCList__do_sort_list, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_remove_row", (PyCFunction)_wrap_GtkCList__do_remove_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 333 "gtkclist.override"
static PyObject *
_wrap_gtk_clist__get_selection(PyGObject *self, void *closure)
{
    guint row;
    GList *selection;
    PyObject *py_int, *ret = PyList_New(0);

    if (ret == NULL)
        return NULL;

    for (selection = GTK_CLIST(self->obj)->selection; selection != NULL;
         selection = selection->next) {
        row = GPOINTER_TO_UINT(selection->data);

        py_int = PyInt_FromLong(row);

        if (!py_int) {
            Py_DECREF(ret);
            return NULL;
        }

        PyList_Append(ret, py_int);
        Py_DECREF(py_int);
    }
    return ret;

}
#line 37442 "gtk.c"


static PyObject *
_wrap_gtk_clist__get_focus_row(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_CLIST(pygobject_get(self))->focus_row;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_clist__get_rows(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_CLIST(pygobject_get(self))->rows;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_clist__get_columns(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_CLIST(pygobject_get(self))->columns;
    return PyInt_FromLong(ret);
}

static const PyGetSetDef gtk_clist_getsets[] = {
    { "selection", (getter)_wrap_gtk_clist__get_selection, (setter)0 },
    { "focus_row", (getter)_wrap_gtk_clist__get_focus_row, (setter)0 },
    { "rows", (getter)_wrap_gtk_clist__get_rows, (setter)0 },
    { "columns", (getter)_wrap_gtk_clist__get_columns, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkCList_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CList",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCList_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_clist_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_clist_new_with_titles,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCList__proxy_do_set_scroll_adjustments(GtkCList *self, GtkAdjustment*hadjustment, GtkAdjustment*vadjustment)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_hadjustment = NULL;
    PyObject *py_vadjustment = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (hadjustment)
        py_hadjustment = pygobject_new((GObject *) hadjustment);
    else {
        Py_INCREF(Py_None);
        py_hadjustment = Py_None;
    }
    if (vadjustment)
        py_vadjustment = pygobject_new((GObject *) vadjustment);
    else {
        Py_INCREF(Py_None);
        py_vadjustment = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_hadjustment);
    PyTuple_SET_ITEM(py_args, 1, py_vadjustment);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_scroll_adjustments");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_refresh(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_refresh");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_select_row(GtkCList *self, gint row, gint column, GdkEvent*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_row;
    PyObject *py_column;
    PyObject *py_event;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_row = PyInt_FromLong(row);
    py_column = PyInt_FromLong(column);
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_row);
    PyTuple_SET_ITEM(py_args, 1, py_column);
    PyTuple_SET_ITEM(py_args, 2, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_select_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_unselect_row(GtkCList *self, gint row, gint column, GdkEvent*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_row;
    PyObject *py_column;
    PyObject *py_event;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_row = PyInt_FromLong(row);
    py_column = PyInt_FromLong(column);
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_row);
    PyTuple_SET_ITEM(py_args, 1, py_column);
    PyTuple_SET_ITEM(py_args, 2, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_unselect_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_row_move(GtkCList *self, gint source_row, gint dest_row)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_source_row;
    PyObject *py_dest_row;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_source_row = PyInt_FromLong(source_row);
    py_dest_row = PyInt_FromLong(dest_row);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_source_row);
    PyTuple_SET_ITEM(py_args, 1, py_dest_row);
    
    py_method = PyObject_GetAttrString(py_self, "do_row_move");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_click_column(GtkCList *self, gint column)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_column;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_column = PyInt_FromLong(column);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_column);
    
    py_method = PyObject_GetAttrString(py_self, "do_click_column");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_resize_column(GtkCList *self, gint column, gint width)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_column;
    PyObject *py_width;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_column = PyInt_FromLong(column);
    py_width = PyInt_FromLong(width);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_column);
    PyTuple_SET_ITEM(py_args, 1, py_width);
    
    py_method = PyObject_GetAttrString(py_self, "do_resize_column");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_toggle_focus_row(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_focus_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_select_all(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_select_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_unselect_all(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_unselect_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_undo_selection(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_undo_selection");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_start_selection(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_start_selection");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_end_selection(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_end_selection");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_extend_selection(GtkCList *self, GtkScrollType scroll_type, gfloat position, gboolean auto_start_selection)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll_type;
    PyObject *py_position;
    PyObject *py_auto_start_selection;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_scroll_type = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll_type);
    if (!py_scroll_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_position = PyFloat_FromDouble(position);
    py_auto_start_selection = auto_start_selection? Py_True : Py_False;
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_scroll_type);
    PyTuple_SET_ITEM(py_args, 1, py_position);
    Py_INCREF(py_auto_start_selection);
    PyTuple_SET_ITEM(py_args, 2, py_auto_start_selection);
    
    py_method = PyObject_GetAttrString(py_self, "do_extend_selection");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_scroll_horizontal(GtkCList *self, GtkScrollType scroll_type, gfloat position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll_type;
    PyObject *py_position;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_scroll_type = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll_type);
    if (!py_scroll_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_position = PyFloat_FromDouble(position);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_scroll_type);
    PyTuple_SET_ITEM(py_args, 1, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_scroll_horizontal");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_scroll_vertical(GtkCList *self, GtkScrollType scroll_type, gfloat position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll_type;
    PyObject *py_position;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_scroll_type = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll_type);
    if (!py_scroll_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_position = PyFloat_FromDouble(position);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_scroll_type);
    PyTuple_SET_ITEM(py_args, 1, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_scroll_vertical");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_toggle_add_mode(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_add_mode");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_abort_column_resize(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_abort_column_resize");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_resync_selection(GtkCList *self, GdkEvent*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_resync_selection");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_clear(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_clear");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_fake_unselect_all(GtkCList *self, gint row)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_row;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_row = PyInt_FromLong(row);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_row);
    
    py_method = PyObject_GetAttrString(py_self, "do_fake_unselect_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_sort_list(GtkCList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_sort_list");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCList__proxy_do_remove_row(GtkCList *self, gint row)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_row;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_row = PyInt_FromLong(row);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_row);
    
    py_method = PyObject_GetAttrString(py_self, "do_remove_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkCList_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkCListClass *klass = GTK_CLIST_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_scroll_adjustments");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_scroll_adjustments")))
            klass->set_scroll_adjustments = _wrap_GtkCList__proxy_do_set_scroll_adjustments;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_refresh");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "refresh")))
            klass->refresh = _wrap_GtkCList__proxy_do_refresh;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_row")))
            klass->select_row = _wrap_GtkCList__proxy_do_select_row;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_unselect_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "unselect_row")))
            klass->unselect_row = _wrap_GtkCList__proxy_do_unselect_row;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_row_move");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "row_move")))
            klass->row_move = _wrap_GtkCList__proxy_do_row_move;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_click_column");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "click_column")))
            klass->click_column = _wrap_GtkCList__proxy_do_click_column;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_resize_column");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "resize_column")))
            klass->resize_column = _wrap_GtkCList__proxy_do_resize_column;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_focus_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_focus_row")))
            klass->toggle_focus_row = _wrap_GtkCList__proxy_do_toggle_focus_row;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_all")))
            klass->select_all = _wrap_GtkCList__proxy_do_select_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_unselect_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "unselect_all")))
            klass->unselect_all = _wrap_GtkCList__proxy_do_unselect_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_undo_selection");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "undo_selection")))
            klass->undo_selection = _wrap_GtkCList__proxy_do_undo_selection;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_start_selection");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "start_selection")))
            klass->start_selection = _wrap_GtkCList__proxy_do_start_selection;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_end_selection");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "end_selection")))
            klass->end_selection = _wrap_GtkCList__proxy_do_end_selection;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_extend_selection");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "extend_selection")))
            klass->extend_selection = _wrap_GtkCList__proxy_do_extend_selection;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_scroll_horizontal");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "scroll_horizontal")))
            klass->scroll_horizontal = _wrap_GtkCList__proxy_do_scroll_horizontal;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_scroll_vertical");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "scroll_vertical")))
            klass->scroll_vertical = _wrap_GtkCList__proxy_do_scroll_vertical;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_add_mode");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_add_mode")))
            klass->toggle_add_mode = _wrap_GtkCList__proxy_do_toggle_add_mode;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_abort_column_resize");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "abort_column_resize")))
            klass->abort_column_resize = _wrap_GtkCList__proxy_do_abort_column_resize;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_resync_selection");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "resync_selection")))
            klass->resync_selection = _wrap_GtkCList__proxy_do_resync_selection;
        Py_DECREF(o);
    }

    /* overriding do_selection_find is currently not supported */

    /* overriding do_draw_row is currently not supported */

    /* overriding do_draw_drag_highlight is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_clear");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "clear")))
            klass->clear = _wrap_GtkCList__proxy_do_clear;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_fake_unselect_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "fake_unselect_all")))
            klass->fake_unselect_all = _wrap_GtkCList__proxy_do_fake_unselect_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_sort_list");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "sort_list")))
            klass->sort_list = _wrap_GtkCList__proxy_do_sort_list;
        Py_DECREF(o);
    }

    /* overriding do_insert_row is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_remove_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "remove_row")))
            klass->remove_row = _wrap_GtkCList__proxy_do_remove_row;
        Py_DECREF(o);
    }

    /* overriding do_set_cell_contents is currently not supported */

    /* overriding do_cell_size_request is currently not supported */
    return 0;
}


/* ----------- GtkColorButton ----------- */

#line 4358 "./gtk.override"
static int
_wrap_gtk_color_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "color", NULL };
    GdkColor *color = NULL;
    PyObject *pycolor = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|O:GtkColorButton.__init__",
                                     kwlist, &pycolor))
        return -1;
    if (pycolor) {
 	if (!pyg_boxed_check(pycolor, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError,
			    "color should be a gtk.gdk.Color");
 		return -1;
	    }
        color = pyg_boxed_get(pycolor, GdkColor);
        pygobject_construct(self, "color", color, NULL);
    } else {
        pygobject_construct(self, NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkColorButton object");
        return -1;
    }
    return 0;
}
#line 39178 "gtk.c"


static PyObject *
_wrap_gtk_color_button_set_color(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "color", NULL };
    PyObject *py_color;
    GdkColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ColorButton.set_color", kwlist, &py_color))
        return NULL;
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor");
        return NULL;
    }
    
    gtk_color_button_set_color(GTK_COLOR_BUTTON(self->obj), color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_color_button_set_alpha(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "alpha", NULL };
    int alpha;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ColorButton.set_alpha", kwlist, &alpha))
        return NULL;
    
    gtk_color_button_set_alpha(GTK_COLOR_BUTTON(self->obj), alpha);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4390 "./gtk.override"
static PyObject *
_wrap_gtk_color_button_get_color(PyGObject *self)
{
    GdkColor color = {0, 0, 0, 0};
 
    gtk_color_button_get_color(GTK_COLOR_BUTTON(self->obj), &color);
    return pyg_boxed_new(GDK_TYPE_COLOR, &color, TRUE, TRUE);
}
#line 39227 "gtk.c"


static PyObject *
_wrap_gtk_color_button_get_alpha(PyGObject *self)
{
    int ret;

    
    ret = gtk_color_button_get_alpha(GTK_COLOR_BUTTON(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_color_button_set_use_alpha(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_alpha", NULL };
    int use_alpha;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ColorButton.set_use_alpha", kwlist, &use_alpha))
        return NULL;
    
    gtk_color_button_set_use_alpha(GTK_COLOR_BUTTON(self->obj), use_alpha);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_color_button_get_use_alpha(PyGObject *self)
{
    int ret;

    
    ret = gtk_color_button_get_use_alpha(GTK_COLOR_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_color_button_set_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "title", NULL };
    char *title;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ColorButton.set_title", kwlist, &title))
        return NULL;
    
    gtk_color_button_set_title(GTK_COLOR_BUTTON(self->obj), title);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_color_button_get_title(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_color_button_get_title(GTK_COLOR_BUTTON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkColorButton__do_color_set(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ColorButton.color_set", kwlist, &PyGtkColorButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_COLOR_BUTTON_CLASS(klass)->color_set)
        GTK_COLOR_BUTTON_CLASS(klass)->color_set(GTK_COLOR_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ColorButton.color_set not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkColorButton_methods[] = {
    { "set_color", (PyCFunction)_wrap_gtk_color_button_set_color, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_alpha", (PyCFunction)_wrap_gtk_color_button_set_alpha, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_color", (PyCFunction)_wrap_gtk_color_button_get_color, METH_NOARGS,
      NULL },
    { "get_alpha", (PyCFunction)_wrap_gtk_color_button_get_alpha, METH_NOARGS,
      NULL },
    { "set_use_alpha", (PyCFunction)_wrap_gtk_color_button_set_use_alpha, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_alpha", (PyCFunction)_wrap_gtk_color_button_get_use_alpha, METH_NOARGS,
      NULL },
    { "set_title", (PyCFunction)_wrap_gtk_color_button_set_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_title", (PyCFunction)_wrap_gtk_color_button_get_title, METH_NOARGS,
      NULL },
    { "do_color_set", (PyCFunction)_wrap_GtkColorButton__do_color_set, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkColorButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ColorButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkColorButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_color_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkColorButton__proxy_do_color_set(GtkColorButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_color_set");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkColorButton_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkColorButtonClass *klass = GTK_COLOR_BUTTON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_color_set");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "color_set")))
            klass->color_set = _wrap_GtkColorButton__proxy_do_color_set;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkVBox ----------- */

static int
_wrap_gtk_vbox_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[2];
    PyObject *parsed_args[2] = {NULL, };
    char *arg_names[] = {"homogeneous", "spacing", NULL };
    char *prop_names[] = {"homogeneous", "spacing", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:gtk.VBox.__init__" , arg_names , &parsed_args[0] , &parsed_args[1]))
        return -1;

    memset(params, 0, sizeof(GParameter)*2);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.VBox object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkVBox_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.VBox",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_vbox_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkColorSelection ----------- */

 static int
_wrap_gtk_color_selection_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.ColorSelection.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.ColorSelection object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_color_selection_get_has_opacity_control(PyGObject *self)
{
    int ret;

    
    ret = gtk_color_selection_get_has_opacity_control(GTK_COLOR_SELECTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_color_selection_set_has_opacity_control(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "has_opacity", NULL };
    int has_opacity;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ColorSelection.set_has_opacity_control", kwlist, &has_opacity))
        return NULL;
    
    gtk_color_selection_set_has_opacity_control(GTK_COLOR_SELECTION(self->obj), has_opacity);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_color_selection_get_has_palette(PyGObject *self)
{
    int ret;

    
    ret = gtk_color_selection_get_has_palette(GTK_COLOR_SELECTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_color_selection_set_has_palette(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "has_palette", NULL };
    int has_palette;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ColorSelection.set_has_palette", kwlist, &has_palette))
        return NULL;
    
    gtk_color_selection_set_has_palette(GTK_COLOR_SELECTION(self->obj), has_palette);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_color_selection_set_current_color(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "color", NULL };
    PyObject *py_color;
    GdkColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ColorSelection.set_current_color", kwlist, &py_color))
        return NULL;
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor");
        return NULL;
    }
    
    gtk_color_selection_set_current_color(GTK_COLOR_SELECTION(self->obj), color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_color_selection_set_current_alpha(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "alpha", NULL };
    int alpha;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ColorSelection.set_current_alpha", kwlist, &alpha))
        return NULL;
    
    gtk_color_selection_set_current_alpha(GTK_COLOR_SELECTION(self->obj), alpha);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2345 "./gtk.override"
static PyObject *
_wrap_gtk_color_selection_get_current_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(self->obj),
                                          &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
#line 39661 "gtk.c"


static PyObject *
_wrap_gtk_color_selection_get_current_alpha(PyGObject *self)
{
    int ret;

    
    ret = gtk_color_selection_get_current_alpha(GTK_COLOR_SELECTION(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_color_selection_set_previous_color(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "color", NULL };
    PyObject *py_color;
    GdkColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ColorSelection.set_previous_color", kwlist, &py_color))
        return NULL;
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor");
        return NULL;
    }
    
    gtk_color_selection_set_previous_color(GTK_COLOR_SELECTION(self->obj), color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_color_selection_set_previous_alpha(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "alpha", NULL };
    int alpha;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ColorSelection.set_previous_alpha", kwlist, &alpha))
        return NULL;
    
    gtk_color_selection_set_previous_alpha(GTK_COLOR_SELECTION(self->obj), alpha);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2356 "./gtk.override"
static PyObject *
_wrap_gtk_color_selection_get_previous_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(self->obj),
                                           &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
#line 39722 "gtk.c"


static PyObject *
_wrap_gtk_color_selection_get_previous_alpha(PyGObject *self)
{
    int ret;

    
    ret = gtk_color_selection_get_previous_alpha(GTK_COLOR_SELECTION(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_color_selection_is_adjusting(PyGObject *self)
{
    int ret;

    
    ret = gtk_color_selection_is_adjusting(GTK_COLOR_SELECTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_color_selection_set_update_policy(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "policy", NULL };
    PyObject *py_policy = NULL;
    GtkUpdateType policy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ColorSelection.set_update_policy", kwlist, &py_policy))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UPDATE_TYPE, py_policy, (gpointer)&policy))
        return NULL;
    
    gtk_color_selection_set_update_policy(GTK_COLOR_SELECTION(self->obj), policy);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkColorSelection__do_color_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ColorSelection.color_changed", kwlist, &PyGtkColorSelection_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_COLOR_SELECTION_CLASS(klass)->color_changed)
        GTK_COLOR_SELECTION_CLASS(klass)->color_changed(GTK_COLOR_SELECTION(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ColorSelection.color_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkColorSelection_methods[] = {
    { "get_has_opacity_control", (PyCFunction)_wrap_gtk_color_selection_get_has_opacity_control, METH_NOARGS,
      NULL },
    { "set_has_opacity_control", (PyCFunction)_wrap_gtk_color_selection_set_has_opacity_control, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_palette", (PyCFunction)_wrap_gtk_color_selection_get_has_palette, METH_NOARGS,
      NULL },
    { "set_has_palette", (PyCFunction)_wrap_gtk_color_selection_set_has_palette, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_current_color", (PyCFunction)_wrap_gtk_color_selection_set_current_color, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_current_alpha", (PyCFunction)_wrap_gtk_color_selection_set_current_alpha, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_color", (PyCFunction)_wrap_gtk_color_selection_get_current_color, METH_NOARGS,
      NULL },
    { "get_current_alpha", (PyCFunction)_wrap_gtk_color_selection_get_current_alpha, METH_NOARGS,
      NULL },
    { "set_previous_color", (PyCFunction)_wrap_gtk_color_selection_set_previous_color, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_previous_alpha", (PyCFunction)_wrap_gtk_color_selection_set_previous_alpha, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_previous_color", (PyCFunction)_wrap_gtk_color_selection_get_previous_color, METH_NOARGS,
      NULL },
    { "get_previous_alpha", (PyCFunction)_wrap_gtk_color_selection_get_previous_alpha, METH_NOARGS,
      NULL },
    { "is_adjusting", (PyCFunction)_wrap_gtk_color_selection_is_adjusting, METH_NOARGS,
      NULL },
    { "set_update_policy", (PyCFunction)_wrap_gtk_color_selection_set_update_policy, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_color_changed", (PyCFunction)_wrap_GtkColorSelection__do_color_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkColorSelection_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ColorSelection",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkColorSelection_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_color_selection_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkColorSelection__proxy_do_color_changed(GtkColorSelection *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_color_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkColorSelection_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkColorSelectionClass *klass = GTK_COLOR_SELECTION_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_color_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "color_changed")))
            klass->color_changed = _wrap_GtkColorSelection__proxy_do_color_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkColorSelectionDialog ----------- */

static int
_wrap_gtk_color_selection_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"title", NULL };
    char *prop_names[] = {"title", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:gtk.ColorSelectionDialog.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.ColorSelectionDialog object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_color_selection_dialog_get_color_selection(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_color_selection_dialog_get_color_selection(GTK_COLOR_SELECTION_DIALOG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkColorSelectionDialog_methods[] = {
    { "get_color_selection", (PyCFunction)_wrap_gtk_color_selection_dialog_get_color_selection, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_color_selection_dialog__get_colorsel(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_COLOR_SELECTION_DIALOG(pygobject_get(self))->colorsel;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_color_selection_dialog__get_ok_button(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_COLOR_SELECTION_DIALOG(pygobject_get(self))->ok_button;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_color_selection_dialog__get_cancel_button(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_COLOR_SELECTION_DIALOG(pygobject_get(self))->cancel_button;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_color_selection_dialog__get_help_button(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_COLOR_SELECTION_DIALOG(pygobject_get(self))->help_button;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyGetSetDef gtk_color_selection_dialog_getsets[] = {
    { "colorsel", (getter)_wrap_gtk_color_selection_dialog__get_colorsel, (setter)0 },
    { "ok_button", (getter)_wrap_gtk_color_selection_dialog__get_ok_button, (setter)0 },
    { "cancel_button", (getter)_wrap_gtk_color_selection_dialog__get_cancel_button, (setter)0 },
    { "help_button", (getter)_wrap_gtk_color_selection_dialog__get_help_button, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkColorSelectionDialog_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ColorSelectionDialog",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkColorSelectionDialog_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_color_selection_dialog_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_color_selection_dialog_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkHBox ----------- */

 static int
_wrap_gtk_hbox_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[2];
    PyObject *parsed_args[2] = {NULL, };
    char *arg_names[] = {"homogeneous", "spacing", NULL };
    char *prop_names[] = {"homogeneous", "spacing", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:gtk.HBox.__init__" , arg_names , &parsed_args[0] , &parsed_args[1]))
        return -1;

    memset(params, 0, sizeof(GParameter)*2);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.HBox object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkHBox_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.HBox",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_hbox_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkCombo ----------- */

 static int
_wrap_gtk_combo_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.ComboBoxEntry") < 0)
        return -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Combo.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Combo object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_combo_set_value_in_list(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "val", "ok_if_empty", NULL };
    int val, ok_if_empty;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Combo.set_value_in_list", kwlist, &val, &ok_if_empty))
        return NULL;
    
    gtk_combo_set_value_in_list(GTK_COMBO(self->obj), val, ok_if_empty);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_set_use_arrows(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "val", NULL };
    int val;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Combo.set_use_arrows", kwlist, &val))
        return NULL;
    
    gtk_combo_set_use_arrows(GTK_COMBO(self->obj), val);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_set_use_arrows_always(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "val", NULL };
    int val;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Combo.set_use_arrows_always", kwlist, &val))
        return NULL;
    
    gtk_combo_set_use_arrows_always(GTK_COMBO(self->obj), val);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_set_case_sensitive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "val", NULL };
    int val;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Combo.set_case_sensitive", kwlist, &val))
        return NULL;
    
    gtk_combo_set_case_sensitive(GTK_COMBO(self->obj), val);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_set_item_string(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item", "item_value", NULL };
    PyGObject *item;
    char *item_value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.Combo.set_item_string", kwlist, &PyGtkItem_Type, &item, &item_value))
        return NULL;
    
    gtk_combo_set_item_string(GTK_COMBO(self->obj), GTK_ITEM(item->obj), item_value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 864 "./gtk.override"
static PyObject *
_wrap_gtk_combo_set_popdown_strings(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "strings", NULL };
    PyObject *list;
    GList *glist = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkCombo.set_popdown_strings", kwlist,
                                     &list))
        return NULL;
    if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "first argument must be a sequence");
        return NULL;
    }
    len = PySequence_Length(list);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(list, i);

        Py_DECREF(item);
        if (!PyString_Check(item) && !PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "sequence item not a string or unicode object");
            g_list_free(glist);
            return NULL;
        }
        glist = g_list_append(glist, PyString_AsString(item));
    }
    gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
    g_list_free(glist);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 40303 "gtk.c"


static PyObject *
_wrap_gtk_combo_disable_activate(PyGObject *self)
{
    
    gtk_combo_disable_activate(GTK_COMBO(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCombo_methods[] = {
    { "set_value_in_list", (PyCFunction)_wrap_gtk_combo_set_value_in_list, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_use_arrows", (PyCFunction)_wrap_gtk_combo_set_use_arrows, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_use_arrows_always", (PyCFunction)_wrap_gtk_combo_set_use_arrows_always, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_case_sensitive", (PyCFunction)_wrap_gtk_combo_set_case_sensitive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_item_string", (PyCFunction)_wrap_gtk_combo_set_item_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_popdown_strings", (PyCFunction)_wrap_gtk_combo_set_popdown_strings, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "disable_activate", (PyCFunction)_wrap_gtk_combo_disable_activate, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_combo__get_entry(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_COMBO(pygobject_get(self))->entry;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_combo__get_list(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_COMBO(pygobject_get(self))->list;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyGetSetDef gtk_combo_getsets[] = {
    { "entry", (getter)_wrap_gtk_combo__get_entry, (setter)0 },
    { "list", (getter)_wrap_gtk_combo__get_list, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkCombo_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Combo",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCombo_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_combo_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_combo_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkComboBox ----------- */

#line 4400 "./gtk.override"
static int
_wrap_gtk_combo_box_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *pymodel = NULL;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkComboBox.__init__",
				     kwlist, &pymodel))
        return -1;
    if (pymodel == NULL || (PyObject *)pymodel == Py_None)
        pygobject_construct(self, NULL);
    else if (pygobject_check(pymodel, &PyGtkTreeModel_Type))
        pygobject_construct(self, "model", GTK_TREE_MODEL(pymodel->obj), NULL);
    else {
	PyErr_SetString(PyExc_TypeError,
			"model must be a gtk.TreeModel or None");
	return -1;
    }
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkComboBox object");
        return -1;
    }
    return 0;
}
#line 40436 "gtk.c"


static PyObject *
_wrap_gtk_combo_box_set_wrap_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", NULL };
    int width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ComboBox.set_wrap_width", kwlist, &width))
        return NULL;
    
    gtk_combo_box_set_wrap_width(GTK_COMBO_BOX(self->obj), width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_set_row_span_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row_span", NULL };
    int row_span;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ComboBox.set_row_span_column", kwlist, &row_span))
        return NULL;
    
    gtk_combo_box_set_row_span_column(GTK_COMBO_BOX(self->obj), row_span);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_set_column_span_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column_span", NULL };
    int column_span;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ComboBox.set_column_span_column", kwlist, &column_span))
        return NULL;
    
    gtk_combo_box_set_column_span_column(GTK_COMBO_BOX(self->obj), column_span);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_get_active(PyGObject *self)
{
    int ret;

    
    ret = gtk_combo_box_get_active(GTK_COMBO_BOX(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_combo_box_set_active(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "index", NULL };
    int index;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ComboBox.set_active", kwlist, &index))
        return NULL;
    
    gtk_combo_box_set_active(GTK_COMBO_BOX(self->obj), index);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4430 "./gtk.override"
static PyObject *
_wrap_gtk_combo_box_get_active_iter(PyGObject *self)
{
    GtkTreeIter iter;
    gboolean ret;

    ret = gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->obj), &iter);

    if (ret)
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 40525 "gtk.c"


static PyObject *
_wrap_gtk_combo_box_set_active_iter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ComboBox.set_active_iter", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_combo_box_set_active_iter(GTK_COMBO_BOX(self->obj), iter);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_set_model(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *py_model = NULL;
    GtkTreeModel *model = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.ComboBox.set_model", kwlist, &py_model))
        return NULL;
    if ((PyObject *)py_model == Py_None)
        model = NULL;
    else if (py_model && pygobject_check(py_model, &PyGtkTreeModel_Type))
        model = GTK_TREE_MODEL(py_model->obj);
    else if (py_model) {
        PyErr_SetString(PyExc_TypeError, "model should be a GtkTreeModel or None");
        return NULL;
    }
    
    gtk_combo_box_set_model(GTK_COMBO_BOX(self->obj), (GtkTreeModel *) model);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_get_model(PyGObject *self)
{
    GtkTreeModel *ret;

    
    ret = gtk_combo_box_get_model(GTK_COMBO_BOX(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_combo_box_append_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ComboBox.append_text", kwlist, &text))
        return NULL;
    
    gtk_combo_box_append_text(GTK_COMBO_BOX(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_insert_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", "text", NULL };
    int position;
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"is:Gtk.ComboBox.insert_text", kwlist, &position, &text))
        return NULL;
    
    gtk_combo_box_insert_text(GTK_COMBO_BOX(self->obj), position, text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_prepend_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ComboBox.prepend_text", kwlist, &text))
        return NULL;
    
    gtk_combo_box_prepend_text(GTK_COMBO_BOX(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_remove_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ComboBox.remove_text", kwlist, &position))
        return NULL;
    
    gtk_combo_box_remove_text(GTK_COMBO_BOX(self->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_popup(PyGObject *self)
{
    
    gtk_combo_box_popup(GTK_COMBO_BOX(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_popdown(PyGObject *self)
{
    
    gtk_combo_box_popdown(GTK_COMBO_BOX(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_get_wrap_width(PyGObject *self)
{
    int ret;

    
    ret = gtk_combo_box_get_wrap_width(GTK_COMBO_BOX(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_combo_box_get_row_span_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_combo_box_get_row_span_column(GTK_COMBO_BOX(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_combo_box_get_column_span_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_combo_box_get_column_span_column(GTK_COMBO_BOX(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_combo_box_get_add_tearoffs(PyGObject *self)
{
    int ret;

    
    ret = gtk_combo_box_get_add_tearoffs(GTK_COMBO_BOX(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_combo_box_set_add_tearoffs(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "add_tearoffs", NULL };
    int add_tearoffs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ComboBox.set_add_tearoffs", kwlist, &add_tearoffs))
        return NULL;
    
    gtk_combo_box_set_add_tearoffs(GTK_COMBO_BOX(self->obj), add_tearoffs);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_get_focus_on_click(PyGObject *self)
{
    int ret;

    
    ret = gtk_combo_box_get_focus_on_click(GTK_COMBO_BOX(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_combo_box_set_focus_on_click(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "focus_on_click", NULL };
    int focus_on_click;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ComboBox.set_focus_on_click", kwlist, &focus_on_click))
        return NULL;
    
    gtk_combo_box_set_focus_on_click(GTK_COMBO_BOX(self->obj), focus_on_click);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 6181 "./gtk.override"
static gboolean
pygtk_combo_box_row_separator_func_cb(GtkTreeModel *model,
				      GtkTreeIter *iter,
				      gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_model, *py_iter;
    gboolean ret = FALSE;
    PyObject *retobj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
 
    py_model = pygobject_new((GObject *)model);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, TRUE, TRUE);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNO)", py_model,
                                     py_iter, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NN)", py_model, py_iter);
    }

    if (retobj != NULL) {
	ret = PyObject_IsTrue(retobj);
        Py_DECREF(retobj);
    } else {
	PyErr_Print();
    }
 
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_combo_box_set_row_separator_func(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc = NULL, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTuple(args,
                          "|OO:GtkComboBox.set_row_separator_func",
                          &pyfunc, &pyarg))
        return NULL;

    if (pyfunc == NULL || pyfunc == Py_None) {
        gtk_combo_box_set_row_separator_func(GTK_COMBO_BOX(self->obj),
                                             NULL, NULL, NULL);
    } else if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);

        gtk_combo_box_set_row_separator_func(
            GTK_COMBO_BOX(self->obj),
            pygtk_combo_box_row_separator_func_cb,
            cunote,
            pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 40823 "gtk.c"


static PyObject *
_wrap_gtk_combo_box_get_active_text(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_combo_box_get_active_text(GTK_COMBO_BOX(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_get_popup_accessible(PyGObject *self)
{
    AtkObject *ret;

    
    ret = gtk_combo_box_get_popup_accessible(GTK_COMBO_BOX(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_combo_box_get_title(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_combo_box_get_title(GTK_COMBO_BOX(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_set_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "title", NULL };
    char *title;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ComboBox.set_title", kwlist, &title))
        return NULL;
    
    gtk_combo_box_set_title(GTK_COMBO_BOX(self->obj), title);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_set_button_sensitivity(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sensitivity", NULL };
    PyObject *py_sensitivity = NULL;
    GtkSensitivityType sensitivity;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ComboBox.set_button_sensitivity", kwlist, &py_sensitivity))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SENSITIVITY_TYPE, py_sensitivity, (gpointer)&sensitivity))
        return NULL;
    
    gtk_combo_box_set_button_sensitivity(GTK_COMBO_BOX(self->obj), sensitivity);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_get_button_sensitivity(PyGObject *self)
{
    gint ret;

    
    ret = gtk_combo_box_get_button_sensitivity(GTK_COMBO_BOX(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SENSITIVITY_TYPE, ret);
}

static PyObject *
_wrap_gtk_combo_box_get_has_entry(PyGObject *self)
{
    int ret;

    
    ret = gtk_combo_box_get_has_entry(GTK_COMBO_BOX(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_combo_box_set_entry_text_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text_column", NULL };
    int text_column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ComboBox.set_entry_text_column", kwlist, &text_column))
        return NULL;
    
    gtk_combo_box_set_entry_text_column(GTK_COMBO_BOX(self->obj), text_column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_get_entry_text_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_combo_box_get_entry_text_column(GTK_COMBO_BOX(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_GtkComboBox__do_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ComboBox.changed", kwlist, &PyGtkComboBox_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_COMBO_BOX_CLASS(klass)->changed)
        GTK_COMBO_BOX_CLASS(klass)->changed(GTK_COMBO_BOX(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ComboBox.changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkComboBox__do_get_active_text(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ComboBox.get_active_text", kwlist, &PyGtkComboBox_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_COMBO_BOX_CLASS(klass)->get_active_text)
        ret = GTK_COMBO_BOX_CLASS(klass)->get_active_text(GTK_COMBO_BOX(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ComboBox.get_active_text not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkComboBox_methods[] = {
    { "set_wrap_width", (PyCFunction)_wrap_gtk_combo_box_set_wrap_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_row_span_column", (PyCFunction)_wrap_gtk_combo_box_set_row_span_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_column_span_column", (PyCFunction)_wrap_gtk_combo_box_set_column_span_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_active", (PyCFunction)_wrap_gtk_combo_box_get_active, METH_NOARGS,
      NULL },
    { "set_active", (PyCFunction)_wrap_gtk_combo_box_set_active, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_active_iter", (PyCFunction)_wrap_gtk_combo_box_get_active_iter, METH_NOARGS,
      NULL },
    { "set_active_iter", (PyCFunction)_wrap_gtk_combo_box_set_active_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_model", (PyCFunction)_wrap_gtk_combo_box_set_model, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_model", (PyCFunction)_wrap_gtk_combo_box_get_model, METH_NOARGS,
      NULL },
    { "append_text", (PyCFunction)_wrap_gtk_combo_box_append_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_text", (PyCFunction)_wrap_gtk_combo_box_insert_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend_text", (PyCFunction)_wrap_gtk_combo_box_prepend_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_text", (PyCFunction)_wrap_gtk_combo_box_remove_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "popup", (PyCFunction)_wrap_gtk_combo_box_popup, METH_NOARGS,
      NULL },
    { "popdown", (PyCFunction)_wrap_gtk_combo_box_popdown, METH_NOARGS,
      NULL },
    { "get_wrap_width", (PyCFunction)_wrap_gtk_combo_box_get_wrap_width, METH_NOARGS,
      NULL },
    { "get_row_span_column", (PyCFunction)_wrap_gtk_combo_box_get_row_span_column, METH_NOARGS,
      NULL },
    { "get_column_span_column", (PyCFunction)_wrap_gtk_combo_box_get_column_span_column, METH_NOARGS,
      NULL },
    { "get_add_tearoffs", (PyCFunction)_wrap_gtk_combo_box_get_add_tearoffs, METH_NOARGS,
      NULL },
    { "set_add_tearoffs", (PyCFunction)_wrap_gtk_combo_box_set_add_tearoffs, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_focus_on_click", (PyCFunction)_wrap_gtk_combo_box_get_focus_on_click, METH_NOARGS,
      NULL },
    { "set_focus_on_click", (PyCFunction)_wrap_gtk_combo_box_set_focus_on_click, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_row_separator_func", (PyCFunction)_wrap_gtk_combo_box_set_row_separator_func, METH_VARARGS,
      NULL },
    { "get_active_text", (PyCFunction)_wrap_gtk_combo_box_get_active_text, METH_NOARGS,
      NULL },
    { "get_popup_accessible", (PyCFunction)_wrap_gtk_combo_box_get_popup_accessible, METH_NOARGS,
      NULL },
    { "get_title", (PyCFunction)_wrap_gtk_combo_box_get_title, METH_NOARGS,
      NULL },
    { "set_title", (PyCFunction)_wrap_gtk_combo_box_set_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_button_sensitivity", (PyCFunction)_wrap_gtk_combo_box_set_button_sensitivity, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_button_sensitivity", (PyCFunction)_wrap_gtk_combo_box_get_button_sensitivity, METH_NOARGS,
      NULL },
    { "get_has_entry", (PyCFunction)_wrap_gtk_combo_box_get_has_entry, METH_NOARGS,
      NULL },
    { "set_entry_text_column", (PyCFunction)_wrap_gtk_combo_box_set_entry_text_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_entry_text_column", (PyCFunction)_wrap_gtk_combo_box_get_entry_text_column, METH_NOARGS,
      NULL },
    { "do_changed", (PyCFunction)_wrap_GtkComboBox__do_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_active_text", (PyCFunction)_wrap_GtkComboBox__do_get_active_text, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkComboBox_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ComboBox",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkComboBox_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_combo_box_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkComboBox__proxy_do_changed(GtkComboBox *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static char*
_wrap_GtkComboBox__proxy_do_get_active_text(GtkComboBox *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    char* retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_active_text");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "s", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    retval = g_strdup(retval);
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkComboBox_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkComboBoxClass *klass = GTK_COMBO_BOX_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "changed")))
            klass->changed = _wrap_GtkComboBox__proxy_do_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_get_active_text");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "get_active_text")))
            klass->get_active_text = _wrap_GtkComboBox__proxy_do_get_active_text;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkComboBoxEntry ----------- */

#line 4479 "./gtk.override"
static int
_wrap_gtk_combo_box_entry_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "model", "column", NULL };
    PyGObject *pymodel = NULL;
    gint column = 0;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Oi:GtkComboBoxEntry.__init__",
				     kwlist, &pymodel, &column))
        return -1;
    if ((PyObject*)pymodel == Py_None || pymodel == NULL)
        pygobject_construct(self, NULL);
    else if (pygobject_check(pymodel, &PyGtkTreeModel_Type)) {
	gint ncol = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(pymodel->obj));

	if (column < 0 || column >= ncol) {
	    PyErr_SetString(PyExc_ValueError, "column value out of range");
	    return -1;
	}
        pygobject_construct(self, "model", GTK_TREE_MODEL(pymodel->obj),
                            "text-column", column, NULL);
    } else {
	PyErr_SetString(PyExc_TypeError,
			"model must be a gtk.TreeModel or None");
	return -1;
    }
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkComboBoxEntry object");
        return -1;
    }
    return 0;
}
#line 41296 "gtk.c"


static PyObject *
_wrap_gtk_combo_box_entry_set_text_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text_column", NULL };
    int text_column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ComboBoxEntry.set_text_column", kwlist, &text_column))
        return NULL;
    
    gtk_combo_box_entry_set_text_column(GTK_COMBO_BOX_ENTRY(self->obj), text_column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_combo_box_entry_get_text_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_combo_box_entry_get_text_column(GTK_COMBO_BOX_ENTRY(self->obj));
    
    return PyInt_FromLong(ret);
}

static const PyMethodDef _PyGtkComboBoxEntry_methods[] = {
    { "set_text_column", (PyCFunction)_wrap_gtk_combo_box_entry_set_text_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text_column", (PyCFunction)_wrap_gtk_combo_box_entry_get_text_column, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkComboBoxEntry_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ComboBoxEntry",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkComboBoxEntry_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_combo_box_entry_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkCTree ----------- */

#line 59 "gtkctree.override"
static int
_wrap_gtk_ctree_new_with_titles(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "columns", "tree_column", "titles", NULL };
    int columns = 1, tree_column = 0;
    PyObject *py_titles = NULL;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.TreeView") < 0)
        return -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iiO:GtkCTree.__init__",
                                     kwlist, &columns, &tree_column,
                                     &py_titles))
        return -1;
    if (py_titles) {
        gchar **titles;
        gint i;

        if (!PySequence_Check(py_titles)) {
            PyErr_SetString(PyExc_TypeError, "titles must be a sequence");
            return -1;
        }
        if (PySequence_Length(py_titles) < columns) {
            PyErr_SetString(PyExc_TypeError, "titles too short");
            return -1;
        }
        titles = g_new(gchar *, columns);
        for (i = 0; i < columns; i++) {
            PyObject *item = PySequence_GetItem(py_titles, i);

            Py_DECREF(item);
            if (!PyString_Check(item) && !PyUnicode_Check(item)) {
                PyErr_SetString(PyExc_TypeError,
                                "sequence item not a string or unicode object");
                g_free(titles);
                return -1;
            }
            titles[i] = PyString_AsString(item);
        }
        self->obj = (GObject *)gtk_ctree_new_with_titles(columns,
                                                tree_column, titles);
        g_free(titles);
    } else
        self->obj = (GObject *)gtk_ctree_new(columns, tree_column);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,"could not create GtkCTree object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
#line 41435 "gtk.c"


#line 113 "gtkctree.override"
static PyObject*
_wrap_gtk_ctree_base_nodes(PyGObject *self, PyObject *args)
{
    PyObject *ret;
    GtkCTreeNode *node;

    /* the first row is always a base node */
    node = GTK_CTREE_NODE(GTK_CLIST(self->obj)->row_list);
    if ((ret = PyList_New(0)) == NULL)
        return NULL;
    while (node) {
        PyObject *obj = pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
        if (obj == NULL) {
            Py_DECREF(ret);
            return NULL;
        }
        PyList_Append(ret, obj);
        Py_DECREF(obj);
        node = GTK_CTREE_ROW(node)->sibling;
    }
    return ret;
}
#line 41461 "gtk.c"


#line 137 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree_insert_node(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", "text", "spacing",
                              "pixmap_closed", "mask_closed", "pixmap_opened",
                              "mask_opened", "is_leaf", "expanded", NULL };
    PyObject *py_text;
    PyGPointer *py_parent, *py_sibling;
    PyGObject *py_pixmap_closed = (PyGObject *) Py_None;
    PyGObject *py_mask_closed = (PyGObject *) Py_None;
    PyGObject *py_pixmap_opened = (PyGObject *) Py_None;
    PyGObject *py_mask_opened = (PyGObject *) Py_None;
    GtkCTreeNode *parent = NULL, *sibling = NULL, *ret;
    gchar **text = NULL;
    GdkPixmap *pixmap_closed = NULL, *pixmap_opened = NULL;
    GdkBitmap *mask_closed = NULL, *mask_opened = NULL;
    gint spacing = 5, is_leaf = 1, expanded = 0, columns, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO|iOOOOii:GtkCTree.insert_node",
                                     kwlist,
                                     &py_parent, &py_sibling, &py_text,
                                     &spacing, &py_pixmap_closed,
                                     &py_mask_closed, &py_pixmap_opened,
                                     &py_mask_opened, &is_leaf, &expanded))
        return NULL;
    if (pyg_pointer_check(py_parent, GTK_TYPE_CTREE_NODE))
        parent = pyg_pointer_get(py_parent, GtkCTreeNode);
    else if ((PyObject *)py_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError, "parent must be a CTreeNode or None");
        return NULL;
    }
    if (pyg_pointer_check(py_sibling, GTK_TYPE_CTREE_NODE))
        sibling = pyg_pointer_get(py_sibling, GtkCTreeNode);
    else if ((PyObject *)py_sibling != Py_None) {
        PyErr_SetString(PyExc_TypeError,"sibling must be a CTreeNode or None");
        return NULL;
    }
    if (pygobject_check(py_pixmap_closed, &PyGdkPixmap_Type))
        pixmap_closed = GDK_PIXMAP(py_pixmap_closed->obj);
    else if ((PyObject *)py_pixmap_closed != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "pixmap_closed must be a GdkPixmap or None");
        return NULL;
    }
    if (pygobject_check(py_mask_closed, &PyGdkPixmap_Type))
        mask_closed = GDK_PIXMAP(py_mask_closed->obj);
    else if ((PyObject *)py_mask_closed != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "mask_closed must be a GdkBitmap or None");
        return NULL;
    }
    if (pygobject_check(py_pixmap_opened, &PyGdkPixmap_Type))
        pixmap_opened = GDK_PIXMAP(py_pixmap_opened->obj);
    else if ((PyObject *)py_pixmap_opened != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "pixmap_opened must be a GdkPixmap or None");
        return NULL;
    }
    if (pygobject_check(py_mask_opened, &PyGdkPixmap_Type))
        mask_opened = GDK_PIXMAP(py_mask_opened->obj);
    else if ((PyObject *)py_mask_opened != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "mask_opened must be a GdkBitmap or None");
        return NULL;
    }
    if (!PySequence_Check(py_text)) {
        PyErr_SetString(PyExc_TypeError, "text must be a sequence");
        return NULL;
    }
    columns = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_text) < columns) {
        PyErr_SetString(PyExc_TypeError, "text is too short");
        return NULL;
    }
    text = g_new(gchar *, columns);
    for (i = 0; i < columns; i++) {
        PyObject *item = PySequence_GetItem(py_text, i);

        Py_DECREF(item);
        if (!PyString_Check(item) && !PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "sequence item not a string or unicode object");
            g_free(text);
            return NULL;
        }
        text[i] = PyString_AsString(item);
    }
    ret = gtk_ctree_insert_node(GTK_CTREE(self->obj), parent, sibling, text,
                                spacing, pixmap_closed, mask_closed,
                                pixmap_opened, mask_opened, is_leaf, expanded);
    g_free(text);
    return pyg_pointer_new(GTK_TYPE_CTREE_NODE, ret);
}
#line 41560 "gtk.c"


static PyObject *
_wrap_gtk_ctree_remove_node(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.remove_node", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_remove_node(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_is_viewable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    int ret;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.is_viewable", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    ret = gtk_ctree_is_viewable(GTK_CTREE(self->obj), node);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_ctree_last(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.last", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    ret = gtk_ctree_last(GTK_CTREE(self->obj), node);
    
    /* pyg_pointer_new handles NULL checking */
    return pyg_pointer_new(GTK_TYPE_CTREE_NODE, ret);
}

static PyObject *
_wrap_gtk_ctree_node_nth(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    PyObject *py_row = NULL;
    guint row = 0;
    GtkCTreeNode *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.node_nth", kwlist, &py_row))
        return NULL;
    if (py_row) {
        if (PyLong_Check(py_row))
            row = PyLong_AsUnsignedLong(py_row);
        else if (PyInt_Check(py_row))
            row = PyInt_AsLong(py_row);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'row' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_ctree_node_nth(GTK_CTREE(self->obj), row);
    
    /* pyg_pointer_new handles NULL checking */
    return pyg_pointer_new(GTK_TYPE_CTREE_NODE, ret);
}

static PyObject *
_wrap_gtk_ctree_find(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "child", NULL };
    PyObject *py_node, *py_child;
    int ret;
    GtkCTreeNode *node = NULL, *child = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.CTree.find", kwlist, &py_node, &py_child))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    if (pyg_pointer_check(py_child, GTK_TYPE_CTREE_NODE))
        child = pyg_pointer_get(py_child, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "child should be a GtkCTreeNode");
        return NULL;
    }
    
    ret = gtk_ctree_find(GTK_CTREE(self->obj), node, child);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_ctree_is_ancestor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "child", NULL };
    PyObject *py_node, *py_child;
    int ret;
    GtkCTreeNode *node = NULL, *child = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.CTree.is_ancestor", kwlist, &py_node, &py_child))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    if (pyg_pointer_check(py_child, GTK_TYPE_CTREE_NODE))
        child = pyg_pointer_get(py_child, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "child should be a GtkCTreeNode");
        return NULL;
    }
    
    ret = gtk_ctree_is_ancestor(GTK_CTREE(self->obj), node, child);
    
    return PyBool_FromLong(ret);

}

#line 236 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree_find_by_row_data(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *data;
    PyGPointer *py_node;
    GtkCTreeNode *node = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "OO:GtkCTree.find_by_row_data", kwlist,
                                    &py_node, &data))
       return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else if ((PyObject *)py_node != Py_None) {
        PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode or None");
        return NULL;
    }
    ret = gtk_ctree_find_by_row_data(GTK_CTREE(self->obj), node, data);
    if (ret)
        return pyg_pointer_new(GTK_TYPE_CTREE_NODE, ret);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 41741 "gtk.c"


#line 263 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree_find_all_by_row_data(PyGObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyGPointer *py_node;
    PyObject *data, *list;
    GtkCTreeNode *node = NULL;
    GList *ret, *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:GtkCTree.find_all_by_row_data",kwlist,
                                     &py_node, &data))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else if ((PyObject *)py_node != Py_None) {
        PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode or None");
        return NULL;
    }
    ret = gtk_ctree_find_all_by_row_data(GTK_CTREE(self->obj), node, data);
    if ((list = PyList_New(0)) == NULL)
        return NULL;
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
        PyObject *item = pyg_pointer_new(GTK_TYPE_CTREE_NODE,
                                         (GtkCTreeNode *) tmp->data);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        PyList_Append(list, item);
        Py_DECREF(item);
    }
    g_list_free(ret);
    return list;
}
#line 41781 "gtk.c"


static PyObject *
_wrap_gtk_ctree_is_hot_spot(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    int x, y, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.CTree.is_hot_spot", kwlist, &x, &y))
        return NULL;
    
    ret = gtk_ctree_is_hot_spot(GTK_CTREE(self->obj), x, y);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_ctree_move(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "new_parent", "new_sibling", NULL };
    PyObject *py_node, *py_new_parent = Py_None, *py_new_sibling = Py_None;
    GtkCTreeNode *node = NULL, *new_parent = NULL, *new_sibling = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOO:Gtk.CTree.move", kwlist, &py_node, &py_new_parent, &py_new_sibling))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    if (pyg_pointer_check(py_new_parent, GTK_TYPE_CTREE_NODE))
        new_parent = pyg_pointer_get(py_new_parent, GtkCTreeNode);
    else if (py_new_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError, "new_parent should be a GtkCTreeNode or None");
        return NULL;
    }
    if (pyg_pointer_check(py_new_sibling, GTK_TYPE_CTREE_NODE))
        new_sibling = pyg_pointer_get(py_new_sibling, GtkCTreeNode);
    else if (py_new_sibling != Py_None) {
        PyErr_SetString(PyExc_TypeError, "new_sibling should be a GtkCTreeNode or None");
        return NULL;
    }
    
    gtk_ctree_move(GTK_CTREE(self->obj), node, new_parent, new_sibling);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_expand(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.expand", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_expand(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_expand_recursive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.expand_recursive", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_expand_recursive(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_expand_to_depth(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "depth", NULL };
    PyObject *py_node;
    int depth;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.CTree.expand_to_depth", kwlist, &py_node, &depth))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_expand_to_depth(GTK_CTREE(self->obj), node, depth);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_collapse(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.collapse", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_collapse(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_collapse_recursive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.collapse_recursive", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_collapse_recursive(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_collapse_to_depth(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "depth", NULL };
    PyObject *py_node;
    int depth;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.CTree.collapse_to_depth", kwlist, &py_node, &depth))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_collapse_to_depth(GTK_CTREE(self->obj), node, depth);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_toggle_expansion(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.toggle_expansion", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_toggle_expansion(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_toggle_expansion_recursive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.toggle_expansion_recursive", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_toggle_expansion_recursive(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_select(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.select", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_select(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_select_recursive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.select_recursive", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_select_recursive(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_unselect(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.unselect", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_unselect(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_unselect_recursive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.unselect_recursive", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_unselect_recursive(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_real_select_recursive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "state", NULL };
    PyObject *py_node;
    int state;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.CTree.real_select_recursive", kwlist, &py_node, &state))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_real_select_recursive(GTK_CTREE(self->obj), node, state);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_node_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", "text", NULL };
    PyObject *py_node;
    int column;
    char *text;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Ois:Gtk.CTree.node_set_text", kwlist, &py_node, &column, &text))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_node_set_text(GTK_CTREE(self->obj), node, column, text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_node_set_pixmap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", "pixmap", "mask", NULL };
    PyObject *py_node;
    int column;
    PyGObject *pixmap, *py_mask;
    GdkPixmap *mask = NULL;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OiO!O:Gtk.CTree.node_set_pixmap", kwlist, &py_node, &column, &PyGdkPixmap_Type, &pixmap, &py_mask))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if ((PyObject *)py_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return NULL;
    }
    
    gtk_ctree_node_set_pixmap(GTK_CTREE(self->obj), node, column, GDK_PIXMAP(pixmap->obj), (GdkBitmap *) mask);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_node_set_pixtext(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", "text", "spacing", "pixmap", "mask", NULL };
    GdkPixmap *mask = NULL;
    GtkCTreeNode *node = NULL;
    PyObject *py_node;
    char *text;
    int column, spacing;
    PyGObject *pixmap, *py_mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OisiO!O:Gtk.CTree.node_set_pixtext", kwlist, &py_node, &column, &text, &spacing, &PyGdkPixmap_Type, &pixmap, &py_mask))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if ((PyObject *)py_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return NULL;
    }
    
    gtk_ctree_node_set_pixtext(GTK_CTREE(self->obj), node, column, text, spacing, GDK_PIXMAP(pixmap->obj), (GdkBitmap *) mask);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_set_node_info(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "text", "spacing", "pixmap_closed", "mask_closed", "pixmap_opened", "mask_opened", "is_leaf", "expanded", NULL };
    GdkPixmap *pixmap_closed = NULL, *mask_closed = NULL, *pixmap_opened = NULL, *mask_opened = NULL;
    GtkCTreeNode *node = NULL;
    PyObject *py_node;
    char *text;
    int spacing, is_leaf, expanded;
    PyGObject *py_pixmap_closed, *py_mask_closed, *py_pixmap_opened, *py_mask_opened;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OsiOOOOii:Gtk.CTree.set_node_info", kwlist, &py_node, &text, &spacing, &py_pixmap_closed, &py_mask_closed, &py_pixmap_opened, &py_mask_opened, &is_leaf, &expanded))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    if (py_pixmap_closed && pygobject_check(py_pixmap_closed, &PyGdkPixmap_Type))
        pixmap_closed = GDK_PIXMAP(py_pixmap_closed->obj);
    else if ((PyObject *)py_pixmap_closed != Py_None) {
        PyErr_SetString(PyExc_TypeError, "pixmap_closed should be a GdkPixmap or None");
        return NULL;
    }
    if (py_mask_closed && pygobject_check(py_mask_closed, &PyGdkPixmap_Type))
        mask_closed = GDK_PIXMAP(py_mask_closed->obj);
    else if ((PyObject *)py_mask_closed != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask_closed should be a GdkPixmap or None");
        return NULL;
    }
    if (py_pixmap_opened && pygobject_check(py_pixmap_opened, &PyGdkPixmap_Type))
        pixmap_opened = GDK_PIXMAP(py_pixmap_opened->obj);
    else if ((PyObject *)py_pixmap_opened != Py_None) {
        PyErr_SetString(PyExc_TypeError, "pixmap_opened should be a GdkPixmap or None");
        return NULL;
    }
    if (py_mask_opened && pygobject_check(py_mask_opened, &PyGdkPixmap_Type))
        mask_opened = GDK_PIXMAP(py_mask_opened->obj);
    else if ((PyObject *)py_mask_opened != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask_opened should be a GdkPixmap or None");
        return NULL;
    }
    
    gtk_ctree_set_node_info(GTK_CTREE(self->obj), node, text, spacing, (GdkPixmap *) pixmap_closed, (GdkBitmap *) mask_closed, (GdkPixmap *) pixmap_opened, (GdkBitmap *) mask_opened, is_leaf, expanded);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_node_set_shift(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", "vertical", "horizontal", NULL };
    PyObject *py_node;
    int column, vertical, horizontal;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oiii:Gtk.CTree.node_set_shift", kwlist, &py_node, &column, &vertical, &horizontal))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_node_set_shift(GTK_CTREE(self->obj), node, column, vertical, horizontal);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_node_set_selectable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "selectable", NULL };
    PyObject *py_node;
    int selectable;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.CTree.node_set_selectable", kwlist, &py_node, &selectable))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_node_set_selectable(GTK_CTREE(self->obj), node, selectable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_node_get_selectable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    int ret;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.node_get_selectable", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    ret = gtk_ctree_node_get_selectable(GTK_CTREE(self->obj), node);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_ctree_node_get_cell_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *py_node;
    int column;
    gint ret;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.CTree.node_get_cell_type", kwlist, &py_node, &column))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    ret = gtk_ctree_node_get_cell_type(GTK_CTREE(self->obj), node, column);
    
    return pyg_enum_from_gtype(GTK_TYPE_CELL_TYPE, ret);
}

#line 301 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree_node_get_text(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyGPointer *node;
    int column;
    char *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oi:GtkCTree.node_get_text", kwlist,
                                     &node, &column))
        return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
        PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
        return NULL;
    }

    if (!gtk_ctree_node_get_text(GTK_CTREE(self->obj),
                                 pyg_pointer_get(node, GtkCTreeNode), column,
                                 &text)) {
        PyErr_SetString(PyExc_ValueError, "can't get text value");
        return NULL;
    }
    return PyString_FromString(text);
}
#line 42379 "gtk.c"


#line 330 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree_node_get_pixmap(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    GdkPixmap *pixmap = NULL;
    GdkBitmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oi:GtkCTree.node_get_pixmap", kwlist,
                                     &node, &column))
        return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
        PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
        return NULL;
    }

    if (!gtk_ctree_node_get_pixmap(GTK_CTREE(self->obj),
                                   pyg_pointer_get(node, GtkCTreeNode), column,
                                   &pixmap, &mask)) {
        PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
        return NULL;
    }
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
                         pygobject_new((GObject *)mask));
}
#line 42412 "gtk.c"


#line 361 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree_node_get_pixtext(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    gchar *text = NULL;
    guint8 spacing;
    GdkPixmap *pixmap = NULL;
    GdkBitmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oi:GtkCTree.node_get_pixtext", kwlist,
                                     &node, &column))
        return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
        PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
        return NULL;
    }

    if (!gtk_ctree_node_get_pixtext(GTK_CTREE(self->obj),
                                    pyg_pointer_get(node, GtkCTreeNode), column,
                                    &text, &spacing, &pixmap, &mask)) {
        PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
        return NULL;
    }
    return Py_BuildValue("(siNN)", text, (int)spacing,
                         pygobject_new((GObject *)pixmap),
                         pygobject_new((GObject *)mask));
}
#line 42448 "gtk.c"


#line 395 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree_get_node_info(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *node;
    gchar *text;
    guint8 spacing;
    GdkPixmap *pixmap_closed, *pixmap_opened;
    GdkBitmap *mask_closed, *mask_opened;
    gboolean is_leaf, expanded;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCTree.get_node_info",
                                     kwlist, &node))
        return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
        PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
        return NULL;
    }

    if (!gtk_ctree_get_node_info(GTK_CTREE(self->obj), pyg_pointer_get(node, GtkCTreeNode),
                                 &text, &spacing, &pixmap_closed, &mask_closed,
                                 &pixmap_opened, &mask_opened,
                                 &is_leaf, &expanded)) {
        PyErr_SetString(PyExc_ValueError, "can't get node info");
        return NULL;
    }
    return Py_BuildValue("(siNNNNii)", text, (int)spacing,
                         pygobject_new((GObject *)pixmap_opened),
                         pygobject_new((GObject *)mask_closed),
                         pygobject_new((GObject *)pixmap_opened),
                         pygobject_new((GObject *)mask_opened),
                         (int)is_leaf, (int)expanded);
}
#line 42487 "gtk.c"


static PyObject *
_wrap_gtk_ctree_node_set_row_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "style", NULL };
    PyObject *py_node;
    PyGObject *style;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO!:Gtk.CTree.node_set_row_style", kwlist, &py_node, &PyGtkStyle_Type, &style))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_node_set_row_style(GTK_CTREE(self->obj), node, GTK_STYLE(style->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_node_get_row_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkStyle *ret;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.node_get_row_style", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    ret = gtk_ctree_node_get_row_style(GTK_CTREE(self->obj), node);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_ctree_node_set_cell_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", "style", NULL };
    PyObject *py_node;
    int column;
    PyGObject *style;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OiO!:Gtk.CTree.node_set_cell_style", kwlist, &py_node, &column, &PyGtkStyle_Type, &style))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_node_set_cell_style(GTK_CTREE(self->obj), node, column, GTK_STYLE(style->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_node_get_cell_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *py_node;
    int column;
    GtkStyle *ret;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.CTree.node_get_cell_style", kwlist, &py_node, &column))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    ret = gtk_ctree_node_get_cell_style(GTK_CTREE(self->obj), node, column);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_ctree_node_set_foreground(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "color", NULL };
    PyObject *py_node, *py_color;
    GdkColor *color = NULL;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.CTree.node_set_foreground", kwlist, &py_node, &py_color))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor");
        return NULL;
    }
    
    gtk_ctree_node_set_foreground(GTK_CTREE(self->obj), node, color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_node_set_background(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "color", NULL };
    PyObject *py_node, *py_color;
    GdkColor *color = NULL;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.CTree.node_set_background", kwlist, &py_node, &py_color))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    if (pyg_boxed_check(py_color, GDK_TYPE_COLOR))
        color = pyg_boxed_get(py_color, GdkColor);
    else {
        PyErr_SetString(PyExc_TypeError, "color should be a GdkColor");
        return NULL;
    }
    
    gtk_ctree_node_set_background(GTK_CTREE(self->obj), node, color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 434 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree_node_set_row_data(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *node, *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:GtkCTree.node_set_row_data", kwlist,
                                     &node, &data))
        return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
        PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
        return NULL;
    }

    Py_INCREF(data);
    gtk_ctree_node_set_row_data_full(GTK_CTREE(self->obj),
                                     pyg_pointer_get(node, GtkCTreeNode), data,
                                     (GDestroyNotify)pyg_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 42667 "gtk.c"


#line 460 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree_node_get_row_data(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *node, *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkCTree.node_get_row_data", kwlist,
                                     &node))
        return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
        PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
        return NULL;
    }

    data = gtk_ctree_node_get_row_data(GTK_CTREE(self->obj),
                                       pyg_pointer_get(node, GtkCTreeNode));
    if (!data) data = Py_None;
    Py_INCREF(data);
    return data;
}
#line 42694 "gtk.c"


static PyObject *
_wrap_gtk_ctree_node_moveto(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", "row_align", "col_align", NULL };
    PyObject *py_node;
    int column;
    double row_align, col_align;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oidd:Gtk.CTree.node_moveto", kwlist, &py_node, &column, &row_align, &col_align))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_node_moveto(GTK_CTREE(self->obj), node, column, row_align, col_align);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_node_is_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    gint ret;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.node_is_visible", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    ret = gtk_ctree_node_is_visible(GTK_CTREE(self->obj), node);
    
    return pyg_enum_from_gtype(GTK_TYPE_VISIBILITY, ret);
}

static PyObject *
_wrap_gtk_ctree_set_indent(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "indent", NULL };
    int indent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CTree.set_indent", kwlist, &indent))
        return NULL;
    
    gtk_ctree_set_indent(GTK_CTREE(self->obj), indent);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_set_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "spacing", NULL };
    int spacing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CTree.set_spacing", kwlist, &spacing))
        return NULL;
    
    gtk_ctree_set_spacing(GTK_CTREE(self->obj), spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_set_show_stub(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_stub", NULL };
    int show_stub;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.CTree.set_show_stub", kwlist, &show_stub))
        return NULL;
    
    gtk_ctree_set_show_stub(GTK_CTREE(self->obj), show_stub);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_set_line_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_style", NULL };
    PyObject *py_line_style = NULL;
    GtkCTreeLineStyle line_style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.set_line_style", kwlist, &py_line_style))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_CTREE_LINE_STYLE, py_line_style, (gpointer)&line_style))
        return NULL;
    
    gtk_ctree_set_line_style(GTK_CTREE(self->obj), line_style);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_set_expander_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "expander_style", NULL };
    PyObject *py_expander_style = NULL;
    GtkCTreeExpanderStyle expander_style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.set_expander_style", kwlist, &py_expander_style))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_CTREE_EXPANDER_STYLE, py_expander_style, (gpointer)&expander_style))
        return NULL;
    
    gtk_ctree_set_expander_style(GTK_CTREE(self->obj), expander_style);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_sort_node(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.sort_node", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_sort_node(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ctree_sort_recursive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CTree.sort_recursive", kwlist, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    
    gtk_ctree_sort_recursive(GTK_CTREE(self->obj), node);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCTree__do_tree_select_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "row", "column", NULL };
    PyGObject *self;
    PyObject *py_row;
    int column;
    GtkCTreeNode *row = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oi:Gtk.CTree.tree_select_row", kwlist, &PyGtkCTree_Type, &self, &py_row, &column))
        return NULL;
    if (pyg_pointer_check(py_row, GTK_TYPE_CTREE_NODE))
        row = pyg_pointer_get(py_row, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "row should be a GtkCTreeNode");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CTREE_CLASS(klass)->tree_select_row)
        GTK_CTREE_CLASS(klass)->tree_select_row(GTK_CTREE(self->obj), row, column);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CTree.tree_select_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCTree__do_tree_unselect_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "row", "column", NULL };
    PyGObject *self;
    PyObject *py_row;
    int column;
    GtkCTreeNode *row = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oi:Gtk.CTree.tree_unselect_row", kwlist, &PyGtkCTree_Type, &self, &py_row, &column))
        return NULL;
    if (pyg_pointer_check(py_row, GTK_TYPE_CTREE_NODE))
        row = pyg_pointer_get(py_row, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "row should be a GtkCTreeNode");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CTREE_CLASS(klass)->tree_unselect_row)
        GTK_CTREE_CLASS(klass)->tree_unselect_row(GTK_CTREE(self->obj), row, column);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CTree.tree_unselect_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCTree__do_tree_expand(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "node", NULL };
    PyGObject *self;
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.CTree.tree_expand", kwlist, &PyGtkCTree_Type, &self, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CTREE_CLASS(klass)->tree_expand)
        GTK_CTREE_CLASS(klass)->tree_expand(GTK_CTREE(self->obj), node);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CTree.tree_expand not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCTree__do_tree_collapse(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "node", NULL };
    PyGObject *self;
    PyObject *py_node;
    GtkCTreeNode *node = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.CTree.tree_collapse", kwlist, &PyGtkCTree_Type, &self, &py_node))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CTREE_CLASS(klass)->tree_collapse)
        GTK_CTREE_CLASS(klass)->tree_collapse(GTK_CTREE(self->obj), node);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CTree.tree_collapse not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCTree__do_tree_move(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "node", "new_parent", "new_sibling", NULL };
    PyGObject *self;
    PyObject *py_node, *py_new_parent, *py_new_sibling;
    GtkCTreeNode *node = NULL, *new_parent = NULL, *new_sibling = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOO:Gtk.CTree.tree_move", kwlist, &PyGtkCTree_Type, &self, &py_node, &py_new_parent, &py_new_sibling))
        return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
        node = pyg_pointer_get(py_node, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "node should be a GtkCTreeNode");
        return NULL;
    }
    if (pyg_pointer_check(py_new_parent, GTK_TYPE_CTREE_NODE))
        new_parent = pyg_pointer_get(py_new_parent, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "new_parent should be a GtkCTreeNode");
        return NULL;
    }
    if (pyg_pointer_check(py_new_sibling, GTK_TYPE_CTREE_NODE))
        new_sibling = pyg_pointer_get(py_new_sibling, GtkCTreeNode);
    else {
        PyErr_SetString(PyExc_TypeError, "new_sibling should be a GtkCTreeNode");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CTREE_CLASS(klass)->tree_move)
        GTK_CTREE_CLASS(klass)->tree_move(GTK_CTREE(self->obj), node, new_parent, new_sibling);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CTree.tree_move not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCTree__do_change_focus_row_expansion(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "action", NULL };
    PyGObject *self;
    PyObject *py_action = NULL;
    GtkCTreeExpansionType action;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.CTree.change_focus_row_expansion", kwlist, &PyGtkCTree_Type, &self, &py_action))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_CTREE_EXPANSION_TYPE, py_action, (gpointer)&action))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CTREE_CLASS(klass)->change_focus_row_expansion)
        GTK_CTREE_CLASS(klass)->change_focus_row_expansion(GTK_CTREE(self->obj), action);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CTree.change_focus_row_expansion not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCTree_methods[] = {
    { "base_nodes", (PyCFunction)_wrap_gtk_ctree_base_nodes, METH_VARARGS,
      NULL },
    { "insert_node", (PyCFunction)_wrap_gtk_ctree_insert_node, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_node", (PyCFunction)_wrap_gtk_ctree_remove_node, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "is_viewable", (PyCFunction)_wrap_gtk_ctree_is_viewable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "last", (PyCFunction)_wrap_gtk_ctree_last, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_nth", (PyCFunction)_wrap_gtk_ctree_node_nth, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "find", (PyCFunction)_wrap_gtk_ctree_find, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "is_ancestor", (PyCFunction)_wrap_gtk_ctree_is_ancestor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "find_by_row_data", (PyCFunction)_wrap_gtk_ctree_find_by_row_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "find_all_by_row_data", (PyCFunction)_wrap_gtk_ctree_find_all_by_row_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "is_hot_spot", (PyCFunction)_wrap_gtk_ctree_is_hot_spot, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move", (PyCFunction)_wrap_gtk_ctree_move, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "expand", (PyCFunction)_wrap_gtk_ctree_expand, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "expand_recursive", (PyCFunction)_wrap_gtk_ctree_expand_recursive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "expand_to_depth", (PyCFunction)_wrap_gtk_ctree_expand_to_depth, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "collapse", (PyCFunction)_wrap_gtk_ctree_collapse, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "collapse_recursive", (PyCFunction)_wrap_gtk_ctree_collapse_recursive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "collapse_to_depth", (PyCFunction)_wrap_gtk_ctree_collapse_to_depth, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "toggle_expansion", (PyCFunction)_wrap_gtk_ctree_toggle_expansion, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "toggle_expansion_recursive", (PyCFunction)_wrap_gtk_ctree_toggle_expansion_recursive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select", (PyCFunction)_wrap_gtk_ctree_select, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_recursive", (PyCFunction)_wrap_gtk_ctree_select_recursive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect", (PyCFunction)_wrap_gtk_ctree_unselect, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_recursive", (PyCFunction)_wrap_gtk_ctree_unselect_recursive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "real_select_recursive", (PyCFunction)_wrap_gtk_ctree_real_select_recursive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_set_text", (PyCFunction)_wrap_gtk_ctree_node_set_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_set_pixmap", (PyCFunction)_wrap_gtk_ctree_node_set_pixmap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_set_pixtext", (PyCFunction)_wrap_gtk_ctree_node_set_pixtext, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_node_info", (PyCFunction)_wrap_gtk_ctree_set_node_info, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_set_shift", (PyCFunction)_wrap_gtk_ctree_node_set_shift, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_set_selectable", (PyCFunction)_wrap_gtk_ctree_node_set_selectable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_get_selectable", (PyCFunction)_wrap_gtk_ctree_node_get_selectable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_get_cell_type", (PyCFunction)_wrap_gtk_ctree_node_get_cell_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_get_text", (PyCFunction)_wrap_gtk_ctree_node_get_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_get_pixmap", (PyCFunction)_wrap_gtk_ctree_node_get_pixmap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_get_pixtext", (PyCFunction)_wrap_gtk_ctree_node_get_pixtext, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_node_info", (PyCFunction)_wrap_gtk_ctree_get_node_info, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_set_row_style", (PyCFunction)_wrap_gtk_ctree_node_set_row_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_get_row_style", (PyCFunction)_wrap_gtk_ctree_node_get_row_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_set_cell_style", (PyCFunction)_wrap_gtk_ctree_node_set_cell_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_get_cell_style", (PyCFunction)_wrap_gtk_ctree_node_get_cell_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_set_foreground", (PyCFunction)_wrap_gtk_ctree_node_set_foreground, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_set_background", (PyCFunction)_wrap_gtk_ctree_node_set_background, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_set_row_data", (PyCFunction)_wrap_gtk_ctree_node_set_row_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_get_row_data", (PyCFunction)_wrap_gtk_ctree_node_get_row_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_moveto", (PyCFunction)_wrap_gtk_ctree_node_moveto, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "node_is_visible", (PyCFunction)_wrap_gtk_ctree_node_is_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_indent", (PyCFunction)_wrap_gtk_ctree_set_indent, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_spacing", (PyCFunction)_wrap_gtk_ctree_set_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_show_stub", (PyCFunction)_wrap_gtk_ctree_set_show_stub, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_line_style", (PyCFunction)_wrap_gtk_ctree_set_line_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_expander_style", (PyCFunction)_wrap_gtk_ctree_set_expander_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "sort_node", (PyCFunction)_wrap_gtk_ctree_sort_node, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "sort_recursive", (PyCFunction)_wrap_gtk_ctree_sort_recursive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_tree_select_row", (PyCFunction)_wrap_GtkCTree__do_tree_select_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_tree_unselect_row", (PyCFunction)_wrap_GtkCTree__do_tree_unselect_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_tree_expand", (PyCFunction)_wrap_GtkCTree__do_tree_expand, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_tree_collapse", (PyCFunction)_wrap_GtkCTree__do_tree_collapse, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_tree_move", (PyCFunction)_wrap_GtkCTree__do_tree_move, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_change_focus_row_expansion", (PyCFunction)_wrap_GtkCTree__do_change_focus_row_expansion, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 35 "gtkctree.override"
static PyObject *
_wrap_gtk_ctree__get_selection(PyGObject *self, void *closure)
{
    GList *selection;
    GtkCTreeNode *node;
    PyObject *ret, *py_node;
    if ((ret = PyList_New(0)) == NULL)
        return NULL;

    for (selection = GTK_CLIST(self->obj)->selection; selection != NULL;
         selection = selection->next) {
        node = selection->data;
        if ((py_node = pyg_pointer_new(GTK_TYPE_CTREE_NODE, node)) == NULL) {
            Py_DECREF(ret);
            return NULL;
        }
        PyList_Append(ret, py_node);
        Py_DECREF(py_node);
    }

    return ret;
}
#line 43205 "gtk.c"


static const PyGetSetDef gtk_ctree_getsets[] = {
    { "selection", (getter)_wrap_gtk_ctree__get_selection, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkCTree_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CTree",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCTree_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_ctree_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_ctree_new_with_titles,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCTree__proxy_do_change_focus_row_expansion(GtkCTree *self, GtkCTreeExpansionType action)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_action;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_action = pyg_enum_from_gtype(GTK_TYPE_CTREE_EXPANSION_TYPE, action);
    if (!py_action) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_action);
    
    py_method = PyObject_GetAttrString(py_self, "do_change_focus_row_expansion");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkCTree_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkCTreeClass *klass = GTK_CTREE_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    /* overriding do_tree_select_row is currently not supported */

    /* overriding do_tree_unselect_row is currently not supported */

    /* overriding do_tree_expand is currently not supported */

    /* overriding do_tree_collapse is currently not supported */

    /* overriding do_tree_move is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_change_focus_row_expansion");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "change_focus_row_expansion")))
            klass->change_focus_row_expansion = _wrap_GtkCTree__proxy_do_change_focus_row_expansion;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkDrawingArea ----------- */

static int
_wrap_gtk_drawing_area_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.DrawingArea.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.DrawingArea object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_drawing_area_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", "height", NULL };
    int width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.DrawingArea.size", kwlist, &width, &height))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkWidget.set_size_request") < 0)
        return NULL;
    
    gtk_drawing_area_size(GTK_DRAWING_AREA(self->obj), width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkDrawingArea_methods[] = {
    { "size", (PyCFunction)_wrap_gtk_drawing_area_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkDrawingArea_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.DrawingArea",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkDrawingArea_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_drawing_area_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkCurve ----------- */

static int
_wrap_gtk_curve_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Curve.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Curve object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_curve_reset(PyGObject *self)
{
    
    gtk_curve_reset(GTK_CURVE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_curve_set_gamma(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gamma", NULL };
    double gamma;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Curve.set_gamma", kwlist, &gamma))
        return NULL;
    
    gtk_curve_set_gamma(GTK_CURVE(self->obj), gamma);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_curve_set_range(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "min_x", "max_x", "min_y", "max_y", NULL };
    double min_x, max_x, min_y, max_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dddd:Gtk.Curve.set_range", kwlist, &min_x, &max_x, &min_y, &max_y))
        return NULL;
    
    gtk_curve_set_range(GTK_CURVE(self->obj), min_x, max_x, min_y, max_y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 901 "./gtk.override"
static PyObject *
_wrap_gtk_curve_get_vector(PyGObject *self, PyObject *args,
                           PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    int size = -1, i;
    gfloat *vector;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|i:GtkCurve.get_vector", kwlist,
                                     &size))
        return NULL;
    if (size < 0) size = GTK_CURVE(self->obj)->num_points;
    vector = g_new(gfloat, size);
    gtk_curve_get_vector(GTK_CURVE(self->obj), size, vector);
    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
        PyTuple_SetItem(ret, i, PyFloat_FromDouble(vector[i]));
    g_free(vector);
    return ret;
}
#line 43534 "gtk.c"


#line 925 "./gtk.override"
static PyObject *
_wrap_gtk_curve_set_vector(PyGObject *self, PyObject *args,
                           PyObject *kwargs)
{
    static char *kwlist[] = { "vector", NULL };
    PyObject *seq;
    int size, i;
    gfloat *vector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCurve.set_vector",
                                     kwlist, &seq))
        return NULL;
    if (!PySequence_Check(seq)) {
        PyErr_SetString(PyExc_TypeError, "1st argument is not a sequence");
        return NULL;
    }
    size = PySequence_Length(seq);
    vector = g_new(gfloat, size);
    for (i = 0; i < size; i++) {
        PyObject *item = PySequence_GetItem(seq, i);

        Py_DECREF(item);
        item = PyNumber_Float(item); /* item has a ref now */
        if (item == NULL) {
            g_free(vector);
            return NULL;
        }
        vector[i] = PyFloat_AsDouble(item);
        Py_DECREF(item);
    }
    gtk_curve_set_vector(GTK_CURVE(self->obj), size, vector);
    g_free(vector);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 43573 "gtk.c"


static PyObject *
_wrap_gtk_curve_set_curve_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    PyObject *py_type = NULL;
    GtkCurveType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Curve.set_curve_type", kwlist, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_CURVE_TYPE, py_type, (gpointer)&type))
        return NULL;
    
    gtk_curve_set_curve_type(GTK_CURVE(self->obj), type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCurve__do_curve_type_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Curve.curve_type_changed", kwlist, &PyGtkCurve_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CURVE_CLASS(klass)->curve_type_changed)
        GTK_CURVE_CLASS(klass)->curve_type_changed(GTK_CURVE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Curve.curve_type_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCurve_methods[] = {
    { "reset", (PyCFunction)_wrap_gtk_curve_reset, METH_NOARGS,
      NULL },
    { "set_gamma", (PyCFunction)_wrap_gtk_curve_set_gamma, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_range", (PyCFunction)_wrap_gtk_curve_set_range, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_vector", (PyCFunction)_wrap_gtk_curve_get_vector, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_vector", (PyCFunction)_wrap_gtk_curve_set_vector, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_curve_type", (PyCFunction)_wrap_gtk_curve_set_curve_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_curve_type_changed", (PyCFunction)_wrap_GtkCurve__do_curve_type_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkCurve_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Curve",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCurve_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_curve_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCurve__proxy_do_curve_type_changed(GtkCurve *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_curve_type_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkCurve_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkCurveClass *klass = GTK_CURVE_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_curve_type_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "curve_type_changed")))
            klass->curve_type_changed = _wrap_GtkCurve__proxy_do_curve_type_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkEntry ----------- */

#line 5440 "./gtk.override"
static int
_wrap_gtk_entry_new(PyGObject * self, PyObject * args, PyObject * kwargs)
{
    static char *kwlist[] = { "max", NULL };
    int max = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:GtkEntry.__init__",
                                     kwlist, &max))
	return -1;
    pygobject_construct(self, "max-length", max, NULL);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkEntry object");
	return -1;
    }
    return 0;
}
#line 43772 "gtk.c"


static PyObject *
_wrap_gtk_entry_set_visibility(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible", NULL };
    int visible;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Entry.set_visibility", kwlist, &visible))
        return NULL;
    
    gtk_entry_set_visibility(GTK_ENTRY(self->obj), visible);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_visibility(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_get_visibility(GTK_ENTRY(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_set_invisible_char(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "ch", NULL };
    gunichar ch;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O&:Gtk.Entry.set_invisible_char", kwlist, pyg_pyobj_to_unichar_conv, &ch))
        return NULL;
    
    gtk_entry_set_invisible_char(GTK_ENTRY(self->obj), ch);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_invisible_char(PyGObject *self)
{
    gunichar ret;
    Py_UNICODE py_ret;

    
    ret = gtk_entry_get_invisible_char(GTK_ENTRY(self->obj));
    
#if !defined(Py_UNICODE_SIZE) || Py_UNICODE_SIZE == 2
    if (ret > 0xffff) {
        PyErr_SetString(PyExc_RuntimeError, "returned character can not be represented in 16-bit unicode");
        return NULL;
    }
#endif
    py_ret = (Py_UNICODE)ret;
    return PyUnicode_FromUnicode(&py_ret, 1);

}

static PyObject *
_wrap_gtk_entry_set_has_frame(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Entry.set_has_frame", kwlist, &setting))
        return NULL;
    
    gtk_entry_set_has_frame(GTK_ENTRY(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_has_frame(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_get_has_frame(GTK_ENTRY(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_set_max_length(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "max", NULL };
    int max;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Entry.set_max_length", kwlist, &max))
        return NULL;
    
    gtk_entry_set_max_length(GTK_ENTRY(self->obj), max);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_max_length(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_get_max_length(GTK_ENTRY(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_entry_set_activates_default(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Entry.set_activates_default", kwlist, &setting))
        return NULL;
    
    gtk_entry_set_activates_default(GTK_ENTRY(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_activates_default(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_get_activates_default(GTK_ENTRY(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_set_width_chars(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "n_chars", NULL };
    int n_chars;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Entry.set_width_chars", kwlist, &n_chars))
        return NULL;
    
    gtk_entry_set_width_chars(GTK_ENTRY(self->obj), n_chars);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_width_chars(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_get_width_chars(GTK_ENTRY(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_entry_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Entry.set_text", kwlist, &text))
        return NULL;
    
    gtk_entry_set_text(GTK_ENTRY(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_text(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_entry_get_text(GTK_ENTRY(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_layout(PyGObject *self)
{
    PangoLayout *ret;

    
    ret = gtk_entry_get_layout(GTK_ENTRY(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 1410 "./gtk.override"
static PyObject *
_wrap_gtk_entry_get_layout_offsets(PyGObject *self, PyObject *args)
{
    int x, y;

    gtk_entry_get_layout_offsets(GTK_ENTRY(self->obj), &x, &y);

    return Py_BuildValue ("(ii)", x, y);
}
#line 43994 "gtk.c"


static PyObject *
_wrap_gtk_entry_set_alignment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "xalign", NULL };
    double xalign;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Entry.set_alignment", kwlist, &xalign))
        return NULL;
    
    gtk_entry_set_alignment(GTK_ENTRY(self->obj), xalign);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_alignment(PyGObject *self)
{
    double ret;

    
    ret = gtk_entry_get_alignment(GTK_ENTRY(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_entry_set_completion(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "completion", NULL };
    PyGObject *py_completion;
    GtkEntryCompletion *completion = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.set_completion", kwlist, &py_completion))
        return NULL;
    if (py_completion && pygobject_check(py_completion, &PyGtkEntryCompletion_Type))
        completion = GTK_ENTRY_COMPLETION(py_completion->obj);
    else if ((PyObject *)py_completion != Py_None) {
        PyErr_SetString(PyExc_TypeError, "completion should be a GtkEntryCompletion or None");
        return NULL;
    }
    
    gtk_entry_set_completion(GTK_ENTRY(self->obj), (GtkEntryCompletion *) completion);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_completion(PyGObject *self)
{
    GtkEntryCompletion *ret;

    
    ret = gtk_entry_get_completion(GTK_ENTRY(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_entry_append_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Entry.append_text", kwlist, &text))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkEditable.insert_text") < 0)
        return NULL;
    
    gtk_entry_append_text(GTK_ENTRY(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_prepend_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Entry.prepend_text", kwlist, &text))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkEditable.insert_text") < 0)
        return NULL;
    
    gtk_entry_prepend_text(GTK_ENTRY(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_set_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Entry.set_position", kwlist, &position))
        return NULL;
    
    gtk_entry_set_position(GTK_ENTRY(self->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_set_editable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "editable", NULL };
    int editable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Entry.set_editable", kwlist, &editable))
        return NULL;
    
    gtk_entry_set_editable(GTK_ENTRY(self->obj), editable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_layout_index_to_text_index(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "layout_index", NULL };
    int layout_index, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Entry.layout_index_to_text_index", kwlist, &layout_index))
        return NULL;
    
    ret = gtk_entry_layout_index_to_text_index(GTK_ENTRY(self->obj), layout_index);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_entry_text_index_to_layout_index(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text_index", NULL };
    int text_index, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Entry.text_index_to_layout_index", kwlist, &text_index))
        return NULL;
    
    ret = gtk_entry_text_index_to_layout_index(GTK_ENTRY(self->obj), text_index);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_entry_set_inner_border(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "border", NULL };
    PyObject *py_border = Py_None;
    GtkBorder *border = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.set_inner_border", kwlist, &py_border))
        return NULL;
    if (pyg_boxed_check(py_border, GTK_TYPE_BORDER))
        border = pyg_boxed_get(py_border, GtkBorder);
    else if (py_border != Py_None) {
        PyErr_SetString(PyExc_TypeError, "border should be a GtkBorder or None");
        return NULL;
    }
    
    gtk_entry_set_inner_border(GTK_ENTRY(self->obj), border);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_inner_border(PyGObject *self)
{
    const GtkBorder *ret;

    
    ret = gtk_entry_get_inner_border(GTK_ENTRY(self->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_BORDER, (GtkBorder*) ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_entry_set_cursor_hadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment;
    GtkAdjustment *adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.set_cursor_hadjustment", kwlist, &py_adjustment))
        return NULL;
    if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if ((PyObject *)py_adjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }
    
    gtk_entry_set_cursor_hadjustment(GTK_ENTRY(self->obj), (GtkAdjustment *) adjustment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_cursor_hadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_entry_get_cursor_hadjustment(GTK_ENTRY(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_entry_set_overwrite_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "overwrite", NULL };
    int overwrite;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Entry.set_overwrite_mode", kwlist, &overwrite))
        return NULL;
    
    gtk_entry_set_overwrite_mode(GTK_ENTRY(self->obj), overwrite);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_overwrite_mode(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_get_overwrite_mode(GTK_ENTRY(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_get_text_length(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_get_text_length(GTK_ENTRY(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_entry_set_progress_fraction(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fraction", NULL };
    double fraction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Entry.set_progress_fraction", kwlist, &fraction))
        return NULL;
    
    gtk_entry_set_progress_fraction(GTK_ENTRY(self->obj), fraction);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_progress_fraction(PyGObject *self)
{
    double ret;

    
    ret = gtk_entry_get_progress_fraction(GTK_ENTRY(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_entry_set_progress_pulse_step(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fraction", NULL };
    double fraction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Entry.set_progress_pulse_step", kwlist, &fraction))
        return NULL;
    
    gtk_entry_set_progress_pulse_step(GTK_ENTRY(self->obj), fraction);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_progress_pulse_step(PyGObject *self)
{
    double ret;

    
    ret = gtk_entry_get_progress_pulse_step(GTK_ENTRY(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_entry_progress_pulse(PyGObject *self)
{
    
    gtk_entry_progress_pulse(GTK_ENTRY(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_set_icon_from_pixbuf(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", "pixbuf", NULL };
    PyObject *py_icon_pos = NULL;
    PyGObject *py_pixbuf;
    GtkEntryIconPosition icon_pos;
    GdkPixbuf *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Entry.set_icon_from_pixbuf", kwlist, &py_icon_pos, &py_pixbuf))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    if (py_pixbuf && pygobject_check(py_pixbuf, &PyGdkPixbuf_Type))
        pixbuf = GDK_PIXBUF(py_pixbuf->obj);
    else if ((PyObject *)py_pixbuf != Py_None) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf or None");
        return NULL;
    }
    
    gtk_entry_set_icon_from_pixbuf(GTK_ENTRY(self->obj), icon_pos, (GdkPixbuf *) pixbuf);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_set_icon_from_stock(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", "stock_id", NULL };
    PyObject *py_icon_pos = NULL;
    char *stock_id;
    GtkEntryIconPosition icon_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oz:Gtk.Entry.set_icon_from_stock", kwlist, &py_icon_pos, &stock_id))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    gtk_entry_set_icon_from_stock(GTK_ENTRY(self->obj), icon_pos, stock_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_set_icon_from_icon_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", "icon_name", NULL };
    PyObject *py_icon_pos = NULL;
    char *icon_name;
    GtkEntryIconPosition icon_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oz:Gtk.Entry.set_icon_from_icon_name", kwlist, &py_icon_pos, &icon_name))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    gtk_entry_set_icon_from_icon_name(GTK_ENTRY(self->obj), icon_pos, icon_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_set_icon_from_gicon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", "icon", NULL };
    PyObject *py_icon_pos = NULL;
    PyGObject *py_icon;
    GtkEntryIconPosition icon_pos;
    GIcon *icon = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Entry.set_icon_from_gicon", kwlist, &py_icon_pos, &py_icon))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    if (py_icon && pygobject_check(py_icon, &PyGIcon_Type))
        icon = G_ICON(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError, "icon should be a GIcon or None");
        return NULL;
    }
    
    gtk_entry_set_icon_from_gicon(GTK_ENTRY(self->obj), icon_pos, (GIcon *) icon);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_icon_storage_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", NULL };
    PyObject *py_icon_pos = NULL;
    GtkEntryIconPosition icon_pos;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.get_icon_storage_type", kwlist, &py_icon_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    ret = gtk_entry_get_icon_storage_type(GTK_ENTRY(self->obj), icon_pos);
    
    return pyg_enum_from_gtype(GTK_TYPE_IMAGE_TYPE, ret);
}

static PyObject *
_wrap_gtk_entry_get_icon_pixbuf(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", NULL };
    PyObject *py_icon_pos = NULL;
    GtkEntryIconPosition icon_pos;
    GdkPixbuf *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.get_icon_pixbuf", kwlist, &py_icon_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    ret = gtk_entry_get_icon_pixbuf(GTK_ENTRY(self->obj), icon_pos);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_entry_get_icon_stock(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", NULL };
    PyObject *py_icon_pos = NULL;
    const gchar *ret;
    GtkEntryIconPosition icon_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.get_icon_stock", kwlist, &py_icon_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    ret = gtk_entry_get_icon_stock(GTK_ENTRY(self->obj), icon_pos);
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_icon_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", NULL };
    PyObject *py_icon_pos = NULL;
    const gchar *ret;
    GtkEntryIconPosition icon_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.get_icon_name", kwlist, &py_icon_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    ret = gtk_entry_get_icon_name(GTK_ENTRY(self->obj), icon_pos);
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_icon_gicon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", NULL };
    PyObject *py_icon_pos = NULL;
    GtkEntryIconPosition icon_pos;
    GIcon *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.get_icon_gicon", kwlist, &py_icon_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    ret = gtk_entry_get_icon_gicon(GTK_ENTRY(self->obj), icon_pos);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_entry_set_icon_activatable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", "activatable", NULL };
    PyObject *py_icon_pos = NULL;
    int activatable;
    GtkEntryIconPosition icon_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.Entry.set_icon_activatable", kwlist, &py_icon_pos, &activatable))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    gtk_entry_set_icon_activatable(GTK_ENTRY(self->obj), icon_pos, activatable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_icon_activatable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", NULL };
    PyObject *py_icon_pos = NULL;
    int ret;
    GtkEntryIconPosition icon_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.get_icon_activatable", kwlist, &py_icon_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    ret = gtk_entry_get_icon_activatable(GTK_ENTRY(self->obj), icon_pos);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_set_icon_sensitive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", "sensitive", NULL };
    PyObject *py_icon_pos = NULL;
    int sensitive;
    GtkEntryIconPosition icon_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.Entry.set_icon_sensitive", kwlist, &py_icon_pos, &sensitive))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    gtk_entry_set_icon_sensitive(GTK_ENTRY(self->obj), icon_pos, sensitive);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_icon_sensitive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", NULL };
    PyObject *py_icon_pos = NULL;
    int ret;
    GtkEntryIconPosition icon_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.get_icon_sensitive", kwlist, &py_icon_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    ret = gtk_entry_get_icon_sensitive(GTK_ENTRY(self->obj), icon_pos);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_get_icon_at_pos(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    int x, y, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Entry.get_icon_at_pos", kwlist, &x, &y))
        return NULL;
    
    ret = gtk_entry_get_icon_at_pos(GTK_ENTRY(self->obj), x, y);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_entry_set_icon_tooltip_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", "tooltip", NULL };
    PyObject *py_icon_pos = NULL;
    char *tooltip;
    GtkEntryIconPosition icon_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oz:Gtk.Entry.set_icon_tooltip_text", kwlist, &py_icon_pos, &tooltip))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    gtk_entry_set_icon_tooltip_text(GTK_ENTRY(self->obj), icon_pos, tooltip);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_icon_tooltip_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", NULL };
    PyObject *py_icon_pos = NULL;
    GtkEntryIconPosition icon_pos;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.get_icon_tooltip_text", kwlist, &py_icon_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    ret = gtk_entry_get_icon_tooltip_text(GTK_ENTRY(self->obj), icon_pos);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_set_icon_tooltip_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", "tooltip", NULL };
    PyObject *py_icon_pos = NULL;
    char *tooltip;
    GtkEntryIconPosition icon_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oz:Gtk.Entry.set_icon_tooltip_markup", kwlist, &py_icon_pos, &tooltip))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    gtk_entry_set_icon_tooltip_markup(GTK_ENTRY(self->obj), icon_pos, tooltip);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_icon_tooltip_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", NULL };
    PyObject *py_icon_pos = NULL;
    GtkEntryIconPosition icon_pos;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.get_icon_tooltip_markup", kwlist, &py_icon_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    ret = gtk_entry_get_icon_tooltip_markup(GTK_ENTRY(self->obj), icon_pos);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_unset_invisible_char(PyGObject *self)
{
    
    gtk_entry_unset_invisible_char(GTK_ENTRY(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_set_icon_drag_source(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", "target_list", "actions", NULL };
    PyObject *py_icon_pos = NULL, *py_target_list, *py_actions = NULL;
    GtkEntryIconPosition icon_pos;
    GtkTargetList *target_list = NULL;
    GdkDragAction actions;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOO:Gtk.Entry.set_icon_drag_source", kwlist, &py_icon_pos, &py_target_list, &py_actions))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    if (pyg_boxed_check(py_target_list, GTK_TYPE_TARGET_LIST))
        target_list = pyg_boxed_get(py_target_list, GtkTargetList);
    else {
        PyErr_SetString(PyExc_TypeError, "target_list should be a GtkTargetList");
        return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION, py_actions, (gpointer)&actions))
        return NULL;
    
    gtk_entry_set_icon_drag_source(GTK_ENTRY(self->obj), icon_pos, target_list, actions);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_current_icon_drag_source(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_get_current_icon_drag_source(GTK_ENTRY(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_entry_get_buffer(PyGObject *self)
{
    GtkEntryBuffer *ret;

    
    ret = gtk_entry_get_buffer(GTK_ENTRY(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_entry_set_buffer(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    PyGObject *buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Entry.set_buffer", kwlist, &PyGtkEntryBuffer_Type, &buffer))
        return NULL;
    
    gtk_entry_set_buffer(GTK_ENTRY(self->obj), GTK_ENTRY_BUFFER(buffer->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_get_icon_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_pos", NULL };
    PyObject *py_icon_pos = NULL;
    GtkEntryIconPosition icon_pos;
    GdkWindow *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.get_icon_window", kwlist, &py_icon_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, py_icon_pos, (gpointer)&icon_pos))
        return NULL;
    
    ret = gtk_entry_get_icon_window(GTK_ENTRY(self->obj), icon_pos);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_entry_get_text_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_entry_get_text_window(GTK_ENTRY(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_entry_im_context_filter_keypress(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", NULL };
    GdkEvent *event = NULL;
    PyObject *py_event;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Entry.im_context_filter_keypress", kwlist, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    ret = gtk_entry_im_context_filter_keypress(GTK_ENTRY(self->obj), (GdkEventKey *)event);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_reset_im_context(PyGObject *self)
{
    
    gtk_entry_reset_im_context(GTK_ENTRY(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntry__do_populate_popup(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "menu", NULL };
    PyGObject *self, *menu;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Entry.populate_popup", kwlist, &PyGtkEntry_Type, &self, &PyGtkMenu_Type, &menu))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_CLASS(klass)->populate_popup)
        GTK_ENTRY_CLASS(klass)->populate_popup(GTK_ENTRY(self->obj), GTK_MENU(menu->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Entry.populate_popup not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntry__do_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Entry.activate", kwlist, &PyGtkEntry_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_CLASS(klass)->activate)
        GTK_ENTRY_CLASS(klass)->activate(GTK_ENTRY(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Entry.activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntry__do_move_cursor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "step", "count", "extend_selection", NULL };
    PyGObject *self;
    PyObject *py_step = NULL;
    GtkMovementStep step;
    int count, extend_selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oii:Gtk.Entry.move_cursor", kwlist, &PyGtkEntry_Type, &self, &py_step, &count, &extend_selection))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_MOVEMENT_STEP, py_step, (gpointer)&step))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_CLASS(klass)->move_cursor)
        GTK_ENTRY_CLASS(klass)->move_cursor(GTK_ENTRY(self->obj), step, count, extend_selection);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Entry.move_cursor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntry__do_insert_at_cursor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "str", NULL };
    PyGObject *self;
    char *str;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.Entry.insert_at_cursor", kwlist, &PyGtkEntry_Type, &self, &str))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_CLASS(klass)->insert_at_cursor)
        GTK_ENTRY_CLASS(klass)->insert_at_cursor(GTK_ENTRY(self->obj), str);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Entry.insert_at_cursor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntry__do_delete_from_cursor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "type", "count", NULL };
    PyGObject *self;
    PyObject *py_type = NULL;
    int count;
    GtkDeleteType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oi:Gtk.Entry.delete_from_cursor", kwlist, &PyGtkEntry_Type, &self, &py_type, &count))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_DELETE_TYPE, py_type, (gpointer)&type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_CLASS(klass)->delete_from_cursor)
        GTK_ENTRY_CLASS(klass)->delete_from_cursor(GTK_ENTRY(self->obj), type, count);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Entry.delete_from_cursor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntry__do_backspace(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Entry.backspace", kwlist, &PyGtkEntry_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_CLASS(klass)->backspace)
        GTK_ENTRY_CLASS(klass)->backspace(GTK_ENTRY(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Entry.backspace not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntry__do_cut_clipboard(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Entry.cut_clipboard", kwlist, &PyGtkEntry_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_CLASS(klass)->cut_clipboard)
        GTK_ENTRY_CLASS(klass)->cut_clipboard(GTK_ENTRY(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Entry.cut_clipboard not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntry__do_copy_clipboard(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Entry.copy_clipboard", kwlist, &PyGtkEntry_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_CLASS(klass)->copy_clipboard)
        GTK_ENTRY_CLASS(klass)->copy_clipboard(GTK_ENTRY(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Entry.copy_clipboard not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntry__do_paste_clipboard(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Entry.paste_clipboard", kwlist, &PyGtkEntry_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_CLASS(klass)->paste_clipboard)
        GTK_ENTRY_CLASS(klass)->paste_clipboard(GTK_ENTRY(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Entry.paste_clipboard not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntry__do_toggle_overwrite(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Entry.toggle_overwrite", kwlist, &PyGtkEntry_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_CLASS(klass)->toggle_overwrite)
        GTK_ENTRY_CLASS(klass)->toggle_overwrite(GTK_ENTRY(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Entry.toggle_overwrite not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkEntry_methods[] = {
    { "set_visibility", (PyCFunction)_wrap_gtk_entry_set_visibility, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visibility", (PyCFunction)_wrap_gtk_entry_get_visibility, METH_NOARGS,
      NULL },
    { "set_invisible_char", (PyCFunction)_wrap_gtk_entry_set_invisible_char, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_invisible_char", (PyCFunction)_wrap_gtk_entry_get_invisible_char, METH_NOARGS,
      NULL },
    { "set_has_frame", (PyCFunction)_wrap_gtk_entry_set_has_frame, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_frame", (PyCFunction)_wrap_gtk_entry_get_has_frame, METH_NOARGS,
      NULL },
    { "set_max_length", (PyCFunction)_wrap_gtk_entry_set_max_length, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_max_length", (PyCFunction)_wrap_gtk_entry_get_max_length, METH_NOARGS,
      NULL },
    { "set_activates_default", (PyCFunction)_wrap_gtk_entry_set_activates_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_activates_default", (PyCFunction)_wrap_gtk_entry_get_activates_default, METH_NOARGS,
      NULL },
    { "set_width_chars", (PyCFunction)_wrap_gtk_entry_set_width_chars, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_width_chars", (PyCFunction)_wrap_gtk_entry_get_width_chars, METH_NOARGS,
      NULL },
    { "set_text", (PyCFunction)_wrap_gtk_entry_set_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text", (PyCFunction)_wrap_gtk_entry_get_text, METH_NOARGS,
      NULL },
    { "get_layout", (PyCFunction)_wrap_gtk_entry_get_layout, METH_NOARGS,
      NULL },
    { "get_layout_offsets", (PyCFunction)_wrap_gtk_entry_get_layout_offsets, METH_NOARGS,
      NULL },
    { "set_alignment", (PyCFunction)_wrap_gtk_entry_set_alignment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_alignment", (PyCFunction)_wrap_gtk_entry_get_alignment, METH_NOARGS,
      NULL },
    { "set_completion", (PyCFunction)_wrap_gtk_entry_set_completion, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_completion", (PyCFunction)_wrap_gtk_entry_get_completion, METH_NOARGS,
      NULL },
    { "append_text", (PyCFunction)_wrap_gtk_entry_append_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend_text", (PyCFunction)_wrap_gtk_entry_prepend_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_position", (PyCFunction)_wrap_gtk_entry_set_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_editable", (PyCFunction)_wrap_gtk_entry_set_editable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "layout_index_to_text_index", (PyCFunction)_wrap_gtk_entry_layout_index_to_text_index, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "text_index_to_layout_index", (PyCFunction)_wrap_gtk_entry_text_index_to_layout_index, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_inner_border", (PyCFunction)_wrap_gtk_entry_set_inner_border, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_inner_border", (PyCFunction)_wrap_gtk_entry_get_inner_border, METH_NOARGS,
      NULL },
    { "set_cursor_hadjustment", (PyCFunction)_wrap_gtk_entry_set_cursor_hadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_cursor_hadjustment", (PyCFunction)_wrap_gtk_entry_get_cursor_hadjustment, METH_NOARGS,
      NULL },
    { "set_overwrite_mode", (PyCFunction)_wrap_gtk_entry_set_overwrite_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_overwrite_mode", (PyCFunction)_wrap_gtk_entry_get_overwrite_mode, METH_NOARGS,
      NULL },
    { "get_text_length", (PyCFunction)_wrap_gtk_entry_get_text_length, METH_NOARGS,
      NULL },
    { "set_progress_fraction", (PyCFunction)_wrap_gtk_entry_set_progress_fraction, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_progress_fraction", (PyCFunction)_wrap_gtk_entry_get_progress_fraction, METH_NOARGS,
      NULL },
    { "set_progress_pulse_step", (PyCFunction)_wrap_gtk_entry_set_progress_pulse_step, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_progress_pulse_step", (PyCFunction)_wrap_gtk_entry_get_progress_pulse_step, METH_NOARGS,
      NULL },
    { "progress_pulse", (PyCFunction)_wrap_gtk_entry_progress_pulse, METH_NOARGS,
      NULL },
    { "set_icon_from_pixbuf", (PyCFunction)_wrap_gtk_entry_set_icon_from_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_from_stock", (PyCFunction)_wrap_gtk_entry_set_icon_from_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_from_icon_name", (PyCFunction)_wrap_gtk_entry_set_icon_from_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_from_gicon", (PyCFunction)_wrap_gtk_entry_set_icon_from_gicon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_storage_type", (PyCFunction)_wrap_gtk_entry_get_icon_storage_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_pixbuf", (PyCFunction)_wrap_gtk_entry_get_icon_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_stock", (PyCFunction)_wrap_gtk_entry_get_icon_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_name", (PyCFunction)_wrap_gtk_entry_get_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_gicon", (PyCFunction)_wrap_gtk_entry_get_icon_gicon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_activatable", (PyCFunction)_wrap_gtk_entry_set_icon_activatable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_activatable", (PyCFunction)_wrap_gtk_entry_get_icon_activatable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_sensitive", (PyCFunction)_wrap_gtk_entry_set_icon_sensitive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_sensitive", (PyCFunction)_wrap_gtk_entry_get_icon_sensitive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_at_pos", (PyCFunction)_wrap_gtk_entry_get_icon_at_pos, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_tooltip_text", (PyCFunction)_wrap_gtk_entry_set_icon_tooltip_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_tooltip_text", (PyCFunction)_wrap_gtk_entry_get_icon_tooltip_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_tooltip_markup", (PyCFunction)_wrap_gtk_entry_set_icon_tooltip_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_tooltip_markup", (PyCFunction)_wrap_gtk_entry_get_icon_tooltip_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unset_invisible_char", (PyCFunction)_wrap_gtk_entry_unset_invisible_char, METH_NOARGS,
      NULL },
    { "set_icon_drag_source", (PyCFunction)_wrap_gtk_entry_set_icon_drag_source, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_icon_drag_source", (PyCFunction)_wrap_gtk_entry_get_current_icon_drag_source, METH_NOARGS,
      NULL },
    { "get_buffer", (PyCFunction)_wrap_gtk_entry_get_buffer, METH_NOARGS,
      NULL },
    { "set_buffer", (PyCFunction)_wrap_gtk_entry_set_buffer, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_window", (PyCFunction)_wrap_gtk_entry_get_icon_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text_window", (PyCFunction)_wrap_gtk_entry_get_text_window, METH_NOARGS,
      NULL },
    { "im_context_filter_keypress", (PyCFunction)_wrap_gtk_entry_im_context_filter_keypress, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reset_im_context", (PyCFunction)_wrap_gtk_entry_reset_im_context, METH_NOARGS,
      NULL },
    { "do_populate_popup", (PyCFunction)_wrap_GtkEntry__do_populate_popup, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_activate", (PyCFunction)_wrap_GtkEntry__do_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_cursor", (PyCFunction)_wrap_GtkEntry__do_move_cursor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_insert_at_cursor", (PyCFunction)_wrap_GtkEntry__do_insert_at_cursor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_delete_from_cursor", (PyCFunction)_wrap_GtkEntry__do_delete_from_cursor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_backspace", (PyCFunction)_wrap_GtkEntry__do_backspace, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_cut_clipboard", (PyCFunction)_wrap_GtkEntry__do_cut_clipboard, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_copy_clipboard", (PyCFunction)_wrap_GtkEntry__do_copy_clipboard, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_paste_clipboard", (PyCFunction)_wrap_GtkEntry__do_paste_clipboard, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toggle_overwrite", (PyCFunction)_wrap_GtkEntry__do_toggle_overwrite, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkEntry_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Entry",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkEntry_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_entry_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkEntry__proxy_do_populate_popup(GtkEntry *self, GtkMenu*menu)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_menu = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (menu)
        py_menu = pygobject_new((GObject *) menu);
    else {
        Py_INCREF(Py_None);
        py_menu = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_menu);
    
    py_method = PyObject_GetAttrString(py_self, "do_populate_popup");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEntry__proxy_do_activate(GtkEntry *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEntry__proxy_do_move_cursor(GtkEntry *self, GtkMovementStep step, gint count, gboolean extend_selection)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_step;
    PyObject *py_count;
    PyObject *py_extend_selection;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_step = pyg_enum_from_gtype(GTK_TYPE_MOVEMENT_STEP, step);
    if (!py_step) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_count = PyInt_FromLong(count);
    py_extend_selection = extend_selection? Py_True : Py_False;
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_step);
    PyTuple_SET_ITEM(py_args, 1, py_count);
    Py_INCREF(py_extend_selection);
    PyTuple_SET_ITEM(py_args, 2, py_extend_selection);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_cursor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEntry__proxy_do_insert_at_cursor(GtkEntry *self, const gchar*str)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_str = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (str)
        py_str = PyString_FromString(str);
    if (!py_str) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_str);
    
    py_method = PyObject_GetAttrString(py_self, "do_insert_at_cursor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEntry__proxy_do_delete_from_cursor(GtkEntry *self, GtkDeleteType type, gint count)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_type;
    PyObject *py_count;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_type = pyg_enum_from_gtype(GTK_TYPE_DELETE_TYPE, type);
    if (!py_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_count = PyInt_FromLong(count);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_type);
    PyTuple_SET_ITEM(py_args, 1, py_count);
    
    py_method = PyObject_GetAttrString(py_self, "do_delete_from_cursor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEntry__proxy_do_backspace(GtkEntry *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_backspace");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEntry__proxy_do_cut_clipboard(GtkEntry *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_cut_clipboard");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEntry__proxy_do_copy_clipboard(GtkEntry *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_copy_clipboard");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEntry__proxy_do_paste_clipboard(GtkEntry *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_paste_clipboard");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEntry__proxy_do_toggle_overwrite(GtkEntry *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_overwrite");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkEntry_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkEntryClass *klass = GTK_ENTRY_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_populate_popup");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "populate_popup")))
            klass->populate_popup = _wrap_GtkEntry__proxy_do_populate_popup;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate")))
            klass->activate = _wrap_GtkEntry__proxy_do_activate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_cursor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_cursor")))
            klass->move_cursor = _wrap_GtkEntry__proxy_do_move_cursor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_insert_at_cursor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "insert_at_cursor")))
            klass->insert_at_cursor = _wrap_GtkEntry__proxy_do_insert_at_cursor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_delete_from_cursor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "delete_from_cursor")))
            klass->delete_from_cursor = _wrap_GtkEntry__proxy_do_delete_from_cursor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_backspace");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "backspace")))
            klass->backspace = _wrap_GtkEntry__proxy_do_backspace;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_cut_clipboard");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "cut_clipboard")))
            klass->cut_clipboard = _wrap_GtkEntry__proxy_do_cut_clipboard;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_copy_clipboard");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "copy_clipboard")))
            klass->copy_clipboard = _wrap_GtkEntry__proxy_do_copy_clipboard;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_paste_clipboard");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "paste_clipboard")))
            klass->paste_clipboard = _wrap_GtkEntry__proxy_do_paste_clipboard;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_overwrite");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_overwrite")))
            klass->toggle_overwrite = _wrap_GtkEntry__proxy_do_toggle_overwrite;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkEntryCompletion ----------- */

static int
_wrap_gtk_entry_completion_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.EntryCompletion.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.EntryCompletion object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_entry_completion_get_entry(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_entry_completion_get_entry(GTK_ENTRY_COMPLETION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_entry_completion_set_model(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *py_model = NULL;
    GtkTreeModel *model = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.EntryCompletion.set_model", kwlist, &py_model))
        return NULL;
    if ((PyObject *)py_model == Py_None)
        model = NULL;
    else if (py_model && pygobject_check(py_model, &PyGtkTreeModel_Type))
        model = GTK_TREE_MODEL(py_model->obj);
    else if (py_model) {
        PyErr_SetString(PyExc_TypeError, "model should be a GtkTreeModel or None");
        return NULL;
    }
    
    gtk_entry_completion_set_model(GTK_ENTRY_COMPLETION(self->obj), (GtkTreeModel *) model);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_get_model(PyGObject *self)
{
    GtkTreeModel *ret;

    
    ret = gtk_entry_completion_get_model(GTK_ENTRY_COMPLETION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 4518 "./gtk.override"
static gboolean
pygtk_entry_completion_match_func_cb(GtkEntryCompletion *completion,
				      const gchar *key,
				      GtkTreeIter *iter,
				      gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_completion, *py_iter;
    gboolean ret = FALSE;
    PyObject *retobj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
 
    py_completion = pygobject_new((GObject *)completion);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, TRUE, TRUE);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NsNO)", py_completion,
                                     key, py_iter, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NsN)", py_completion,
                                     key, py_iter);
    }

    if (retobj != NULL) {
	ret = PyObject_IsTrue(retobj);
        Py_DECREF(retobj);
    } else {
	PyErr_Print();
    }
 
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_entry_completion_set_match_func(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTuple(args,
                          "O|O:GtkEntryCompletion.set_match_func",
                          &pyfunc, &pyarg))
        return NULL;
 
    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);

    gtk_entry_completion_set_match_func(GTK_ENTRY_COMPLETION(self->obj),
					pygtk_entry_completion_match_func_cb,
					cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 46091 "gtk.c"


static PyObject *
_wrap_gtk_entry_completion_set_minimum_key_length(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "length", NULL };
    int length;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EntryCompletion.set_minimum_key_length", kwlist, &length))
        return NULL;
    
    gtk_entry_completion_set_minimum_key_length(GTK_ENTRY_COMPLETION(self->obj), length);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_get_minimum_key_length(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_completion_get_minimum_key_length(GTK_ENTRY_COMPLETION(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_entry_completion_complete(PyGObject *self)
{
    
    gtk_entry_completion_complete(GTK_ENTRY_COMPLETION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_insert_action_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "index", "text", NULL };
    int index;
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"is:Gtk.EntryCompletion.insert_action_text", kwlist, &index, &text))
        return NULL;
    
    gtk_entry_completion_insert_action_text(GTK_ENTRY_COMPLETION(self->obj), index, text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_insert_action_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "index", "markup", NULL };
    int index;
    char *markup;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"is:Gtk.EntryCompletion.insert_action_markup", kwlist, &index, &markup))
        return NULL;
    
    gtk_entry_completion_insert_action_markup(GTK_ENTRY_COMPLETION(self->obj), index, markup);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_delete_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "index", NULL };
    int index;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EntryCompletion.delete_action", kwlist, &index))
        return NULL;
    
    gtk_entry_completion_delete_action(GTK_ENTRY_COMPLETION(self->obj), index);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_set_text_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EntryCompletion.set_text_column", kwlist, &column))
        return NULL;
    
    gtk_entry_completion_set_text_column(GTK_ENTRY_COMPLETION(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_get_text_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_completion_get_text_column(GTK_ENTRY_COMPLETION(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_entry_completion_insert_prefix(PyGObject *self)
{
    
    gtk_entry_completion_insert_prefix(GTK_ENTRY_COMPLETION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_set_inline_completion(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "inline_completion", NULL };
    int inline_completion;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EntryCompletion.set_inline_completion", kwlist, &inline_completion))
        return NULL;
    
    gtk_entry_completion_set_inline_completion(GTK_ENTRY_COMPLETION(self->obj), inline_completion);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_get_inline_completion(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_completion_get_inline_completion(GTK_ENTRY_COMPLETION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_completion_set_popup_completion(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "popup_completion", NULL };
    int popup_completion;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EntryCompletion.set_popup_completion", kwlist, &popup_completion))
        return NULL;
    
    gtk_entry_completion_set_popup_completion(GTK_ENTRY_COMPLETION(self->obj), popup_completion);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_get_popup_completion(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_completion_get_popup_completion(GTK_ENTRY_COMPLETION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_completion_set_popup_set_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "popup_set_width", NULL };
    int popup_set_width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EntryCompletion.set_popup_set_width", kwlist, &popup_set_width))
        return NULL;
    
    gtk_entry_completion_set_popup_set_width(GTK_ENTRY_COMPLETION(self->obj), popup_set_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_get_popup_set_width(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_completion_get_popup_set_width(GTK_ENTRY_COMPLETION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_completion_set_popup_single_match(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "popup_single_match", NULL };
    int popup_single_match;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EntryCompletion.set_popup_single_match", kwlist, &popup_single_match))
        return NULL;
    
    gtk_entry_completion_set_popup_single_match(GTK_ENTRY_COMPLETION(self->obj), popup_single_match);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_get_popup_single_match(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_completion_get_popup_single_match(GTK_ENTRY_COMPLETION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_entry_completion_get_completion_prefix(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_entry_completion_get_completion_prefix(GTK_ENTRY_COMPLETION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_set_inline_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "inline_selection", NULL };
    int inline_selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EntryCompletion.set_inline_selection", kwlist, &inline_selection))
        return NULL;
    
    gtk_entry_completion_set_inline_selection(GTK_ENTRY_COMPLETION(self->obj), inline_selection);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_completion_get_inline_selection(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_completion_get_inline_selection(GTK_ENTRY_COMPLETION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkEntryCompletion__do_match_selected(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "model", "iter", NULL };
    PyGObject *self, *model;
    GtkTreeIter *iter = NULL;
    int ret;
    PyObject *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O:Gtk.EntryCompletion.match_selected", kwlist, &PyGtkEntryCompletion_Type, &self, &PyGtkTreeModel_Type, &model, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_COMPLETION_CLASS(klass)->match_selected)
        ret = GTK_ENTRY_COMPLETION_CLASS(klass)->match_selected(GTK_ENTRY_COMPLETION(self->obj), GTK_TREE_MODEL(model->obj), iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.EntryCompletion.match_selected not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkEntryCompletion__do_action_activated(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "index_", NULL };
    PyGObject *self;
    int index_;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.EntryCompletion.action_activated", kwlist, &PyGtkEntryCompletion_Type, &self, &index_))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_COMPLETION_CLASS(klass)->action_activated)
        GTK_ENTRY_COMPLETION_CLASS(klass)->action_activated(GTK_ENTRY_COMPLETION(self->obj), index_);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.EntryCompletion.action_activated not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEntryCompletion__do_insert_prefix(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "prefix", NULL };
    PyGObject *self;
    char *prefix;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.EntryCompletion.insert_prefix", kwlist, &PyGtkEntryCompletion_Type, &self, &prefix))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ENTRY_COMPLETION_CLASS(klass)->insert_prefix)
        ret = GTK_ENTRY_COMPLETION_CLASS(klass)->insert_prefix(GTK_ENTRY_COMPLETION(self->obj), prefix);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.EntryCompletion.insert_prefix not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkEntryCompletion_methods[] = {
    { "get_entry", (PyCFunction)_wrap_gtk_entry_completion_get_entry, METH_NOARGS,
      NULL },
    { "set_model", (PyCFunction)_wrap_gtk_entry_completion_set_model, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_model", (PyCFunction)_wrap_gtk_entry_completion_get_model, METH_NOARGS,
      NULL },
    { "set_match_func", (PyCFunction)_wrap_gtk_entry_completion_set_match_func, METH_VARARGS,
      NULL },
    { "set_minimum_key_length", (PyCFunction)_wrap_gtk_entry_completion_set_minimum_key_length, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_minimum_key_length", (PyCFunction)_wrap_gtk_entry_completion_get_minimum_key_length, METH_NOARGS,
      NULL },
    { "complete", (PyCFunction)_wrap_gtk_entry_completion_complete, METH_NOARGS,
      NULL },
    { "insert_action_text", (PyCFunction)_wrap_gtk_entry_completion_insert_action_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_action_markup", (PyCFunction)_wrap_gtk_entry_completion_insert_action_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "delete_action", (PyCFunction)_wrap_gtk_entry_completion_delete_action, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_text_column", (PyCFunction)_wrap_gtk_entry_completion_set_text_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text_column", (PyCFunction)_wrap_gtk_entry_completion_get_text_column, METH_NOARGS,
      NULL },
    { "insert_prefix", (PyCFunction)_wrap_gtk_entry_completion_insert_prefix, METH_NOARGS,
      NULL },
    { "set_inline_completion", (PyCFunction)_wrap_gtk_entry_completion_set_inline_completion, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_inline_completion", (PyCFunction)_wrap_gtk_entry_completion_get_inline_completion, METH_NOARGS,
      NULL },
    { "set_popup_completion", (PyCFunction)_wrap_gtk_entry_completion_set_popup_completion, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_popup_completion", (PyCFunction)_wrap_gtk_entry_completion_get_popup_completion, METH_NOARGS,
      NULL },
    { "set_popup_set_width", (PyCFunction)_wrap_gtk_entry_completion_set_popup_set_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_popup_set_width", (PyCFunction)_wrap_gtk_entry_completion_get_popup_set_width, METH_NOARGS,
      NULL },
    { "set_popup_single_match", (PyCFunction)_wrap_gtk_entry_completion_set_popup_single_match, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_popup_single_match", (PyCFunction)_wrap_gtk_entry_completion_get_popup_single_match, METH_NOARGS,
      NULL },
    { "get_completion_prefix", (PyCFunction)_wrap_gtk_entry_completion_get_completion_prefix, METH_NOARGS,
      NULL },
    { "set_inline_selection", (PyCFunction)_wrap_gtk_entry_completion_set_inline_selection, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_inline_selection", (PyCFunction)_wrap_gtk_entry_completion_get_inline_selection, METH_NOARGS,
      NULL },
    { "do_match_selected", (PyCFunction)_wrap_GtkEntryCompletion__do_match_selected, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_action_activated", (PyCFunction)_wrap_GtkEntryCompletion__do_action_activated, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_insert_prefix", (PyCFunction)_wrap_GtkEntryCompletion__do_insert_prefix, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkEntryCompletion_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.EntryCompletion",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkEntryCompletion_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_entry_completion_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gboolean
_wrap_GtkEntryCompletion__proxy_do_match_selected(GtkEntryCompletion *self, GtkTreeModel*model, GtkTreeIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_model = NULL;
    PyObject *py_iter;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (model)
        py_model = pygobject_new((GObject *) model);
    else {
        Py_INCREF(Py_None);
        py_model = Py_None;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_model);
    PyTuple_SET_ITEM(py_args, 1, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_match_selected");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkEntryCompletion__proxy_do_action_activated(GtkEntryCompletion *self, gint index_)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_index_;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_index_ = PyInt_FromLong(index_);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_index_);
    
    py_method = PyObject_GetAttrString(py_self, "do_action_activated");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkEntryCompletion__proxy_do_insert_prefix(GtkEntryCompletion *self, const gchar*prefix)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_prefix = NULL;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (prefix)
        py_prefix = PyString_FromString(prefix);
    if (!py_prefix) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_prefix);
    
    py_method = PyObject_GetAttrString(py_self, "do_insert_prefix");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkEntryCompletion_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkEntryCompletionClass *klass = GTK_ENTRY_COMPLETION_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_match_selected");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "match_selected")))
            klass->match_selected = _wrap_GtkEntryCompletion__proxy_do_match_selected;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_action_activated");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "action_activated")))
            klass->action_activated = _wrap_GtkEntryCompletion__proxy_do_action_activated;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_insert_prefix");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "insert_prefix")))
            klass->insert_prefix = _wrap_GtkEntryCompletion__proxy_do_insert_prefix;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkEventBox ----------- */

static int
_wrap_gtk_event_box_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.EventBox.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.EventBox object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_event_box_get_visible_window(PyGObject *self)
{
    int ret;

    
    ret = gtk_event_box_get_visible_window(GTK_EVENT_BOX(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_event_box_set_visible_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible_window", NULL };
    int visible_window;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EventBox.set_visible_window", kwlist, &visible_window))
        return NULL;
    
    gtk_event_box_set_visible_window(GTK_EVENT_BOX(self->obj), visible_window);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_event_box_get_above_child(PyGObject *self)
{
    int ret;

    
    ret = gtk_event_box_get_above_child(GTK_EVENT_BOX(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_event_box_set_above_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "above_child", NULL };
    int above_child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EventBox.set_above_child", kwlist, &above_child))
        return NULL;
    
    gtk_event_box_set_above_child(GTK_EVENT_BOX(self->obj), above_child);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkEventBox_methods[] = {
    { "get_visible_window", (PyCFunction)_wrap_gtk_event_box_get_visible_window, METH_NOARGS,
      NULL },
    { "set_visible_window", (PyCFunction)_wrap_gtk_event_box_set_visible_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_above_child", (PyCFunction)_wrap_gtk_event_box_get_above_child, METH_NOARGS,
      NULL },
    { "set_above_child", (PyCFunction)_wrap_gtk_event_box_set_above_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkEventBox_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.EventBox",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkEventBox_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_event_box_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkExpander ----------- */

static int
_wrap_gtk_expander_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"label", NULL };
    char *prop_names[] = {"label", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.Expander.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Expander object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_expander_set_expanded(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "expanded", NULL };
    int expanded;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Expander.set_expanded", kwlist, &expanded))
        return NULL;
    
    gtk_expander_set_expanded(GTK_EXPANDER(self->obj), expanded);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_expander_get_expanded(PyGObject *self)
{
    int ret;

    
    ret = gtk_expander_get_expanded(GTK_EXPANDER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_expander_set_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "spacing", NULL };
    int spacing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Expander.set_spacing", kwlist, &spacing))
        return NULL;
    
    gtk_expander_set_spacing(GTK_EXPANDER(self->obj), spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_expander_get_spacing(PyGObject *self)
{
    int ret;

    
    ret = gtk_expander_get_spacing(GTK_EXPANDER(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_expander_set_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.Expander.set_label", kwlist, &label))
        return NULL;
    
    gtk_expander_set_label(GTK_EXPANDER(self->obj), label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_expander_get_label(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_expander_get_label(GTK_EXPANDER(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_expander_set_use_underline(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_underline", NULL };
    int use_underline;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Expander.set_use_underline", kwlist, &use_underline))
        return NULL;
    
    gtk_expander_set_use_underline(GTK_EXPANDER(self->obj), use_underline);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_expander_get_use_underline(PyGObject *self)
{
    int ret;

    
    ret = gtk_expander_get_use_underline(GTK_EXPANDER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_expander_set_use_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_markup", NULL };
    int use_markup;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Expander.set_use_markup", kwlist, &use_markup))
        return NULL;
    
    gtk_expander_set_use_markup(GTK_EXPANDER(self->obj), use_markup);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_expander_get_use_markup(PyGObject *self)
{
    int ret;

    
    ret = gtk_expander_get_use_markup(GTK_EXPANDER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_expander_set_label_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label_widget", NULL };
    PyGObject *py_label_widget;
    GtkWidget *label_widget = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Expander.set_label_widget", kwlist, &py_label_widget))
        return NULL;
    if (py_label_widget && pygobject_check(py_label_widget, &PyGtkWidget_Type))
        label_widget = GTK_WIDGET(py_label_widget->obj);
    else if ((PyObject *)py_label_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "label_widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_expander_set_label_widget(GTK_EXPANDER(self->obj), (GtkWidget *) label_widget);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_expander_get_label_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_expander_get_label_widget(GTK_EXPANDER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_expander_set_label_fill(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label_fill", NULL };
    int label_fill;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Expander.set_label_fill", kwlist, &label_fill))
        return NULL;
    
    gtk_expander_set_label_fill(GTK_EXPANDER(self->obj), label_fill);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_expander_get_label_fill(PyGObject *self)
{
    int ret;

    
    ret = gtk_expander_get_label_fill(GTK_EXPANDER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkExpander__do_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Expander.activate", kwlist, &PyGtkExpander_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_EXPANDER_CLASS(klass)->activate)
        GTK_EXPANDER_CLASS(klass)->activate(GTK_EXPANDER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Expander.activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkExpander_methods[] = {
    { "set_expanded", (PyCFunction)_wrap_gtk_expander_set_expanded, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_expanded", (PyCFunction)_wrap_gtk_expander_get_expanded, METH_NOARGS,
      NULL },
    { "set_spacing", (PyCFunction)_wrap_gtk_expander_set_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_spacing", (PyCFunction)_wrap_gtk_expander_get_spacing, METH_NOARGS,
      NULL },
    { "set_label", (PyCFunction)_wrap_gtk_expander_set_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label", (PyCFunction)_wrap_gtk_expander_get_label, METH_NOARGS,
      NULL },
    { "set_use_underline", (PyCFunction)_wrap_gtk_expander_set_use_underline, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_underline", (PyCFunction)_wrap_gtk_expander_get_use_underline, METH_NOARGS,
      NULL },
    { "set_use_markup", (PyCFunction)_wrap_gtk_expander_set_use_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_markup", (PyCFunction)_wrap_gtk_expander_get_use_markup, METH_NOARGS,
      NULL },
    { "set_label_widget", (PyCFunction)_wrap_gtk_expander_set_label_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label_widget", (PyCFunction)_wrap_gtk_expander_get_label_widget, METH_NOARGS,
      NULL },
    { "set_label_fill", (PyCFunction)_wrap_gtk_expander_set_label_fill, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label_fill", (PyCFunction)_wrap_gtk_expander_get_label_fill, METH_NOARGS,
      NULL },
    { "do_activate", (PyCFunction)_wrap_GtkExpander__do_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkExpander_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Expander",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkExpander_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_expander_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkExpander__proxy_do_activate(GtkExpander *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkExpander_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkExpanderClass *klass = GTK_EXPANDER_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate")))
            klass->activate = _wrap_GtkExpander__proxy_do_activate;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkFileChooserButton ----------- */

#line 6251 "./gtk.override"
static int
_wrap_gtk_file_chooser_button_new(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist1[] = { "title", "backend", NULL };
    static char *kwlist2[] = { "dialog", NULL };
    gchar *title, *backend = NULL;
    PyGObject *dialog;
 
    if (PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s|z:GtkFileChooserButton.__init__",
				     kwlist1, &title, &backend))
        pygobject_construct(self, "title", title,
                            "file-system-backend", backend,
                            NULL);
    else {
        PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "O!:GtkFileChooserButton.__init__",
                                         kwlist2, &PyGtkFileChooserDialog_Type,
					 &dialog)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "Usage: one of:\n"
			    "  gtk.FileChooserButton(title, backend=None)\n"
			    "  gtk.FileChooserButton(filechooserdialog)");
	    return -1;
	}
        pygobject_construct(self, "dialog", GTK_WIDGET(dialog->obj), NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkFileChooserBUtton object");
        return -1;
    }
    return 0;
}
#line 47373 "gtk.c"


static PyObject *
_wrap_gtk_file_chooser_button_get_title(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_file_chooser_button_get_title(GTK_FILE_CHOOSER_BUTTON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_button_set_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "title", NULL };
    char *title;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooserButton.set_title", kwlist, &title))
        return NULL;
    
    gtk_file_chooser_button_set_title(GTK_FILE_CHOOSER_BUTTON(self->obj), title);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_button_get_width_chars(PyGObject *self)
{
    int ret;

    
    ret = gtk_file_chooser_button_get_width_chars(GTK_FILE_CHOOSER_BUTTON(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_file_chooser_button_set_width_chars(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "n_chars", NULL };
    int n_chars;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FileChooserButton.set_width_chars", kwlist, &n_chars))
        return NULL;
    
    gtk_file_chooser_button_set_width_chars(GTK_FILE_CHOOSER_BUTTON(self->obj), n_chars);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_button_get_focus_on_click(PyGObject *self)
{
    int ret;

    
    ret = gtk_file_chooser_button_get_focus_on_click(GTK_FILE_CHOOSER_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_button_set_focus_on_click(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "focus_on_click", NULL };
    int focus_on_click;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FileChooserButton.set_focus_on_click", kwlist, &focus_on_click))
        return NULL;
    
    gtk_file_chooser_button_set_focus_on_click(GTK_FILE_CHOOSER_BUTTON(self->obj), focus_on_click);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkFileChooserButton_methods[] = {
    { "get_title", (PyCFunction)_wrap_gtk_file_chooser_button_get_title, METH_NOARGS,
      NULL },
    { "set_title", (PyCFunction)_wrap_gtk_file_chooser_button_set_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_width_chars", (PyCFunction)_wrap_gtk_file_chooser_button_get_width_chars, METH_NOARGS,
      NULL },
    { "set_width_chars", (PyCFunction)_wrap_gtk_file_chooser_button_set_width_chars, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_focus_on_click", (PyCFunction)_wrap_gtk_file_chooser_button_get_focus_on_click, METH_NOARGS,
      NULL },
    { "set_focus_on_click", (PyCFunction)_wrap_gtk_file_chooser_button_set_focus_on_click, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkFileChooserButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.FileChooserButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkFileChooserButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_file_chooser_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkFileChooserDialog ----------- */

#line 3896 "./gtk.override"
static int
_wrap_gtk_file_chooser_dialog_new(PyGObject *self,
				  PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "title", "parent", "action", "buttons", "backend", NULL };
    gchar *title = NULL;
    PyGObject *py_window = NULL;
    PyObject *py_buttons = Py_None;
    PyObject *py_action = NULL;
    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
    GtkWindow *parent = NULL;
    gchar *backend = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zOOOz:GtkFileChooserDialog.__init__", kwlist,
                                     &title, &py_window, &py_action,
                                     &py_buttons,
				     &backend))
        return -1;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
	parent = NULL;
    else if (pygobject_check(py_window, &PyGtkWindow_Type))
	parent = GTK_WINDOW(py_window->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "parent must be a GtkWindow or None");
        return -1;
    }

    if (pyg_enum_get_value(GTK_TYPE_FILE_CHOOSER_ACTION, py_action,
                           (gint *)&action))
        return -1;
    if (py_buttons == Py_None)
        len = 0;
    else if (PyTuple_Check(py_buttons))
        len = PyTuple_Size(py_buttons);
    else {
        PyErr_SetString(PyExc_TypeError, "buttons must be a tuple containing text/response pairs or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    pygobject_construct(self,
                        "title", title, 
                        "action", action,
                        "file-system-backend", backend,
                        NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkFileChooserDialog object");
        return -1;
    }

  if (parent)
    gtk_window_set_transient_for (GTK_WINDOW (self->obj), parent);

  for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyString_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyInt_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }
        gtk_dialog_add_button(GTK_DIALOG(self->obj), PyString_AsString(text),
                              PyInt_AsLong(id));
    }
    g_object_ref(self->obj); /* we don't own the first reference of windows */
    
    return 0;
}
#line 47614 "gtk.c"


#line 8699 "./gtk.override"
/* This is a Workaround to solve a problem in the __mro__ of FileChooserDialog,
 * without this method a gtk.Widget method  with the same name will be called
 * which will always return None, see bug 534042.
 */
static PyObject *
_wrap_gtk_file_chooser_dialog_get_action(PyGObject *self)
{
   gint ret;

   ret = gtk_file_chooser_get_action(GTK_FILE_CHOOSER(self->obj));

   return pyg_enum_from_gtype(GTK_TYPE_FILE_CHOOSER_ACTION, ret);

}
#line 47632 "gtk.c"


static const PyMethodDef _PyGtkFileChooserDialog_methods[] = {
    { "get_action", (PyCFunction)_wrap_gtk_file_chooser_dialog_get_action, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkFileChooserDialog_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.FileChooserDialog",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkFileChooserDialog_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_file_chooser_dialog_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkFileChooserWidget ----------- */

#line 4724 "./gtk.override"
static int
_wrap_gtk_file_chooser_widget_new(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "action", "backend", NULL };
    PyObject *py_action = NULL;
    gchar * backend = NULL;
    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|Oz:GtkFileChooserWidget.__init__",
				     kwlist, &py_action, &backend))
        return -1;
    if (py_action && pyg_enum_get_value(GTK_TYPE_FILE_CHOOSER_ACTION,
					py_action, (gint *)&action))
        return -1;
        pygobject_construct(self,
                            "action", action, "file-system-backend", backend,
                            NULL);
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkFileChooserWidget object");
        return -1;
    }
    return 0;
}
#line 47718 "gtk.c"


PyTypeObject G_GNUC_INTERNAL PyGtkFileChooserWidget_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.FileChooserWidget",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_file_chooser_widget_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkFileFilter ----------- */

 static int
_wrap_gtk_file_filter_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.FileFilter.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.FileFilter object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_file_filter_set_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileFilter.set_name", kwlist, &name))
        return NULL;
    
    gtk_file_filter_set_name(GTK_FILE_FILTER(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_filter_get_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_file_filter_get_name(GTK_FILE_FILTER(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_filter_add_mime_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mime_type", NULL };
    char *mime_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileFilter.add_mime_type", kwlist, &mime_type))
        return NULL;
    
    gtk_file_filter_add_mime_type(GTK_FILE_FILTER(self->obj), mime_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_filter_add_pattern(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pattern", NULL };
    char *pattern;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileFilter.add_pattern", kwlist, &pattern))
        return NULL;
    
    gtk_file_filter_add_pattern(GTK_FILE_FILTER(self->obj), pattern);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_filter_add_pixbuf_formats(PyGObject *self)
{
    
    gtk_file_filter_add_pixbuf_formats(GTK_FILE_FILTER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4815 "./gtk.override"
static gboolean
pygtk_file_filter_add_custom_cb(const GtkFileFilterInfo *filter_info,
				gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    gboolean ret = FALSE;
    PyObject *retobj, *py_filter_info, *py_obj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_filter_info = PyTuple_New(4);

    if (filter_info->filename
	&& (filter_info->contains & GTK_FILE_FILTER_FILENAME)) {
	py_obj = PyString_FromString(filter_info->filename);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 0, py_obj);
    if (filter_info->uri
	&& (filter_info->contains & GTK_FILE_FILTER_URI)) {
	py_obj = PyString_FromString(filter_info->uri);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 1, py_obj);
    if (filter_info->display_name
	&& (filter_info->contains & GTK_FILE_FILTER_DISPLAY_NAME)) {
	py_obj = PyString_FromString(filter_info->display_name);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 2, py_obj);
    if (filter_info->mime_type
	&& (filter_info->contains & GTK_FILE_FILTER_MIME_TYPE)) {
	py_obj = PyString_FromString(filter_info->mime_type);
    } else {
	Py_INCREF(Py_None);
	py_obj = Py_None;
    }
    PyTuple_SetItem(py_filter_info, 3, py_obj);
 
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NO)", py_filter_info,
				     cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(N)", py_filter_info);
    }

    if (retobj != NULL) {
	ret = PyObject_IsTrue(retobj);
        Py_DECREF(retobj);
    } else {
	PyErr_Print();
    }
 
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_file_filter_add_custom(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyflags, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
    GtkFileFilterFlags flags;
 
    if (!PyArg_ParseTuple(args,
                          "OO|O:GtkEntryCompletion.set_match_func",
                          &pyflags, &pyfunc, &pyarg))
        return NULL;
 
    if (pyg_flags_get_value(GTK_TYPE_FILE_FILTER_FLAGS, pyflags,
			   (gint *)&flags))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);

    gtk_file_filter_add_custom(GTK_FILE_FILTER(self->obj), flags,
			       pygtk_file_filter_add_custom_cb,
			       cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 47958 "gtk.c"


static PyObject *
_wrap_gtk_file_filter_get_needed(PyGObject *self)
{
    guint ret;

    
    ret = gtk_file_filter_get_needed(GTK_FILE_FILTER(self->obj));
    
    return pyg_flags_from_gtype(GTK_TYPE_FILE_FILTER_FLAGS, ret);
}

#line 4755 "./gtk.override"
static PyObject *
_wrap_gtk_file_filter_filter(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "filter_info", NULL };
    GtkFileFilterInfo filter_info = { 0, NULL, NULL, NULL, NULL };
    PyObject *py_filter_info, *obj;
    PyObject *pyret = Py_False;
    int size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkFileFilter.filter", kwlist,
				     &PyTuple_Type, &py_filter_info))
        return NULL;

    size = PyTuple_Size(py_filter_info);
    if (size != 4) {
	PyErr_SetString(PyExc_RuntimeError,
                        "filter_info tuple must contain 4 items"
			" each of type string or None");
	return NULL;
    }

    if ((obj = PyTuple_GetItem(py_filter_info, 0)) != Py_None) {
	if (!PyString_Check(obj))
	    goto error;
	filter_info.filename = PyString_AsString(obj);
	filter_info.contains |= GTK_FILE_FILTER_FILENAME;
    }
    if ((obj = PyTuple_GetItem(py_filter_info, 1)) != Py_None) {
	if (!PyString_Check(obj))
	    goto error;
	filter_info.uri = PyString_AsString(obj);
	filter_info.contains |= GTK_FILE_FILTER_URI;
    }
    if ((obj = PyTuple_GetItem(py_filter_info, 2)) != Py_None) {
	if (!PyString_Check(obj))
	    goto error;
	filter_info.display_name = PyString_AsString(obj);
	filter_info.contains |= GTK_FILE_FILTER_DISPLAY_NAME;
    }
    if ((obj = PyTuple_GetItem(py_filter_info, 3)) != Py_None) {
	if (!PyString_Check(obj))
	    goto error;
	filter_info.mime_type = PyString_AsString(obj);
	filter_info.contains |= GTK_FILE_FILTER_MIME_TYPE;
    }

    if (gtk_file_filter_filter(GTK_FILE_FILTER(self->obj), &filter_info))
	pyret = Py_True;
    Py_INCREF(pyret);
    return pyret;

 error:
    PyErr_SetString(PyExc_TypeError, "filter_info 4-tuple items"
		    " must be of type string or None");
    return NULL;
}
#line 48031 "gtk.c"


static const PyMethodDef _PyGtkFileFilter_methods[] = {
    { "set_name", (PyCFunction)_wrap_gtk_file_filter_set_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_name", (PyCFunction)_wrap_gtk_file_filter_get_name, METH_NOARGS,
      NULL },
    { "add_mime_type", (PyCFunction)_wrap_gtk_file_filter_add_mime_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_pattern", (PyCFunction)_wrap_gtk_file_filter_add_pattern, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_pixbuf_formats", (PyCFunction)_wrap_gtk_file_filter_add_pixbuf_formats, METH_NOARGS,
      NULL },
    { "add_custom", (PyCFunction)_wrap_gtk_file_filter_add_custom, METH_VARARGS,
      NULL },
    { "get_needed", (PyCFunction)_wrap_gtk_file_filter_get_needed, METH_NOARGS,
      NULL },
    { "filter", (PyCFunction)_wrap_gtk_file_filter_filter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkFileFilter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.FileFilter",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkFileFilter_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_file_filter_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkFileSelection ----------- */

static int
_wrap_gtk_file_selection_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"title", NULL };
    char *prop_names[] = {"title", NULL };
    guint nparams, i;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.FileChooserDialog") < 0)
        return -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.FileSelection.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.FileSelection object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_file_selection_set_filename(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileSelection.set_filename", kwlist, &filename))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.FileChooserDialog") < 0)
        return NULL;
    
    gtk_file_selection_set_filename(GTK_FILE_SELECTION(self->obj), filename);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_selection_get_filename(PyGObject *self)
{
    const gchar *ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.FileChooserDialog") < 0)
        return NULL;
    
    ret = gtk_file_selection_get_filename(GTK_FILE_SELECTION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_selection_complete(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pattern", NULL };
    char *pattern;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileSelection.complete", kwlist, &pattern))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.FileChooserDialog") < 0)
        return NULL;
    
    gtk_file_selection_complete(GTK_FILE_SELECTION(self->obj), pattern);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_selection_show_fileop_buttons(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.FileChooserDialog") < 0)
        return NULL;
    
    gtk_file_selection_show_fileop_buttons(GTK_FILE_SELECTION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_selection_hide_fileop_buttons(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.FileChooserDialog") < 0)
        return NULL;
    
    gtk_file_selection_hide_fileop_buttons(GTK_FILE_SELECTION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3361 "./gtk.override"
static PyObject *
_wrap_gtk_file_selection_get_selections(PyGObject *self)
{
    gchar **filenames = NULL;
    int size;
    int i;
    PyObject *ret;

    filenames = gtk_file_selection_get_selections(
        GTK_FILE_SELECTION(self->obj));

    for (i = 0; filenames[i]; i++);
    size = i;

    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
        PyTuple_SetItem(ret, i, PyString_FromString(filenames[i]));

    return ret;
}
#line 48231 "gtk.c"


static PyObject *
_wrap_gtk_file_selection_set_select_multiple(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "select_multiple", NULL };
    int select_multiple;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FileSelection.set_select_multiple", kwlist, &select_multiple))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.FileChooserDialog") < 0)
        return NULL;
    
    gtk_file_selection_set_select_multiple(GTK_FILE_SELECTION(self->obj), select_multiple);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_selection_get_select_multiple(PyGObject *self)
{
    int ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.FileChooserDialog") < 0)
        return NULL;
    
    ret = gtk_file_selection_get_select_multiple(GTK_FILE_SELECTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkFileSelection_methods[] = {
    { "set_filename", (PyCFunction)_wrap_gtk_file_selection_set_filename, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_filename", (PyCFunction)_wrap_gtk_file_selection_get_filename, METH_NOARGS,
      NULL },
    { "complete", (PyCFunction)_wrap_gtk_file_selection_complete, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "show_fileop_buttons", (PyCFunction)_wrap_gtk_file_selection_show_fileop_buttons, METH_NOARGS,
      NULL },
    { "hide_fileop_buttons", (PyCFunction)_wrap_gtk_file_selection_hide_fileop_buttons, METH_NOARGS,
      NULL },
    { "get_selections", (PyCFunction)_wrap_gtk_file_selection_get_selections, METH_NOARGS,
      NULL },
    { "set_select_multiple", (PyCFunction)_wrap_gtk_file_selection_set_select_multiple, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_select_multiple", (PyCFunction)_wrap_gtk_file_selection_get_select_multiple, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_file_selection__get_dir_list(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->dir_list;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_file_list(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->file_list;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_selection_entry(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->selection_entry;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_selection_text(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->selection_text;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_main_vbox(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->main_vbox;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_ok_button(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->ok_button;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_cancel_button(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->cancel_button;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_help_button(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->help_button;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_history_pulldown(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->history_pulldown;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_history_menu(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->history_menu;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_fileop_dialog(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->fileop_dialog;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_fileop_entry(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->fileop_entry;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_fileop_file(PyObject *self, void *closure)
{
    const gchar *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->fileop_file;
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_selection__get_fileop_c_dir(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->fileop_c_dir;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_fileop_del_file(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->fileop_del_file;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_fileop_ren_file(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->fileop_ren_file;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_button_area(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->button_area;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_selection__get_action_area(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FILE_SELECTION(pygobject_get(self))->action_area;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyGetSetDef gtk_file_selection_getsets[] = {
    { "dir_list", (getter)_wrap_gtk_file_selection__get_dir_list, (setter)0 },
    { "file_list", (getter)_wrap_gtk_file_selection__get_file_list, (setter)0 },
    { "selection_entry", (getter)_wrap_gtk_file_selection__get_selection_entry, (setter)0 },
    { "selection_text", (getter)_wrap_gtk_file_selection__get_selection_text, (setter)0 },
    { "main_vbox", (getter)_wrap_gtk_file_selection__get_main_vbox, (setter)0 },
    { "ok_button", (getter)_wrap_gtk_file_selection__get_ok_button, (setter)0 },
    { "cancel_button", (getter)_wrap_gtk_file_selection__get_cancel_button, (setter)0 },
    { "help_button", (getter)_wrap_gtk_file_selection__get_help_button, (setter)0 },
    { "history_pulldown", (getter)_wrap_gtk_file_selection__get_history_pulldown, (setter)0 },
    { "history_menu", (getter)_wrap_gtk_file_selection__get_history_menu, (setter)0 },
    { "fileop_dialog", (getter)_wrap_gtk_file_selection__get_fileop_dialog, (setter)0 },
    { "fileop_entry", (getter)_wrap_gtk_file_selection__get_fileop_entry, (setter)0 },
    { "fileop_file", (getter)_wrap_gtk_file_selection__get_fileop_file, (setter)0 },
    { "fileop_c_dir", (getter)_wrap_gtk_file_selection__get_fileop_c_dir, (setter)0 },
    { "fileop_del_file", (getter)_wrap_gtk_file_selection__get_fileop_del_file, (setter)0 },
    { "fileop_ren_file", (getter)_wrap_gtk_file_selection__get_fileop_ren_file, (setter)0 },
    { "button_area", (getter)_wrap_gtk_file_selection__get_button_area, (setter)0 },
    { "action_area", (getter)_wrap_gtk_file_selection__get_action_area, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkFileSelection_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.FileSelection",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkFileSelection_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_file_selection_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_file_selection_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkFixed ----------- */

 static int
_wrap_gtk_fixed_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Fixed.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Fixed object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_fixed_put(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "x", "y", NULL };
    PyGObject *widget;
    int x, y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.Fixed.put", kwlist, &PyGtkWidget_Type, &widget, &x, &y))
        return NULL;
    
    gtk_fixed_put(GTK_FIXED(self->obj), GTK_WIDGET(widget->obj), x, y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_fixed_move(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "x", "y", NULL };
    PyGObject *widget;
    int x, y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.Fixed.move", kwlist, &PyGtkWidget_Type, &widget, &x, &y))
        return NULL;
    
    gtk_fixed_move(GTK_FIXED(self->obj), GTK_WIDGET(widget->obj), x, y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_fixed_set_has_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "has_window", NULL };
    int has_window;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Fixed.set_has_window", kwlist, &has_window))
        return NULL;
    
    gtk_fixed_set_has_window(GTK_FIXED(self->obj), has_window);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_fixed_get_has_window(PyGObject *self)
{
    int ret;

    
    ret = gtk_fixed_get_has_window(GTK_FIXED(self->obj));
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkFixed_methods[] = {
    { "put", (PyCFunction)_wrap_gtk_fixed_put, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move", (PyCFunction)_wrap_gtk_fixed_move, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_has_window", (PyCFunction)_wrap_gtk_fixed_set_has_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_window", (PyCFunction)_wrap_gtk_fixed_get_has_window, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkFixed_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Fixed",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkFixed_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_fixed_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkFontButton ----------- */

#line 4915 "./gtk.override"
static int
_wrap_gtk_font_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fontname", NULL };
    gchar * fontname = NULL;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkFontButton.__init__",
				     kwlist, &fontname))
        return -1;

    if (fontname == NULL)
        pygobject_construct(self, NULL);
    else
        pygobject_construct(self, "font-name", fontname, NULL);
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkFontButton object");
        return -1;
    }
    return 0;
}
#line 48701 "gtk.c"


static PyObject *
_wrap_gtk_font_button_get_title(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_font_button_get_title(GTK_FONT_BUTTON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_button_set_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "title", NULL };
    char *title;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FontButton.set_title", kwlist, &title))
        return NULL;
    
    gtk_font_button_set_title(GTK_FONT_BUTTON(self->obj), title);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_button_get_use_font(PyGObject *self)
{
    int ret;

    
    ret = gtk_font_button_get_use_font(GTK_FONT_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_font_button_set_use_font(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_font", NULL };
    int use_font;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FontButton.set_use_font", kwlist, &use_font))
        return NULL;
    
    gtk_font_button_set_use_font(GTK_FONT_BUTTON(self->obj), use_font);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_button_get_use_size(PyGObject *self)
{
    int ret;

    
    ret = gtk_font_button_get_use_size(GTK_FONT_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_font_button_set_use_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_size", NULL };
    int use_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FontButton.set_use_size", kwlist, &use_size))
        return NULL;
    
    gtk_font_button_set_use_size(GTK_FONT_BUTTON(self->obj), use_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_button_get_font_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_font_button_get_font_name(GTK_FONT_BUTTON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_button_set_font_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fontname", NULL };
    char *fontname;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FontButton.set_font_name", kwlist, &fontname))
        return NULL;
    
    ret = gtk_font_button_set_font_name(GTK_FONT_BUTTON(self->obj), fontname);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_font_button_get_show_style(PyGObject *self)
{
    int ret;

    
    ret = gtk_font_button_get_show_style(GTK_FONT_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_font_button_set_show_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_style", NULL };
    int show_style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FontButton.set_show_style", kwlist, &show_style))
        return NULL;
    
    gtk_font_button_set_show_style(GTK_FONT_BUTTON(self->obj), show_style);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_button_get_show_size(PyGObject *self)
{
    int ret;

    
    ret = gtk_font_button_get_show_size(GTK_FONT_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_font_button_set_show_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_size", NULL };
    int show_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FontButton.set_show_size", kwlist, &show_size))
        return NULL;
    
    gtk_font_button_set_show_size(GTK_FONT_BUTTON(self->obj), show_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkFontButton__do_font_set(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.FontButton.font_set", kwlist, &PyGtkFontButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_FONT_BUTTON_CLASS(klass)->font_set)
        GTK_FONT_BUTTON_CLASS(klass)->font_set(GTK_FONT_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.FontButton.font_set not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkFontButton_methods[] = {
    { "get_title", (PyCFunction)_wrap_gtk_font_button_get_title, METH_NOARGS,
      NULL },
    { "set_title", (PyCFunction)_wrap_gtk_font_button_set_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_font", (PyCFunction)_wrap_gtk_font_button_get_use_font, METH_NOARGS,
      NULL },
    { "set_use_font", (PyCFunction)_wrap_gtk_font_button_set_use_font, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_size", (PyCFunction)_wrap_gtk_font_button_get_use_size, METH_NOARGS,
      NULL },
    { "set_use_size", (PyCFunction)_wrap_gtk_font_button_set_use_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_font_name", (PyCFunction)_wrap_gtk_font_button_get_font_name, METH_NOARGS,
      NULL },
    { "set_font_name", (PyCFunction)_wrap_gtk_font_button_set_font_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_style", (PyCFunction)_wrap_gtk_font_button_get_show_style, METH_NOARGS,
      NULL },
    { "set_show_style", (PyCFunction)_wrap_gtk_font_button_set_show_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_size", (PyCFunction)_wrap_gtk_font_button_get_show_size, METH_NOARGS,
      NULL },
    { "set_show_size", (PyCFunction)_wrap_gtk_font_button_set_show_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_font_set", (PyCFunction)_wrap_GtkFontButton__do_font_set, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkFontButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.FontButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkFontButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_font_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkFontButton__proxy_do_font_set(GtkFontButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_font_set");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkFontButton_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkFontButtonClass *klass = GTK_FONT_BUTTON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_font_set");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "font_set")))
            klass->font_set = _wrap_GtkFontButton__proxy_do_font_set;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkFontSelection ----------- */

static int
_wrap_gtk_font_selection_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.FontSelection.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.FontSelection object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_font_selection_get_font_name(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_font_selection_get_font_name(GTK_FONT_SELECTION(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_selection_get_font(PyGObject *self)
{
    GdkFont *ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkFontSelection.get_font_name") < 0)
        return NULL;
    
    ret = gtk_font_selection_get_font(GTK_FONT_SELECTION(self->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GDK_TYPE_FONT, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_font_selection_set_font_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fontname", NULL };
    char *fontname;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FontSelection.set_font_name", kwlist, &fontname))
        return NULL;
    
    ret = gtk_font_selection_set_font_name(GTK_FONT_SELECTION(self->obj), fontname);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_font_selection_get_preview_text(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_font_selection_get_preview_text(GTK_FONT_SELECTION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_selection_set_preview_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FontSelection.set_preview_text", kwlist, &text))
        return NULL;
    
    gtk_font_selection_set_preview_text(GTK_FONT_SELECTION(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_selection_get_family_list(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_font_selection_get_family_list(GTK_FONT_SELECTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_get_face_list(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_font_selection_get_face_list(GTK_FONT_SELECTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_get_size_entry(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_font_selection_get_size_entry(GTK_FONT_SELECTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_get_size_list(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_font_selection_get_size_list(GTK_FONT_SELECTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_get_preview_entry(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_font_selection_get_preview_entry(GTK_FONT_SELECTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_get_family(PyGObject *self)
{
    PangoFontFamily *ret;

    
    ret = gtk_font_selection_get_family(GTK_FONT_SELECTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_get_face(PyGObject *self)
{
    PangoFontFace *ret;

    
    ret = gtk_font_selection_get_face(GTK_FONT_SELECTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_get_size(PyGObject *self)
{
    int ret;

    
    ret = gtk_font_selection_get_size(GTK_FONT_SELECTION(self->obj));
    
    return PyInt_FromLong(ret);
}

static const PyMethodDef _PyGtkFontSelection_methods[] = {
    { "get_font_name", (PyCFunction)_wrap_gtk_font_selection_get_font_name, METH_NOARGS,
      NULL },
    { "get_font", (PyCFunction)_wrap_gtk_font_selection_get_font, METH_NOARGS,
      NULL },
    { "set_font_name", (PyCFunction)_wrap_gtk_font_selection_set_font_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_preview_text", (PyCFunction)_wrap_gtk_font_selection_get_preview_text, METH_NOARGS,
      NULL },
    { "set_preview_text", (PyCFunction)_wrap_gtk_font_selection_set_preview_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_family_list", (PyCFunction)_wrap_gtk_font_selection_get_family_list, METH_NOARGS,
      NULL },
    { "get_face_list", (PyCFunction)_wrap_gtk_font_selection_get_face_list, METH_NOARGS,
      NULL },
    { "get_size_entry", (PyCFunction)_wrap_gtk_font_selection_get_size_entry, METH_NOARGS,
      NULL },
    { "get_size_list", (PyCFunction)_wrap_gtk_font_selection_get_size_list, METH_NOARGS,
      NULL },
    { "get_preview_entry", (PyCFunction)_wrap_gtk_font_selection_get_preview_entry, METH_NOARGS,
      NULL },
    { "get_family", (PyCFunction)_wrap_gtk_font_selection_get_family, METH_NOARGS,
      NULL },
    { "get_face", (PyCFunction)_wrap_gtk_font_selection_get_face, METH_NOARGS,
      NULL },
    { "get_size", (PyCFunction)_wrap_gtk_font_selection_get_size, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkFontSelection_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.FontSelection",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkFontSelection_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_font_selection_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkFontSelectionDialog ----------- */

static int
_wrap_gtk_font_selection_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"title", NULL };
    char *prop_names[] = {"title", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:gtk.FontSelectionDialog.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.FontSelectionDialog object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_font_selection_dialog_get_font_name(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_font_selection_dialog_get_font_name(GTK_FONT_SELECTION_DIALOG(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_selection_dialog_get_font(PyGObject *self)
{
    GdkFont *ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkFontSelectionDialog.get_font_name") < 0)
        return NULL;
    
    ret = gtk_font_selection_dialog_get_font(GTK_FONT_SELECTION_DIALOG(self->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GDK_TYPE_FONT, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_font_selection_dialog_set_font_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fontname", NULL };
    char *fontname;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FontSelectionDialog.set_font_name", kwlist, &fontname))
        return NULL;
    
    ret = gtk_font_selection_dialog_set_font_name(GTK_FONT_SELECTION_DIALOG(self->obj), fontname);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_font_selection_dialog_get_preview_text(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_font_selection_dialog_get_preview_text(GTK_FONT_SELECTION_DIALOG(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_selection_dialog_set_preview_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FontSelectionDialog.set_preview_text", kwlist, &text))
        return NULL;
    
    gtk_font_selection_dialog_set_preview_text(GTK_FONT_SELECTION_DIALOG(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_font_selection_dialog_get_ok_button(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_font_selection_dialog_get_ok_button(GTK_FONT_SELECTION_DIALOG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_dialog_get_apply_button(PyGObject *self)
{
    GtkWidget *ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this method") < 0)
        return NULL;
    
    ret = gtk_font_selection_dialog_get_apply_button(GTK_FONT_SELECTION_DIALOG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_dialog_get_cancel_button(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_font_selection_dialog_get_cancel_button(GTK_FONT_SELECTION_DIALOG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_dialog_get_font_selection(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_font_selection_dialog_get_font_selection(GTK_FONT_SELECTION_DIALOG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkFontSelectionDialog_methods[] = {
    { "get_font_name", (PyCFunction)_wrap_gtk_font_selection_dialog_get_font_name, METH_NOARGS,
      NULL },
    { "get_font", (PyCFunction)_wrap_gtk_font_selection_dialog_get_font, METH_NOARGS,
      NULL },
    { "set_font_name", (PyCFunction)_wrap_gtk_font_selection_dialog_set_font_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_preview_text", (PyCFunction)_wrap_gtk_font_selection_dialog_get_preview_text, METH_NOARGS,
      NULL },
    { "set_preview_text", (PyCFunction)_wrap_gtk_font_selection_dialog_set_preview_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_ok_button", (PyCFunction)_wrap_gtk_font_selection_dialog_get_ok_button, METH_NOARGS,
      NULL },
    { "get_apply_button", (PyCFunction)_wrap_gtk_font_selection_dialog_get_apply_button, METH_NOARGS,
      NULL },
    { "get_cancel_button", (PyCFunction)_wrap_gtk_font_selection_dialog_get_cancel_button, METH_NOARGS,
      NULL },
    { "get_font_selection", (PyCFunction)_wrap_gtk_font_selection_dialog_get_font_selection, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_font_selection_dialog__get_fontsel(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FONT_SELECTION_DIALOG(pygobject_get(self))->fontsel;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_dialog__get_main_vbox(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FONT_SELECTION_DIALOG(pygobject_get(self))->main_vbox;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_dialog__get_action_area(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FONT_SELECTION_DIALOG(pygobject_get(self))->action_area;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_dialog__get_ok_button(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FONT_SELECTION_DIALOG(pygobject_get(self))->ok_button;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_dialog__get_apply_button(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FONT_SELECTION_DIALOG(pygobject_get(self))->apply_button;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_font_selection_dialog__get_cancel_button(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_FONT_SELECTION_DIALOG(pygobject_get(self))->cancel_button;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyGetSetDef gtk_font_selection_dialog_getsets[] = {
    { "fontsel", (getter)_wrap_gtk_font_selection_dialog__get_fontsel, (setter)0 },
    { "main_vbox", (getter)_wrap_gtk_font_selection_dialog__get_main_vbox, (setter)0 },
    { "action_area", (getter)_wrap_gtk_font_selection_dialog__get_action_area, (setter)0 },
    { "ok_button", (getter)_wrap_gtk_font_selection_dialog__get_ok_button, (setter)0 },
    { "apply_button", (getter)_wrap_gtk_font_selection_dialog__get_apply_button, (setter)0 },
    { "cancel_button", (getter)_wrap_gtk_font_selection_dialog__get_cancel_button, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkFontSelectionDialog_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.FontSelectionDialog",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkFontSelectionDialog_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_font_selection_dialog_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_font_selection_dialog_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkGammaCurve ----------- */

 static int
_wrap_gtk_gamma_curve_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.GammaCurve.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.GammaCurve object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_gamma_curve__get_table(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_GAMMA_CURVE(pygobject_get(self))->table;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_gamma_curve__get_curve(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_GAMMA_CURVE(pygobject_get(self))->curve;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_gamma_curve__get_gamma(PyObject *self, void *closure)
{
    double ret;

    ret = GTK_GAMMA_CURVE(pygobject_get(self))->gamma;
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_gamma_curve__get_gamma_dialog(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_GAMMA_CURVE(pygobject_get(self))->gamma_dialog;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_gamma_curve__get_gamma_text(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_GAMMA_CURVE(pygobject_get(self))->gamma_text;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyGetSetDef gtk_gamma_curve_getsets[] = {
    { "table", (getter)_wrap_gtk_gamma_curve__get_table, (setter)0 },
    { "curve", (getter)_wrap_gtk_gamma_curve__get_curve, (setter)0 },
    { "gamma", (getter)_wrap_gtk_gamma_curve__get_gamma, (setter)0 },
    { "gamma_dialog", (getter)_wrap_gtk_gamma_curve__get_gamma_dialog, (setter)0 },
    { "gamma_text", (getter)_wrap_gtk_gamma_curve__get_gamma_text, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkGammaCurve_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.GammaCurve",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_gamma_curve_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_gamma_curve_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkHandleBox ----------- */

static int
_wrap_gtk_handle_box_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.HandleBox.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.HandleBox object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_handle_box_set_shadow_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    PyObject *py_type = NULL;
    GtkShadowType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.HandleBox.set_shadow_type", kwlist, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_type, (gpointer)&type))
        return NULL;
    
    gtk_handle_box_set_shadow_type(GTK_HANDLE_BOX(self->obj), type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_handle_box_get_shadow_type(PyGObject *self)
{
    gint ret;

    
    ret = gtk_handle_box_get_shadow_type(GTK_HANDLE_BOX(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, ret);
}

static PyObject *
_wrap_gtk_handle_box_set_handle_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    PyObject *py_position = NULL;
    GtkPositionType position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.HandleBox.set_handle_position", kwlist, &py_position))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_position, (gpointer)&position))
        return NULL;
    
    gtk_handle_box_set_handle_position(GTK_HANDLE_BOX(self->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_handle_box_get_handle_position(PyGObject *self)
{
    gint ret;

    
    ret = gtk_handle_box_get_handle_position(GTK_HANDLE_BOX(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_POSITION_TYPE, ret);
}

static PyObject *
_wrap_gtk_handle_box_set_snap_edge(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "edge", NULL };
    PyObject *py_edge = NULL;
    GtkPositionType edge;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.HandleBox.set_snap_edge", kwlist, &py_edge))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_edge, (gpointer)&edge))
        return NULL;
    
    gtk_handle_box_set_snap_edge(GTK_HANDLE_BOX(self->obj), edge);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_handle_box_get_snap_edge(PyGObject *self)
{
    gint ret;

    
    ret = gtk_handle_box_get_snap_edge(GTK_HANDLE_BOX(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_POSITION_TYPE, ret);
}

static PyObject *
_wrap_gtk_handle_box_get_child_detached(PyGObject *self)
{
    int ret;

    
    ret = gtk_handle_box_get_child_detached(GTK_HANDLE_BOX(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkHandleBox__do_child_attached(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "child", NULL };
    PyGObject *self, *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.HandleBox.child_attached", kwlist, &PyGtkHandleBox_Type, &self, &PyGtkWidget_Type, &child))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_HANDLE_BOX_CLASS(klass)->child_attached)
        GTK_HANDLE_BOX_CLASS(klass)->child_attached(GTK_HANDLE_BOX(self->obj), GTK_WIDGET(child->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.HandleBox.child_attached not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkHandleBox__do_child_detached(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "child", NULL };
    PyGObject *self, *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.HandleBox.child_detached", kwlist, &PyGtkHandleBox_Type, &self, &PyGtkWidget_Type, &child))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_HANDLE_BOX_CLASS(klass)->child_detached)
        GTK_HANDLE_BOX_CLASS(klass)->child_detached(GTK_HANDLE_BOX(self->obj), GTK_WIDGET(child->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.HandleBox.child_detached not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkHandleBox_methods[] = {
    { "set_shadow_type", (PyCFunction)_wrap_gtk_handle_box_set_shadow_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_shadow_type", (PyCFunction)_wrap_gtk_handle_box_get_shadow_type, METH_NOARGS,
      NULL },
    { "set_handle_position", (PyCFunction)_wrap_gtk_handle_box_set_handle_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_handle_position", (PyCFunction)_wrap_gtk_handle_box_get_handle_position, METH_NOARGS,
      NULL },
    { "set_snap_edge", (PyCFunction)_wrap_gtk_handle_box_set_snap_edge, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_snap_edge", (PyCFunction)_wrap_gtk_handle_box_get_snap_edge, METH_NOARGS,
      NULL },
    { "get_child_detached", (PyCFunction)_wrap_gtk_handle_box_get_child_detached, METH_NOARGS,
      NULL },
    { "do_child_attached", (PyCFunction)_wrap_GtkHandleBox__do_child_attached, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_child_detached", (PyCFunction)_wrap_GtkHandleBox__do_child_detached, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkHandleBox_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.HandleBox",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkHandleBox_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_handle_box_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkHandleBox__proxy_do_child_attached(GtkHandleBox *self, GtkWidget*child)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_child = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (child)
        py_child = pygobject_new((GObject *) child);
    else {
        Py_INCREF(Py_None);
        py_child = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_child);
    
    py_method = PyObject_GetAttrString(py_self, "do_child_attached");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkHandleBox__proxy_do_child_detached(GtkHandleBox *self, GtkWidget*child)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_child = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (child)
        py_child = pygobject_new((GObject *) child);
    else {
        Py_INCREF(Py_None);
        py_child = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_child);
    
    py_method = PyObject_GetAttrString(py_self, "do_child_detached");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkHandleBox_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkHandleBoxClass *klass = GTK_HANDLE_BOX_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_child_attached");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "child_attached")))
            klass->child_attached = _wrap_GtkHandleBox__proxy_do_child_attached;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_child_detached");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "child_detached")))
            klass->child_detached = _wrap_GtkHandleBox__proxy_do_child_detached;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkHButtonBox ----------- */

static int
_wrap_gtk_hbutton_box_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.HButtonBox.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.HButtonBox object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkHButtonBox_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.HButtonBox",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_hbutton_box_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkPaned ----------- */

static PyObject *
_wrap_gtk_paned_add1(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Paned.add1", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    gtk_paned_add1(GTK_PANED(self->obj), GTK_WIDGET(child->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paned_add2(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Paned.add2", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    gtk_paned_add2(GTK_PANED(self->obj), GTK_WIDGET(child->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paned_pack1(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "resize", "shrink", NULL };
    PyGObject *child;
    int resize = FALSE, shrink = TRUE;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|ii:Gtk.Paned.pack1", kwlist, &PyGtkWidget_Type, &child, &resize, &shrink))
        return NULL;
    
    gtk_paned_pack1(GTK_PANED(self->obj), GTK_WIDGET(child->obj), resize, shrink);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paned_pack2(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "resize", "shrink", NULL };
    PyGObject *child;
    int resize = TRUE, shrink = TRUE;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|ii:Gtk.Paned.pack2", kwlist, &PyGtkWidget_Type, &child, &resize, &shrink))
        return NULL;
    
    gtk_paned_pack2(GTK_PANED(self->obj), GTK_WIDGET(child->obj), resize, shrink);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paned_get_position(PyGObject *self)
{
    int ret;

    
    ret = gtk_paned_get_position(GTK_PANED(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_paned_set_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Paned.set_position", kwlist, &position))
        return NULL;
    
    gtk_paned_set_position(GTK_PANED(self->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paned_get_child1(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_paned_get_child1(GTK_PANED(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_paned_get_child2(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_paned_get_child2(GTK_PANED(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_paned_compute_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "allocation", "child1_req", "child2_req", NULL };
    int allocation, child1_req, child2_req;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iii:Gtk.Paned.compute_position", kwlist, &allocation, &child1_req, &child2_req))
        return NULL;
    
    gtk_paned_compute_position(GTK_PANED(self->obj), allocation, child1_req, child2_req);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paned_get_handle_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_paned_get_handle_window(GTK_PANED(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkPaned__do_cycle_child_focus(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "reverse", NULL };
    PyGObject *self;
    int reverse, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Paned.cycle_child_focus", kwlist, &PyGtkPaned_Type, &self, &reverse))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PANED_CLASS(klass)->cycle_child_focus)
        ret = GTK_PANED_CLASS(klass)->cycle_child_focus(GTK_PANED(self->obj), reverse);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Paned.cycle_child_focus not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkPaned__do_toggle_handle_focus(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Paned.toggle_handle_focus", kwlist, &PyGtkPaned_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PANED_CLASS(klass)->toggle_handle_focus)
        ret = GTK_PANED_CLASS(klass)->toggle_handle_focus(GTK_PANED(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Paned.toggle_handle_focus not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkPaned__do_move_handle(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll", NULL };
    PyGObject *self;
    PyObject *py_scroll = NULL;
    int ret;
    GtkScrollType scroll;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Paned.move_handle", kwlist, &PyGtkPaned_Type, &self, &py_scroll))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll, (gpointer)&scroll))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PANED_CLASS(klass)->move_handle)
        ret = GTK_PANED_CLASS(klass)->move_handle(GTK_PANED(self->obj), scroll);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Paned.move_handle not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkPaned__do_cycle_handle_focus(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "reverse", NULL };
    PyGObject *self;
    int reverse, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Paned.cycle_handle_focus", kwlist, &PyGtkPaned_Type, &self, &reverse))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PANED_CLASS(klass)->cycle_handle_focus)
        ret = GTK_PANED_CLASS(klass)->cycle_handle_focus(GTK_PANED(self->obj), reverse);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Paned.cycle_handle_focus not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkPaned__do_accept_position(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Paned.accept_position", kwlist, &PyGtkPaned_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PANED_CLASS(klass)->accept_position)
        ret = GTK_PANED_CLASS(klass)->accept_position(GTK_PANED(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Paned.accept_position not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkPaned__do_cancel_position(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Paned.cancel_position", kwlist, &PyGtkPaned_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PANED_CLASS(klass)->cancel_position)
        ret = GTK_PANED_CLASS(klass)->cancel_position(GTK_PANED(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Paned.cancel_position not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkPaned_methods[] = {
    { "add1", (PyCFunction)_wrap_gtk_paned_add1, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add2", (PyCFunction)_wrap_gtk_paned_add2, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "pack1", (PyCFunction)_wrap_gtk_paned_pack1, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "pack2", (PyCFunction)_wrap_gtk_paned_pack2, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_position", (PyCFunction)_wrap_gtk_paned_get_position, METH_NOARGS,
      NULL },
    { "set_position", (PyCFunction)_wrap_gtk_paned_set_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_child1", (PyCFunction)_wrap_gtk_paned_get_child1, METH_NOARGS,
      NULL },
    { "get_child2", (PyCFunction)_wrap_gtk_paned_get_child2, METH_NOARGS,
      NULL },
    { "compute_position", (PyCFunction)_wrap_gtk_paned_compute_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_handle_window", (PyCFunction)_wrap_gtk_paned_get_handle_window, METH_NOARGS,
      NULL },
    { "do_cycle_child_focus", (PyCFunction)_wrap_GtkPaned__do_cycle_child_focus, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toggle_handle_focus", (PyCFunction)_wrap_GtkPaned__do_toggle_handle_focus, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_handle", (PyCFunction)_wrap_GtkPaned__do_move_handle, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_cycle_handle_focus", (PyCFunction)_wrap_GtkPaned__do_cycle_handle_focus, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_accept_position", (PyCFunction)_wrap_GtkPaned__do_accept_position, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_cancel_position", (PyCFunction)_wrap_GtkPaned__do_cancel_position, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkPaned_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Paned",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkPaned_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gboolean
_wrap_GtkPaned__proxy_do_cycle_child_focus(GtkPaned *self, gboolean reverse)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_reverse;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_reverse = reverse? Py_True : Py_False;
    
    py_args = PyTuple_New(1);
    Py_INCREF(py_reverse);
    PyTuple_SET_ITEM(py_args, 0, py_reverse);
    
    py_method = PyObject_GetAttrString(py_self, "do_cycle_child_focus");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkPaned__proxy_do_toggle_handle_focus(GtkPaned *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_handle_focus");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkPaned__proxy_do_move_handle(GtkPaned *self, GtkScrollType scroll)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_scroll = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll);
    if (!py_scroll) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_scroll);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_handle");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkPaned__proxy_do_cycle_handle_focus(GtkPaned *self, gboolean reverse)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_reverse;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_reverse = reverse? Py_True : Py_False;
    
    py_args = PyTuple_New(1);
    Py_INCREF(py_reverse);
    PyTuple_SET_ITEM(py_args, 0, py_reverse);
    
    py_method = PyObject_GetAttrString(py_self, "do_cycle_handle_focus");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkPaned__proxy_do_accept_position(GtkPaned *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_accept_position");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkPaned__proxy_do_cancel_position(GtkPaned *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_cancel_position");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkPaned_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkPanedClass *klass = GTK_PANED_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_cycle_child_focus");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "cycle_child_focus")))
            klass->cycle_child_focus = _wrap_GtkPaned__proxy_do_cycle_child_focus;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_handle_focus");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_handle_focus")))
            klass->toggle_handle_focus = _wrap_GtkPaned__proxy_do_toggle_handle_focus;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_handle");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_handle")))
            klass->move_handle = _wrap_GtkPaned__proxy_do_move_handle;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_cycle_handle_focus");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "cycle_handle_focus")))
            klass->cycle_handle_focus = _wrap_GtkPaned__proxy_do_cycle_handle_focus;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_accept_position");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "accept_position")))
            klass->accept_position = _wrap_GtkPaned__proxy_do_accept_position;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_cancel_position");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "cancel_position")))
            klass->cancel_position = _wrap_GtkPaned__proxy_do_cancel_position;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkHPaned ----------- */

static int
_wrap_gtk_hpaned_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.HPaned.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.HPaned object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkHPaned_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.HPaned",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_hpaned_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkRuler ----------- */

static PyObject *
_wrap_gtk_ruler_set_metric(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "metric", NULL };
    PyObject *py_metric = NULL;
    GtkMetricType metric;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Ruler.set_metric", kwlist, &py_metric))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_METRIC_TYPE, py_metric, (gpointer)&metric))
        return NULL;
    
    gtk_ruler_set_metric(GTK_RULER(self->obj), metric);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ruler_set_range(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "lower", "upper", "position", "max_size", NULL };
    double lower, upper, position, max_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dddd:Gtk.Ruler.set_range", kwlist, &lower, &upper, &position, &max_size))
        return NULL;
    
    gtk_ruler_set_range(GTK_RULER(self->obj), lower, upper, position, max_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ruler_draw_ticks(PyGObject *self)
{
    
    gtk_ruler_draw_ticks(GTK_RULER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ruler_draw_pos(PyGObject *self)
{
    
    gtk_ruler_draw_pos(GTK_RULER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ruler_get_metric(PyGObject *self)
{
    gint ret;

    
    ret = gtk_ruler_get_metric(GTK_RULER(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_METRIC_TYPE, ret);
}

#line 3138 "./gtk.override"
static PyObject *
_wrap_gtk_ruler_get_range(PyGObject *self)
{
    gdouble lower, upper, position, max_size;

    gtk_ruler_get_range(GTK_RULER(self->obj), &lower, &upper, &position,
                        &max_size);
    return Py_BuildValue("(dddd)", lower, upper, position, max_size);
}
#line 51163 "gtk.c"


static PyObject *
_wrap_GtkRuler__do_draw_ticks(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Ruler.draw_ticks", kwlist, &PyGtkRuler_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RULER_CLASS(klass)->draw_ticks)
        GTK_RULER_CLASS(klass)->draw_ticks(GTK_RULER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Ruler.draw_ticks not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRuler__do_draw_pos(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Ruler.draw_pos", kwlist, &PyGtkRuler_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RULER_CLASS(klass)->draw_pos)
        GTK_RULER_CLASS(klass)->draw_pos(GTK_RULER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Ruler.draw_pos not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkRuler_methods[] = {
    { "set_metric", (PyCFunction)_wrap_gtk_ruler_set_metric, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_range", (PyCFunction)_wrap_gtk_ruler_set_range, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "draw_ticks", (PyCFunction)_wrap_gtk_ruler_draw_ticks, METH_NOARGS,
      NULL },
    { "draw_pos", (PyCFunction)_wrap_gtk_ruler_draw_pos, METH_NOARGS,
      NULL },
    { "get_metric", (PyCFunction)_wrap_gtk_ruler_get_metric, METH_NOARGS,
      NULL },
    { "get_range", (PyCFunction)_wrap_gtk_ruler_get_range, METH_NOARGS,
      NULL },
    { "do_draw_ticks", (PyCFunction)_wrap_GtkRuler__do_draw_ticks, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_pos", (PyCFunction)_wrap_GtkRuler__do_draw_pos, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRuler_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Ruler",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRuler_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkRuler__proxy_do_draw_ticks(GtkRuler *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_ticks");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkRuler__proxy_do_draw_pos(GtkRuler *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_pos");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkRuler_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkRulerClass *klass = GTK_RULER_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_ticks");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_ticks")))
            klass->draw_ticks = _wrap_GtkRuler__proxy_do_draw_ticks;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_pos");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_pos")))
            klass->draw_pos = _wrap_GtkRuler__proxy_do_draw_pos;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkHRuler ----------- */

static int
_wrap_gtk_hruler_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.HRuler.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.HRuler object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkHRuler_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.HRuler",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_hruler_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkRange ----------- */

static PyObject *
_wrap_gtk_range_set_update_policy(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "policy", NULL };
    PyObject *py_policy = NULL;
    GtkUpdateType policy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Range.set_update_policy", kwlist, &py_policy))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UPDATE_TYPE, py_policy, (gpointer)&policy))
        return NULL;
    
    gtk_range_set_update_policy(GTK_RANGE(self->obj), policy);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_update_policy(PyGObject *self)
{
    gint ret;

    
    ret = gtk_range_get_update_policy(GTK_RANGE(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_UPDATE_TYPE, ret);
}

static PyObject *
_wrap_gtk_range_set_adjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *adjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Range.set_adjustment", kwlist, &PyGtkAdjustment_Type, &adjustment))
        return NULL;
    
    gtk_range_set_adjustment(GTK_RANGE(self->obj), GTK_ADJUSTMENT(adjustment->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_adjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_range_get_adjustment(GTK_RANGE(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_range_set_inverted(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Range.set_inverted", kwlist, &setting))
        return NULL;
    
    gtk_range_set_inverted(GTK_RANGE(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_inverted(PyGObject *self)
{
    int ret;

    
    ret = gtk_range_get_inverted(GTK_RANGE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_range_set_increments(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "step", "page", NULL };
    double step, page;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dd:Gtk.Range.set_increments", kwlist, &step, &page))
        return NULL;
    
    gtk_range_set_increments(GTK_RANGE(self->obj), step, page);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_set_range(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "min", "max", NULL };
    double min, max;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dd:Gtk.Range.set_range", kwlist, &min, &max))
        return NULL;
    
    gtk_range_set_range(GTK_RANGE(self->obj), min, max);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_set_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    double value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Range.set_value", kwlist, &value))
        return NULL;
    
    gtk_range_set_value(GTK_RANGE(self->obj), value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_value(PyGObject *self)
{
    double ret;

    
    ret = gtk_range_get_value(GTK_RANGE(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_range_set_lower_stepper_sensitivity(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sensitivity", NULL };
    PyObject *py_sensitivity = NULL;
    GtkSensitivityType sensitivity;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Range.set_lower_stepper_sensitivity", kwlist, &py_sensitivity))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SENSITIVITY_TYPE, py_sensitivity, (gpointer)&sensitivity))
        return NULL;
    
    gtk_range_set_lower_stepper_sensitivity(GTK_RANGE(self->obj), sensitivity);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_lower_stepper_sensitivity(PyGObject *self)
{
    gint ret;

    
    ret = gtk_range_get_lower_stepper_sensitivity(GTK_RANGE(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SENSITIVITY_TYPE, ret);
}

static PyObject *
_wrap_gtk_range_set_upper_stepper_sensitivity(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sensitivity", NULL };
    PyObject *py_sensitivity = NULL;
    GtkSensitivityType sensitivity;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Range.set_upper_stepper_sensitivity", kwlist, &py_sensitivity))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SENSITIVITY_TYPE, py_sensitivity, (gpointer)&sensitivity))
        return NULL;
    
    gtk_range_set_upper_stepper_sensitivity(GTK_RANGE(self->obj), sensitivity);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_upper_stepper_sensitivity(PyGObject *self)
{
    gint ret;

    
    ret = gtk_range_get_upper_stepper_sensitivity(GTK_RANGE(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SENSITIVITY_TYPE, ret);
}

static PyObject *
_wrap_gtk_range_set_show_fill_level(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_fill_level", NULL };
    int show_fill_level;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Range.set_show_fill_level", kwlist, &show_fill_level))
        return NULL;
    
    gtk_range_set_show_fill_level(GTK_RANGE(self->obj), show_fill_level);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_show_fill_level(PyGObject *self)
{
    int ret;

    
    ret = gtk_range_get_show_fill_level(GTK_RANGE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_range_set_restrict_to_fill_level(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "restrict_to_fill_level", NULL };
    int restrict_to_fill_level;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Range.set_restrict_to_fill_level", kwlist, &restrict_to_fill_level))
        return NULL;
    
    gtk_range_set_restrict_to_fill_level(GTK_RANGE(self->obj), restrict_to_fill_level);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_restrict_to_fill_level(PyGObject *self)
{
    int ret;

    
    ret = gtk_range_get_restrict_to_fill_level(GTK_RANGE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_range_set_fill_level(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fill_level", NULL };
    double fill_level;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Range.set_fill_level", kwlist, &fill_level))
        return NULL;
    
    gtk_range_set_fill_level(GTK_RANGE(self->obj), fill_level);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_fill_level(PyGObject *self)
{
    double ret;

    
    ret = gtk_range_get_fill_level(GTK_RANGE(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_range_set_flippable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flippable", NULL };
    int flippable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Range.set_flippable", kwlist, &flippable))
        return NULL;
    
    gtk_range_set_flippable(GTK_RANGE(self->obj), flippable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_flippable(PyGObject *self)
{
    int ret;

    
    ret = gtk_range_get_flippable(GTK_RANGE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_range_get_min_slider_size(PyGObject *self)
{
    int ret;

    
    ret = gtk_range_get_min_slider_size(GTK_RANGE(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_range_get_range_rect(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "range_rect", NULL };
    PyObject *py_range_rect;
    GdkRectangle range_rect = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Range.get_range_rect", kwlist, &py_range_rect))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_range_rect, &range_rect))
        return NULL;
    
    gtk_range_get_range_rect(GTK_RANGE(self->obj), &range_rect);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_slider_size_fixed(PyGObject *self)
{
    int ret;

    
    ret = gtk_range_get_slider_size_fixed(GTK_RANGE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_range_set_min_slider_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "min_size", NULL };
    int min_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Range.set_min_slider_size", kwlist, &min_size))
        return NULL;
    
    gtk_range_set_min_slider_size(GTK_RANGE(self->obj), min_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_set_slider_size_fixed(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "size_fixed", NULL };
    int size_fixed;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Range.set_slider_size_fixed", kwlist, &size_fixed))
        return NULL;
    
    gtk_range_set_slider_size_fixed(GTK_RANGE(self->obj), size_fixed);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_set_round_digits(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "round_digits", NULL };
    int round_digits;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Range.set_round_digits", kwlist, &round_digits))
        return NULL;
    
    gtk_range_set_round_digits(GTK_RANGE(self->obj), round_digits);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_range_get_round_digits(PyGObject *self)
{
    int ret;

    
    ret = gtk_range_get_round_digits(GTK_RANGE(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_GtkRange__do_value_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Range.value_changed", kwlist, &PyGtkRange_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RANGE_CLASS(klass)->value_changed)
        GTK_RANGE_CLASS(klass)->value_changed(GTK_RANGE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Range.value_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRange__do_adjust_bounds(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "new_value", NULL };
    PyGObject *self;
    double new_value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!d:Gtk.Range.adjust_bounds", kwlist, &PyGtkRange_Type, &self, &new_value))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RANGE_CLASS(klass)->adjust_bounds)
        GTK_RANGE_CLASS(klass)->adjust_bounds(GTK_RANGE(self->obj), new_value);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Range.adjust_bounds not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRange__do_move_slider(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll", NULL };
    PyGObject *self;
    PyObject *py_scroll = NULL;
    GtkScrollType scroll;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Range.move_slider", kwlist, &PyGtkRange_Type, &self, &py_scroll))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll, (gpointer)&scroll))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RANGE_CLASS(klass)->move_slider)
        GTK_RANGE_CLASS(klass)->move_slider(GTK_RANGE(self->obj), scroll);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Range.move_slider not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRange__do_get_range_border(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "border_", NULL };
    PyGObject *self;
    PyObject *py_border_;
    GtkBorder *border_ = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Range.get_range_border", kwlist, &PyGtkRange_Type, &self, &py_border_))
        return NULL;
    if (pyg_boxed_check(py_border_, GTK_TYPE_BORDER))
        border_ = pyg_boxed_get(py_border_, GtkBorder);
    else {
        PyErr_SetString(PyExc_TypeError, "border_ should be a GtkBorder");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RANGE_CLASS(klass)->get_range_border)
        GTK_RANGE_CLASS(klass)->get_range_border(GTK_RANGE(self->obj), border_);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Range.get_range_border not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRange__do_change_value(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll", "new_value", NULL };
    PyGObject *self;
    PyObject *py_scroll = NULL;
    int ret;
    GtkScrollType scroll;
    double new_value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Od:Gtk.Range.change_value", kwlist, &PyGtkRange_Type, &self, &py_scroll, &new_value))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll, (gpointer)&scroll))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RANGE_CLASS(klass)->change_value)
        ret = GTK_RANGE_CLASS(klass)->change_value(GTK_RANGE(self->obj), scroll, new_value);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Range.change_value not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkRange_methods[] = {
    { "set_update_policy", (PyCFunction)_wrap_gtk_range_set_update_policy, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_update_policy", (PyCFunction)_wrap_gtk_range_get_update_policy, METH_NOARGS,
      NULL },
    { "set_adjustment", (PyCFunction)_wrap_gtk_range_set_adjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_adjustment", (PyCFunction)_wrap_gtk_range_get_adjustment, METH_NOARGS,
      NULL },
    { "set_inverted", (PyCFunction)_wrap_gtk_range_set_inverted, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_inverted", (PyCFunction)_wrap_gtk_range_get_inverted, METH_NOARGS,
      NULL },
    { "set_increments", (PyCFunction)_wrap_gtk_range_set_increments, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_range", (PyCFunction)_wrap_gtk_range_set_range, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_value", (PyCFunction)_wrap_gtk_range_set_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_value", (PyCFunction)_wrap_gtk_range_get_value, METH_NOARGS,
      NULL },
    { "set_lower_stepper_sensitivity", (PyCFunction)_wrap_gtk_range_set_lower_stepper_sensitivity, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_lower_stepper_sensitivity", (PyCFunction)_wrap_gtk_range_get_lower_stepper_sensitivity, METH_NOARGS,
      NULL },
    { "set_upper_stepper_sensitivity", (PyCFunction)_wrap_gtk_range_set_upper_stepper_sensitivity, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_upper_stepper_sensitivity", (PyCFunction)_wrap_gtk_range_get_upper_stepper_sensitivity, METH_NOARGS,
      NULL },
    { "set_show_fill_level", (PyCFunction)_wrap_gtk_range_set_show_fill_level, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_fill_level", (PyCFunction)_wrap_gtk_range_get_show_fill_level, METH_NOARGS,
      NULL },
    { "set_restrict_to_fill_level", (PyCFunction)_wrap_gtk_range_set_restrict_to_fill_level, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_restrict_to_fill_level", (PyCFunction)_wrap_gtk_range_get_restrict_to_fill_level, METH_NOARGS,
      NULL },
    { "set_fill_level", (PyCFunction)_wrap_gtk_range_set_fill_level, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_fill_level", (PyCFunction)_wrap_gtk_range_get_fill_level, METH_NOARGS,
      NULL },
    { "set_flippable", (PyCFunction)_wrap_gtk_range_set_flippable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_flippable", (PyCFunction)_wrap_gtk_range_get_flippable, METH_NOARGS,
      NULL },
    { "get_min_slider_size", (PyCFunction)_wrap_gtk_range_get_min_slider_size, METH_NOARGS,
      NULL },
    { "get_range_rect", (PyCFunction)_wrap_gtk_range_get_range_rect, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_slider_size_fixed", (PyCFunction)_wrap_gtk_range_get_slider_size_fixed, METH_NOARGS,
      NULL },
    { "set_min_slider_size", (PyCFunction)_wrap_gtk_range_set_min_slider_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_slider_size_fixed", (PyCFunction)_wrap_gtk_range_set_slider_size_fixed, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_round_digits", (PyCFunction)_wrap_gtk_range_set_round_digits, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_round_digits", (PyCFunction)_wrap_gtk_range_get_round_digits, METH_NOARGS,
      NULL },
    { "do_value_changed", (PyCFunction)_wrap_GtkRange__do_value_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_adjust_bounds", (PyCFunction)_wrap_GtkRange__do_adjust_bounds, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_slider", (PyCFunction)_wrap_GtkRange__do_move_slider, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_range_border", (PyCFunction)_wrap_GtkRange__do_get_range_border, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_change_value", (PyCFunction)_wrap_GtkRange__do_change_value, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRange_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Range",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRange_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkRange__proxy_do_value_changed(GtkRange *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_value_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkRange__proxy_do_adjust_bounds(GtkRange *self, gdouble new_value)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_new_value;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_new_value = PyFloat_FromDouble(new_value);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_new_value);
    
    py_method = PyObject_GetAttrString(py_self, "do_adjust_bounds");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkRange__proxy_do_move_slider(GtkRange *self, GtkScrollType scroll)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_scroll = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll);
    if (!py_scroll) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_scroll);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_slider");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkRange__proxy_do_get_range_border(GtkRange *self, GtkBorder*border_)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_border_;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_border_ = pyg_boxed_new(GTK_TYPE_BORDER, border_, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_border_);
    
    py_method = PyObject_GetAttrString(py_self, "do_get_range_border");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkRange__proxy_do_change_value(GtkRange *self, GtkScrollType scroll, gdouble new_value)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll;
    PyObject *py_new_value;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_scroll = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll);
    if (!py_scroll) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_new_value = PyFloat_FromDouble(new_value);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_scroll);
    PyTuple_SET_ITEM(py_args, 1, py_new_value);
    
    py_method = PyObject_GetAttrString(py_self, "do_change_value");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkRange_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkRangeClass *klass = GTK_RANGE_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_value_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "value_changed")))
            klass->value_changed = _wrap_GtkRange__proxy_do_value_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_adjust_bounds");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "adjust_bounds")))
            klass->adjust_bounds = _wrap_GtkRange__proxy_do_adjust_bounds;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_slider");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_slider")))
            klass->move_slider = _wrap_GtkRange__proxy_do_move_slider;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_get_range_border");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "get_range_border")))
            klass->get_range_border = _wrap_GtkRange__proxy_do_get_range_border;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_change_value");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "change_value")))
            klass->change_value = _wrap_GtkRange__proxy_do_change_value;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkScale ----------- */

static PyObject *
_wrap_gtk_scale_set_digits(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "digits", NULL };
    int digits;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Scale.set_digits", kwlist, &digits))
        return NULL;
    
    gtk_scale_set_digits(GTK_SCALE(self->obj), digits);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scale_get_digits(PyGObject *self)
{
    int ret;

    
    ret = gtk_scale_get_digits(GTK_SCALE(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_scale_set_draw_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "draw_value", NULL };
    int draw_value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Scale.set_draw_value", kwlist, &draw_value))
        return NULL;
    
    gtk_scale_set_draw_value(GTK_SCALE(self->obj), draw_value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scale_get_draw_value(PyGObject *self)
{
    int ret;

    
    ret = gtk_scale_get_draw_value(GTK_SCALE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_scale_set_value_pos(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pos", NULL };
    PyObject *py_pos = NULL;
    GtkPositionType pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Scale.set_value_pos", kwlist, &py_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_pos, (gpointer)&pos))
        return NULL;
    
    gtk_scale_set_value_pos(GTK_SCALE(self->obj), pos);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scale_get_value_pos(PyGObject *self)
{
    gint ret;

    
    ret = gtk_scale_get_value_pos(GTK_SCALE(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_POSITION_TYPE, ret);
}

static PyObject *
_wrap_gtk_scale_get_layout(PyGObject *self)
{
    PangoLayout *ret;

    
    ret = gtk_scale_get_layout(GTK_SCALE(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 5400 "./gtk.override"
static PyObject *
_wrap_gtk_scale_get_layout_offsets(PyGObject *self)
{
    gint x = 0, y = 0;

    gtk_scale_get_layout_offsets(GTK_SCALE(self->obj), &x, &y);

    return Py_BuildValue("(ii)", x, y);
}
#line 52614 "gtk.c"


static PyObject *
_wrap_gtk_scale_add_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", "position", "markup", NULL };
    PyObject *py_position = NULL;
    double value;
    char *markup;
    GtkPositionType position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dOz:Gtk.Scale.add_mark", kwlist, &value, &py_position, &markup))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_position, (gpointer)&position))
        return NULL;
    
    gtk_scale_add_mark(GTK_SCALE(self->obj), value, position, markup);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scale_clear_marks(PyGObject *self)
{
    
    gtk_scale_clear_marks(GTK_SCALE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkScale__do_format_value(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "value", NULL };
    PyGObject *self;
    double value;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!d:Gtk.Scale.format_value", kwlist, &PyGtkScale_Type, &self, &value))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_SCALE_CLASS(klass)->format_value)
        ret = GTK_SCALE_CLASS(klass)->format_value(GTK_SCALE(self->obj), value);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Scale.format_value not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkScale__do_draw_value(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Scale.draw_value", kwlist, &PyGtkScale_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_SCALE_CLASS(klass)->draw_value)
        GTK_SCALE_CLASS(klass)->draw_value(GTK_SCALE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Scale.draw_value not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkScale_methods[] = {
    { "set_digits", (PyCFunction)_wrap_gtk_scale_set_digits, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_digits", (PyCFunction)_wrap_gtk_scale_get_digits, METH_NOARGS,
      NULL },
    { "set_draw_value", (PyCFunction)_wrap_gtk_scale_set_draw_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_draw_value", (PyCFunction)_wrap_gtk_scale_get_draw_value, METH_NOARGS,
      NULL },
    { "set_value_pos", (PyCFunction)_wrap_gtk_scale_set_value_pos, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_value_pos", (PyCFunction)_wrap_gtk_scale_get_value_pos, METH_NOARGS,
      NULL },
    { "get_layout", (PyCFunction)_wrap_gtk_scale_get_layout, METH_NOARGS,
      NULL },
    { "get_layout_offsets", (PyCFunction)_wrap_gtk_scale_get_layout_offsets, METH_NOARGS,
      NULL },
    { "add_mark", (PyCFunction)_wrap_gtk_scale_add_mark, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "clear_marks", (PyCFunction)_wrap_gtk_scale_clear_marks, METH_NOARGS,
      NULL },
    { "do_format_value", (PyCFunction)_wrap_GtkScale__do_format_value, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_value", (PyCFunction)_wrap_GtkScale__do_draw_value, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkScale_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Scale",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkScale_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gchar*
_wrap_GtkScale__proxy_do_format_value(GtkScale *self, gdouble value)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_value;
    gchar* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_value = PyFloat_FromDouble(value);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_value);
    
    py_method = PyObject_GetAttrString(py_self, "do_format_value");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "s", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    retval = g_strdup(retval);
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkScale__proxy_do_draw_value(GtkScale *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_value");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkScale_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkScaleClass *klass = GTK_SCALE_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_format_value");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "format_value")))
            klass->format_value = _wrap_GtkScale__proxy_do_format_value;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_value");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_value")))
            klass->draw_value = _wrap_GtkScale__proxy_do_draw_value;
        Py_DECREF(o);
    }

    /* overriding do_get_layout_offsets is currently not supported */
    return 0;
}


/* ----------- GtkHScale ----------- */

static int
_wrap_gtk_hscale_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"adjustment", NULL };
    char *prop_names[] = {"adjustment", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.HScale.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.HScale object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkHScale_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.HScale",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_hscale_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkScrollbar ----------- */

PyTypeObject G_GNUC_INTERNAL PyGtkScrollbar_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Scrollbar",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkHScrollbar ----------- */

 static int
_wrap_gtk_hscrollbar_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"adjustment", NULL };
    char *prop_names[] = {"adjustment", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.HScrollbar.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.HScrollbar object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkHScrollbar_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.HScrollbar",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_hscrollbar_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkSeparator ----------- */

PyTypeObject G_GNUC_INTERNAL PyGtkSeparator_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Separator",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkHSeparator ----------- */

 static int
_wrap_gtk_hseparator_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.HSeparator.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.HSeparator object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkHSeparator_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.HSeparator",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_hseparator_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkIconFactory ----------- */

static int
_wrap_gtk_icon_factory_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.IconFactory.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.IconFactory object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_icon_factory_add(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "icon_set", NULL };
    char *stock_id;
    PyObject *py_icon_set;
    GtkIconSet *icon_set = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO:Gtk.IconFactory.add", kwlist, &stock_id, &py_icon_set))
        return NULL;
    if (pyg_boxed_check(py_icon_set, GTK_TYPE_ICON_SET))
        icon_set = pyg_boxed_get(py_icon_set, GtkIconSet);
    else {
        PyErr_SetString(PyExc_TypeError, "icon_set should be a GtkIconSet");
        return NULL;
    }
    
    gtk_icon_factory_add(GTK_ICON_FACTORY(self->obj), stock_id, icon_set);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_factory_lookup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", NULL };
    char *stock_id;
    GtkIconSet *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.IconFactory.lookup", kwlist, &stock_id))
        return NULL;
    
    ret = gtk_icon_factory_lookup(GTK_ICON_FACTORY(self->obj), stock_id);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_ICON_SET, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_icon_factory_add_default(PyGObject *self)
{
    
    gtk_icon_factory_add_default(GTK_ICON_FACTORY(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_factory_remove_default(PyGObject *self)
{
    
    gtk_icon_factory_remove_default(GTK_ICON_FACTORY(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkIconFactory_methods[] = {
    { "add", (PyCFunction)_wrap_gtk_icon_factory_add, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "lookup", (PyCFunction)_wrap_gtk_icon_factory_lookup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_default", (PyCFunction)_wrap_gtk_icon_factory_add_default, METH_NOARGS,
      NULL },
    { "remove_default", (PyCFunction)_wrap_gtk_icon_factory_remove_default, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkIconFactory_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.IconFactory",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkIconFactory_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_icon_factory_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkIconTheme ----------- */

static int
_wrap_gtk_icon_theme_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.IconTheme.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.IconTheme object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_icon_theme_set_screen(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *screen;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IconTheme.set_screen", kwlist, &PyGdkScreen_Type, &screen))
        return NULL;
    
    gtk_icon_theme_set_screen(GTK_ICON_THEME(self->obj), GDK_SCREEN(screen->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 5201 "./gtk.override"
static PyObject *
_wrap_gtk_icon_theme_set_search_path(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    int i, len;
    PyObject *py_seq;
    gchar **paths;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,
				     "O:GtkIconTheme.set_search_path",
                                     kwlist, &py_seq))
        return NULL;

    if (!PySequence_Check(py_seq) || (len = PySequence_Size(py_seq)) < 0) {
	PyErr_SetString(PyExc_ValueError,
			"path should be a sequence of strings");
	return NULL;
    }

    paths = g_new(gchar *, len);
    for (i = 0; i < len; i++) {
	PyObject *py_path = PySequence_GetItem(py_seq, i);
	if (!PyString_Check(py_path)) {
	    PyErr_SetString(PyExc_ValueError, "path items must be strings");
	    Py_DECREF(py_path);
	    g_free(paths);
	    return NULL;
	}
	paths[i] = PyString_AsString(py_path);
	Py_DECREF(py_path);
    }

    gtk_icon_theme_set_search_path(GTK_ICON_THEME(self->obj),
				   (const gchar **)paths, len);

    g_free(paths);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 53465 "gtk.c"


#line 5243 "./gtk.override"
static PyObject *
_wrap_gtk_icon_theme_get_search_path(PyGObject *self)
{
    gchar **paths;
    gint n_items;
    PyObject *py_tuple;
    int i;

    gtk_icon_theme_get_search_path(GTK_ICON_THEME(self->obj),
				   &paths, &n_items);

    py_tuple = PyTuple_New(n_items);
    for (i = 0; i < n_items; i++)
	PyTuple_SetItem(py_tuple, i, PyString_FromString(paths[i]));

    g_strfreev(paths);

    return py_tuple;
}
#line 53488 "gtk.c"


static PyObject *
_wrap_gtk_icon_theme_append_search_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    char *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.IconTheme.append_search_path", kwlist, &path))
        return NULL;
    
    gtk_icon_theme_append_search_path(GTK_ICON_THEME(self->obj), path);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_theme_prepend_search_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    char *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.IconTheme.prepend_search_path", kwlist, &path))
        return NULL;
    
    gtk_icon_theme_prepend_search_path(GTK_ICON_THEME(self->obj), path);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_theme_set_custom_theme(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "theme_name", NULL };
    char *theme_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.IconTheme.set_custom_theme", kwlist, &theme_name))
        return NULL;
    
    gtk_icon_theme_set_custom_theme(GTK_ICON_THEME(self->obj), theme_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_theme_has_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    char *icon_name;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.IconTheme.has_icon", kwlist, &icon_name))
        return NULL;
    
    ret = gtk_icon_theme_has_icon(GTK_ICON_THEME(self->obj), icon_name);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_icon_theme_lookup_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", "size", "flags", NULL };
    char *icon_name;
    int size;
    GtkIconInfo *ret;
    GtkIconLookupFlags flags;
    PyObject *py_flags = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"siO:Gtk.IconTheme.lookup_icon", kwlist, &icon_name, &size, &py_flags))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, py_flags, (gpointer)&flags))
        return NULL;
    
    ret = gtk_icon_theme_lookup_icon(GTK_ICON_THEME(self->obj), icon_name, size, flags);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_ICON_INFO, ret, FALSE, TRUE);
}

static PyObject *
_wrap_gtk_icon_theme_load_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", "size", "flags", NULL };
    GtkIconLookupFlags flags;
    int size;
    GdkPixbuf *ret;
    GError *error = NULL;
    char *icon_name;
    PyObject *py_flags = NULL, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"siO:Gtk.IconTheme.load_icon", kwlist, &icon_name, &size, &py_flags))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, py_flags, (gpointer)&flags))
        return NULL;
    
    ret = gtk_icon_theme_load_icon(GTK_ICON_THEME(self->obj), icon_name, size, flags, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

#line 5264 "./gtk.override"
static PyObject *
_wrap_gtk_icon_theme_list_icons(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "context", NULL };
    GList *icons;
    gchar *context = NULL;
    int i;
    guint len;
    PyObject *py_icons;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkIconTheme.list_icons",
                                     kwlist, &context))
        return NULL;

    icons = gtk_icon_theme_list_icons(GTK_ICON_THEME(self->obj), context);
    len = g_list_length(icons);

    py_icons = PyTuple_New(len);

    for (i = 0; i < len; i++) {
	char *name = (char *)g_list_nth_data(icons, i);

	PyTuple_SetItem(py_icons, i, PyString_FromString(name));
    }
    g_list_foreach(icons, (GFunc)g_free, NULL);
    g_list_free(icons);

    return py_icons;
}
#line 53631 "gtk.c"


static PyObject *
_wrap_gtk_icon_theme_get_example_icon_name(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_icon_theme_get_example_icon_name(GTK_ICON_THEME(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_theme_rescan_if_needed(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_theme_rescan_if_needed(GTK_ICON_THEME(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 6292 "./gtk.override"
static PyObject *
_wrap_gtk_icon_theme_get_icon_sizes(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    const gchar *icon_name;
    gint *sizes;
    int i;
    PyObject *py_sizes;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkIconTheme.get_icon_sizes",
				     kwlist, &icon_name))
        return NULL;

    sizes = gtk_icon_theme_get_icon_sizes(GTK_ICON_THEME(self->obj),
                                          icon_name);

    for (i = 0; sizes[i] != 0; i++) ;

    if ((py_sizes = PyTuple_New(i)) == NULL) {
        g_free(sizes);
        return NULL;
    }
    for (i = 0; sizes[i] != 0; i++)
        PyTuple_SET_ITEM(py_sizes, i, PyInt_FromLong(sizes[i]));

    g_free(sizes);
    return py_sizes;
}
#line 53694 "gtk.c"


#line 8628 "./gtk.override"
static PyObject *
_wrap_gtk_icon_theme_choose_icon(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char         *kwlist[] = { "icon_names", "size", "flags", NULL };
    int                 i, len;
    gint                size;
    PyObject            *py_icons, *py_flags = NULL;
    gchar               **icon_names;
    GtkIconLookupFlags  flags;
    GtkIconInfo         *ret;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,
                                     "OiO:GtkIconTheme.choose_icon",
                                     kwlist, &py_icons, &size, &py_flags))
        return NULL;

    if (!PySequence_Check(py_icons) || (len = PySequence_Size(py_icons)) < 0) {
        PyErr_SetString(PyExc_ValueError,
                        "icon_names should be a sequence of strings");
        return NULL;
    }
    
    if (pyg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS,
                            py_flags, (gpointer)&flags))
        return NULL;

    icon_names = g_new(gchar *, len + 1);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(py_icons, i);
        if (!item) {
            g_free(icon_names);
            return NULL;
        }
        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError, "icon must be a string");
            g_free(icon_names);
            Py_DECREF(item);
            return NULL;
        }
        icon_names[i] = PyString_AsString(item);
        Py_DECREF(item);
    }
    icon_names[len] = NULL;

    ret = gtk_icon_theme_choose_icon(GTK_ICON_THEME(self->obj),
                                     (const gchar **)icon_names, size, flags);

    g_free(icon_names);
    return pyg_boxed_new(GTK_TYPE_ICON_INFO, ret, TRUE, TRUE);
}
#line 53749 "gtk.c"


#line 8603 "./gtk.override"
static PyObject *
_wrap_gtk_icon_theme_list_contexts(PyGObject *self)
{
    GList   *contexts;
    int i;
    guint len;
    PyObject *py_contexts;

    contexts = gtk_icon_theme_list_contexts(GTK_ICON_THEME(self->obj));
    len = g_list_length(contexts);

    py_contexts = PyTuple_New(len);

    for (i = 0; i < len; i++) {
        char *name = (char *)g_list_nth_data(contexts, i);

        PyTuple_SetItem(py_contexts, i, PyString_FromString(name));
    }
    g_list_foreach(contexts, (GFunc)g_free, NULL);
    g_list_free(contexts);

    return py_contexts;
}
#line 53776 "gtk.c"


static PyObject *
_wrap_gtk_icon_theme_lookup_by_gicon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon", "size", "flags", NULL };
    PyGObject *icon;
    int size;
    GtkIconInfo *ret;
    GtkIconLookupFlags flags;
    PyObject *py_flags = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iO:Gtk.IconTheme.lookup_by_gicon", kwlist, &PyGIcon_Type, &icon, &size, &py_flags))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, py_flags, (gpointer)&flags))
        return NULL;
    
    ret = gtk_icon_theme_lookup_by_gicon(GTK_ICON_THEME(self->obj), G_ICON(icon->obj), size, flags);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_ICON_INFO, ret, TRUE, TRUE);
}

static PyObject *
_wrap_GtkIconTheme__do_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IconTheme.changed", kwlist, &PyGtkIconTheme_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ICON_THEME_CLASS(klass)->changed)
        GTK_ICON_THEME_CLASS(klass)->changed(GTK_ICON_THEME(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IconTheme.changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkIconTheme_methods[] = {
    { "set_screen", (PyCFunction)_wrap_gtk_icon_theme_set_screen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_search_path", (PyCFunction)_wrap_gtk_icon_theme_set_search_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_search_path", (PyCFunction)_wrap_gtk_icon_theme_get_search_path, METH_NOARGS,
      NULL },
    { "append_search_path", (PyCFunction)_wrap_gtk_icon_theme_append_search_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend_search_path", (PyCFunction)_wrap_gtk_icon_theme_prepend_search_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_custom_theme", (PyCFunction)_wrap_gtk_icon_theme_set_custom_theme, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "has_icon", (PyCFunction)_wrap_gtk_icon_theme_has_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "lookup_icon", (PyCFunction)_wrap_gtk_icon_theme_lookup_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "load_icon", (PyCFunction)_wrap_gtk_icon_theme_load_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "list_icons", (PyCFunction)_wrap_gtk_icon_theme_list_icons, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_example_icon_name", (PyCFunction)_wrap_gtk_icon_theme_get_example_icon_name, METH_NOARGS,
      NULL },
    { "rescan_if_needed", (PyCFunction)_wrap_gtk_icon_theme_rescan_if_needed, METH_NOARGS,
      NULL },
    { "get_icon_sizes", (PyCFunction)_wrap_gtk_icon_theme_get_icon_sizes, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "choose_icon", (PyCFunction)_wrap_gtk_icon_theme_choose_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "list_contexts", (PyCFunction)_wrap_gtk_icon_theme_list_contexts, METH_NOARGS,
      NULL },
    { "lookup_by_gicon", (PyCFunction)_wrap_gtk_icon_theme_lookup_by_gicon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_changed", (PyCFunction)_wrap_GtkIconTheme__do_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkIconTheme_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.IconTheme",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkIconTheme_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_icon_theme_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkIconTheme__proxy_do_changed(GtkIconTheme *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkIconTheme_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkIconThemeClass *klass = GTK_ICON_THEME_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "changed")))
            klass->changed = _wrap_GtkIconTheme__proxy_do_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkIconView ----------- */

#line 29 "gtkiconview.override"
static int
_wrap_gtk_icon_view_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *pymodel = NULL;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkIconView.__init__",
				     kwlist, &pymodel))
        return -1;
    if (pymodel == NULL || (PyObject *)pymodel == Py_None)
        pygobject_construct(self, NULL);
    else if (pygobject_check(pymodel, &PyGtkTreeModel_Type))
        pygobject_construct(self, "model", GTK_TREE_MODEL(pymodel->obj), NULL);
    else {
	PyErr_SetString(PyExc_TypeError,
			"model must be a gtk.TreeModel or None");
	return -1;
    }
 
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkIconView object");
        return -1;
    }
    return 0;
}
#line 54007 "gtk.c"


static PyObject *
_wrap_gtk_icon_view_set_model(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *py_model = NULL;
    GtkTreeModel *model = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.IconView.set_model", kwlist, &py_model))
        return NULL;
    if ((PyObject *)py_model == Py_None)
        model = NULL;
    else if (py_model && pygobject_check(py_model, &PyGtkTreeModel_Type))
        model = GTK_TREE_MODEL(py_model->obj);
    else if (py_model) {
        PyErr_SetString(PyExc_TypeError, "model should be a GtkTreeModel or None");
        return NULL;
    }
    
    gtk_icon_view_set_model(GTK_ICON_VIEW(self->obj), (GtkTreeModel *) model);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_model(PyGObject *self)
{
    GtkTreeModel *ret;

    
    ret = gtk_icon_view_get_model(GTK_ICON_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_icon_view_set_text_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_text_column", kwlist, &column))
        return NULL;
    
    gtk_icon_view_set_text_column(GTK_ICON_VIEW(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_text_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_text_column(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_set_markup_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_markup_column", kwlist, &column))
        return NULL;
    
    gtk_icon_view_set_markup_column(GTK_ICON_VIEW(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_markup_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_markup_column(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_set_pixbuf_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_pixbuf_column", kwlist, &column))
        return NULL;
    
    gtk_icon_view_set_pixbuf_column(GTK_ICON_VIEW(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_pixbuf_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_pixbuf_column(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_set_orientation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "orientation", NULL };
    GtkOrientation orientation;
    PyObject *py_orientation = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconView.set_orientation", kwlist, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    
    gtk_icon_view_set_orientation(GTK_ICON_VIEW(self->obj), orientation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_icon_view_get_orientation(GTK_ICON_VIEW(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, ret);
}

static PyObject *
_wrap_gtk_icon_view_set_columns(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "columns", NULL };
    int columns;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_columns", kwlist, &columns))
        return NULL;
    
    gtk_icon_view_set_columns(GTK_ICON_VIEW(self->obj), columns);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_columns(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_columns(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_set_item_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item_width", NULL };
    int item_width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_item_width", kwlist, &item_width))
        return NULL;
    
    gtk_icon_view_set_item_width(GTK_ICON_VIEW(self->obj), item_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_item_width(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_item_width(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_set_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "spacing", NULL };
    int spacing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_spacing", kwlist, &spacing))
        return NULL;
    
    gtk_icon_view_set_spacing(GTK_ICON_VIEW(self->obj), spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_spacing(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_spacing(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_set_row_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row_spacing", NULL };
    int row_spacing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_row_spacing", kwlist, &row_spacing))
        return NULL;
    
    gtk_icon_view_set_row_spacing(GTK_ICON_VIEW(self->obj), row_spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_row_spacing(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_row_spacing(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_set_column_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column_spacing", NULL };
    int column_spacing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_column_spacing", kwlist, &column_spacing))
        return NULL;
    
    gtk_icon_view_set_column_spacing(GTK_ICON_VIEW(self->obj), column_spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_column_spacing(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_column_spacing(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_set_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "margin", NULL };
    int margin;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_margin", kwlist, &margin))
        return NULL;
    
    gtk_icon_view_set_margin(GTK_ICON_VIEW(self->obj), margin);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_margin(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_margin(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_get_path_at_pos(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    int x, y;
    GtkTreePath *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.IconView.get_path_at_pos", kwlist, &x, &y))
        return NULL;
    
    ret = gtk_icon_view_get_path_at_pos(GTK_ICON_VIEW(self->obj), x, y);
    
    if (ret) {
        PyObject *py_ret = pygtk_tree_path_to_pyobject(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 129 "gtkiconview.override"
static PyObject *
_wrap_gtk_icon_view_get_item_at_pos(PyGObject *self, PyObject *args, 
				    PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    GtkTreePath *path;
    GtkCellRenderer *renderer;
    gint x,y;
    gboolean r;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "ii:GtkIconView.get_item_at_pos",
                                     kwlist,
                                     &x, &y))
        return NULL;


    r = gtk_icon_view_get_item_at_pos(GTK_ICON_VIEW(self->obj), x, y, &path, &renderer);
    if (r && path) {
        PyObject *py_path = pygtk_tree_path_to_pyobject(path);
        gtk_tree_path_free(path);
        return Py_BuildValue("(NN)", py_path, pygobject_new((GObject*)renderer));
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 54357 "gtk.c"


#line 158 "gtkiconview.override"
static PyObject *
_wrap_gtk_icon_view_get_visible_range(PyGObject *self)
{
    GtkTreePath *start_path, *end_path;
    gboolean r;
    
    r = gtk_icon_view_get_visible_range(GTK_ICON_VIEW(self->obj),
					&start_path, &end_path);
    if (r) {
        PyObject *py_start_path = pygtk_tree_path_to_pyobject(start_path);
        PyObject *py_end_path = pygtk_tree_path_to_pyobject(end_path);
        gtk_tree_path_free(start_path);
        gtk_tree_path_free(end_path); 
       return Py_BuildValue("(NN)", py_start_path, py_end_path);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 54380 "gtk.c"


#line 80 "gtkiconview.override"
static void
pygtk_icon_view_selected_foreach_cb(GtkIconView *iconview,
                                    GtkTreePath *path,
                                    gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret;
 
    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNO)",
                         pygobject_new((GObject *)iconview),
                         pygtk_tree_path_to_pyobject(path),
                         PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
        PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF(args);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_icon_view_selected_foreach(PyGObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data",  NULL };
    PyObject *func, *data, *py_data = Py_None;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkIconView.foreach",
                                     kwlist, &func, &py_data)) {
        return NULL;
    }
    if (!PyCallable_Check(func)) {
        PyErr_SetString(PyExc_TypeError, "func must be callable");
        return NULL;
    }
 
    data = Py_BuildValue("(OO)", func, py_data);
     
    gtk_icon_view_selected_foreach(GTK_ICON_VIEW(self->obj),
                                   pygtk_icon_view_selected_foreach_cb,
                                   (gpointer)data);
    Py_DECREF(data);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 54431 "gtk.c"


static PyObject *
_wrap_gtk_icon_view_set_selection_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mode", NULL };
    PyObject *py_mode = NULL;
    GtkSelectionMode mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconView.set_selection_mode", kwlist, &py_mode))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SELECTION_MODE, py_mode, (gpointer)&mode))
        return NULL;
    
    gtk_icon_view_set_selection_mode(GTK_ICON_VIEW(self->obj), mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_selection_mode(PyGObject *self)
{
    gint ret;

    
    ret = gtk_icon_view_get_selection_mode(GTK_ICON_VIEW(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SELECTION_MODE, ret);
}

static PyObject *
_wrap_gtk_icon_view_select_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconView.select_path", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_icon_view_select_path(GTK_ICON_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_unselect_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconView.unselect_path", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_icon_view_unselect_path(GTK_ICON_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_path_is_selected(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    int ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconView.path_is_selected", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_icon_view_path_is_selected(GTK_ICON_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

#line 57 "gtkiconview.override"
static PyObject *
_wrap_gtk_icon_view_get_selected_items(PyGObject *self)
{
    GList *paths;
    PyObject *py_paths;
    int plen, i;

    paths = gtk_icon_view_get_selected_items(GTK_ICON_VIEW(self->obj));

    plen = g_list_length(paths);
    if ((py_paths = PyList_New(plen)) == NULL)
        return NULL;
    for (i = 0; i < plen; i++) {
        GtkTreePath *path = (GtkTreePath *)g_list_nth_data(paths, i);
        PyObject *pypath = pygtk_tree_path_to_pyobject(path);
        PyList_SET_ITEM(py_paths, i, pypath);
    }
    g_list_foreach(paths, (GFunc)gtk_tree_path_free, NULL);
    g_list_free(paths);
    return py_paths;
}
#line 54555 "gtk.c"


static PyObject *
_wrap_gtk_icon_view_select_all(PyGObject *self)
{
    
    gtk_icon_view_select_all(GTK_ICON_VIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_unselect_all(PyGObject *self)
{
    
    gtk_icon_view_unselect_all(GTK_ICON_VIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_item_activated(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconView.item_activated", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_icon_view_item_activated(GTK_ICON_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_set_cursor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "cell", "start_editing", NULL };
    PyObject *py_path;
    PyGObject *py_cell = NULL;
    int start_editing = FALSE;
    GtkCellRenderer *cell = NULL;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O|Oi:Gtk.IconView.set_cursor", kwlist, &py_path, &py_cell, &start_editing))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if ((PyObject *)py_cell == Py_None)
        cell = NULL;
    else if (py_cell && pygobject_check(py_cell, &PyGtkCellRenderer_Type))
        cell = GTK_CELL_RENDERER(py_cell->obj);
    else if (py_cell) {
        PyErr_SetString(PyExc_TypeError, "cell should be a GtkCellRenderer or None");
        return NULL;
    }
    
    gtk_icon_view_set_cursor(GTK_ICON_VIEW(self->obj), path, (GtkCellRenderer *) cell, start_editing);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 179 "gtkiconview.override"
static PyObject *
_wrap_gtk_icon_view_get_cursor(PyGObject *self)
{
    GtkTreePath *path;
    GtkCellRenderer *renderer;
    gboolean r;

    r = gtk_icon_view_get_cursor(GTK_ICON_VIEW(self->obj), &path, &renderer);
    if (r && path) {
        PyObject *py_path = pygtk_tree_path_to_pyobject(path);
        gtk_tree_path_free(path);
        return Py_BuildValue("(NN)", py_path, pygobject_new((GObject*)renderer));
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 54653 "gtk.c"


static PyObject *
_wrap_gtk_icon_view_scroll_to_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "use_align", "row_align", "col_align", NULL };
    PyObject *py_path;
    int use_align;
    GtkTreePath *path;
    double row_align, col_align;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oidd:Gtk.IconView.scroll_to_path", kwlist, &py_path, &use_align, &row_align, &col_align))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_icon_view_scroll_to_path(GTK_ICON_VIEW(self->obj), path, use_align, row_align, col_align);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 247 "gtkiconview.override"
static PyObject *
_wrap_gtk_icon_view_enable_model_drag_source(PyGObject *self, PyObject *args,
                                             PyObject *kwargs)
{
    static char *kwlist[] = { "start_button_mask", "targets", "actions", NULL };
    PyObject *py_sbmask, *py_targets, *py_actions;
    GdkModifierType sbmask;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO:GtkIconView.enable_model_drag_source",
                                     kwlist,
                                     &py_sbmask, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,
                             py_sbmask, (gint *)&sbmask))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!PySequence_Check(py_targets)) {
        PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
        return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_GetItem(py_targets, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
            return NULL;
        }
    }
    gtk_icon_view_enable_model_drag_source(GTK_ICON_VIEW(self->obj),
                                           sbmask, targets, n_targets, actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 54728 "gtk.c"


#line 295 "gtkiconview.override"
static PyObject *
_wrap_gtk_icon_view_enable_model_drag_dest(PyGObject *self, PyObject *args,
                                           PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "actions", NULL };
    PyObject *py_targets, *py_actions;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:GtkIconView.enable_model_drag_dest",
                                     kwlist,
                                     &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!PySequence_Check(py_targets)) {
        PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
        return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_GetItem(py_targets, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
            return NULL;
        }
    }
    gtk_icon_view_enable_model_drag_dest(GTK_ICON_VIEW(self->obj),
                                         targets, n_targets, actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 54774 "gtk.c"


static PyObject *
_wrap_gtk_icon_view_unset_model_drag_source(PyGObject *self)
{
    
    gtk_icon_view_unset_model_drag_source(GTK_ICON_VIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_unset_model_drag_dest(PyGObject *self)
{
    
    gtk_icon_view_unset_model_drag_dest(GTK_ICON_VIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_set_reorderable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "reorderable", NULL };
    int reorderable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_reorderable", kwlist, &reorderable))
        return NULL;
    
    gtk_icon_view_set_reorderable(GTK_ICON_VIEW(self->obj), reorderable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_reorderable(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_reorderable(GTK_ICON_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_icon_view_set_drag_dest_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "pos", NULL };
    PyObject *py_path = Py_None, *py_pos = NULL;
    GtkIconViewDropPosition pos;
    GtkTreePath *path = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.IconView.set_drag_dest_item", kwlist, &py_path, &py_pos))
        return NULL;
    if (py_path != Py_None) {
        path = pygtk_tree_path_from_pyobject(py_path);
        if (!path) {
            PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
            return NULL;
        }
    }
    if (pyg_enum_get_value(GTK_TYPE_ICON_VIEW_DROP_POSITION, py_pos, (gpointer)&pos))
        return NULL;
    
    gtk_icon_view_set_drag_dest_item(GTK_ICON_VIEW(self->obj), path, pos);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 198 "gtkiconview.override"
static PyObject *
_wrap_gtk_icon_view_get_drag_dest_item(PyGObject *self)
{
    GtkTreePath *path;
    GtkIconViewDropPosition pos;

    gtk_icon_view_get_drag_dest_item(GTK_ICON_VIEW(self->obj), &path, &pos);
    if (path) {
        PyObject *py_path = pygtk_tree_path_to_pyobject(path);
        gtk_tree_path_free(path);
        return Py_BuildValue("(NN)", py_path,
			     pyg_enum_from_gtype(GTK_TYPE_ICON_VIEW_DROP_POSITION, (gint)pos));
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 54870 "gtk.c"


#line 217 "gtkiconview.override"
static PyObject *
_wrap_gtk_icon_view_get_dest_item_at_pos(PyGObject *self, PyObject *args, 
					 PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    GtkTreePath *path;
    GtkIconViewDropPosition pos;
    gint drag_x, drag_y;
    gboolean r;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "ii:GtkIconView.get_dest_item_at_pos",
                                     kwlist, &drag_x, &drag_y))
        return NULL;


    r = gtk_icon_view_get_dest_item_at_pos(GTK_ICON_VIEW(self->obj),
					   drag_x, drag_y, &path, &pos);
    if (r && path) {
        PyObject *py_path = pygtk_tree_path_to_pyobject(path);
        gtk_tree_path_free(path);
        return Py_BuildValue("(NN)", py_path,
			     pyg_enum_from_gtype(GTK_TYPE_ICON_VIEW_DROP_POSITION, (gint) pos));
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 54902 "gtk.c"


static PyObject *
_wrap_gtk_icon_view_create_drag_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GdkPixmap *ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconView.create_drag_icon", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_icon_view_create_drag_icon(GTK_ICON_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 377 "gtkiconview.override"
static PyObject*
_wrap_gtk_icon_view_convert_widget_to_bin_window_coords(PyGObject *self,
                                                        PyObject *args,
                                                        PyObject *kwargs)
{
    static char *kwlist[] = { "widget_x", "widget_y", NULL };
    gint widget_x, widget_y, window_x = 0, window_y = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                        "ii:GtkIconView.convert_widget_to_bin_window_coords",
                        kwlist, &widget_x, &widget_y))
        return NULL;
    
    gtk_icon_view_convert_widget_to_bin_window_coords(GTK_ICON_VIEW(self->obj),
                                          widget_x, widget_y,
                                          &window_x, &window_y);
    
    return Py_BuildValue("(ii)", window_x, window_y);
}
#line 54949 "gtk.c"


static PyObject *
_wrap_gtk_icon_view_set_tooltip_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tooltip", "path", NULL };
    PyGObject *tooltip;
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.IconView.set_tooltip_item", kwlist, &PyGtkTooltip_Type, &tooltip, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_icon_view_set_tooltip_item(GTK_ICON_VIEW(self->obj), GTK_TOOLTIP(tooltip->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_set_tooltip_cell(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tooltip", "path", "cell", NULL };
    PyGObject *tooltip, *py_cell;
    PyObject *py_path;
    GtkCellRenderer *cell = NULL;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.IconView.set_tooltip_cell", kwlist, &PyGtkTooltip_Type, &tooltip, &py_path, &py_cell))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if (py_cell && pygobject_check(py_cell, &PyGtkCellRenderer_Type))
        cell = GTK_CELL_RENDERER(py_cell->obj);
    else if ((PyObject *)py_cell != Py_None) {
        PyErr_SetString(PyExc_TypeError, "cell should be a GtkCellRenderer or None");
        return NULL;
    }
    
    gtk_icon_view_set_tooltip_cell(GTK_ICON_VIEW(self->obj), GTK_TOOLTIP(tooltip->obj), path, (GtkCellRenderer *) cell);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 339 "gtkiconview.override"
static PyObject *
_wrap_gtk_icon_view_get_tooltip_context(PyGObject *self,
                                        PyObject *args,
                                        PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", "keyboard_tip", NULL };
    
    gboolean        ret;
    PyObject        *py_ret = Py_None, *py_keyboard_tip = Py_True;
    gint            x, y;
    GtkTreeModel    *tree_model;
    GtkTreePath     *path;
    GtkTreeIter     iter;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                        "iiO:GtkIconView.get_tooltip_context",
                        kwlist, &x, &y, &py_keyboard_tip))
        return NULL;
    
    ret = gtk_icon_view_get_tooltip_context(GTK_ICON_VIEW(self->obj), &x, &y,
                                            PyObject_IsTrue(py_keyboard_tip),
                                            &tree_model,
                                            &path, &iter);
    if (ret) {
        py_ret = Py_BuildValue("(NNN)",
                               pygobject_new((GObject *)tree_model),
                               pygtk_tree_path_to_pyobject(path),
                               pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter,
                                             TRUE, TRUE));

        gtk_tree_path_free(path);
        return py_ret;
    }
    Py_INCREF(py_ret);    
    return py_ret;
}
#line 55044 "gtk.c"


static PyObject *
_wrap_gtk_icon_view_set_tooltip_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_tooltip_column", kwlist, &column))
        return NULL;
    
    gtk_icon_view_set_tooltip_column(GTK_ICON_VIEW(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_tooltip_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_tooltip_column(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_set_item_padding(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item_padding", NULL };
    int item_padding;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IconView.set_item_padding", kwlist, &item_padding))
        return NULL;
    
    gtk_icon_view_set_item_padding(GTK_ICON_VIEW(self->obj), item_padding);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_item_padding(PyGObject *self)
{
    int ret;

    
    ret = gtk_icon_view_get_item_padding(GTK_ICON_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_get_item_row(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    int ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconView.get_item_row", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_icon_view_get_item_row(GTK_ICON_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_get_item_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    int ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconView.get_item_column", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_icon_view_get_item_column(GTK_ICON_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_icon_view_set_item_orientation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "orientation", NULL };
    GtkOrientation orientation;
    PyObject *py_orientation = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IconView.set_item_orientation", kwlist, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    
    gtk_icon_view_set_item_orientation(GTK_ICON_VIEW(self->obj), orientation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_view_get_item_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_icon_view_get_item_orientation(GTK_ICON_VIEW(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, ret);
}

static PyObject *
_wrap_GtkIconView__do_set_scroll_adjustments(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "hadjustment", "vadjustment", NULL };
    PyGObject *self, *hadjustment, *vadjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!:Gtk.IconView.set_scroll_adjustments", kwlist, &PyGtkIconView_Type, &self, &PyGtkAdjustment_Type, &hadjustment, &PyGtkAdjustment_Type, &vadjustment))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ICON_VIEW_CLASS(klass)->set_scroll_adjustments)
        GTK_ICON_VIEW_CLASS(klass)->set_scroll_adjustments(GTK_ICON_VIEW(self->obj), GTK_ADJUSTMENT(hadjustment->obj), GTK_ADJUSTMENT(vadjustment->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IconView.set_scroll_adjustments not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIconView__do_item_activated(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "path", NULL };
    PyGObject *self;
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.IconView.item_activated", kwlist, &PyGtkIconView_Type, &self, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ICON_VIEW_CLASS(klass)->item_activated)
        GTK_ICON_VIEW_CLASS(klass)->item_activated(GTK_ICON_VIEW(self->obj), path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IconView.item_activated not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIconView__do_selection_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IconView.selection_changed", kwlist, &PyGtkIconView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ICON_VIEW_CLASS(klass)->selection_changed)
        GTK_ICON_VIEW_CLASS(klass)->selection_changed(GTK_ICON_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IconView.selection_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIconView__do_select_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IconView.select_all", kwlist, &PyGtkIconView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ICON_VIEW_CLASS(klass)->select_all)
        GTK_ICON_VIEW_CLASS(klass)->select_all(GTK_ICON_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IconView.select_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIconView__do_unselect_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IconView.unselect_all", kwlist, &PyGtkIconView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ICON_VIEW_CLASS(klass)->unselect_all)
        GTK_ICON_VIEW_CLASS(klass)->unselect_all(GTK_ICON_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IconView.unselect_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIconView__do_select_cursor_item(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IconView.select_cursor_item", kwlist, &PyGtkIconView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ICON_VIEW_CLASS(klass)->select_cursor_item)
        GTK_ICON_VIEW_CLASS(klass)->select_cursor_item(GTK_ICON_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IconView.select_cursor_item not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIconView__do_toggle_cursor_item(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IconView.toggle_cursor_item", kwlist, &PyGtkIconView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ICON_VIEW_CLASS(klass)->toggle_cursor_item)
        GTK_ICON_VIEW_CLASS(klass)->toggle_cursor_item(GTK_ICON_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IconView.toggle_cursor_item not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIconView__do_move_cursor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "step", "count", NULL };
    PyGObject *self;
    PyObject *py_step = NULL;
    GtkMovementStep step;
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oi:Gtk.IconView.move_cursor", kwlist, &PyGtkIconView_Type, &self, &py_step, &count))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_MOVEMENT_STEP, py_step, (gpointer)&step))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ICON_VIEW_CLASS(klass)->move_cursor)
        ret = GTK_ICON_VIEW_CLASS(klass)->move_cursor(GTK_ICON_VIEW(self->obj), step, count);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IconView.move_cursor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkIconView__do_activate_cursor_item(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IconView.activate_cursor_item", kwlist, &PyGtkIconView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ICON_VIEW_CLASS(klass)->activate_cursor_item)
        ret = GTK_ICON_VIEW_CLASS(klass)->activate_cursor_item(GTK_ICON_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IconView.activate_cursor_item not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkIconView_methods[] = {
    { "set_model", (PyCFunction)_wrap_gtk_icon_view_set_model, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_model", (PyCFunction)_wrap_gtk_icon_view_get_model, METH_NOARGS,
      NULL },
    { "set_text_column", (PyCFunction)_wrap_gtk_icon_view_set_text_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text_column", (PyCFunction)_wrap_gtk_icon_view_get_text_column, METH_NOARGS,
      NULL },
    { "set_markup_column", (PyCFunction)_wrap_gtk_icon_view_set_markup_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_markup_column", (PyCFunction)_wrap_gtk_icon_view_get_markup_column, METH_NOARGS,
      NULL },
    { "set_pixbuf_column", (PyCFunction)_wrap_gtk_icon_view_set_pixbuf_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_pixbuf_column", (PyCFunction)_wrap_gtk_icon_view_get_pixbuf_column, METH_NOARGS,
      NULL },
    { "set_orientation", (PyCFunction)_wrap_gtk_icon_view_set_orientation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_orientation", (PyCFunction)_wrap_gtk_icon_view_get_orientation, METH_NOARGS,
      NULL },
    { "set_columns", (PyCFunction)_wrap_gtk_icon_view_set_columns, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_columns", (PyCFunction)_wrap_gtk_icon_view_get_columns, METH_NOARGS,
      NULL },
    { "set_item_width", (PyCFunction)_wrap_gtk_icon_view_set_item_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_item_width", (PyCFunction)_wrap_gtk_icon_view_get_item_width, METH_NOARGS,
      NULL },
    { "set_spacing", (PyCFunction)_wrap_gtk_icon_view_set_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_spacing", (PyCFunction)_wrap_gtk_icon_view_get_spacing, METH_NOARGS,
      NULL },
    { "set_row_spacing", (PyCFunction)_wrap_gtk_icon_view_set_row_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_row_spacing", (PyCFunction)_wrap_gtk_icon_view_get_row_spacing, METH_NOARGS,
      NULL },
    { "set_column_spacing", (PyCFunction)_wrap_gtk_icon_view_set_column_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_column_spacing", (PyCFunction)_wrap_gtk_icon_view_get_column_spacing, METH_NOARGS,
      NULL },
    { "set_margin", (PyCFunction)_wrap_gtk_icon_view_set_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_margin", (PyCFunction)_wrap_gtk_icon_view_get_margin, METH_NOARGS,
      NULL },
    { "get_path_at_pos", (PyCFunction)_wrap_gtk_icon_view_get_path_at_pos, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_item_at_pos", (PyCFunction)_wrap_gtk_icon_view_get_item_at_pos, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible_range", (PyCFunction)_wrap_gtk_icon_view_get_visible_range, METH_NOARGS,
      NULL },
    { "selected_foreach", (PyCFunction)_wrap_gtk_icon_view_selected_foreach, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_selection_mode", (PyCFunction)_wrap_gtk_icon_view_set_selection_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_selection_mode", (PyCFunction)_wrap_gtk_icon_view_get_selection_mode, METH_NOARGS,
      NULL },
    { "select_path", (PyCFunction)_wrap_gtk_icon_view_select_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_path", (PyCFunction)_wrap_gtk_icon_view_unselect_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "path_is_selected", (PyCFunction)_wrap_gtk_icon_view_path_is_selected, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_selected_items", (PyCFunction)_wrap_gtk_icon_view_get_selected_items, METH_NOARGS,
      NULL },
    { "select_all", (PyCFunction)_wrap_gtk_icon_view_select_all, METH_NOARGS,
      NULL },
    { "unselect_all", (PyCFunction)_wrap_gtk_icon_view_unselect_all, METH_NOARGS,
      NULL },
    { "item_activated", (PyCFunction)_wrap_gtk_icon_view_item_activated, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_cursor", (PyCFunction)_wrap_gtk_icon_view_set_cursor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_cursor", (PyCFunction)_wrap_gtk_icon_view_get_cursor, METH_NOARGS,
      NULL },
    { "scroll_to_path", (PyCFunction)_wrap_gtk_icon_view_scroll_to_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "enable_model_drag_source", (PyCFunction)_wrap_gtk_icon_view_enable_model_drag_source, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "enable_model_drag_dest", (PyCFunction)_wrap_gtk_icon_view_enable_model_drag_dest, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unset_model_drag_source", (PyCFunction)_wrap_gtk_icon_view_unset_model_drag_source, METH_NOARGS,
      NULL },
    { "unset_model_drag_dest", (PyCFunction)_wrap_gtk_icon_view_unset_model_drag_dest, METH_NOARGS,
      NULL },
    { "set_reorderable", (PyCFunction)_wrap_gtk_icon_view_set_reorderable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_reorderable", (PyCFunction)_wrap_gtk_icon_view_get_reorderable, METH_NOARGS,
      NULL },
    { "set_drag_dest_item", (PyCFunction)_wrap_gtk_icon_view_set_drag_dest_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_drag_dest_item", (PyCFunction)_wrap_gtk_icon_view_get_drag_dest_item, METH_NOARGS,
      NULL },
    { "get_dest_item_at_pos", (PyCFunction)_wrap_gtk_icon_view_get_dest_item_at_pos, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "create_drag_icon", (PyCFunction)_wrap_gtk_icon_view_create_drag_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_widget_to_bin_window_coords", (PyCFunction)_wrap_gtk_icon_view_convert_widget_to_bin_window_coords, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tooltip_item", (PyCFunction)_wrap_gtk_icon_view_set_tooltip_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tooltip_cell", (PyCFunction)_wrap_gtk_icon_view_set_tooltip_cell, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tooltip_context", (PyCFunction)_wrap_gtk_icon_view_get_tooltip_context, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tooltip_column", (PyCFunction)_wrap_gtk_icon_view_set_tooltip_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tooltip_column", (PyCFunction)_wrap_gtk_icon_view_get_tooltip_column, METH_NOARGS,
      NULL },
    { "set_item_padding", (PyCFunction)_wrap_gtk_icon_view_set_item_padding, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_item_padding", (PyCFunction)_wrap_gtk_icon_view_get_item_padding, METH_NOARGS,
      NULL },
    { "get_item_row", (PyCFunction)_wrap_gtk_icon_view_get_item_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_item_column", (PyCFunction)_wrap_gtk_icon_view_get_item_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_item_orientation", (PyCFunction)_wrap_gtk_icon_view_set_item_orientation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_item_orientation", (PyCFunction)_wrap_gtk_icon_view_get_item_orientation, METH_NOARGS,
      NULL },
    { "do_set_scroll_adjustments", (PyCFunction)_wrap_GtkIconView__do_set_scroll_adjustments, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_item_activated", (PyCFunction)_wrap_GtkIconView__do_item_activated, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_selection_changed", (PyCFunction)_wrap_GtkIconView__do_selection_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_all", (PyCFunction)_wrap_GtkIconView__do_select_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unselect_all", (PyCFunction)_wrap_GtkIconView__do_unselect_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_cursor_item", (PyCFunction)_wrap_GtkIconView__do_select_cursor_item, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toggle_cursor_item", (PyCFunction)_wrap_GtkIconView__do_toggle_cursor_item, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_cursor", (PyCFunction)_wrap_GtkIconView__do_move_cursor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_activate_cursor_item", (PyCFunction)_wrap_GtkIconView__do_activate_cursor_item, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkIconView_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.IconView",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkIconView_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_icon_view_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkIconView__proxy_do_set_scroll_adjustments(GtkIconView *self, GtkAdjustment*hadjustment, GtkAdjustment*vadjustment)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_hadjustment = NULL;
    PyObject *py_vadjustment = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (hadjustment)
        py_hadjustment = pygobject_new((GObject *) hadjustment);
    else {
        Py_INCREF(Py_None);
        py_hadjustment = Py_None;
    }
    if (vadjustment)
        py_vadjustment = pygobject_new((GObject *) vadjustment);
    else {
        Py_INCREF(Py_None);
        py_vadjustment = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_hadjustment);
    PyTuple_SET_ITEM(py_args, 1, py_vadjustment);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_scroll_adjustments");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIconView__proxy_do_item_activated(GtkIconView *self, GtkTreePath*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_item_activated");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIconView__proxy_do_selection_changed(GtkIconView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_selection_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIconView__proxy_do_select_all(GtkIconView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_select_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIconView__proxy_do_unselect_all(GtkIconView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_unselect_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIconView__proxy_do_select_cursor_item(GtkIconView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_select_cursor_item");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIconView__proxy_do_toggle_cursor_item(GtkIconView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_cursor_item");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkIconView__proxy_do_move_cursor(GtkIconView *self, GtkMovementStep step, gint count)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_step;
    PyObject *py_count;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_step = pyg_enum_from_gtype(GTK_TYPE_MOVEMENT_STEP, step);
    if (!py_step) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_count = PyInt_FromLong(count);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_step);
    PyTuple_SET_ITEM(py_args, 1, py_count);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_cursor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkIconView__proxy_do_activate_cursor_item(GtkIconView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate_cursor_item");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkIconView_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkIconViewClass *klass = GTK_ICON_VIEW_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_scroll_adjustments");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_scroll_adjustments")))
            klass->set_scroll_adjustments = _wrap_GtkIconView__proxy_do_set_scroll_adjustments;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_item_activated");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "item_activated")))
            klass->item_activated = _wrap_GtkIconView__proxy_do_item_activated;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_selection_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "selection_changed")))
            klass->selection_changed = _wrap_GtkIconView__proxy_do_selection_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_all")))
            klass->select_all = _wrap_GtkIconView__proxy_do_select_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_unselect_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "unselect_all")))
            klass->unselect_all = _wrap_GtkIconView__proxy_do_unselect_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_cursor_item");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_cursor_item")))
            klass->select_cursor_item = _wrap_GtkIconView__proxy_do_select_cursor_item;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_cursor_item");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_cursor_item")))
            klass->toggle_cursor_item = _wrap_GtkIconView__proxy_do_toggle_cursor_item;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_cursor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_cursor")))
            klass->move_cursor = _wrap_GtkIconView__proxy_do_move_cursor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate_cursor_item");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate_cursor_item")))
            klass->activate_cursor_item = _wrap_GtkIconView__proxy_do_activate_cursor_item;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkImage ----------- */

static int
_wrap_gtk_image_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Image.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Image object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_image_clear(PyGObject *self)
{
    
    gtk_image_clear(GTK_IMAGE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_set_from_pixmap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixmap", "mask", NULL };
    PyGObject *pixmap, *py_mask;
    GdkPixmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Image.set_from_pixmap", kwlist, &PyGdkPixmap_Type, &pixmap, &py_mask))
        return NULL;
    if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if ((PyObject *)py_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return NULL;
    }
    
    gtk_image_set_from_pixmap(GTK_IMAGE(self->obj), GDK_PIXMAP(pixmap->obj), (GdkBitmap *) mask);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_set_from_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gdk_image", "mask", NULL };
    PyGObject *py_gdk_image, *py_mask;
    GdkPixmap *mask = NULL;
    GdkImage *gdk_image = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Image.set_from_image", kwlist, &py_gdk_image, &py_mask))
        return NULL;
    if (py_gdk_image && pygobject_check(py_gdk_image, &PyGdkImage_Type))
        gdk_image = GDK_IMAGE(py_gdk_image->obj);
    else if ((PyObject *)py_gdk_image != Py_None) {
        PyErr_SetString(PyExc_TypeError, "gdk_image should be a GdkImage or None");
        return NULL;
    }
    if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if ((PyObject *)py_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return NULL;
    }
    
    gtk_image_set_from_image(GTK_IMAGE(self->obj), (GdkImage *) gdk_image, (GdkBitmap *) mask);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_set_from_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.Image.set_from_file", kwlist, &filename))
        return NULL;
    
    gtk_image_set_from_file(GTK_IMAGE(self->obj), filename);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_set_from_pixbuf(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *py_pixbuf;
    GdkPixbuf *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Image.set_from_pixbuf", kwlist, &py_pixbuf))
        return NULL;
    if (py_pixbuf && pygobject_check(py_pixbuf, &PyGdkPixbuf_Type))
        pixbuf = GDK_PIXBUF(py_pixbuf->obj);
    else if ((PyObject *)py_pixbuf != Py_None) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf or None");
        return NULL;
    }
    
    gtk_image_set_from_pixbuf(GTK_IMAGE(self->obj), (GdkPixbuf *) pixbuf);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_set_from_stock(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "size", NULL };
    char *stock_id;
    PyObject *py_size = NULL;
    GtkIconSize size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO:Gtk.Image.set_from_stock", kwlist, &stock_id, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    gtk_image_set_from_stock(GTK_IMAGE(self->obj), stock_id, size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_set_from_icon_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_set", "size", NULL };
    PyObject *py_icon_set, *py_size = NULL;
    GtkIconSize size;
    GtkIconSet *icon_set = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Image.set_from_icon_set", kwlist, &py_icon_set, &py_size))
        return NULL;
    if (pyg_boxed_check(py_icon_set, GTK_TYPE_ICON_SET))
        icon_set = pyg_boxed_get(py_icon_set, GtkIconSet);
    else {
        PyErr_SetString(PyExc_TypeError, "icon_set should be a GtkIconSet");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    gtk_image_set_from_icon_set(GTK_IMAGE(self->obj), icon_set, size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_set_from_animation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "animation", NULL };
    PyGObject *animation;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Image.set_from_animation", kwlist, &PyGdkPixbufAnimation_Type, &animation))
        return NULL;
    
    gtk_image_set_from_animation(GTK_IMAGE(self->obj), GDK_PIXBUF_ANIMATION(animation->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_get_storage_type(PyGObject *self)
{
    gint ret;

    
    ret = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_IMAGE_TYPE, ret);
}

#line 3405 "./gtk.override"
static PyObject *
_wrap_gtk_image_get_pixmap(PyGObject *self)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_PIXMAP || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixmap or empty");
        return NULL;
    }
    gtk_image_get_pixmap(GTK_IMAGE(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
#line 56419 "gtk.c"


#line 3423 "./gtk.override"
static PyObject *
_wrap_gtk_image_get_image(PyGObject *self)
{
    GdkImage *image;
    GdkBitmap *mask;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_IMAGE || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkImage or empty");
        return NULL;
    }
    gtk_image_get_image(GTK_IMAGE(self->obj), &image, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)image),
			 pygobject_new((GObject *)mask));
}
#line 56439 "gtk.c"


#line 3493 "./gtk.override"
static PyObject *
_wrap_gtk_image_get_pixbuf(PyGObject *self)
{
    GdkPixbuf *ret;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_PIXBUF || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixbuf or empty");
        return NULL;
    }
    ret = gtk_image_get_pixbuf(GTK_IMAGE(self->obj));
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
#line 56458 "gtk.c"


#line 3441 "./gtk.override"
static PyObject *
_wrap_gtk_image_get_stock(PyGObject *self)
{
    gchar *stock_id;
    GtkIconSize size;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_STOCK || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a stock icon or empty");
        return NULL;
    }
    gtk_image_get_stock(GTK_IMAGE(self->obj), &stock_id, &size);

    if (stock_id) {
	return Py_BuildValue("(NN)",
			     PyString_FromString(stock_id),
			     pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
    } else {
	Py_INCREF(Py_None);
	return Py_BuildValue("(ON)",
			     Py_None,
			     pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
    }
}
#line 56487 "gtk.c"


#line 3468 "./gtk.override"
static PyObject *
_wrap_gtk_image_get_icon_set(PyGObject *self)
{
    GtkIconSet *icon_set;
    GtkIconSize size;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_ICON_SET || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GtkIconSet or empty");
        return NULL;
    }
    gtk_image_get_icon_set(GTK_IMAGE(self->obj), &icon_set, &size);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)icon_set),
			 pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
}
#line 56507 "gtk.c"


#line 3510 "./gtk.override"
static PyObject *
_wrap_gtk_image_get_animation(PyGObject *self)
{
    GdkPixbufAnimation *ret;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_ANIMATION || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixbufAnimation or empty");
        return NULL;
    }

    ret = gtk_image_get_animation(GTK_IMAGE(self->obj));
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
#line 56527 "gtk.c"


static PyObject *
_wrap_gtk_image_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "val", "mask", NULL };
    PyGObject *val, *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Image.set", kwlist, &PyGdkImage_Type, &val, &PyGdkPixmap_Type, &mask))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_image_set(GTK_IMAGE(self->obj), GDK_IMAGE(val->obj), GDK_PIXMAP(mask->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3486 "./gtk.override"
static PyObject *
_wrap_gtk_image_get(PyGObject *self)
{
    return _wrap_gtk_image_get_image(self);
}
#line 56553 "gtk.c"


static PyObject *
_wrap_gtk_image_set_from_icon_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", "size", NULL };
    char *icon_name;
    PyObject *py_size = NULL;
    GtkIconSize size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO:Gtk.Image.set_from_icon_name", kwlist, &icon_name, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    gtk_image_set_from_icon_name(GTK_IMAGE(self->obj), icon_name, size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_set_pixel_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixel_size", NULL };
    int pixel_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Image.set_pixel_size", kwlist, &pixel_size))
        return NULL;
    
    gtk_image_set_pixel_size(GTK_IMAGE(self->obj), pixel_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 6324 "./gtk.override"
static PyObject *
_wrap_gtk_image_get_icon_name(PyGObject *self)
{
    gchar *icon_name = NULL;
    GtkIconSize size = GTK_ICON_SIZE_INVALID;

    gtk_image_get_icon_name(GTK_IMAGE(self->obj),
                            (G_CONST_RETURN gchar **)&icon_name, &size);

    return Py_BuildValue("(sN)", icon_name,
                         pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size));
}
#line 56603 "gtk.c"


static PyObject *
_wrap_gtk_image_get_pixel_size(PyGObject *self)
{
    int ret;

    
    ret = gtk_image_get_pixel_size(GTK_IMAGE(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_image_set_from_gicon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon", "size", NULL };
    PyGObject *icon;
    PyObject *py_size = NULL;
    GtkIconSize size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Image.set_from_gicon", kwlist, &PyGIcon_Type, &icon, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    gtk_image_set_from_gicon(GTK_IMAGE(self->obj), G_ICON(icon->obj), size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkImage_methods[] = {
    { "clear", (PyCFunction)_wrap_gtk_image_clear, METH_NOARGS,
      NULL },
    { "set_from_pixmap", (PyCFunction)_wrap_gtk_image_set_from_pixmap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_from_image", (PyCFunction)_wrap_gtk_image_set_from_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_from_file", (PyCFunction)_wrap_gtk_image_set_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_from_pixbuf", (PyCFunction)_wrap_gtk_image_set_from_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_from_stock", (PyCFunction)_wrap_gtk_image_set_from_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_from_icon_set", (PyCFunction)_wrap_gtk_image_set_from_icon_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_from_animation", (PyCFunction)_wrap_gtk_image_set_from_animation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_storage_type", (PyCFunction)_wrap_gtk_image_get_storage_type, METH_NOARGS,
      NULL },
    { "get_pixmap", (PyCFunction)_wrap_gtk_image_get_pixmap, METH_NOARGS,
      NULL },
    { "get_image", (PyCFunction)_wrap_gtk_image_get_image, METH_NOARGS,
      NULL },
    { "get_pixbuf", (PyCFunction)_wrap_gtk_image_get_pixbuf, METH_NOARGS,
      NULL },
    { "get_stock", (PyCFunction)_wrap_gtk_image_get_stock, METH_NOARGS,
      NULL },
    { "get_icon_set", (PyCFunction)_wrap_gtk_image_get_icon_set, METH_NOARGS,
      NULL },
    { "get_animation", (PyCFunction)_wrap_gtk_image_get_animation, METH_NOARGS,
      NULL },
    { "set", (PyCFunction)_wrap_gtk_image_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get", (PyCFunction)_wrap_gtk_image_get, METH_NOARGS,
      NULL },
    { "set_from_icon_name", (PyCFunction)_wrap_gtk_image_set_from_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_pixel_size", (PyCFunction)_wrap_gtk_image_set_pixel_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_name", (PyCFunction)_wrap_gtk_image_get_icon_name, METH_NOARGS,
      NULL },
    { "get_pixel_size", (PyCFunction)_wrap_gtk_image_get_pixel_size, METH_NOARGS,
      NULL },
    { "set_from_gicon", (PyCFunction)_wrap_gtk_image_set_from_gicon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkImage_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Image",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkImage_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_image_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkImageMenuItem ----------- */

#line 2054 "./gtk.override"
static int
_wrap_gtk_image_menu_item_new(PyGObject *self, PyObject *args,PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "accel_group", NULL };
    gchar *stock_id = NULL;
    PyObject *py_accel_group = Py_None;
    GtkAccelGroup *accel_group= NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zO:GtkImageMenuItem.__init__",kwlist,
                                     &stock_id, &py_accel_group))
        return -1;
    if (pygobject_check(py_accel_group, &PyGtkAccelGroup_Type))
        accel_group = GTK_ACCEL_GROUP(pygobject_get(py_accel_group));

    if (stock_id) {
        pygobject_construct(self,
                            "label", stock_id,
                            "use-stock", TRUE,
                            "accel-group", accel_group,
                            NULL);
    }
    else
        pygobject_construct(self, NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkImageMenuItem object");
        return -1;
    }
    return 0;
}
#line 56765 "gtk.c"


static PyObject *
_wrap_gtk_image_menu_item_set_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "image", NULL };
    PyGObject *py_image;
    GtkWidget *image = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ImageMenuItem.set_image", kwlist, &py_image))
        return NULL;
    if (py_image && pygobject_check(py_image, &PyGtkWidget_Type))
        image = GTK_WIDGET(py_image->obj);
    else if ((PyObject *)py_image != Py_None) {
        PyErr_SetString(PyExc_TypeError, "image should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(self->obj), (GtkWidget *) image);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_menu_item_get_image(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_image_menu_item_get_image(GTK_IMAGE_MENU_ITEM(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_image_menu_item_set_always_show_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "always_show", NULL };
    int always_show;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ImageMenuItem.set_always_show_image", kwlist, &always_show))
        return NULL;
    
    gtk_image_menu_item_set_always_show_image(GTK_IMAGE_MENU_ITEM(self->obj), always_show);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_menu_item_get_always_show_image(PyGObject *self)
{
    int ret;

    
    ret = gtk_image_menu_item_get_always_show_image(GTK_IMAGE_MENU_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_image_menu_item_set_use_stock(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_stock", NULL };
    int use_stock;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ImageMenuItem.set_use_stock", kwlist, &use_stock))
        return NULL;
    
    gtk_image_menu_item_set_use_stock(GTK_IMAGE_MENU_ITEM(self->obj), use_stock);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_menu_item_get_use_stock(PyGObject *self)
{
    int ret;

    
    ret = gtk_image_menu_item_get_use_stock(GTK_IMAGE_MENU_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_image_menu_item_set_accel_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_group", NULL };
    PyGObject *accel_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ImageMenuItem.set_accel_group", kwlist, &PyGtkAccelGroup_Type, &accel_group))
        return NULL;
    
    gtk_image_menu_item_set_accel_group(GTK_IMAGE_MENU_ITEM(self->obj), GTK_ACCEL_GROUP(accel_group->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkImageMenuItem_methods[] = {
    { "set_image", (PyCFunction)_wrap_gtk_image_menu_item_set_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_image", (PyCFunction)_wrap_gtk_image_menu_item_get_image, METH_NOARGS,
      NULL },
    { "set_always_show_image", (PyCFunction)_wrap_gtk_image_menu_item_set_always_show_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_always_show_image", (PyCFunction)_wrap_gtk_image_menu_item_get_always_show_image, METH_NOARGS,
      NULL },
    { "set_use_stock", (PyCFunction)_wrap_gtk_image_menu_item_set_use_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_stock", (PyCFunction)_wrap_gtk_image_menu_item_get_use_stock, METH_NOARGS,
      NULL },
    { "set_accel_group", (PyCFunction)_wrap_gtk_image_menu_item_set_accel_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkImageMenuItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ImageMenuItem",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkImageMenuItem_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_image_menu_item_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkIMContext ----------- */

static PyObject *
_wrap_gtk_im_context_set_client_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", NULL };
    PyGObject *py_window;
    GdkWindow *window = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IMContext.set_client_window", kwlist, &py_window))
        return NULL;
    if (py_window && pygobject_check(py_window, &PyGdkWindow_Type))
        window = GDK_WINDOW(py_window->obj);
    else if ((PyObject *)py_window != Py_None) {
        PyErr_SetString(PyExc_TypeError, "window should be a GdkWindow or None");
        return NULL;
    }
    
    gtk_im_context_set_client_window(GTK_IM_CONTEXT(self->obj), (GdkWindow *) window);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3149 "./gtk.override"
static PyObject *
_wrap_gtk_im_context_get_preedit_string(PyGObject *self)
{
    gchar *str;
    PangoAttrList *attrs;
    gint cursor_pos;
    PyObject *ret;

    gtk_im_context_get_preedit_string(GTK_IM_CONTEXT(self->obj),
                                      &str, &attrs, &cursor_pos);

    ret = Py_BuildValue("(sNi)", str,
                        pyg_boxed_new(PANGO_TYPE_ATTR_LIST, attrs, FALSE,TRUE),
                        cursor_pos);
    g_free(str);

    return ret;
}
#line 56979 "gtk.c"


#line 3169 "./gtk.override"
static PyObject *
_wrap_gtk_im_context_filter_keypress(PyGObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    PyObject *key;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkIMContext.filter_keypress", kwlist,
                                     &key))
        return NULL;

    if (!pyg_boxed_check(key, GDK_TYPE_EVENT)) {
        PyErr_SetString(PyExc_TypeError, "key must be a GdkEvent");
        return NULL;
    }

    ret = gtk_im_context_filter_keypress(GTK_IM_CONTEXT(self->obj),
                                         pyg_boxed_get(key, GdkEventKey));
    return PyBool_FromLong(ret);
}
#line 57005 "gtk.c"


static PyObject *
_wrap_gtk_im_context_focus_in(PyGObject *self)
{
    
    gtk_im_context_focus_in(GTK_IM_CONTEXT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_im_context_focus_out(PyGObject *self)
{
    
    gtk_im_context_focus_out(GTK_IM_CONTEXT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_im_context_reset(PyGObject *self)
{
    
    gtk_im_context_reset(GTK_IM_CONTEXT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_im_context_set_cursor_location(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "area", NULL };
    PyObject *py_area;
    GdkRectangle area = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.IMContext.set_cursor_location", kwlist, &py_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    
    gtk_im_context_set_cursor_location(GTK_IM_CONTEXT(self->obj), &area);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_im_context_set_use_preedit(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_preedit", NULL };
    int use_preedit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.IMContext.set_use_preedit", kwlist, &use_preedit))
        return NULL;
    
    gtk_im_context_set_use_preedit(GTK_IM_CONTEXT(self->obj), use_preedit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_im_context_set_surrounding(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", "len", "cursor_index", NULL };
    char *text;
    int len, cursor_index;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sii:Gtk.IMContext.set_surrounding", kwlist, &text, &len, &cursor_index))
        return NULL;
    
    gtk_im_context_set_surrounding(GTK_IM_CONTEXT(self->obj), text, len, cursor_index);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3193 "./gtk.override"
static PyObject *
_wrap_gtk_im_context_get_surrounding(PyGObject *self)
{
    gchar *text;
    gint cursor_index;

    if (gtk_im_context_get_surrounding(GTK_IM_CONTEXT(self->obj),
                                       &text, &cursor_index)) {
        PyObject *ret = Py_BuildValue("(si)", text, cursor_index);

        g_free(text);
        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 57104 "gtk.c"


static PyObject *
_wrap_gtk_im_context_delete_surrounding(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "offset", "n_chars", NULL };
    int offset, n_chars, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.IMContext.delete_surrounding", kwlist, &offset, &n_chars))
        return NULL;
    
    ret = gtk_im_context_delete_surrounding(GTK_IM_CONTEXT(self->obj), offset, n_chars);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkIMContext__do_preedit_start(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IMContext.preedit_start", kwlist, &PyGtkIMContext_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->preedit_start)
        GTK_IM_CONTEXT_CLASS(klass)->preedit_start(GTK_IM_CONTEXT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.preedit_start not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIMContext__do_preedit_end(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IMContext.preedit_end", kwlist, &PyGtkIMContext_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->preedit_end)
        GTK_IM_CONTEXT_CLASS(klass)->preedit_end(GTK_IM_CONTEXT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.preedit_end not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIMContext__do_preedit_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IMContext.preedit_changed", kwlist, &PyGtkIMContext_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->preedit_changed)
        GTK_IM_CONTEXT_CLASS(klass)->preedit_changed(GTK_IM_CONTEXT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.preedit_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIMContext__do_commit(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "str", NULL };
    PyGObject *self;
    char *str;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.IMContext.commit", kwlist, &PyGtkIMContext_Type, &self, &str))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->commit)
        GTK_IM_CONTEXT_CLASS(klass)->commit(GTK_IM_CONTEXT(self->obj), str);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.commit not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIMContext__do_retrieve_surrounding(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IMContext.retrieve_surrounding", kwlist, &PyGtkIMContext_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->retrieve_surrounding)
        ret = GTK_IM_CONTEXT_CLASS(klass)->retrieve_surrounding(GTK_IM_CONTEXT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.retrieve_surrounding not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkIMContext__do_delete_surrounding(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "offset", "n_chars", NULL };
    PyGObject *self;
    int offset, n_chars, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.IMContext.delete_surrounding", kwlist, &PyGtkIMContext_Type, &self, &offset, &n_chars))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->delete_surrounding)
        ret = GTK_IM_CONTEXT_CLASS(klass)->delete_surrounding(GTK_IM_CONTEXT(self->obj), offset, n_chars);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.delete_surrounding not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkIMContext__do_set_client_window(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", NULL };
    PyGObject *self, *window;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.IMContext.set_client_window", kwlist, &PyGtkIMContext_Type, &self, &PyGdkWindow_Type, &window))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->set_client_window)
        GTK_IM_CONTEXT_CLASS(klass)->set_client_window(GTK_IM_CONTEXT(self->obj), GDK_WINDOW(window->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.set_client_window not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIMContext__do_filter_keypress(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.IMContext.filter_keypress", kwlist, &PyGtkIMContext_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->filter_keypress)
        ret = GTK_IM_CONTEXT_CLASS(klass)->filter_keypress(GTK_IM_CONTEXT(self->obj), (GdkEventKey *)event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.filter_keypress not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkIMContext__do_focus_in(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IMContext.focus_in", kwlist, &PyGtkIMContext_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->focus_in)
        GTK_IM_CONTEXT_CLASS(klass)->focus_in(GTK_IM_CONTEXT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.focus_in not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIMContext__do_focus_out(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IMContext.focus_out", kwlist, &PyGtkIMContext_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->focus_out)
        GTK_IM_CONTEXT_CLASS(klass)->focus_out(GTK_IM_CONTEXT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.focus_out not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIMContext__do_reset(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IMContext.reset", kwlist, &PyGtkIMContext_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->reset)
        GTK_IM_CONTEXT_CLASS(klass)->reset(GTK_IM_CONTEXT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.reset not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIMContext__do_set_cursor_location(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "area", NULL };
    PyGObject *self;
    PyObject *py_area;
    GdkRectangle area = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.IMContext.set_cursor_location", kwlist, &PyGtkIMContext_Type, &self, &py_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->set_cursor_location)
        GTK_IM_CONTEXT_CLASS(klass)->set_cursor_location(GTK_IM_CONTEXT(self->obj), &area);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.set_cursor_location not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIMContext__do_set_use_preedit(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "use_preedit", NULL };
    PyGObject *self;
    int use_preedit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.IMContext.set_use_preedit", kwlist, &PyGtkIMContext_Type, &self, &use_preedit))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->set_use_preedit)
        GTK_IM_CONTEXT_CLASS(klass)->set_use_preedit(GTK_IM_CONTEXT(self->obj), use_preedit);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.set_use_preedit not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkIMContext__do_set_surrounding(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "text", "len", "cursor_index", NULL };
    PyGObject *self;
    char *text;
    int len, cursor_index;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!sii:Gtk.IMContext.set_surrounding", kwlist, &PyGtkIMContext_Type, &self, &text, &len, &cursor_index))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_IM_CONTEXT_CLASS(klass)->set_surrounding)
        GTK_IM_CONTEXT_CLASS(klass)->set_surrounding(GTK_IM_CONTEXT(self->obj), text, len, cursor_index);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.IMContext.set_surrounding not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkIMContext_methods[] = {
    { "set_client_window", (PyCFunction)_wrap_gtk_im_context_set_client_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_preedit_string", (PyCFunction)_wrap_gtk_im_context_get_preedit_string, METH_NOARGS,
      NULL },
    { "filter_keypress", (PyCFunction)_wrap_gtk_im_context_filter_keypress, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "focus_in", (PyCFunction)_wrap_gtk_im_context_focus_in, METH_NOARGS,
      NULL },
    { "focus_out", (PyCFunction)_wrap_gtk_im_context_focus_out, METH_NOARGS,
      NULL },
    { "reset", (PyCFunction)_wrap_gtk_im_context_reset, METH_NOARGS,
      NULL },
    { "set_cursor_location", (PyCFunction)_wrap_gtk_im_context_set_cursor_location, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_use_preedit", (PyCFunction)_wrap_gtk_im_context_set_use_preedit, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_surrounding", (PyCFunction)_wrap_gtk_im_context_set_surrounding, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_surrounding", (PyCFunction)_wrap_gtk_im_context_get_surrounding, METH_NOARGS,
      NULL },
    { "delete_surrounding", (PyCFunction)_wrap_gtk_im_context_delete_surrounding, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_preedit_start", (PyCFunction)_wrap_GtkIMContext__do_preedit_start, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_preedit_end", (PyCFunction)_wrap_GtkIMContext__do_preedit_end, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_preedit_changed", (PyCFunction)_wrap_GtkIMContext__do_preedit_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_commit", (PyCFunction)_wrap_GtkIMContext__do_commit, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_retrieve_surrounding", (PyCFunction)_wrap_GtkIMContext__do_retrieve_surrounding, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_delete_surrounding", (PyCFunction)_wrap_GtkIMContext__do_delete_surrounding, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_client_window", (PyCFunction)_wrap_GtkIMContext__do_set_client_window, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_filter_keypress", (PyCFunction)_wrap_GtkIMContext__do_filter_keypress, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_focus_in", (PyCFunction)_wrap_GtkIMContext__do_focus_in, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_focus_out", (PyCFunction)_wrap_GtkIMContext__do_focus_out, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_reset", (PyCFunction)_wrap_GtkIMContext__do_reset, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_cursor_location", (PyCFunction)_wrap_GtkIMContext__do_set_cursor_location, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_use_preedit", (PyCFunction)_wrap_GtkIMContext__do_set_use_preedit, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_surrounding", (PyCFunction)_wrap_GtkIMContext__do_set_surrounding, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkIMContext_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.IMContext",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkIMContext_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkIMContext__proxy_do_preedit_start(GtkIMContext *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_preedit_start");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIMContext__proxy_do_preedit_end(GtkIMContext *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_preedit_end");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIMContext__proxy_do_preedit_changed(GtkIMContext *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_preedit_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIMContext__proxy_do_commit(GtkIMContext *self, const gchar*str)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_str = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (str)
        py_str = PyString_FromString(str);
    if (!py_str) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_str);
    
    py_method = PyObject_GetAttrString(py_self, "do_commit");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkIMContext__proxy_do_retrieve_surrounding(GtkIMContext *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_retrieve_surrounding");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkIMContext__proxy_do_delete_surrounding(GtkIMContext *self, gint offset, gint n_chars)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_offset;
    PyObject *py_n_chars;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_offset = PyInt_FromLong(offset);
    py_n_chars = PyInt_FromLong(n_chars);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_offset);
    PyTuple_SET_ITEM(py_args, 1, py_n_chars);
    
    py_method = PyObject_GetAttrString(py_self, "do_delete_surrounding");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkIMContext__proxy_do_set_client_window(GtkIMContext *self, GdkWindow*window)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_client_window");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkIMContext__proxy_do_filter_keypress(GtkIMContext *self, GdkEventKey*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_filter_keypress");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkIMContext__proxy_do_focus_in(GtkIMContext *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_focus_in");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIMContext__proxy_do_focus_out(GtkIMContext *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_focus_out");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIMContext__proxy_do_reset(GtkIMContext *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_reset");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIMContext__proxy_do_set_cursor_location(GtkIMContext *self, GdkRectangle*area)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_area;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_area);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_cursor_location");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIMContext__proxy_do_set_use_preedit(GtkIMContext *self, gboolean use_preedit)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_use_preedit;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_use_preedit = use_preedit? Py_True : Py_False;
    
    py_args = PyTuple_New(1);
    Py_INCREF(py_use_preedit);
    PyTuple_SET_ITEM(py_args, 0, py_use_preedit);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_use_preedit");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkIMContext__proxy_do_set_surrounding(GtkIMContext *self, const gchar*text, gint len, gint cursor_index)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_text = NULL;
    PyObject *py_len;
    PyObject *py_cursor_index;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (text)
        py_text = PyString_FromString(text);
    if (!py_text) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_len = PyInt_FromLong(len);
    py_cursor_index = PyInt_FromLong(cursor_index);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_text);
    PyTuple_SET_ITEM(py_args, 1, py_len);
    PyTuple_SET_ITEM(py_args, 2, py_cursor_index);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_surrounding");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkIMContext_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkIMContextClass *klass = GTK_IM_CONTEXT_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_preedit_start");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "preedit_start")))
            klass->preedit_start = _wrap_GtkIMContext__proxy_do_preedit_start;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_preedit_end");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "preedit_end")))
            klass->preedit_end = _wrap_GtkIMContext__proxy_do_preedit_end;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_preedit_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "preedit_changed")))
            klass->preedit_changed = _wrap_GtkIMContext__proxy_do_preedit_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_commit");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "commit")))
            klass->commit = _wrap_GtkIMContext__proxy_do_commit;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_retrieve_surrounding");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "retrieve_surrounding")))
            klass->retrieve_surrounding = _wrap_GtkIMContext__proxy_do_retrieve_surrounding;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_delete_surrounding");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "delete_surrounding")))
            klass->delete_surrounding = _wrap_GtkIMContext__proxy_do_delete_surrounding;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_client_window");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_client_window")))
            klass->set_client_window = _wrap_GtkIMContext__proxy_do_set_client_window;
        Py_DECREF(o);
    }

    /* overriding do_get_preedit_string is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_filter_keypress");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "filter_keypress")))
            klass->filter_keypress = _wrap_GtkIMContext__proxy_do_filter_keypress;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_focus_in");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "focus_in")))
            klass->focus_in = _wrap_GtkIMContext__proxy_do_focus_in;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_focus_out");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "focus_out")))
            klass->focus_out = _wrap_GtkIMContext__proxy_do_focus_out;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_reset");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "reset")))
            klass->reset = _wrap_GtkIMContext__proxy_do_reset;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_cursor_location");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_cursor_location")))
            klass->set_cursor_location = _wrap_GtkIMContext__proxy_do_set_cursor_location;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_use_preedit");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_use_preedit")))
            klass->set_use_preedit = _wrap_GtkIMContext__proxy_do_set_use_preedit;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_surrounding");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_surrounding")))
            klass->set_surrounding = _wrap_GtkIMContext__proxy_do_set_surrounding;
        Py_DECREF(o);
    }

    /* overriding do_get_surrounding is currently not supported */
    return 0;
}


/* ----------- GtkIMContextSimple ----------- */

static int
_wrap_gtk_im_context_simple_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.IMContextSimple.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.IMContextSimple object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkIMContextSimple_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.IMContextSimple",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_im_context_simple_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkIMMulticontext ----------- */

static int
_wrap_gtk_im_multicontext_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.IMMulticontext.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.IMMulticontext object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_im_multicontext_append_menuitems(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "menushell", NULL };
    PyGObject *menushell;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.IMMulticontext.append_menuitems", kwlist, &PyGtkMenuShell_Type, &menushell))
        return NULL;
    
    gtk_im_multicontext_append_menuitems(GTK_IM_MULTICONTEXT(self->obj), GTK_MENU_SHELL(menushell->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_im_multicontext_get_context_id(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_im_multicontext_get_context_id(GTK_IM_MULTICONTEXT(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_im_multicontext_set_context_id(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "context_id", NULL };
    char *context_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.IMMulticontext.set_context_id", kwlist, &context_id))
        return NULL;
    
    gtk_im_multicontext_set_context_id(GTK_IM_MULTICONTEXT(self->obj), context_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkIMMulticontext_methods[] = {
    { "append_menuitems", (PyCFunction)_wrap_gtk_im_multicontext_append_menuitems, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_context_id", (PyCFunction)_wrap_gtk_im_multicontext_get_context_id, METH_NOARGS,
      NULL },
    { "set_context_id", (PyCFunction)_wrap_gtk_im_multicontext_set_context_id, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkIMMulticontext_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.IMMulticontext",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkIMMulticontext_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_im_multicontext_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkInputDialog ----------- */

static int
_wrap_gtk_input_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.InputDialog.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.InputDialog object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_GtkInputDialog__do_enable_device(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "device", NULL };
    PyGObject *self, *device;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.InputDialog.enable_device", kwlist, &PyGtkInputDialog_Type, &self, &PyGdkDevice_Type, &device))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_INPUT_DIALOG_CLASS(klass)->enable_device)
        GTK_INPUT_DIALOG_CLASS(klass)->enable_device(GTK_INPUT_DIALOG(self->obj), GDK_DEVICE(device->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.InputDialog.enable_device not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkInputDialog__do_disable_device(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "device", NULL };
    PyGObject *self, *device;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.InputDialog.disable_device", kwlist, &PyGtkInputDialog_Type, &self, &PyGdkDevice_Type, &device))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_INPUT_DIALOG_CLASS(klass)->disable_device)
        GTK_INPUT_DIALOG_CLASS(klass)->disable_device(GTK_INPUT_DIALOG(self->obj), GDK_DEVICE(device->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.InputDialog.disable_device not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkInputDialog_methods[] = {
    { "do_enable_device", (PyCFunction)_wrap_GtkInputDialog__do_enable_device, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_disable_device", (PyCFunction)_wrap_GtkInputDialog__do_disable_device, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkInputDialog_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.InputDialog",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkInputDialog_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_input_dialog_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkInputDialog__proxy_do_enable_device(GtkInputDialog *self, GdkDevice*device)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_device = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (device)
        py_device = pygobject_new((GObject *) device);
    else {
        Py_INCREF(Py_None);
        py_device = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_device);
    
    py_method = PyObject_GetAttrString(py_self, "do_enable_device");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkInputDialog__proxy_do_disable_device(GtkInputDialog *self, GdkDevice*device)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_device = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (device)
        py_device = pygobject_new((GObject *) device);
    else {
        Py_INCREF(Py_None);
        py_device = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_device);
    
    py_method = PyObject_GetAttrString(py_self, "do_disable_device");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkInputDialog_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkInputDialogClass *klass = GTK_INPUT_DIALOG_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_enable_device");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "enable_device")))
            klass->enable_device = _wrap_GtkInputDialog__proxy_do_enable_device;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_disable_device");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "disable_device")))
            klass->disable_device = _wrap_GtkInputDialog__proxy_do_disable_device;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkInvisible ----------- */

static int
_wrap_gtk_invisible_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Invisible.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Invisible object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_invisible_set_screen(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *screen;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Invisible.set_screen", kwlist, &PyGdkScreen_Type, &screen))
        return NULL;
    
    gtk_invisible_set_screen(GTK_INVISIBLE(self->obj), GDK_SCREEN(screen->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_invisible_get_screen(PyGObject *self)
{
    GdkScreen *ret;

    
    ret = gtk_invisible_get_screen(GTK_INVISIBLE(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkInvisible_methods[] = {
    { "set_screen", (PyCFunction)_wrap_gtk_invisible_set_screen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_screen", (PyCFunction)_wrap_gtk_invisible_get_screen, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkInvisible_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Invisible",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkInvisible_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_invisible_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkItemFactory ----------- */

static int
_wrap_gtk_item_factory_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "container_type", "path", "accel_group", NULL };
    PyObject *py_container_type = NULL;
    char *path;
    GType container_type;
    GtkAccelGroup *accel_group = NULL;
    PyGObject *py_accel_group = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Os|O:Gtk.ItemFactory.__init__", kwlist, &py_container_type, &path, &py_accel_group))
        return -1;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.UIManager") < 0)
        return -1;
    if ((container_type = pyg_type_from_object(py_container_type)) == 0)
        return -1;
    if ((PyObject *)py_accel_group == Py_None)
        accel_group = NULL;
    else if (py_accel_group && pygobject_check(py_accel_group, &PyGtkAccelGroup_Type))
        accel_group = GTK_ACCEL_GROUP(py_accel_group->obj);
    else if (py_accel_group) {
        PyErr_SetString(PyExc_TypeError, "accel_group should be a GtkAccelGroup or None");
        return -1;
    }
    self->obj = (GObject *)gtk_item_factory_new(container_type, path, (GtkAccelGroup *) accel_group);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkItemFactory object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}

static PyObject *
_wrap_gtk_item_factory_construct(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "container_type", "path", "accel_group", NULL };
    PyObject *py_container_type = NULL;
    char *path;
    GType container_type;
    PyGObject *accel_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OsO!:Gtk.ItemFactory.construct", kwlist, &py_container_type, &path, &PyGtkAccelGroup_Type, &accel_group))
        return NULL;
    if ((container_type = pyg_type_from_object(py_container_type)) == 0)
        return NULL;
    
    gtk_item_factory_construct(GTK_ITEM_FACTORY(self->obj), container_type, path, GTK_ACCEL_GROUP(accel_group->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_item_factory_get_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    char *path;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ItemFactory.get_item", kwlist, &path))
        return NULL;
    
    ret = gtk_item_factory_get_item(GTK_ITEM_FACTORY(self->obj), path);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_item_factory_get_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    char *path;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ItemFactory.get_widget", kwlist, &path))
        return NULL;
    
    ret = gtk_item_factory_get_widget(GTK_ITEM_FACTORY(self->obj), path);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_item_factory_get_widget_by_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", NULL };
    PyObject *py_action = NULL;
    GtkWidget *ret;
    guint action = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ItemFactory.get_widget_by_action", kwlist, &py_action))
        return NULL;
    if (py_action) {
        if (PyLong_Check(py_action))
            action = PyLong_AsUnsignedLong(py_action);
        else if (PyInt_Check(py_action))
            action = PyInt_AsLong(py_action);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'action' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_item_factory_get_widget_by_action(GTK_ITEM_FACTORY(self->obj), action);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_item_factory_get_item_by_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", NULL };
    PyObject *py_action = NULL;
    GtkWidget *ret;
    guint action = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ItemFactory.get_item_by_action", kwlist, &py_action))
        return NULL;
    if (py_action) {
        if (PyLong_Check(py_action))
            action = PyLong_AsUnsignedLong(py_action);
        else if (PyInt_Check(py_action))
            action = PyInt_AsLong(py_action);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'action' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_item_factory_get_item_by_action(GTK_ITEM_FACTORY(self->obj), action);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 1421 "./gtk.override"
static void
pygtk_item_factory_cb(PyGtkCustomNotify *cunote,
                      guint action, GtkWidget *widget)
{
    PyGILState_STATE state;
    PyObject *ret;

    state = pyg_gil_state_ensure();
    if (cunote->data)
        ret = PyObject_CallFunction(cunote->func, "OiO", cunote->data, action,
                                    pygobject_new((GObject *)widget));
    else
        ret = PyObject_CallFunction(cunote->func, "iO", action,
                                    pygobject_new((GObject *)widget));
    if (ret == NULL) {
        PyErr_Print();
    } else
        Py_DECREF(ret);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_item_factory_create_items(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "callback_data", NULL };
    PyObject *list, *cb, *cbdata = NULL;
    GtkItemFactoryEntry ent;
    PyObject *extra_data = NULL;
    GtkItemFactory *ifact;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkItemFactory.create_items", kwlist,
                                     &list, &cbdata))
        return NULL;

    if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    ifact = GTK_ITEM_FACTORY(self->obj);
    len = PySequence_Size(list);
    for (i = 0; i < len; i++) {
        PyGtkCustomNotify *cunote = NULL;
        PyObject *item = PySequence_GetItem(list, i);
        Py_DECREF(item);

        memset(&ent, 0, sizeof(ent));
        cb = Py_None;

        if (!PyArg_ParseTuple(item, "s|zOizO", &(ent.path), &(ent.accelerator),
                              &cb, &(ent.callback_action), &(ent.item_type),
                              &extra_data)) {
            return NULL;
        }

        if (cb == Py_None) {
            ent.callback = NULL;
        } else {
            ent.callback = (GtkItemFactoryCallback)pygtk_item_factory_cb;
            cunote = g_new0(PyGtkCustomNotify, 1);
            cunote->func = cb;
            cunote->data = cbdata;
            Py_XINCREF(cunote->func);
            Py_XINCREF(cunote->data);
        }

        if (extra_data != NULL) {
            if (PyString_Check(extra_data)) {
                ent.extra_data = PyString_AsString(extra_data);
            } else if (pygobject_check(extra_data, &PyGdkPixbuf_Type)) {
		/* create_items actually expects inline image data 
		 * so let's create it for the user from the pixbuf
		 * it's not optimal but it's convenient
		 */  
		GdkPixdata pixdata; 
		GdkPixbuf * pixbuf;
		guint8 * serialstr;
		guint len;
		
		pixbuf = GDK_PIXBUF(pygobject_get(extra_data));
		gdk_pixdata_from_pixbuf(&pixdata, pixbuf, FALSE);
		serialstr = gdk_pixdata_serialize(&pixdata, &len);
                ent.extra_data = serialstr;
            } else {
                PyErr_SetString(PyExc_TypeError,
                                "last argument must be a GdkPixBuf or a string");
                return NULL;
            }
        }
        if (cunote != NULL) {
	    PyGILState_STATE state;
	    state = pyg_gil_state_ensure();
            g_object_weak_ref(G_OBJECT(ifact),
                              (GWeakNotify) pygtk_custom_destroy_notify,
                              cunote);
	    pyg_gil_state_release(state);
        }

        gtk_item_factory_create_item(ifact, &ent, cunote, 1);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 59369 "gtk.c"


static PyObject *
_wrap_gtk_item_factory_delete_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    char *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ItemFactory.delete_item", kwlist, &path))
        return NULL;
    
    gtk_item_factory_delete_item(GTK_ITEM_FACTORY(self->obj), path);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_item_factory_popup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", "mouse_button", "time", NULL };
    PyObject *py_x = NULL, *py_y = NULL, *py_mouse_button = NULL;
    unsigned long time = GDK_CURRENT_TIME;
    guint x = 0, y = 0, mouse_button = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOO|k:Gtk.ItemFactory.popup", kwlist, &py_x, &py_y, &py_mouse_button, &time))
        return NULL;
    if (py_x) {
        if (PyLong_Check(py_x))
            x = PyLong_AsUnsignedLong(py_x);
        else if (PyInt_Check(py_x))
            x = PyInt_AsLong(py_x);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'x' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_y) {
        if (PyLong_Check(py_y))
            y = PyLong_AsUnsignedLong(py_y);
        else if (PyInt_Check(py_y))
            y = PyInt_AsLong(py_y);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'y' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_mouse_button) {
        if (PyLong_Check(py_mouse_button))
            mouse_button = PyLong_AsUnsignedLong(py_mouse_button);
        else if (PyInt_Check(py_mouse_button))
            mouse_button = PyInt_AsLong(py_mouse_button);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'mouse_button' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_item_factory_popup(GTK_ITEM_FACTORY(self->obj), x, y, mouse_button, time);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkItemFactory_methods[] = {
    { "construct", (PyCFunction)_wrap_gtk_item_factory_construct, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_item", (PyCFunction)_wrap_gtk_item_factory_get_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_widget", (PyCFunction)_wrap_gtk_item_factory_get_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_widget_by_action", (PyCFunction)_wrap_gtk_item_factory_get_widget_by_action, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_item_by_action", (PyCFunction)_wrap_gtk_item_factory_get_item_by_action, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "create_items", (PyCFunction)_wrap_gtk_item_factory_create_items, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "delete_item", (PyCFunction)_wrap_gtk_item_factory_delete_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "popup", (PyCFunction)_wrap_gtk_item_factory_popup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkItemFactory_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ItemFactory",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkItemFactory_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_item_factory_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkLayout ----------- */

static int
_wrap_gtk_layout_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[2];
    PyObject *parsed_args[2] = {NULL, };
    char *arg_names[] = {"hadjustment", "vadjustment", NULL };
    char *prop_names[] = {"hadjustment", "vadjustment", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:gtk.Layout.__init__" , arg_names , &parsed_args[0] , &parsed_args[1]))
        return -1;

    memset(params, 0, sizeof(GParameter)*2);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Layout object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_layout_put(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child_widget", "x", "y", NULL };
    PyGObject *child_widget;
    int x, y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.Layout.put", kwlist, &PyGtkWidget_Type, &child_widget, &x, &y))
        return NULL;
    
    gtk_layout_put(GTK_LAYOUT(self->obj), GTK_WIDGET(child_widget->obj), x, y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_layout_move(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child_widget", "x", "y", NULL };
    PyGObject *child_widget;
    int x, y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.Layout.move", kwlist, &PyGtkWidget_Type, &child_widget, &x, &y))
        return NULL;
    
    gtk_layout_move(GTK_LAYOUT(self->obj), GTK_WIDGET(child_widget->obj), x, y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_layout_set_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", "height", NULL };
    PyObject *py_width = NULL, *py_height = NULL;
    guint width = 0, height = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Layout.set_size", kwlist, &py_width, &py_height))
        return NULL;
    if (py_width) {
        if (PyLong_Check(py_width))
            width = PyLong_AsUnsignedLong(py_width);
        else if (PyInt_Check(py_width))
            width = PyInt_AsLong(py_width);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'width' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_height) {
        if (PyLong_Check(py_height))
            height = PyLong_AsUnsignedLong(py_height);
        else if (PyInt_Check(py_height))
            height = PyInt_AsLong(py_height);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'height' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_layout_set_size(GTK_LAYOUT(self->obj), width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3098 "./gtk.override"
static PyObject *
_wrap_gtk_layout_get_size(PyGObject *self)
{
    guint width, height;
    gtk_layout_get_size(GTK_LAYOUT(self->obj), &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
#line 59610 "gtk.c"


static PyObject *
_wrap_gtk_layout_get_hadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_layout_get_hadjustment(GTK_LAYOUT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_layout_get_vadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_layout_get_vadjustment(GTK_LAYOUT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_layout_set_hadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment;
    GtkAdjustment *adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Layout.set_hadjustment", kwlist, &py_adjustment))
        return NULL;
    if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if ((PyObject *)py_adjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }
    
    gtk_layout_set_hadjustment(GTK_LAYOUT(self->obj), (GtkAdjustment *) adjustment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_layout_set_vadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment;
    GtkAdjustment *adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Layout.set_vadjustment", kwlist, &py_adjustment))
        return NULL;
    if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if ((PyObject *)py_adjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }
    
    gtk_layout_set_vadjustment(GTK_LAYOUT(self->obj), (GtkAdjustment *) adjustment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_layout_freeze(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_layout_freeze(GTK_LAYOUT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_layout_thaw(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_layout_thaw(GTK_LAYOUT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_layout_get_bin_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_layout_get_bin_window(GTK_LAYOUT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkLayout__do_set_scroll_adjustments(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "hadjustment", "vadjustment", NULL };
    PyGObject *self, *hadjustment, *vadjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!:Gtk.Layout.set_scroll_adjustments", kwlist, &PyGtkLayout_Type, &self, &PyGtkAdjustment_Type, &hadjustment, &PyGtkAdjustment_Type, &vadjustment))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LAYOUT_CLASS(klass)->set_scroll_adjustments)
        GTK_LAYOUT_CLASS(klass)->set_scroll_adjustments(GTK_LAYOUT(self->obj), GTK_ADJUSTMENT(hadjustment->obj), GTK_ADJUSTMENT(vadjustment->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Layout.set_scroll_adjustments not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkLayout_methods[] = {
    { "put", (PyCFunction)_wrap_gtk_layout_put, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move", (PyCFunction)_wrap_gtk_layout_move, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_size", (PyCFunction)_wrap_gtk_layout_set_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_size", (PyCFunction)_wrap_gtk_layout_get_size, METH_NOARGS,
      NULL },
    { "get_hadjustment", (PyCFunction)_wrap_gtk_layout_get_hadjustment, METH_NOARGS,
      NULL },
    { "get_vadjustment", (PyCFunction)_wrap_gtk_layout_get_vadjustment, METH_NOARGS,
      NULL },
    { "set_hadjustment", (PyCFunction)_wrap_gtk_layout_set_hadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_vadjustment", (PyCFunction)_wrap_gtk_layout_set_vadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "freeze", (PyCFunction)_wrap_gtk_layout_freeze, METH_NOARGS,
      NULL },
    { "thaw", (PyCFunction)_wrap_gtk_layout_thaw, METH_NOARGS,
      NULL },
    { "get_bin_window", (PyCFunction)_wrap_gtk_layout_get_bin_window, METH_NOARGS,
      NULL },
    { "do_set_scroll_adjustments", (PyCFunction)_wrap_GtkLayout__do_set_scroll_adjustments, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_layout__get_bin_window(PyObject *self, void *closure)
{
    GdkWindow *ret;

    ret = GTK_LAYOUT(pygobject_get(self))->bin_window;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyGetSetDef gtk_layout_getsets[] = {
    { "bin_window", (getter)_wrap_gtk_layout__get_bin_window, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkLayout_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Layout",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkLayout_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_layout_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_layout_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkLayout__proxy_do_set_scroll_adjustments(GtkLayout *self, GtkAdjustment*hadjustment, GtkAdjustment*vadjustment)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_hadjustment = NULL;
    PyObject *py_vadjustment = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (hadjustment)
        py_hadjustment = pygobject_new((GObject *) hadjustment);
    else {
        Py_INCREF(Py_None);
        py_hadjustment = Py_None;
    }
    if (vadjustment)
        py_vadjustment = pygobject_new((GObject *) vadjustment);
    else {
        Py_INCREF(Py_None);
        py_vadjustment = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_hadjustment);
    PyTuple_SET_ITEM(py_args, 1, py_vadjustment);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_scroll_adjustments");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkLayout_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkLayoutClass *klass = GTK_LAYOUT_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_scroll_adjustments");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_scroll_adjustments")))
            klass->set_scroll_adjustments = _wrap_GtkLayout__proxy_do_set_scroll_adjustments;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkList ----------- */

 static int
_wrap_gtk_list_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.List.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.List object");
        return -1;
    }
    return 0;
}

#line 2336 "./gtk.override"
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure);
static PyObject *
_wrap_gtk_list_get_selection(PyGObject *self)
{
    return _wrap_gtk_list__get_selection(self, NULL);
}
#line 59955 "gtk.c"


#line 2197 "./gtk.override"
static PyObject *
_wrap_gtk_list_insert_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", "position", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int position, len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!i:GtkList.insert_items",
                                     kwlist, &PyList_Type, &py_items,
                                     &position))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_insert_items(GTK_LIST(self->obj), items, position);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 59986 "gtk.c"


#line 2226 "./gtk.override"
static PyObject *
_wrap_gtk_list_append_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.append_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_append_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 60016 "gtk.c"


#line 2254 "./gtk.override"
static PyObject *
_wrap_gtk_list_prepend_items(PyGObject *self, PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.preppend_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_prepend_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 60046 "gtk.c"


#line 2282 "./gtk.override"
static PyObject *
_wrap_gtk_list_remove_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.remove_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_remove_items(GTK_LIST(self->obj), items);
    g_list_free(items);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 60077 "gtk.c"


static PyObject *
_wrap_gtk_list_clear_items(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start", "end", NULL };
    int start, end;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.List.clear_items", kwlist, &start, &end))
        return NULL;
    
    gtk_list_clear_items(GTK_LIST(self->obj), start, end);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_select_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item", NULL };
    int item;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.List.select_item", kwlist, &item))
        return NULL;
    
    gtk_list_select_item(GTK_LIST(self->obj), item);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_unselect_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item", NULL };
    int item;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.List.unselect_item", kwlist, &item))
        return NULL;
    
    gtk_list_unselect_item(GTK_LIST(self->obj), item);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_select_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.List.select_child", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    gtk_list_select_child(GTK_LIST(self->obj), GTK_WIDGET(child->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_unselect_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.List.unselect_child", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    gtk_list_unselect_child(GTK_LIST(self->obj), GTK_WIDGET(child->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_child_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.List.child_position", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    ret = gtk_list_child_position(GTK_LIST(self->obj), GTK_WIDGET(child->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_list_set_selection_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mode", NULL };
    PyObject *py_mode = NULL;
    GtkSelectionMode mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.List.set_selection_mode", kwlist, &py_mode))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SELECTION_MODE, py_mode, (gpointer)&mode))
        return NULL;
    
    gtk_list_set_selection_mode(GTK_LIST(self->obj), mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_extend_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "scroll_type", "position", "auto_start_selection", NULL };
    PyObject *py_scroll_type = NULL;
    double position;
    int auto_start_selection;
    GtkScrollType scroll_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Odi:Gtk.List.extend_selection", kwlist, &py_scroll_type, &position, &auto_start_selection))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll_type, (gpointer)&scroll_type))
        return NULL;
    
    gtk_list_extend_selection(GTK_LIST(self->obj), scroll_type, position, auto_start_selection);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_start_selection(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    
    gtk_list_start_selection(GTK_LIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_end_selection(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    
    gtk_list_end_selection(GTK_LIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_select_all(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    
    gtk_list_select_all(GTK_LIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_unselect_all(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    
    gtk_list_unselect_all(GTK_LIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_scroll_horizontal(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "scroll_type", "position", NULL };
    PyObject *py_scroll_type = NULL;
    double position;
    GtkScrollType scroll_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Od:Gtk.List.scroll_horizontal", kwlist, &py_scroll_type, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll_type, (gpointer)&scroll_type))
        return NULL;
    
    gtk_list_scroll_horizontal(GTK_LIST(self->obj), scroll_type, position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_scroll_vertical(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "scroll_type", "position", NULL };
    PyObject *py_scroll_type = NULL;
    double position;
    GtkScrollType scroll_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Od:Gtk.List.scroll_vertical", kwlist, &py_scroll_type, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll_type, (gpointer)&scroll_type))
        return NULL;
    
    gtk_list_scroll_vertical(GTK_LIST(self->obj), scroll_type, position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_toggle_add_mode(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    
    gtk_list_toggle_add_mode(GTK_LIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_toggle_focus_row(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    
    gtk_list_toggle_focus_row(GTK_LIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_toggle_row(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item", NULL };
    PyGObject *item;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.List.toggle_row", kwlist, &PyGtkWidget_Type, &item))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    
    gtk_list_toggle_row(GTK_LIST(self->obj), GTK_WIDGET(item->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_undo_selection(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    
    gtk_list_undo_selection(GTK_LIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_end_drag_selection(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkListStore/GtkTreeView") < 0)
        return NULL;
    
    gtk_list_end_drag_selection(GTK_LIST(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkList__do_selection_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.List.selection_changed", kwlist, &PyGtkList_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_CLASS(klass)->selection_changed)
        GTK_LIST_CLASS(klass)->selection_changed(GTK_LIST(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.List.selection_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkList__do_select_child(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "child", NULL };
    PyGObject *self, *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.List.select_child", kwlist, &PyGtkList_Type, &self, &PyGtkWidget_Type, &child))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_CLASS(klass)->select_child)
        GTK_LIST_CLASS(klass)->select_child(GTK_LIST(self->obj), GTK_WIDGET(child->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.List.select_child not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkList__do_unselect_child(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "child", NULL };
    PyGObject *self, *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.List.unselect_child", kwlist, &PyGtkList_Type, &self, &PyGtkWidget_Type, &child))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_CLASS(klass)->unselect_child)
        GTK_LIST_CLASS(klass)->unselect_child(GTK_LIST(self->obj), GTK_WIDGET(child->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.List.unselect_child not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkList_methods[] = {
    { "get_selection", (PyCFunction)_wrap_gtk_list_get_selection, METH_NOARGS,
      NULL },
    { "insert_items", (PyCFunction)_wrap_gtk_list_insert_items, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "append_items", (PyCFunction)_wrap_gtk_list_append_items, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend_items", (PyCFunction)_wrap_gtk_list_prepend_items, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_items", (PyCFunction)_wrap_gtk_list_remove_items, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "clear_items", (PyCFunction)_wrap_gtk_list_clear_items, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_item", (PyCFunction)_wrap_gtk_list_select_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_item", (PyCFunction)_wrap_gtk_list_unselect_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_child", (PyCFunction)_wrap_gtk_list_select_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_child", (PyCFunction)_wrap_gtk_list_unselect_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "child_position", (PyCFunction)_wrap_gtk_list_child_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_selection_mode", (PyCFunction)_wrap_gtk_list_set_selection_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "extend_selection", (PyCFunction)_wrap_gtk_list_extend_selection, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "start_selection", (PyCFunction)_wrap_gtk_list_start_selection, METH_NOARGS,
      NULL },
    { "end_selection", (PyCFunction)_wrap_gtk_list_end_selection, METH_NOARGS,
      NULL },
    { "select_all", (PyCFunction)_wrap_gtk_list_select_all, METH_NOARGS,
      NULL },
    { "unselect_all", (PyCFunction)_wrap_gtk_list_unselect_all, METH_NOARGS,
      NULL },
    { "scroll_horizontal", (PyCFunction)_wrap_gtk_list_scroll_horizontal, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "scroll_vertical", (PyCFunction)_wrap_gtk_list_scroll_vertical, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "toggle_add_mode", (PyCFunction)_wrap_gtk_list_toggle_add_mode, METH_NOARGS,
      NULL },
    { "toggle_focus_row", (PyCFunction)_wrap_gtk_list_toggle_focus_row, METH_NOARGS,
      NULL },
    { "toggle_row", (PyCFunction)_wrap_gtk_list_toggle_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "undo_selection", (PyCFunction)_wrap_gtk_list_undo_selection, METH_NOARGS,
      NULL },
    { "end_drag_selection", (PyCFunction)_wrap_gtk_list_end_drag_selection, METH_NOARGS,
      NULL },
    { "do_selection_changed", (PyCFunction)_wrap_GtkList__do_selection_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_child", (PyCFunction)_wrap_GtkList__do_select_child, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unselect_child", (PyCFunction)_wrap_GtkList__do_unselect_child, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 2311 "./gtk.override"
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure)
{
    GList *selection;
    PyObject *item, *ret = PyList_New(0);

    if (ret == NULL)
        return NULL;

    for (selection = GTK_LIST(self->obj)->selection; selection != NULL;
         selection = selection->next) {
        item = pygobject_new((GObject *) GTK_LIST_ITEM(selection->data));

        if (!item) {
            Py_DECREF(ret);
            return NULL;
        }

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    return ret;
}
#line 60515 "gtk.c"


static const PyGetSetDef gtk_list_getsets[] = {
    { "selection", (getter)_wrap_gtk_list__get_selection, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkList_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.List",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkList_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_list_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_list_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkList__proxy_do_selection_changed(GtkList *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_selection_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkList__proxy_do_select_child(GtkList *self, GtkWidget*child)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_child = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (child)
        py_child = pygobject_new((GObject *) child);
    else {
        Py_INCREF(Py_None);
        py_child = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_child);
    
    py_method = PyObject_GetAttrString(py_self, "do_select_child");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkList__proxy_do_unselect_child(GtkList *self, GtkWidget*child)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_child = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (child)
        py_child = pygobject_new((GObject *) child);
    else {
        Py_INCREF(Py_None);
        py_child = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_child);
    
    py_method = PyObject_GetAttrString(py_self, "do_unselect_child");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkList_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkListClass *klass = GTK_LIST_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_selection_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "selection_changed")))
            klass->selection_changed = _wrap_GtkList__proxy_do_selection_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_child");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_child")))
            klass->select_child = _wrap_GtkList__proxy_do_select_child;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_unselect_child");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "unselect_child")))
            klass->unselect_child = _wrap_GtkList__proxy_do_unselect_child;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkListItem ----------- */

#line 1836 "./gtk.override"
static int
_wrap_gtk_list_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.TreeView") < 0)
        return -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkListItem.__init__",
                                     kwlist, &text))
        return -1;
    if (text)
        self->obj = (GObject *)gtk_list_item_new_with_label(text);
    else
        self->obj = (GObject *)gtk_list_item_new();
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkListItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
#line 60819 "gtk.c"


static PyObject *
_wrap_gtk_list_item_select(PyGObject *self)
{
    
    gtk_list_item_select(GTK_LIST_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_item_deselect(PyGObject *self)
{
    
    gtk_list_item_deselect(GTK_LIST_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkListItem__do_toggle_focus_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ListItem.toggle_focus_row", kwlist, &PyGtkListItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_ITEM_CLASS(klass)->toggle_focus_row)
        GTK_LIST_ITEM_CLASS(klass)->toggle_focus_row(GTK_LIST_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ListItem.toggle_focus_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkListItem__do_select_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ListItem.select_all", kwlist, &PyGtkListItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_ITEM_CLASS(klass)->select_all)
        GTK_LIST_ITEM_CLASS(klass)->select_all(GTK_LIST_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ListItem.select_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkListItem__do_unselect_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ListItem.unselect_all", kwlist, &PyGtkListItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_ITEM_CLASS(klass)->unselect_all)
        GTK_LIST_ITEM_CLASS(klass)->unselect_all(GTK_LIST_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ListItem.unselect_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkListItem__do_undo_selection(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ListItem.undo_selection", kwlist, &PyGtkListItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_ITEM_CLASS(klass)->undo_selection)
        GTK_LIST_ITEM_CLASS(klass)->undo_selection(GTK_LIST_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ListItem.undo_selection not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkListItem__do_start_selection(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ListItem.start_selection", kwlist, &PyGtkListItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_ITEM_CLASS(klass)->start_selection)
        GTK_LIST_ITEM_CLASS(klass)->start_selection(GTK_LIST_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ListItem.start_selection not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkListItem__do_end_selection(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ListItem.end_selection", kwlist, &PyGtkListItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_ITEM_CLASS(klass)->end_selection)
        GTK_LIST_ITEM_CLASS(klass)->end_selection(GTK_LIST_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ListItem.end_selection not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkListItem__do_extend_selection(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll_type", "position", "auto_start_selection", NULL };
    PyGObject *self;
    PyObject *py_scroll_type = NULL;
    int auto_start_selection;
    GtkScrollType scroll_type;
    double position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Odi:Gtk.ListItem.extend_selection", kwlist, &PyGtkListItem_Type, &self, &py_scroll_type, &position, &auto_start_selection))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll_type, (gpointer)&scroll_type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_ITEM_CLASS(klass)->extend_selection)
        GTK_LIST_ITEM_CLASS(klass)->extend_selection(GTK_LIST_ITEM(self->obj), scroll_type, position, auto_start_selection);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ListItem.extend_selection not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkListItem__do_scroll_horizontal(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll_type", "position", NULL };
    PyGObject *self;
    PyObject *py_scroll_type = NULL;
    GtkScrollType scroll_type;
    double position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Od:Gtk.ListItem.scroll_horizontal", kwlist, &PyGtkListItem_Type, &self, &py_scroll_type, &position))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll_type, (gpointer)&scroll_type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_ITEM_CLASS(klass)->scroll_horizontal)
        GTK_LIST_ITEM_CLASS(klass)->scroll_horizontal(GTK_LIST_ITEM(self->obj), scroll_type, position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ListItem.scroll_horizontal not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkListItem__do_scroll_vertical(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll_type", "position", NULL };
    PyGObject *self;
    PyObject *py_scroll_type = NULL;
    GtkScrollType scroll_type;
    double position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Od:Gtk.ListItem.scroll_vertical", kwlist, &PyGtkListItem_Type, &self, &py_scroll_type, &position))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll_type, (gpointer)&scroll_type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_ITEM_CLASS(klass)->scroll_vertical)
        GTK_LIST_ITEM_CLASS(klass)->scroll_vertical(GTK_LIST_ITEM(self->obj), scroll_type, position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ListItem.scroll_vertical not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkListItem__do_toggle_add_mode(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ListItem.toggle_add_mode", kwlist, &PyGtkListItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_LIST_ITEM_CLASS(klass)->toggle_add_mode)
        GTK_LIST_ITEM_CLASS(klass)->toggle_add_mode(GTK_LIST_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ListItem.toggle_add_mode not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkListItem_methods[] = {
    { "select", (PyCFunction)_wrap_gtk_list_item_select, METH_NOARGS,
      NULL },
    { "deselect", (PyCFunction)_wrap_gtk_list_item_deselect, METH_NOARGS,
      NULL },
    { "do_toggle_focus_row", (PyCFunction)_wrap_GtkListItem__do_toggle_focus_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_all", (PyCFunction)_wrap_GtkListItem__do_select_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unselect_all", (PyCFunction)_wrap_GtkListItem__do_unselect_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_undo_selection", (PyCFunction)_wrap_GtkListItem__do_undo_selection, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_start_selection", (PyCFunction)_wrap_GtkListItem__do_start_selection, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_end_selection", (PyCFunction)_wrap_GtkListItem__do_end_selection, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_extend_selection", (PyCFunction)_wrap_GtkListItem__do_extend_selection, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_scroll_horizontal", (PyCFunction)_wrap_GtkListItem__do_scroll_horizontal, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_scroll_vertical", (PyCFunction)_wrap_GtkListItem__do_scroll_vertical, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toggle_add_mode", (PyCFunction)_wrap_GtkListItem__do_toggle_add_mode, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkListItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ListItem",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkListItem_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_list_item_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkListItem__proxy_do_toggle_focus_row(GtkListItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_focus_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkListItem__proxy_do_select_all(GtkListItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_select_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkListItem__proxy_do_unselect_all(GtkListItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_unselect_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkListItem__proxy_do_undo_selection(GtkListItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_undo_selection");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkListItem__proxy_do_start_selection(GtkListItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_start_selection");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkListItem__proxy_do_end_selection(GtkListItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_end_selection");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkListItem__proxy_do_extend_selection(GtkListItem *self, GtkScrollType scroll_type, gfloat position, gboolean auto_start_selection)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll_type;
    PyObject *py_position;
    PyObject *py_auto_start_selection;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_scroll_type = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll_type);
    if (!py_scroll_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_position = PyFloat_FromDouble(position);
    py_auto_start_selection = auto_start_selection? Py_True : Py_False;
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_scroll_type);
    PyTuple_SET_ITEM(py_args, 1, py_position);
    Py_INCREF(py_auto_start_selection);
    PyTuple_SET_ITEM(py_args, 2, py_auto_start_selection);
    
    py_method = PyObject_GetAttrString(py_self, "do_extend_selection");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkListItem__proxy_do_scroll_horizontal(GtkListItem *self, GtkScrollType scroll_type, gfloat position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll_type;
    PyObject *py_position;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_scroll_type = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll_type);
    if (!py_scroll_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_position = PyFloat_FromDouble(position);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_scroll_type);
    PyTuple_SET_ITEM(py_args, 1, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_scroll_horizontal");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkListItem__proxy_do_scroll_vertical(GtkListItem *self, GtkScrollType scroll_type, gfloat position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll_type;
    PyObject *py_position;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_scroll_type = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll_type);
    if (!py_scroll_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_position = PyFloat_FromDouble(position);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_scroll_type);
    PyTuple_SET_ITEM(py_args, 1, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_scroll_vertical");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkListItem__proxy_do_toggle_add_mode(GtkListItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_add_mode");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkListItem_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkListItemClass *klass = GTK_LIST_ITEM_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_focus_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_focus_row")))
            klass->toggle_focus_row = _wrap_GtkListItem__proxy_do_toggle_focus_row;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_all")))
            klass->select_all = _wrap_GtkListItem__proxy_do_select_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_unselect_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "unselect_all")))
            klass->unselect_all = _wrap_GtkListItem__proxy_do_unselect_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_undo_selection");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "undo_selection")))
            klass->undo_selection = _wrap_GtkListItem__proxy_do_undo_selection;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_start_selection");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "start_selection")))
            klass->start_selection = _wrap_GtkListItem__proxy_do_start_selection;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_end_selection");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "end_selection")))
            klass->end_selection = _wrap_GtkListItem__proxy_do_end_selection;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_extend_selection");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "extend_selection")))
            klass->extend_selection = _wrap_GtkListItem__proxy_do_extend_selection;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_scroll_horizontal");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "scroll_horizontal")))
            klass->scroll_horizontal = _wrap_GtkListItem__proxy_do_scroll_horizontal;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_scroll_vertical");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "scroll_vertical")))
            klass->scroll_vertical = _wrap_GtkListItem__proxy_do_scroll_vertical;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_add_mode");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_add_mode")))
            klass->toggle_add_mode = _wrap_GtkListItem__proxy_do_toggle_add_mode;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkListStore ----------- */

#line 1557 "gtktreeview.override"
static int
_wrap_gtk_list_store_new(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    if (len == 0) {
        PyErr_SetString(PyExc_TypeError,
                        "GtkListStore requires at least one argument");
        return -1;
    }

    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
        PyObject *item = PyTuple_GetItem(args, i);

        column_types[i] = pyg_type_from_object(item);
        if (column_types[i] == 0) {
            g_free(column_types);
            return -1;
        }
    }

    pygobject_construct(self, NULL);
    gtk_list_store_set_column_types(GTK_LIST_STORE(self->obj), len, column_types);
    g_free(column_types);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkListStore object");
        return -1;
    }
    return 0;
}
#line 61881 "gtk.c"


#line 1594 "gtktreeview.override"
static PyObject*
_wrap_gtk_list_store_set_column_types(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    if (len == 0) {
        PyErr_SetString(PyExc_TypeError,
                        "GtkListStore set_column_types requires at least one argument");
        return NULL;
    }

    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
        PyObject *item = PyTuple_GetItem(args, i);

        column_types[i] = pyg_type_from_object(item);
        if (column_types[i] == 0) {
            g_free(column_types);
	    return NULL;
        }
    }
    
    gtk_list_store_set_column_types(GTK_LIST_STORE(self->obj), len, column_types);
    g_free(column_types);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 61915 "gtk.c"


#line 1686 "gtktreeview.override"
static PyObject *
_wrap_gtk_list_store_set_value(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *pyvalue;
    gint column;
    GValue value = { 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OiO:GtkListStore.set_value",
                                     kwlist, &iter, &column, &pyvalue))
        return NULL;
    if (column < 0 ||
        column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
        PyErr_SetString(PyExc_ValueError, "column number is out of range");
        return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
        PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
        return NULL;
    }
    g_value_init(&value,
                 gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
                                                column));
    if (pyg_value_from_pyobject(&value, pyvalue)) {
        PyErr_SetString(PyExc_TypeError,
                        "value is of the wrong type for this column");
        return NULL;
    }
    gtk_list_store_set_value(GTK_LIST_STORE(self->obj),
                             pyg_boxed_get(iter, GtkTreeIter), column, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 61955 "gtk.c"


#line 1628 "gtktreeview.override"
static PyObject *
_wrap_gtk_list_store_set(PyGObject *self, PyObject *args)
{
    PyObject *iter;
    int len, i;

    len = PyTuple_Size(args);
    if (len == 0) {
        PyErr_SetString(PyExc_TypeError, "GtkListStore.set requires at least three arguments");
        return NULL;
    }

    iter = PyTuple_GetItem(args, 0);
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
        PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
        return NULL;
    }

    if ((len - 1) % 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Argument list must be column, value pairs.  No -1 "
                        "termination is needed.");
        return NULL;
    }
    for (i = 1; i < len; i+=2) {
        gint column;
        GValue value = { 0 };
        PyObject *py_column = PyTuple_GetItem(args, i);
        PyObject *py_value = PyTuple_GetItem(args, i + 1);

        if (!PyInt_Check(py_column)) {
            PyErr_SetString(PyExc_TypeError,
                            "Expected numeric argument for column.");
            return NULL;
        }
        column = PyInt_AsLong(py_column);
        if (column < 0 ||
            column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
            PyErr_SetString(PyExc_ValueError, "column number is out of range");
            return NULL;
        }
        g_value_init(&value,
                     gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
                                                    column));
        if (pyg_value_from_pyobject(&value, py_value)) {
            PyErr_SetString(PyExc_TypeError,
                            "value is of the wrong type for this column");
            return NULL;
        }
        gtk_list_store_set_value(GTK_LIST_STORE(self->obj),
                                 pyg_boxed_get(iter, GtkTreeIter), column, &value);
        g_value_unset(&value);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 62015 "gtk.c"


static PyObject *
_wrap_gtk_list_store_remove(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ListStore.remove", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_list_store_remove(GTK_LIST_STORE(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

#line 1727 "gtktreeview.override"
static PyObject *
_wrap_gtk_list_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", "row", NULL };
    GtkTreeIter iter;
    gint position;
    PyObject *items = NULL;
    gint n_columns = 0;
    gint *columns = NULL;
    GValue *values = NULL;
    gint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i|O:GtkListStore.insert",
                                     kwlist, &position, &items)) {
        return NULL;
    }

    if (items) {
	if (!PySequence_Check(items)) {
	    PyErr_SetString(PyExc_TypeError, "expecting a sequence");
	    return NULL;
	}
	
	n_columns = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
	if (PySequence_Length(items) != n_columns) {
	    PyErr_SetString(PyExc_ValueError, "row sequence has wrong length");
	    return NULL;
	}
    }

    columns = g_new0(gint, n_columns);
    values = g_new0(GValue, n_columns);
    for (i = 0; i < n_columns; i++) {
	PyObject *item;

	item = PySequence_GetItem(items, i);
	if (!item)
	    return NULL;

	g_value_init(&values[i], gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj), i));
	
	if (pyg_value_from_pyobject(&values[i], item)) {
	    Py_DECREF(item);
	    PyErr_SetString(PyExc_TypeError,
			    "value is of wrong type for this column");
	    return NULL;
	}

	columns[i] = i;
	    
	Py_DECREF(item);
    }

    gtk_list_store_insert_with_valuesv(GTK_LIST_STORE(self->obj), &iter, position,
				       columns,
				       values,
				       n_columns);
    
    for (i = 0; i < n_columns; i++) {
	g_value_unset(&values[i]);
    }
    if (values)
	g_free(values);
    if (columns)
	g_free(columns);

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 62110 "gtk.c"


#line 1797 "gtktreeview.override"
static PyObject *
_wrap_gtk_list_store_insert_before(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "sibling", "row", NULL };
    PyObject *py_sibling;
    GtkTreeIter iter, *sibling = NULL;
    PyObject *row = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkListStore.insert_before",
                                     kwlist, &py_sibling, &row)) {
        return NULL;
    }

    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
        sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sibling must be a GtkTreeIter or None");
        return NULL;
    }
    gtk_list_store_insert_before(GTK_LIST_STORE(self->obj), &iter, sibling);

    /* optionally set items in the new row */
    if (row != Py_None &&
        _pygtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter, row) < 0)
        return NULL;

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 62145 "gtk.c"


#line 1830 "gtktreeview.override"
static PyObject *
_wrap_gtk_list_store_insert_after(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "sibling", "row", NULL };
    PyObject *py_sibling;
    GtkTreeIter iter, *sibling = NULL;
    PyObject *row = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkListStore.insert_after",
                                     kwlist, &py_sibling, &row))
        return NULL;
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
        sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sibling must be a GtkTreeIter or None");
        return NULL;
    }
    gtk_list_store_insert_after(GTK_LIST_STORE(self->obj), &iter, sibling);

    /* optionally set items in the new row */
    if (row != Py_None &&
        _pygtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter, row) < 0)
        return NULL;

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 62178 "gtk.c"


#line 1861 "gtktreeview.override"
static PyObject *
_wrap_gtk_list_store_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    GtkTreeIter iter;
    PyObject *row = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkListStore.prepend",
				     kwlist, &row))
	return NULL;

    gtk_list_store_prepend(GTK_LIST_STORE(self->obj), &iter);

    /* optionally set items in the new row */
    if (row != Py_None &&
        _pygtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter, row) < 0)
        return NULL;

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 62202 "gtk.c"


#line 1883 "gtktreeview.override"
static PyObject *
_wrap_gtk_list_store_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    GtkTreeIter iter;
    PyObject *row = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkListStore.append",
				     kwlist, &row))
	return NULL;

    gtk_list_store_append(GTK_LIST_STORE(self->obj), &iter);

    /* optionally set items in the new row */
    if (row != Py_None &&
        _pygtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter, row) < 0)
        return NULL;

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 62226 "gtk.c"


static PyObject *
_wrap_gtk_list_store_clear(PyGObject *self)
{
    
    gtk_list_store_clear(GTK_LIST_STORE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_store_iter_is_valid(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ListStore.iter_is_valid", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_list_store_iter_is_valid(GTK_LIST_STORE(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

#line 1905 "gtktreeview.override"
static PyObject *
_wrap_gtk_list_store_reorder(PyGObject *self, PyObject *args)
{
    PyObject *list;
    gint *new_order;
    GtkListStore *store;
    int i;
    int length;
    
    if (!PyArg_ParseTuple(args, "O:GtkListStore.reorder", &list))
	return NULL;

    if (!PyList_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "first argument should be a list");
        return NULL;
    }
    store = GTK_LIST_STORE(self->obj);
    length = gtk_tree_model_iter_n_children (GTK_TREE_MODEL(store), NULL);

    if (PyList_Size(list) < length) {
        PyErr_SetString(PyExc_TypeError, "list must at least have the same size as the number of items in the store");
        return NULL;
    }

    new_order = g_new0(gint, length);
    for (i = 0; i < length; i++) {
	PyObject *item = PyList_GetItem(list, i);
	int index;
	if (!PyInt_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "all items must be of type int");
	    g_free(new_order);
	    return NULL;
	}
	index = PyInt_AsLong(item);
	if (index < 0 || index >= length) {
	    PyErr_SetString(PyExc_ValueError, "position index out of range");
	    g_free(new_order);
	    return NULL;
	}
	new_order[i] = index;
    }
    gtk_list_store_reorder(GTK_LIST_STORE(self->obj), new_order);

    g_free(new_order);
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 62311 "gtk.c"


static PyObject *
_wrap_gtk_list_store_swap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "a", "b", NULL };
    PyObject *py_a, *py_b;
    GtkTreeIter *a = NULL, *b = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.ListStore.swap", kwlist, &py_a, &py_b))
        return NULL;
    if (pyg_boxed_check(py_a, GTK_TYPE_TREE_ITER))
        a = pyg_boxed_get(py_a, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "a should be a GtkTreeIter");
        return NULL;
    }
    if (pyg_boxed_check(py_b, GTK_TYPE_TREE_ITER))
        b = pyg_boxed_get(py_b, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "b should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_list_store_swap(GTK_LIST_STORE(self->obj), a, b);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_store_move_after(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "position", NULL };
    PyObject *py_iter, *py_position = Py_None;
    GtkTreeIter *iter = NULL, *position = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.ListStore.move_after", kwlist, &py_iter, &py_position))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    if (pyg_boxed_check(py_position, GTK_TYPE_TREE_ITER))
        position = pyg_boxed_get(py_position, GtkTreeIter);
    else if (py_position != Py_None) {
        PyErr_SetString(PyExc_TypeError, "position should be a GtkTreeIter or None");
        return NULL;
    }
    
    gtk_list_store_move_after(GTK_LIST_STORE(self->obj), iter, position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_list_store_move_before(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "position", NULL };
    PyObject *py_iter, *py_position = Py_None;
    GtkTreeIter *iter = NULL, *position = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.ListStore.move_before", kwlist, &py_iter, &py_position))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    if (pyg_boxed_check(py_position, GTK_TYPE_TREE_ITER))
        position = pyg_boxed_get(py_position, GtkTreeIter);
    else if (py_position != Py_None) {
        PyErr_SetString(PyExc_TypeError, "position should be a GtkTreeIter or None");
        return NULL;
    }
    
    gtk_list_store_move_before(GTK_LIST_STORE(self->obj), iter, position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkListStore_methods[] = {
    { "set_column_types", (PyCFunction)_wrap_gtk_list_store_set_column_types, METH_VARARGS,
      NULL },
    { "set_value", (PyCFunction)_wrap_gtk_list_store_set_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set", (PyCFunction)_wrap_gtk_list_store_set, METH_VARARGS,
      NULL },
    { "remove", (PyCFunction)_wrap_gtk_list_store_remove, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert", (PyCFunction)_wrap_gtk_list_store_insert, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_before", (PyCFunction)_wrap_gtk_list_store_insert_before, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_after", (PyCFunction)_wrap_gtk_list_store_insert_after, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend", (PyCFunction)_wrap_gtk_list_store_prepend, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "append", (PyCFunction)_wrap_gtk_list_store_append, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "clear", (PyCFunction)_wrap_gtk_list_store_clear, METH_NOARGS,
      NULL },
    { "iter_is_valid", (PyCFunction)_wrap_gtk_list_store_iter_is_valid, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reorder", (PyCFunction)_wrap_gtk_list_store_reorder, METH_VARARGS,
      NULL },
    { "swap", (PyCFunction)_wrap_gtk_list_store_swap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move_after", (PyCFunction)_wrap_gtk_list_store_move_after, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move_before", (PyCFunction)_wrap_gtk_list_store_move_before, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkListStore_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ListStore",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkListStore_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_list_store_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkMenuShell ----------- */

static PyObject *
_wrap_gtk_menu_shell_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuShell.append", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    gtk_menu_shell_append(GTK_MENU_SHELL(self->obj), GTK_WIDGET(child->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_shell_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuShell.prepend", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    gtk_menu_shell_prepend(GTK_MENU_SHELL(self->obj), GTK_WIDGET(child->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_shell_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "position", NULL };
    PyGObject *child;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.MenuShell.insert", kwlist, &PyGtkWidget_Type, &child, &position))
        return NULL;
    
    gtk_menu_shell_insert(GTK_MENU_SHELL(self->obj), GTK_WIDGET(child->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_shell_deactivate(PyGObject *self)
{
    
    gtk_menu_shell_deactivate(GTK_MENU_SHELL(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_shell_select_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "menu_item", NULL };
    PyGObject *menu_item;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuShell.select_item", kwlist, &PyGtkWidget_Type, &menu_item))
        return NULL;
    
    gtk_menu_shell_select_item(GTK_MENU_SHELL(self->obj), GTK_WIDGET(menu_item->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_shell_deselect(PyGObject *self)
{
    
    gtk_menu_shell_deselect(GTK_MENU_SHELL(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_shell_activate_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "menu_item", "force_deactivate", NULL };
    PyGObject *menu_item;
    int force_deactivate;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.MenuShell.activate_item", kwlist, &PyGtkWidget_Type, &menu_item, &force_deactivate))
        return NULL;
    
    gtk_menu_shell_activate_item(GTK_MENU_SHELL(self->obj), GTK_WIDGET(menu_item->obj), force_deactivate);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_shell_select_first(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "search_sensitive", NULL };
    int search_sensitive;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.MenuShell.select_first", kwlist, &search_sensitive))
        return NULL;
    
    gtk_menu_shell_select_first(GTK_MENU_SHELL(self->obj), search_sensitive);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_shell_cancel(PyGObject *self)
{
    
    gtk_menu_shell_cancel(GTK_MENU_SHELL(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_shell_get_take_focus(PyGObject *self)
{
    int ret;

    
    ret = gtk_menu_shell_get_take_focus(GTK_MENU_SHELL(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_menu_shell_set_take_focus(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "take_focus", NULL };
    int take_focus;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.MenuShell.set_take_focus", kwlist, &take_focus))
        return NULL;
    
    gtk_menu_shell_set_take_focus(GTK_MENU_SHELL(self->obj), take_focus);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuShell__do_deactivate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuShell.deactivate", kwlist, &PyGtkMenuShell_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_SHELL_CLASS(klass)->deactivate)
        GTK_MENU_SHELL_CLASS(klass)->deactivate(GTK_MENU_SHELL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuShell.deactivate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuShell__do_selection_done(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuShell.selection_done", kwlist, &PyGtkMenuShell_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_SHELL_CLASS(klass)->selection_done)
        GTK_MENU_SHELL_CLASS(klass)->selection_done(GTK_MENU_SHELL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuShell.selection_done not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuShell__do_move_current(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "direction", NULL };
    PyGObject *self;
    PyObject *py_direction = NULL;
    GtkMenuDirectionType direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.MenuShell.move_current", kwlist, &PyGtkMenuShell_Type, &self, &py_direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_MENU_DIRECTION_TYPE, py_direction, (gpointer)&direction))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_SHELL_CLASS(klass)->move_current)
        GTK_MENU_SHELL_CLASS(klass)->move_current(GTK_MENU_SHELL(self->obj), direction);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuShell.move_current not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuShell__do_activate_current(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "force_hide", NULL };
    PyGObject *self;
    int force_hide;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.MenuShell.activate_current", kwlist, &PyGtkMenuShell_Type, &self, &force_hide))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_SHELL_CLASS(klass)->activate_current)
        GTK_MENU_SHELL_CLASS(klass)->activate_current(GTK_MENU_SHELL(self->obj), force_hide);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuShell.activate_current not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuShell__do_cancel(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuShell.cancel", kwlist, &PyGtkMenuShell_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_SHELL_CLASS(klass)->cancel)
        GTK_MENU_SHELL_CLASS(klass)->cancel(GTK_MENU_SHELL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuShell.cancel not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuShell__do_select_item(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "menu_item", NULL };
    PyGObject *self, *menu_item;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.MenuShell.select_item", kwlist, &PyGtkMenuShell_Type, &self, &PyGtkWidget_Type, &menu_item))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_SHELL_CLASS(klass)->select_item)
        GTK_MENU_SHELL_CLASS(klass)->select_item(GTK_MENU_SHELL(self->obj), GTK_WIDGET(menu_item->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuShell.select_item not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuShell__do_insert(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "child", "position", NULL };
    PyGObject *self, *child;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!i:Gtk.MenuShell.insert", kwlist, &PyGtkMenuShell_Type, &self, &PyGtkWidget_Type, &child, &position))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_SHELL_CLASS(klass)->insert)
        GTK_MENU_SHELL_CLASS(klass)->insert(GTK_MENU_SHELL(self->obj), GTK_WIDGET(child->obj), position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuShell.insert not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuShell__do_get_popup_delay(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuShell.get_popup_delay", kwlist, &PyGtkMenuShell_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_SHELL_CLASS(klass)->get_popup_delay)
        ret = GTK_MENU_SHELL_CLASS(klass)->get_popup_delay(GTK_MENU_SHELL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuShell.get_popup_delay not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyInt_FromLong(ret);
}

static const PyMethodDef _PyGtkMenuShell_methods[] = {
    { "append", (PyCFunction)_wrap_gtk_menu_shell_append, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend", (PyCFunction)_wrap_gtk_menu_shell_prepend, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert", (PyCFunction)_wrap_gtk_menu_shell_insert, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "deactivate", (PyCFunction)_wrap_gtk_menu_shell_deactivate, METH_NOARGS,
      NULL },
    { "select_item", (PyCFunction)_wrap_gtk_menu_shell_select_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "deselect", (PyCFunction)_wrap_gtk_menu_shell_deselect, METH_NOARGS,
      NULL },
    { "activate_item", (PyCFunction)_wrap_gtk_menu_shell_activate_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_first", (PyCFunction)_wrap_gtk_menu_shell_select_first, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "cancel", (PyCFunction)_wrap_gtk_menu_shell_cancel, METH_NOARGS,
      NULL },
    { "get_take_focus", (PyCFunction)_wrap_gtk_menu_shell_get_take_focus, METH_NOARGS,
      NULL },
    { "set_take_focus", (PyCFunction)_wrap_gtk_menu_shell_set_take_focus, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_deactivate", (PyCFunction)_wrap_GtkMenuShell__do_deactivate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_selection_done", (PyCFunction)_wrap_GtkMenuShell__do_selection_done, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_current", (PyCFunction)_wrap_GtkMenuShell__do_move_current, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_activate_current", (PyCFunction)_wrap_GtkMenuShell__do_activate_current, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_cancel", (PyCFunction)_wrap_GtkMenuShell__do_cancel, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_item", (PyCFunction)_wrap_GtkMenuShell__do_select_item, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_insert", (PyCFunction)_wrap_GtkMenuShell__do_insert, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_popup_delay", (PyCFunction)_wrap_GtkMenuShell__do_get_popup_delay, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkMenuShell_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.MenuShell",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkMenuShell_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkMenuShell__proxy_do_deactivate(GtkMenuShell *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_deactivate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkMenuShell__proxy_do_selection_done(GtkMenuShell *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_selection_done");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkMenuShell__proxy_do_move_current(GtkMenuShell *self, GtkMenuDirectionType direction)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_direction;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_direction = pyg_enum_from_gtype(GTK_TYPE_MENU_DIRECTION_TYPE, direction);
    if (!py_direction) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_direction);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_current");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkMenuShell__proxy_do_activate_current(GtkMenuShell *self, gboolean force_hide)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_force_hide;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_force_hide = force_hide? Py_True : Py_False;
    
    py_args = PyTuple_New(1);
    Py_INCREF(py_force_hide);
    PyTuple_SET_ITEM(py_args, 0, py_force_hide);
    
    py_method = PyObject_GetAttrString(py_self, "do_activate_current");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkMenuShell__proxy_do_cancel(GtkMenuShell *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_cancel");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkMenuShell__proxy_do_select_item(GtkMenuShell *self, GtkWidget*menu_item)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_menu_item = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (menu_item)
        py_menu_item = pygobject_new((GObject *) menu_item);
    else {
        Py_INCREF(Py_None);
        py_menu_item = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_menu_item);
    
    py_method = PyObject_GetAttrString(py_self, "do_select_item");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkMenuShell__proxy_do_insert(GtkMenuShell *self, GtkWidget*child, gint position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_child = NULL;
    PyObject *py_position;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (child)
        py_child = pygobject_new((GObject *) child);
    else {
        Py_INCREF(Py_None);
        py_child = Py_None;
    }
    py_position = PyInt_FromLong(position);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_child);
    PyTuple_SET_ITEM(py_args, 1, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_insert");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gint
_wrap_GtkMenuShell__proxy_do_get_popup_delay(GtkMenuShell *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gint retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_popup_delay");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "i", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkMenuShell_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkMenuShellClass *klass = GTK_MENU_SHELL_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_deactivate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "deactivate")))
            klass->deactivate = _wrap_GtkMenuShell__proxy_do_deactivate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_selection_done");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "selection_done")))
            klass->selection_done = _wrap_GtkMenuShell__proxy_do_selection_done;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_current");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_current")))
            klass->move_current = _wrap_GtkMenuShell__proxy_do_move_current;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate_current");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate_current")))
            klass->activate_current = _wrap_GtkMenuShell__proxy_do_activate_current;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_cancel");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "cancel")))
            klass->cancel = _wrap_GtkMenuShell__proxy_do_cancel;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_item");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_item")))
            klass->select_item = _wrap_GtkMenuShell__proxy_do_select_item;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_insert");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "insert")))
            klass->insert = _wrap_GtkMenuShell__proxy_do_insert;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_get_popup_delay");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "get_popup_delay")))
            klass->get_popup_delay = _wrap_GtkMenuShell__proxy_do_get_popup_delay;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkMenu ----------- */

static int
_wrap_gtk_menu_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Menu.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Menu object");
        return -1;
    }
    return 0;
}

#line 1528 "./gtk.override"
static void
pygtk_menu_position(GtkMenu *menu, int *x, int *y, gboolean *push_in,
                    gpointer user_data)
{
    PyGtkCustomNotify *cunote = (PyGtkCustomNotify*)user_data;
    PyObject *ret;
    PyGILState_STATE state;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    if (cunote->data) {
        ret = PyObject_CallFunction(cunote->func, "(NO)",
                                    pygobject_new((GObject *)menu),
                                    cunote->data);
    } else {
        ret = PyObject_CallFunction(cunote->func, "(N)",
                                    pygobject_new((GObject *)menu));
    }

    if (ret == NULL || !PyArg_ParseTuple(ret, "iii", x, y, push_in)) {
        PyErr_Print();
        Py_XDECREF(ret);
    } else {
        Py_DECREF(ret);
    }
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_menu_popup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent_menu_shell", "parent_menu_item", "func",
                       "button", "activate_time", "data", NULL };
    PyGObject *py_pms, *py_pmi;
    GtkWidget *pms = NULL, *pmi = NULL;
    GtkMenu *menu = GTK_MENU(self->obj);
    PyObject *func, *data = NULL;
    int button;
    guint32 time;
    PyObject *pytime;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,  "OOOiO|O:GtkMenu.popup",
                                     kwlist, &py_pms, &py_pmi, &func,
                                     &button, &pytime, &data))
        return NULL;
    if (pygobject_check(py_pms, &PyGtkWidget_Type))
        pms = GTK_WIDGET(py_pms->obj);
    else if ((PyObject *)py_pms != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "parent_menu_shell must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_pmi, &PyGtkWidget_Type))
        pmi = GTK_WIDGET(py_pmi->obj);
    else if ((PyObject *)py_pmi != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "parent_menu_item must be a GtkWidget or None");
        return NULL;
    }
    if (!PyCallable_Check(func) && func != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "func must be a callable object or None");
        return NULL;
    }
    if (PyLong_Check(pytime)) {
	time = PyLong_AsUnsignedLong(pytime);
	if (PyErr_Occurred())
	    return NULL;
    } else if (PyInt_Check(pytime)) {
	time = PyInt_AsLong(pytime);
    } else {
        PyErr_SetString(PyExc_TypeError,
                        "last argument must be int or long");
        return NULL;
    }

    /* this is an ugly hack to avoid leaking memory and references
       gtk_menu_popup should use a data destroy function */
    if (menu->position_func == pygtk_menu_position) {
        cunote = menu->position_func_data;
        Py_DECREF(cunote->func);
        Py_XDECREF(cunote->data);
        g_free(cunote);
    }
    if (func != Py_None) {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = func;
        cunote->data = data;
        Py_INCREF(func);
        Py_XINCREF(data);
        gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
                       (GtkMenuPositionFunc)pygtk_menu_position,
                       cunote, button, time);
    } else
        gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 63591 "gtk.c"


static PyObject *
_wrap_gtk_menu_reposition(PyGObject *self)
{
    
    gtk_menu_reposition(GTK_MENU(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_popdown(PyGObject *self)
{
    
    gtk_menu_popdown(GTK_MENU(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_get_active(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_menu_get_active(GTK_MENU(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_menu_set_active(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "index", NULL };
    PyObject *py_index = NULL;
    guint index = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Menu.set_active", kwlist, &py_index))
        return NULL;
    if (py_index) {
        if (PyLong_Check(py_index))
            index = PyLong_AsUnsignedLong(py_index);
        else if (PyInt_Check(py_index))
            index = PyInt_AsLong(py_index);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'index' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_menu_set_active(GTK_MENU(self->obj), index);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_set_accel_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_group", NULL };
    PyGObject *py_accel_group;
    GtkAccelGroup *accel_group = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Menu.set_accel_group", kwlist, &py_accel_group))
        return NULL;
    if (py_accel_group && pygobject_check(py_accel_group, &PyGtkAccelGroup_Type))
        accel_group = GTK_ACCEL_GROUP(py_accel_group->obj);
    else if ((PyObject *)py_accel_group != Py_None) {
        PyErr_SetString(PyExc_TypeError, "accel_group should be a GtkAccelGroup or None");
        return NULL;
    }
    
    gtk_menu_set_accel_group(GTK_MENU(self->obj), (GtkAccelGroup *) accel_group);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_get_accel_group(PyGObject *self)
{
    GtkAccelGroup *ret;

    
    ret = gtk_menu_get_accel_group(GTK_MENU(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_menu_set_accel_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", NULL };
    char *accel_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.Menu.set_accel_path", kwlist, &accel_path))
        return NULL;
    
    gtk_menu_set_accel_path(GTK_MENU(self->obj), accel_path);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1896 "./gtk.override"
static void
pygtk_menu_detach (GtkWidget *attach_widget, GtkMenu *menu)
{
    PyGILState_STATE state;
    PyObject *func;
    PyObject *ret;

    func = g_object_get_data (G_OBJECT (menu), "pygtk_menu_detach_func");

    if (!func)
        return;

    state = pyg_gil_state_ensure();

    ret = PyObject_CallFunction (func, "OO",
                                 pygobject_new ((GObject *) menu),
                                 pygobject_new ((GObject *) attach_widget));
    if (ret == NULL) {
        PyErr_Print ();
        Py_XDECREF (ret);
    }
    else
        Py_DECREF (ret);

    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_menu_attach_to_widget (PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "attach_widget", "detach_func", NULL };
    PyGObject *py_attach_widget;
    PyObject *detach_func;
    GtkWidget *attach_widget;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O!O:GtkMenu.attach_to_widget",
                                      kwlist, &PyGtkWidget_Type,
                                      &py_attach_widget, &detach_func))
        return NULL;

    attach_widget = GTK_WIDGET (py_attach_widget->obj);

    if (!PyCallable_Check (detach_func) && detach_func != Py_None) {
        PyErr_SetString (PyExc_TypeError, "second argument not callable");
        return NULL;
    }

    if (detach_func != Py_None) {
        Py_INCREF (detach_func);
        g_object_set_data_full (self->obj,
                                "pygtk_menu_detach_func",
                                detach_func,
                                pyg_destroy_notify);
    }
    else
        g_object_set_data (self->obj, "pygtk_menu_detach_func", NULL);

    gtk_menu_attach_to_widget (GTK_MENU (self->obj), attach_widget,
                               (GtkMenuDetachFunc) pygtk_menu_detach);

    Py_INCREF (Py_None);
    return Py_None;
}
#line 63766 "gtk.c"


static PyObject *
_wrap_gtk_menu_detach(PyGObject *self)
{
    
    gtk_menu_detach(GTK_MENU(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_get_attach_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_menu_get_attach_widget(GTK_MENU(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_menu_set_tearoff_state(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "torn_off", NULL };
    int torn_off;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Menu.set_tearoff_state", kwlist, &torn_off))
        return NULL;
    
    gtk_menu_set_tearoff_state(GTK_MENU(self->obj), torn_off);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_get_tearoff_state(PyGObject *self)
{
    int ret;

    
    ret = gtk_menu_get_tearoff_state(GTK_MENU(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_menu_set_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "title", NULL };
    char *title;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Menu.set_title", kwlist, &title))
        return NULL;
    
    gtk_menu_set_title(GTK_MENU(self->obj), title);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_get_title(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_menu_get_title(GTK_MENU(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_reorder_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "position", NULL };
    PyGObject *child;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Menu.reorder_child", kwlist, &PyGtkWidget_Type, &child, &position))
        return NULL;
    
    gtk_menu_reorder_child(GTK_MENU(self->obj), GTK_WIDGET(child->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_set_screen(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *py_screen;
    GdkScreen *screen = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Menu.set_screen", kwlist, &py_screen))
        return NULL;
    if (py_screen && pygobject_check(py_screen, &PyGdkScreen_Type))
        screen = GDK_SCREEN(py_screen->obj);
    else if ((PyObject *)py_screen != Py_None) {
        PyErr_SetString(PyExc_TypeError, "screen should be a GdkScreen or None");
        return NULL;
    }
    
    gtk_menu_set_screen(GTK_MENU(self->obj), (GdkScreen *) screen);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_attach(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "left_attach", "right_attach", "top_attach", "bottom_attach", NULL };
    PyGObject *child;
    PyObject *py_left_attach = NULL, *py_right_attach = NULL, *py_top_attach = NULL, *py_bottom_attach = NULL;
    guint left_attach = 0, right_attach = 0, top_attach = 0, bottom_attach = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOO:Gtk.Menu.attach", kwlist, &PyGtkWidget_Type, &child, &py_left_attach, &py_right_attach, &py_top_attach, &py_bottom_attach))
        return NULL;
    if (py_left_attach) {
        if (PyLong_Check(py_left_attach))
            left_attach = PyLong_AsUnsignedLong(py_left_attach);
        else if (PyInt_Check(py_left_attach))
            left_attach = PyInt_AsLong(py_left_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'left_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_right_attach) {
        if (PyLong_Check(py_right_attach))
            right_attach = PyLong_AsUnsignedLong(py_right_attach);
        else if (PyInt_Check(py_right_attach))
            right_attach = PyInt_AsLong(py_right_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'right_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_top_attach) {
        if (PyLong_Check(py_top_attach))
            top_attach = PyLong_AsUnsignedLong(py_top_attach);
        else if (PyInt_Check(py_top_attach))
            top_attach = PyInt_AsLong(py_top_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'top_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_bottom_attach) {
        if (PyLong_Check(py_bottom_attach))
            bottom_attach = PyLong_AsUnsignedLong(py_bottom_attach);
        else if (PyInt_Check(py_bottom_attach))
            bottom_attach = PyInt_AsLong(py_bottom_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'bottom_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_menu_attach(GTK_MENU(self->obj), GTK_WIDGET(child->obj), left_attach, right_attach, top_attach, bottom_attach);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_set_monitor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "monitor_num", NULL };
    int monitor_num;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Menu.set_monitor", kwlist, &monitor_num))
        return NULL;
    
    gtk_menu_set_monitor(GTK_MENU(self->obj), monitor_num);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_get_accel_path(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_menu_get_accel_path(GTK_MENU(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_get_monitor(PyGObject *self)
{
    int ret;

    
    ret = gtk_menu_get_monitor(GTK_MENU(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_menu_set_reserve_toggle_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "reserve_toggle_size", NULL };
    int reserve_toggle_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Menu.set_reserve_toggle_size", kwlist, &reserve_toggle_size))
        return NULL;
    
    gtk_menu_set_reserve_toggle_size(GTK_MENU(self->obj), reserve_toggle_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_get_reserve_toggle_size(PyGObject *self)
{
    int ret;

    
    ret = gtk_menu_get_reserve_toggle_size(GTK_MENU(self->obj));
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkMenu_methods[] = {
    { "popup", (PyCFunction)_wrap_gtk_menu_popup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reposition", (PyCFunction)_wrap_gtk_menu_reposition, METH_NOARGS,
      NULL },
    { "popdown", (PyCFunction)_wrap_gtk_menu_popdown, METH_NOARGS,
      NULL },
    { "get_active", (PyCFunction)_wrap_gtk_menu_get_active, METH_NOARGS,
      NULL },
    { "set_active", (PyCFunction)_wrap_gtk_menu_set_active, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_accel_group", (PyCFunction)_wrap_gtk_menu_set_accel_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_accel_group", (PyCFunction)_wrap_gtk_menu_get_accel_group, METH_NOARGS,
      NULL },
    { "set_accel_path", (PyCFunction)_wrap_gtk_menu_set_accel_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "attach_to_widget", (PyCFunction)_wrap_gtk_menu_attach_to_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "detach", (PyCFunction)_wrap_gtk_menu_detach, METH_NOARGS,
      NULL },
    { "get_attach_widget", (PyCFunction)_wrap_gtk_menu_get_attach_widget, METH_NOARGS,
      NULL },
    { "set_tearoff_state", (PyCFunction)_wrap_gtk_menu_set_tearoff_state, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tearoff_state", (PyCFunction)_wrap_gtk_menu_get_tearoff_state, METH_NOARGS,
      NULL },
    { "set_title", (PyCFunction)_wrap_gtk_menu_set_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_title", (PyCFunction)_wrap_gtk_menu_get_title, METH_NOARGS,
      NULL },
    { "reorder_child", (PyCFunction)_wrap_gtk_menu_reorder_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_screen", (PyCFunction)_wrap_gtk_menu_set_screen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "attach", (PyCFunction)_wrap_gtk_menu_attach, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_monitor", (PyCFunction)_wrap_gtk_menu_set_monitor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_accel_path", (PyCFunction)_wrap_gtk_menu_get_accel_path, METH_NOARGS,
      NULL },
    { "get_monitor", (PyCFunction)_wrap_gtk_menu_get_monitor, METH_NOARGS,
      NULL },
    { "set_reserve_toggle_size", (PyCFunction)_wrap_gtk_menu_set_reserve_toggle_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_reserve_toggle_size", (PyCFunction)_wrap_gtk_menu_get_reserve_toggle_size, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkMenu_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Menu",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkMenu_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_menu_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkMenuBar ----------- */

static int
_wrap_gtk_menu_bar_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.MenuBar.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.MenuBar object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_menu_bar_get_pack_direction(PyGObject *self)
{
    gint ret;

    
    ret = gtk_menu_bar_get_pack_direction(GTK_MENU_BAR(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_PACK_DIRECTION, ret);
}

static PyObject *
_wrap_gtk_menu_bar_set_pack_direction(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pack_dir", NULL };
    PyObject *py_pack_dir = NULL;
    GtkPackDirection pack_dir;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.MenuBar.set_pack_direction", kwlist, &py_pack_dir))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PACK_DIRECTION, py_pack_dir, (gpointer)&pack_dir))
        return NULL;
    
    gtk_menu_bar_set_pack_direction(GTK_MENU_BAR(self->obj), pack_dir);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_bar_get_child_pack_direction(PyGObject *self)
{
    gint ret;

    
    ret = gtk_menu_bar_get_child_pack_direction(GTK_MENU_BAR(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_PACK_DIRECTION, ret);
}

static PyObject *
_wrap_gtk_menu_bar_set_child_pack_direction(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child_pack_dir", NULL };
    PyObject *py_child_pack_dir = NULL;
    GtkPackDirection child_pack_dir;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.MenuBar.set_child_pack_direction", kwlist, &py_child_pack_dir))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PACK_DIRECTION, py_child_pack_dir, (gpointer)&child_pack_dir))
        return NULL;
    
    gtk_menu_bar_set_child_pack_direction(GTK_MENU_BAR(self->obj), child_pack_dir);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkMenuBar_methods[] = {
    { "get_pack_direction", (PyCFunction)_wrap_gtk_menu_bar_get_pack_direction, METH_NOARGS,
      NULL },
    { "set_pack_direction", (PyCFunction)_wrap_gtk_menu_bar_set_pack_direction, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_child_pack_direction", (PyCFunction)_wrap_gtk_menu_bar_get_child_pack_direction, METH_NOARGS,
      NULL },
    { "set_child_pack_direction", (PyCFunction)_wrap_gtk_menu_bar_set_child_pack_direction, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkMenuBar_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.MenuBar",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkMenuBar_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_menu_bar_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkToolItem ----------- */

static int
_wrap_gtk_tool_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.ToolItem.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.ToolItem object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_tool_item_set_homogeneous(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "homogeneous", NULL };
    int homogeneous;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToolItem.set_homogeneous", kwlist, &homogeneous))
        return NULL;
    
    gtk_tool_item_set_homogeneous(GTK_TOOL_ITEM(self->obj), homogeneous);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_get_homogeneous(PyGObject *self)
{
    int ret;

    
    ret = gtk_tool_item_get_homogeneous(GTK_TOOL_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tool_item_set_expand(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "expand", NULL };
    int expand;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToolItem.set_expand", kwlist, &expand))
        return NULL;
    
    gtk_tool_item_set_expand(GTK_TOOL_ITEM(self->obj), expand);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_get_expand(PyGObject *self)
{
    int ret;

    
    ret = gtk_tool_item_get_expand(GTK_TOOL_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tool_item_set_tooltip(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tooltips", "tip_text", "tip_private", NULL };
    PyGObject *tooltips;
    char *tip_text = NULL, *tip_private = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|zz:Gtk.ToolItem.set_tooltip", kwlist, &PyGtkTooltips_Type, &tooltips, &tip_text, &tip_private))
        return NULL;
    
    gtk_tool_item_set_tooltip(GTK_TOOL_ITEM(self->obj), GTK_TOOLTIPS(tooltips->obj), tip_text, tip_private);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_set_use_drag_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_drag_window", NULL };
    int use_drag_window;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToolItem.set_use_drag_window", kwlist, &use_drag_window))
        return NULL;
    
    gtk_tool_item_set_use_drag_window(GTK_TOOL_ITEM(self->obj), use_drag_window);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_get_use_drag_window(PyGObject *self)
{
    int ret;

    
    ret = gtk_tool_item_get_use_drag_window(GTK_TOOL_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tool_item_set_visible_horizontal(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible_horizontal", NULL };
    int visible_horizontal;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToolItem.set_visible_horizontal", kwlist, &visible_horizontal))
        return NULL;
    
    gtk_tool_item_set_visible_horizontal(GTK_TOOL_ITEM(self->obj), visible_horizontal);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_get_visible_horizontal(PyGObject *self)
{
    int ret;

    
    ret = gtk_tool_item_get_visible_horizontal(GTK_TOOL_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tool_item_set_visible_vertical(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible_vertical", NULL };
    int visible_vertical;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToolItem.set_visible_vertical", kwlist, &visible_vertical))
        return NULL;
    
    gtk_tool_item_set_visible_vertical(GTK_TOOL_ITEM(self->obj), visible_vertical);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_get_visible_vertical(PyGObject *self)
{
    int ret;

    
    ret = gtk_tool_item_get_visible_vertical(GTK_TOOL_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tool_item_set_is_important(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "is_important", NULL };
    int is_important;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToolItem.set_is_important", kwlist, &is_important))
        return NULL;
    
    gtk_tool_item_set_is_important(GTK_TOOL_ITEM(self->obj), is_important);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_get_is_important(PyGObject *self)
{
    int ret;

    
    ret = gtk_tool_item_get_is_important(GTK_TOOL_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tool_item_get_icon_size(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_item_get_icon_size(GTK_TOOL_ITEM(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, ret);
}

static PyObject *
_wrap_gtk_tool_item_get_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_item_get_orientation(GTK_TOOL_ITEM(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, ret);
}

static PyObject *
_wrap_gtk_tool_item_get_toolbar_style(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_item_get_toolbar_style(GTK_TOOL_ITEM(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_TOOLBAR_STYLE, ret);
}

static PyObject *
_wrap_gtk_tool_item_get_relief_style(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_item_get_relief_style(GTK_TOOL_ITEM(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_RELIEF_STYLE, ret);
}

static PyObject *
_wrap_gtk_tool_item_retrieve_proxy_menu_item(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_tool_item_retrieve_proxy_menu_item(GTK_TOOL_ITEM(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tool_item_set_proxy_menu_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "menu_item_id", "menu_item", NULL };
    char *menu_item_id;
    PyGObject *py_menu_item;
    GtkWidget *menu_item = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO:Gtk.ToolItem.set_proxy_menu_item", kwlist, &menu_item_id, &py_menu_item))
        return NULL;
    if (py_menu_item && pygobject_check(py_menu_item, &PyGtkWidget_Type))
        menu_item = GTK_WIDGET(py_menu_item->obj);
    else if ((PyObject *)py_menu_item != Py_None) {
        PyErr_SetString(PyExc_TypeError, "menu_item should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_tool_item_set_proxy_menu_item(GTK_TOOL_ITEM(self->obj), menu_item_id, (GtkWidget *) menu_item);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_get_proxy_menu_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "menu_item_id", NULL };
    char *menu_item_id;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ToolItem.get_proxy_menu_item", kwlist, &menu_item_id))
        return NULL;
    
    ret = gtk_tool_item_get_proxy_menu_item(GTK_TOOL_ITEM(self->obj), menu_item_id);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tool_item_rebuild_menu(PyGObject *self)
{
    
    gtk_tool_item_rebuild_menu(GTK_TOOL_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_set_tooltip_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.ToolItem.set_tooltip_text", kwlist, &text))
        return NULL;
    
    gtk_tool_item_set_tooltip_text(GTK_TOOL_ITEM(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_set_tooltip_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "markup", NULL };
    char *markup;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.ToolItem.set_tooltip_markup", kwlist, &markup))
        return NULL;
    
    gtk_tool_item_set_tooltip_markup(GTK_TOOL_ITEM(self->obj), markup);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_toolbar_reconfigured(PyGObject *self)
{
    
    gtk_tool_item_toolbar_reconfigured(GTK_TOOL_ITEM(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_get_ellipsize_mode(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_item_get_ellipsize_mode(GTK_TOOL_ITEM(self->obj));
    
    return pyg_enum_from_gtype(PANGO_TYPE_ELLIPSIZE_MODE, ret);
}

static PyObject *
_wrap_gtk_tool_item_get_text_alignment(PyGObject *self)
{
    double ret;

    
    ret = gtk_tool_item_get_text_alignment(GTK_TOOL_ITEM(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_tool_item_get_text_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_item_get_text_orientation(GTK_TOOL_ITEM(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, ret);
}

static PyObject *
_wrap_gtk_tool_item_get_text_size_group(PyGObject *self)
{
    GtkSizeGroup *ret;

    
    ret = gtk_tool_item_get_text_size_group(GTK_TOOL_ITEM(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkToolItem__do_create_menu_proxy(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolItem.create_menu_proxy", kwlist, &PyGtkToolItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TOOL_ITEM_CLASS(klass)->create_menu_proxy)
        ret = GTK_TOOL_ITEM_CLASS(klass)->create_menu_proxy(GTK_TOOL_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ToolItem.create_menu_proxy not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkToolItem__do_toolbar_reconfigured(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolItem.toolbar_reconfigured", kwlist, &PyGtkToolItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TOOL_ITEM_CLASS(klass)->toolbar_reconfigured)
        GTK_TOOL_ITEM_CLASS(klass)->toolbar_reconfigured(GTK_TOOL_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ToolItem.toolbar_reconfigured not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkToolItem__do_set_tooltip(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "tooltips", "tip_text", "tip_private", NULL };
    PyGObject *self, *tooltips;
    char *tip_text, *tip_private;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!ss:Gtk.ToolItem.set_tooltip", kwlist, &PyGtkToolItem_Type, &self, &PyGtkTooltips_Type, &tooltips, &tip_text, &tip_private))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TOOL_ITEM_CLASS(klass)->set_tooltip)
        ret = GTK_TOOL_ITEM_CLASS(klass)->set_tooltip(GTK_TOOL_ITEM(self->obj), GTK_TOOLTIPS(tooltips->obj), tip_text, tip_private);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ToolItem.set_tooltip not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkToolItem_methods[] = {
    { "set_homogeneous", (PyCFunction)_wrap_gtk_tool_item_set_homogeneous, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_homogeneous", (PyCFunction)_wrap_gtk_tool_item_get_homogeneous, METH_NOARGS,
      NULL },
    { "set_expand", (PyCFunction)_wrap_gtk_tool_item_set_expand, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_expand", (PyCFunction)_wrap_gtk_tool_item_get_expand, METH_NOARGS,
      NULL },
    { "set_tooltip", (PyCFunction)_wrap_gtk_tool_item_set_tooltip, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_use_drag_window", (PyCFunction)_wrap_gtk_tool_item_set_use_drag_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_drag_window", (PyCFunction)_wrap_gtk_tool_item_get_use_drag_window, METH_NOARGS,
      NULL },
    { "set_visible_horizontal", (PyCFunction)_wrap_gtk_tool_item_set_visible_horizontal, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible_horizontal", (PyCFunction)_wrap_gtk_tool_item_get_visible_horizontal, METH_NOARGS,
      NULL },
    { "set_visible_vertical", (PyCFunction)_wrap_gtk_tool_item_set_visible_vertical, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible_vertical", (PyCFunction)_wrap_gtk_tool_item_get_visible_vertical, METH_NOARGS,
      NULL },
    { "set_is_important", (PyCFunction)_wrap_gtk_tool_item_set_is_important, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_is_important", (PyCFunction)_wrap_gtk_tool_item_get_is_important, METH_NOARGS,
      NULL },
    { "get_icon_size", (PyCFunction)_wrap_gtk_tool_item_get_icon_size, METH_NOARGS,
      NULL },
    { "get_orientation", (PyCFunction)_wrap_gtk_tool_item_get_orientation, METH_NOARGS,
      NULL },
    { "get_toolbar_style", (PyCFunction)_wrap_gtk_tool_item_get_toolbar_style, METH_NOARGS,
      NULL },
    { "get_relief_style", (PyCFunction)_wrap_gtk_tool_item_get_relief_style, METH_NOARGS,
      NULL },
    { "retrieve_proxy_menu_item", (PyCFunction)_wrap_gtk_tool_item_retrieve_proxy_menu_item, METH_NOARGS,
      NULL },
    { "set_proxy_menu_item", (PyCFunction)_wrap_gtk_tool_item_set_proxy_menu_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_proxy_menu_item", (PyCFunction)_wrap_gtk_tool_item_get_proxy_menu_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rebuild_menu", (PyCFunction)_wrap_gtk_tool_item_rebuild_menu, METH_NOARGS,
      NULL },
    { "set_tooltip_text", (PyCFunction)_wrap_gtk_tool_item_set_tooltip_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tooltip_markup", (PyCFunction)_wrap_gtk_tool_item_set_tooltip_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "toolbar_reconfigured", (PyCFunction)_wrap_gtk_tool_item_toolbar_reconfigured, METH_NOARGS,
      NULL },
    { "get_ellipsize_mode", (PyCFunction)_wrap_gtk_tool_item_get_ellipsize_mode, METH_NOARGS,
      NULL },
    { "get_text_alignment", (PyCFunction)_wrap_gtk_tool_item_get_text_alignment, METH_NOARGS,
      NULL },
    { "get_text_orientation", (PyCFunction)_wrap_gtk_tool_item_get_text_orientation, METH_NOARGS,
      NULL },
    { "get_text_size_group", (PyCFunction)_wrap_gtk_tool_item_get_text_size_group, METH_NOARGS,
      NULL },
    { "do_create_menu_proxy", (PyCFunction)_wrap_GtkToolItem__do_create_menu_proxy, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toolbar_reconfigured", (PyCFunction)_wrap_GtkToolItem__do_toolbar_reconfigured, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_tooltip", (PyCFunction)_wrap_GtkToolItem__do_set_tooltip, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkToolItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ToolItem",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkToolItem_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tool_item_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gboolean
_wrap_GtkToolItem__proxy_do_create_menu_proxy(GtkToolItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_create_menu_proxy");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkToolItem__proxy_do_toolbar_reconfigured(GtkToolItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toolbar_reconfigured");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkToolItem__proxy_do_set_tooltip(GtkToolItem *self, GtkTooltips*tooltips, const gchar*tip_text, const gchar*tip_private)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_tooltips = NULL;
    PyObject *py_tip_text = NULL;
    PyObject *py_tip_private = NULL;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (tooltips)
        py_tooltips = pygobject_new((GObject *) tooltips);
    else {
        Py_INCREF(Py_None);
        py_tooltips = Py_None;
    }
    if (tip_text)
        py_tip_text = PyString_FromString(tip_text);
    if (!py_tip_text) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_tooltips);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (tip_private)
        py_tip_private = PyString_FromString(tip_private);
    if (!py_tip_private) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_tip_text);
        Py_DECREF(py_tooltips);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_tooltips);
    PyTuple_SET_ITEM(py_args, 1, py_tip_text);
    PyTuple_SET_ITEM(py_args, 2, py_tip_private);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_tooltip");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkToolItem_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkToolItemClass *klass = GTK_TOOL_ITEM_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_create_menu_proxy");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "create_menu_proxy")))
            klass->create_menu_proxy = _wrap_GtkToolItem__proxy_do_create_menu_proxy;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toolbar_reconfigured");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toolbar_reconfigured")))
            klass->toolbar_reconfigured = _wrap_GtkToolItem__proxy_do_toolbar_reconfigured;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_tooltip");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_tooltip")))
            klass->set_tooltip = _wrap_GtkToolItem__proxy_do_set_tooltip;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkToolButton ----------- */

#line 373 "gtktoolbar.override"
static int
_wrap_gtk_tool_button_new(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist1[] = { "stock_id", NULL };
    static char *kwlist2[] = { "icon_widget", "label", NULL };
    PyGObject *py_icon_widget = NULL;
    GtkWidget *icon_widget = NULL;
    char *label = NULL;
    char *stock_id = NULL;

    if (PyArg_ParseTupleAndKeywords(args, kwargs,
				    "s:GtkToolButton.__init__", kwlist1,
				    &stock_id)) {
        pygobject_construct(self, "stock-id", stock_id, NULL);
    } else {
	PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|Oz:GtkToolButton.__init__", kwlist2,
					 &py_icon_widget, &label)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "Usage: one of:\n"
			    "  gtk.ToolButton(icon_widget=None, label=None)\n"
			    "  gtk.ToolButton(stock_id)");
	    return -1;
	}

	if (py_icon_widget && (PyObject *)py_icon_widget != Py_None) {
	    if (!pygobject_check(py_icon_widget, &PyGtkWidget_Type)) {
		PyErr_SetString(PyExc_TypeError,
			    "Usage: one of:\n"
			    "  gtk.ToolButton(icon_widget=None, label=None)\n"
			    "  gtk.ToolButton(stock_id)");
		return -1;
	    }
	    icon_widget = GTK_WIDGET(py_icon_widget->obj);
	}
        pygobject_construct(self, "icon-widget", icon_widget,
                            "label", label, NULL);
    }

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkToolButton object");
        return -1;
    }
    return 0;
}
#line 65115 "gtk.c"


static PyObject *
_wrap_gtk_tool_button_set_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.ToolButton.set_label", kwlist, &label))
        return NULL;
    
    gtk_tool_button_set_label(GTK_TOOL_BUTTON(self->obj), label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_button_get_label(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_tool_button_get_label(GTK_TOOL_BUTTON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_button_set_use_underline(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_underline", NULL };
    int use_underline;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToolButton.set_use_underline", kwlist, &use_underline))
        return NULL;
    
    gtk_tool_button_set_use_underline(GTK_TOOL_BUTTON(self->obj), use_underline);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_button_get_use_underline(PyGObject *self)
{
    int ret;

    
    ret = gtk_tool_button_get_use_underline(GTK_TOOL_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tool_button_set_stock_id(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", NULL };
    char *stock_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.ToolButton.set_stock_id", kwlist, &stock_id))
        return NULL;
    
    gtk_tool_button_set_stock_id(GTK_TOOL_BUTTON(self->obj), stock_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_button_set_icon_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    char *icon_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.ToolButton.set_icon_name", kwlist, &icon_name))
        return NULL;
    
    gtk_tool_button_set_icon_name(GTK_TOOL_BUTTON(self->obj), icon_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_button_get_icon_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_tool_button_get_icon_name(GTK_TOOL_BUTTON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_button_get_stock_id(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_tool_button_get_stock_id(GTK_TOOL_BUTTON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_button_set_icon_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_widget", NULL };
    PyGObject *py_icon_widget;
    GtkWidget *icon_widget = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ToolButton.set_icon_widget", kwlist, &py_icon_widget))
        return NULL;
    if (py_icon_widget && pygobject_check(py_icon_widget, &PyGtkWidget_Type))
        icon_widget = GTK_WIDGET(py_icon_widget->obj);
    else if ((PyObject *)py_icon_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "icon_widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_tool_button_set_icon_widget(GTK_TOOL_BUTTON(self->obj), (GtkWidget *) icon_widget);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_button_get_icon_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_tool_button_get_icon_widget(GTK_TOOL_BUTTON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tool_button_set_label_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label_widget", NULL };
    PyGObject *py_label_widget;
    GtkWidget *label_widget = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ToolButton.set_label_widget", kwlist, &py_label_widget))
        return NULL;
    if (py_label_widget && pygobject_check(py_label_widget, &PyGtkWidget_Type))
        label_widget = GTK_WIDGET(py_label_widget->obj);
    else if ((PyObject *)py_label_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "label_widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_tool_button_set_label_widget(GTK_TOOL_BUTTON(self->obj), (GtkWidget *) label_widget);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_button_get_label_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_tool_button_get_label_widget(GTK_TOOL_BUTTON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkToolButton__do_clicked(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolButton.clicked", kwlist, &PyGtkToolButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TOOL_BUTTON_CLASS(klass)->clicked)
        GTK_TOOL_BUTTON_CLASS(klass)->clicked(GTK_TOOL_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ToolButton.clicked not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkToolButton_methods[] = {
    { "set_label", (PyCFunction)_wrap_gtk_tool_button_set_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label", (PyCFunction)_wrap_gtk_tool_button_get_label, METH_NOARGS,
      NULL },
    { "set_use_underline", (PyCFunction)_wrap_gtk_tool_button_set_use_underline, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_underline", (PyCFunction)_wrap_gtk_tool_button_get_use_underline, METH_NOARGS,
      NULL },
    { "set_stock_id", (PyCFunction)_wrap_gtk_tool_button_set_stock_id, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_name", (PyCFunction)_wrap_gtk_tool_button_set_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_name", (PyCFunction)_wrap_gtk_tool_button_get_icon_name, METH_NOARGS,
      NULL },
    { "get_stock_id", (PyCFunction)_wrap_gtk_tool_button_get_stock_id, METH_NOARGS,
      NULL },
    { "set_icon_widget", (PyCFunction)_wrap_gtk_tool_button_set_icon_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_icon_widget", (PyCFunction)_wrap_gtk_tool_button_get_icon_widget, METH_NOARGS,
      NULL },
    { "set_label_widget", (PyCFunction)_wrap_gtk_tool_button_set_label_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label_widget", (PyCFunction)_wrap_gtk_tool_button_get_label_widget, METH_NOARGS,
      NULL },
    { "do_clicked", (PyCFunction)_wrap_GtkToolButton__do_clicked, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkToolButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ToolButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkToolButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tool_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkToolButton__proxy_do_clicked(GtkToolButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_clicked");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkToolButton_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkToolButtonClass *klass = GTK_TOOL_BUTTON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_clicked");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "clicked")))
            klass->clicked = _wrap_GtkToolButton__proxy_do_clicked;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkMenuToolButton ----------- */

#line 532 "gtktoolbar.override"
static int
_wrap_gtk_menu_tool_button_new(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist1[] = { "stock_id", NULL };
    static char *kwlist2[] = { "icon_widget", "label", NULL };
    gchar *stock_id, *label;
    PyObject *py_icon_widget;
    GtkWidget *icon_widget = NULL;
 
    if (PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkMenuToolButton.__init__",
				     kwlist1, &stock_id))
        pygobject_construct(self, "stock-id", stock_id, NULL);
    else {
        PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "Oz:GtkFileChooserButton.__init__",
                                         kwlist2, &py_icon_widget, &label)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "Usage: one of:\n"
			    "  gtk.MenuToolButton(stock_id)\n"
			    "  gtk.MenuToolButton(icon_widget, label)");
	    return -1;
	}
        if (py_icon_widget != Py_None) {
            if (pygobject_check(py_icon_widget, &PyGtkWidget_Type)) {
                icon_widget = GTK_WIDGET(pygobject_get(py_icon_widget));
            } else {
                PyErr_SetString(PyExc_TypeError,
                                "icon_widget must be a GtkWidget type or None");
                return -1;
            }
        }
        pygobject_construct(self, "icon-widget", icon_widget,
                            "label", label, NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkMenuToolButton object");
        return -1;
    }
    return 0;
}
#line 65518 "gtk.c"


static PyObject *
_wrap_gtk_menu_tool_button_set_menu(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "menu", NULL };
    PyGObject *menu;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuToolButton.set_menu", kwlist, &PyGtkWidget_Type, &menu))
        return NULL;
    
    gtk_menu_tool_button_set_menu(GTK_MENU_TOOL_BUTTON(self->obj), GTK_WIDGET(menu->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_tool_button_get_menu(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_menu_tool_button_get_menu(GTK_MENU_TOOL_BUTTON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_menu_tool_button_set_arrow_tooltip(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tooltips", "tip_text", "tip_private", NULL };
    PyGObject *tooltips;
    char *tip_text, *tip_private = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!z|z:Gtk.MenuToolButton.set_arrow_tooltip", kwlist, &PyGtkTooltips_Type, &tooltips, &tip_text, &tip_private))
        return NULL;
    
    gtk_menu_tool_button_set_arrow_tooltip(GTK_MENU_TOOL_BUTTON(self->obj), GTK_TOOLTIPS(tooltips->obj), tip_text, tip_private);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_tool_button_set_arrow_tooltip_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.MenuToolButton.set_arrow_tooltip_text", kwlist, &text))
        return NULL;
    
    gtk_menu_tool_button_set_arrow_tooltip_text(GTK_MENU_TOOL_BUTTON(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_menu_tool_button_set_arrow_tooltip_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "markup", NULL };
    char *markup;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.MenuToolButton.set_arrow_tooltip_markup", kwlist, &markup))
        return NULL;
    
    gtk_menu_tool_button_set_arrow_tooltip_markup(GTK_MENU_TOOL_BUTTON(self->obj), markup);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkMenuToolButton__do_show_menu(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MenuToolButton.show_menu", kwlist, &PyGtkMenuToolButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_MENU_TOOL_BUTTON_CLASS(klass)->show_menu)
        GTK_MENU_TOOL_BUTTON_CLASS(klass)->show_menu(GTK_MENU_TOOL_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.MenuToolButton.show_menu not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkMenuToolButton_methods[] = {
    { "set_menu", (PyCFunction)_wrap_gtk_menu_tool_button_set_menu, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_menu", (PyCFunction)_wrap_gtk_menu_tool_button_get_menu, METH_NOARGS,
      NULL },
    { "set_arrow_tooltip", (PyCFunction)_wrap_gtk_menu_tool_button_set_arrow_tooltip, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_arrow_tooltip_text", (PyCFunction)_wrap_gtk_menu_tool_button_set_arrow_tooltip_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_arrow_tooltip_markup", (PyCFunction)_wrap_gtk_menu_tool_button_set_arrow_tooltip_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_show_menu", (PyCFunction)_wrap_GtkMenuToolButton__do_show_menu, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkMenuToolButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.MenuToolButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkMenuToolButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_menu_tool_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkMenuToolButton__proxy_do_show_menu(GtkMenuToolButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_show_menu");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkMenuToolButton_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkMenuToolButtonClass *klass = GTK_MENU_TOOL_BUTTON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_show_menu");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "show_menu")))
            klass->show_menu = _wrap_GtkMenuToolButton__proxy_do_show_menu;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkMessageDialog ----------- */

#line 2777 "./gtk.override"
static int
_wrap_gtk_message_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkButtonsType buttons = GTK_BUTTONS_NONE;
    static char *kwlist[] = { "parent", "flags", "type", "buttons", "message_format", NULL };
    PyObject *py_flags = NULL, *py_type = NULL, *py_buttons = NULL;
    GtkDialogFlags flags = 0;
    GtkWindow *parent = NULL;
    GtkMessageType type = GTK_MESSAGE_INFO;
    PyGObject *py_parent = NULL;
    char *message_format = NULL;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOOz:GtkMessageDialog.__init__", kwlist, &py_parent, &py_flags, &py_type, &py_buttons, &message_format))
        return -1;
    if ((PyObject *)py_parent == Py_None)
        parent = NULL;
    else if (py_parent && pygobject_check(py_parent, &PyGtkWindow_Type))
        parent = GTK_WINDOW(py_parent->obj);
    else if (py_parent) {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkWindow or None");
        return -1;
    }
    if (pyg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, py_type, (gint *)&type))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_BUTTONS_TYPE, py_buttons, (gint *)&buttons))
        return -1;

#if GTK_CHECK_VERSION(2, 9, 0)

    if (flags & GTK_DIALOG_NO_SEPARATOR)
        g_warning("The gtk.DIALOG_NO_SEPARATOR flag cannot be used for gtk.MessageDialog");
    
    pygobject_construct(self, "buttons", buttons,
                        "message-type", type,
                        (message_format? "text" : NULL), message_format,
                        NULL);
    if (parent != NULL)
        gtk_window_set_transient_for(GTK_WINDOW(self->obj), parent);
    
    if (flags & GTK_DIALOG_MODAL)
        gtk_window_set_modal(GTK_WINDOW(self->obj), TRUE);

    if (flags & GTK_DIALOG_DESTROY_WITH_PARENT)
        gtk_window_set_destroy_with_parent(GTK_WINDOW(self->obj), TRUE);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkMessageDialog object");
        return -1;
    }
    
    g_object_ref(self->obj); /* we don't own the first reference of windows */

#else

      /* Note: with older API (< 2.10), it is impossible to
       * construct a GtkMessageDialog through g_object_new(), because
       * there is no 'message' property and the label field is
       * private */
    if (message_format)
        self->obj = (GObject *)gtk_message_dialog_new(parent, flags, type,
                                                      buttons, "%s",
                                                      message_format);
    else
        self->obj = (GObject *)gtk_message_dialog_new(parent, flags, type,
                                                      buttons, message_format);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkMessageDialog object");
        return -1;
    }
    
    g_object_ref(self->obj); /* we don't own the first reference of windows */

    if (pyg_type_from_object((PyObject *) self) != GTK_TYPE_MESSAGE_DIALOG) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing gtk.MessageDialog");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);

#endif
    return 0;
}
#line 65840 "gtk.c"


static PyObject *
_wrap_gtk_message_dialog_set_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    char *str;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.MessageDialog.set_markup", kwlist, &str))
        return NULL;
    
    gtk_message_dialog_set_markup(GTK_MESSAGE_DIALOG(self->obj), str);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 6338 "./gtk.override"
static PyObject *
_wrap_gtk_message_dialog_format_secondary_text(PyGObject *self, PyObject *args,
                                               PyObject *kwargs)
{
    static char *kwlist[] = { "message_format", NULL };
    gchar *message_format = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|z:GtkMessageDialog.format_secondary_text",
                                     kwlist, &message_format))
        return NULL;

    if (message_format)
        gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(self->obj),
                                                 "%s", message_format);
    else
        gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(self->obj),
                                                 NULL);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 65880 "gtk.c"


#line 6361 "./gtk.override"
static PyObject *
_wrap_gtk_message_dialog_format_secondary_markup(PyGObject *self, PyObject *args,
                                               PyObject *kwargs)
{
    static char *kwlist[] = { "message_format", NULL };
    gchar *message_format = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|z:GtkMessageDialog.format_secondary_markup",
                                     kwlist, &message_format))
        return NULL;

    if (message_format)
        gtk_message_dialog_format_secondary_markup(GTK_MESSAGE_DIALOG(self->obj),
                                                   "%s", message_format);
    else
        gtk_message_dialog_format_secondary_markup(GTK_MESSAGE_DIALOG(self->obj),
                                                   NULL);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 65905 "gtk.c"


static PyObject *
_wrap_gtk_message_dialog_set_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "image", NULL };
    PyGObject *image;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MessageDialog.set_image", kwlist, &PyGtkWidget_Type, &image))
        return NULL;
    
    gtk_message_dialog_set_image(GTK_MESSAGE_DIALOG(self->obj), GTK_WIDGET(image->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_message_dialog_get_image(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_message_dialog_get_image(GTK_MESSAGE_DIALOG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_message_dialog_get_message_area(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_message_dialog_get_message_area(GTK_MESSAGE_DIALOG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkMessageDialog_methods[] = {
    { "set_markup", (PyCFunction)_wrap_gtk_message_dialog_set_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "format_secondary_text", (PyCFunction)_wrap_gtk_message_dialog_format_secondary_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "format_secondary_markup", (PyCFunction)_wrap_gtk_message_dialog_format_secondary_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_image", (PyCFunction)_wrap_gtk_message_dialog_set_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_image", (PyCFunction)_wrap_gtk_message_dialog_get_image, METH_NOARGS,
      NULL },
    { "get_message_area", (PyCFunction)_wrap_gtk_message_dialog_get_message_area, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 8715 "./gtk.override"
static PyObject *
_wrap_gtk_message_dialog__get_image(PyObject *self, void *closure)
{
    GtkWidget *ret;
    
    if (PyErr_Warn(PyExc_DeprecationWarning,
                   "use set_image() instead") < 0)
        return NULL;
    
    ret = GTK_MESSAGE_DIALOG(pygobject_get(self))->image;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
#line 65977 "gtk.c"


#line 8730 "./gtk.override"
static PyObject *
_wrap_gtk_message_dialog__get_label(PyObject *self, void *closure)
{
    GtkWidget *ret;
    
    if (PyErr_Warn(PyExc_DeprecationWarning,
                   "use set_markup() instead") < 0)
        return NULL;

    ret = GTK_MESSAGE_DIALOG(pygobject_get(self))->label;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
#line 65994 "gtk.c"


static const PyGetSetDef gtk_message_dialog_getsets[] = {
    { "image", (getter)_wrap_gtk_message_dialog__get_image, (setter)0 },
    { "label", (getter)_wrap_gtk_message_dialog__get_label, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkMessageDialog_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.MessageDialog",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkMessageDialog_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_message_dialog_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_message_dialog_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkNotebook ----------- */

static int
_wrap_gtk_notebook_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Notebook.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Notebook object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_notebook_append_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "tab_label", NULL };
    PyGObject *child, *py_tab_label = NULL;
    int ret;
    GtkWidget *tab_label = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|O:Gtk.Notebook.append_page", kwlist, &PyGtkWidget_Type, &child, &py_tab_label))
        return NULL;
    if ((PyObject *)py_tab_label == Py_None)
        tab_label = NULL;
    else if (py_tab_label && pygobject_check(py_tab_label, &PyGtkWidget_Type))
        tab_label = GTK_WIDGET(py_tab_label->obj);
    else if (py_tab_label) {
        PyErr_SetString(PyExc_TypeError, "tab_label should be a GtkWidget or None");
        return NULL;
    }
    
    ret = gtk_notebook_append_page(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), (GtkWidget *) tab_label);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_append_page_menu(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "tab_label", "menu_label", NULL };
    PyGObject *child, *py_tab_label = NULL, *py_menu_label = NULL;
    int ret;
    GtkWidget *tab_label = NULL, *menu_label = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|OO:Gtk.Notebook.append_page_menu", kwlist, &PyGtkWidget_Type, &child, &py_tab_label, &py_menu_label))
        return NULL;
    if ((PyObject *)py_tab_label == Py_None)
        tab_label = NULL;
    else if (py_tab_label && pygobject_check(py_tab_label, &PyGtkWidget_Type))
        tab_label = GTK_WIDGET(py_tab_label->obj);
    else if (py_tab_label) {
        PyErr_SetString(PyExc_TypeError, "tab_label should be a GtkWidget or None");
        return NULL;
    }
    if ((PyObject *)py_menu_label == Py_None)
        menu_label = NULL;
    else if (py_menu_label && pygobject_check(py_menu_label, &PyGtkWidget_Type))
        menu_label = GTK_WIDGET(py_menu_label->obj);
    else if (py_menu_label) {
        PyErr_SetString(PyExc_TypeError, "menu_label should be a GtkWidget or None");
        return NULL;
    }
    
    ret = gtk_notebook_append_page_menu(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), (GtkWidget *) tab_label, (GtkWidget *) menu_label);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_prepend_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "tab_label", NULL };
    PyGObject *child, *py_tab_label = NULL;
    int ret;
    GtkWidget *tab_label = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|O:Gtk.Notebook.prepend_page", kwlist, &PyGtkWidget_Type, &child, &py_tab_label))
        return NULL;
    if ((PyObject *)py_tab_label == Py_None)
        tab_label = NULL;
    else if (py_tab_label && pygobject_check(py_tab_label, &PyGtkWidget_Type))
        tab_label = GTK_WIDGET(py_tab_label->obj);
    else if (py_tab_label) {
        PyErr_SetString(PyExc_TypeError, "tab_label should be a GtkWidget or None");
        return NULL;
    }
    
    ret = gtk_notebook_prepend_page(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), (GtkWidget *) tab_label);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_prepend_page_menu(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "tab_label", "menu_label", NULL };
    PyGObject *child, *py_tab_label = NULL, *py_menu_label = NULL;
    int ret;
    GtkWidget *tab_label = NULL, *menu_label = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|OO:Gtk.Notebook.prepend_page_menu", kwlist, &PyGtkWidget_Type, &child, &py_tab_label, &py_menu_label))
        return NULL;
    if ((PyObject *)py_tab_label == Py_None)
        tab_label = NULL;
    else if (py_tab_label && pygobject_check(py_tab_label, &PyGtkWidget_Type))
        tab_label = GTK_WIDGET(py_tab_label->obj);
    else if (py_tab_label) {
        PyErr_SetString(PyExc_TypeError, "tab_label should be a GtkWidget or None");
        return NULL;
    }
    if ((PyObject *)py_menu_label == Py_None)
        menu_label = NULL;
    else if (py_menu_label && pygobject_check(py_menu_label, &PyGtkWidget_Type))
        menu_label = GTK_WIDGET(py_menu_label->obj);
    else if (py_menu_label) {
        PyErr_SetString(PyExc_TypeError, "menu_label should be a GtkWidget or None");
        return NULL;
    }
    
    ret = gtk_notebook_prepend_page_menu(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), (GtkWidget *) tab_label, (GtkWidget *) menu_label);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_insert_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "tab_label", "position", NULL };
    PyGObject *child, *py_tab_label = NULL;
    int position = -1, ret;
    GtkWidget *tab_label = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|Oi:Gtk.Notebook.insert_page", kwlist, &PyGtkWidget_Type, &child, &py_tab_label, &position))
        return NULL;
    if ((PyObject *)py_tab_label == Py_None)
        tab_label = NULL;
    else if (py_tab_label && pygobject_check(py_tab_label, &PyGtkWidget_Type))
        tab_label = GTK_WIDGET(py_tab_label->obj);
    else if (py_tab_label) {
        PyErr_SetString(PyExc_TypeError, "tab_label should be a GtkWidget or None");
        return NULL;
    }
    
    ret = gtk_notebook_insert_page(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), (GtkWidget *) tab_label, position);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_insert_page_menu(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "tab_label", "menu_label", "position", NULL };
    PyGObject *child, *py_tab_label = NULL, *py_menu_label = NULL;
    int position = -1, ret;
    GtkWidget *tab_label = NULL, *menu_label = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|OOi:Gtk.Notebook.insert_page_menu", kwlist, &PyGtkWidget_Type, &child, &py_tab_label, &py_menu_label, &position))
        return NULL;
    if ((PyObject *)py_tab_label == Py_None)
        tab_label = NULL;
    else if (py_tab_label && pygobject_check(py_tab_label, &PyGtkWidget_Type))
        tab_label = GTK_WIDGET(py_tab_label->obj);
    else if (py_tab_label) {
        PyErr_SetString(PyExc_TypeError, "tab_label should be a GtkWidget or None");
        return NULL;
    }
    if ((PyObject *)py_menu_label == Py_None)
        menu_label = NULL;
    else if (py_menu_label && pygobject_check(py_menu_label, &PyGtkWidget_Type))
        menu_label = GTK_WIDGET(py_menu_label->obj);
    else if (py_menu_label) {
        PyErr_SetString(PyExc_TypeError, "menu_label should be a GtkWidget or None");
        return NULL;
    }
    
    ret = gtk_notebook_insert_page_menu(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), (GtkWidget *) tab_label, (GtkWidget *) menu_label, position);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_remove_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_num", NULL };
    int page_num;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Notebook.remove_page", kwlist, &page_num))
        return NULL;
    
    gtk_notebook_remove_page(GTK_NOTEBOOK(self->obj), page_num);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_current_page(PyGObject *self)
{
    int ret;

    
    ret = gtk_notebook_get_current_page(GTK_NOTEBOOK(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_get_nth_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_num", NULL };
    int page_num;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Notebook.get_nth_page", kwlist, &page_num))
        return NULL;
    
    ret = gtk_notebook_get_nth_page(GTK_NOTEBOOK(self->obj), page_num);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_notebook_get_n_pages(PyGObject *self)
{
    int ret;

    
    ret = gtk_notebook_get_n_pages(GTK_NOTEBOOK(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_page_num(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Notebook.page_num", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    ret = gtk_notebook_page_num(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_set_current_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_num", NULL };
    int page_num;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Notebook.set_current_page", kwlist, &page_num))
        return NULL;
    
    gtk_notebook_set_current_page(GTK_NOTEBOOK(self->obj), page_num);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_next_page(PyGObject *self)
{
    
    gtk_notebook_next_page(GTK_NOTEBOOK(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_prev_page(PyGObject *self)
{
    
    gtk_notebook_prev_page(GTK_NOTEBOOK(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_set_show_border(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_border", NULL };
    int show_border;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Notebook.set_show_border", kwlist, &show_border))
        return NULL;
    
    gtk_notebook_set_show_border(GTK_NOTEBOOK(self->obj), show_border);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_show_border(PyGObject *self)
{
    int ret;

    
    ret = gtk_notebook_get_show_border(GTK_NOTEBOOK(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_notebook_set_show_tabs(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_tabs", NULL };
    int show_tabs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Notebook.set_show_tabs", kwlist, &show_tabs))
        return NULL;
    
    gtk_notebook_set_show_tabs(GTK_NOTEBOOK(self->obj), show_tabs);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_show_tabs(PyGObject *self)
{
    int ret;

    
    ret = gtk_notebook_get_show_tabs(GTK_NOTEBOOK(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_notebook_set_tab_pos(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pos", NULL };
    PyObject *py_pos = NULL;
    GtkPositionType pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Notebook.set_tab_pos", kwlist, &py_pos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_pos, (gpointer)&pos))
        return NULL;
    
    gtk_notebook_set_tab_pos(GTK_NOTEBOOK(self->obj), pos);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_tab_pos(PyGObject *self)
{
    gint ret;

    
    ret = gtk_notebook_get_tab_pos(GTK_NOTEBOOK(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_POSITION_TYPE, ret);
}

static PyObject *
_wrap_gtk_notebook_set_homogeneous_tabs(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "homogeneous", NULL };
    int homogeneous;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Notebook.set_homogeneous_tabs", kwlist, &homogeneous))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_notebook_set_homogeneous_tabs(GTK_NOTEBOOK(self->obj), homogeneous);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_set_tab_border(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "border_width", NULL };
    PyObject *py_border_width = NULL;
    guint border_width = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Notebook.set_tab_border", kwlist, &py_border_width))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (py_border_width) {
        if (PyLong_Check(py_border_width))
            border_width = PyLong_AsUnsignedLong(py_border_width);
        else if (PyInt_Check(py_border_width))
            border_width = PyInt_AsLong(py_border_width);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'border_width' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_notebook_set_tab_border(GTK_NOTEBOOK(self->obj), border_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_set_tab_hborder(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tab_hborder", NULL };
    PyObject *py_tab_hborder = NULL;
    guint tab_hborder = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Notebook.set_tab_hborder", kwlist, &py_tab_hborder))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (py_tab_hborder) {
        if (PyLong_Check(py_tab_hborder))
            tab_hborder = PyLong_AsUnsignedLong(py_tab_hborder);
        else if (PyInt_Check(py_tab_hborder))
            tab_hborder = PyInt_AsLong(py_tab_hborder);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'tab_hborder' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_notebook_set_tab_hborder(GTK_NOTEBOOK(self->obj), tab_hborder);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_set_tab_vborder(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tab_vborder", NULL };
    PyObject *py_tab_vborder = NULL;
    guint tab_vborder = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Notebook.set_tab_vborder", kwlist, &py_tab_vborder))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (py_tab_vborder) {
        if (PyLong_Check(py_tab_vborder))
            tab_vborder = PyLong_AsUnsignedLong(py_tab_vborder);
        else if (PyInt_Check(py_tab_vborder))
            tab_vborder = PyInt_AsLong(py_tab_vborder);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'tab_vborder' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_notebook_set_tab_vborder(GTK_NOTEBOOK(self->obj), tab_vborder);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_set_scrollable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "scrollable", NULL };
    int scrollable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Notebook.set_scrollable", kwlist, &scrollable))
        return NULL;
    
    gtk_notebook_set_scrollable(GTK_NOTEBOOK(self->obj), scrollable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_scrollable(PyGObject *self)
{
    int ret;

    
    ret = gtk_notebook_get_scrollable(GTK_NOTEBOOK(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_notebook_popup_enable(PyGObject *self)
{
    
    gtk_notebook_popup_enable(GTK_NOTEBOOK(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_popup_disable(PyGObject *self)
{
    
    gtk_notebook_popup_disable(GTK_NOTEBOOK(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_tab_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Notebook.get_tab_label", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    ret = gtk_notebook_get_tab_label(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_notebook_set_tab_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "tab_label", NULL };
    PyGObject *child, *py_tab_label = NULL;
    GtkWidget *tab_label = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|O:Gtk.Notebook.set_tab_label", kwlist, &PyGtkWidget_Type, &child, &py_tab_label))
        return NULL;
    if ((PyObject *)py_tab_label == Py_None)
        tab_label = NULL;
    else if (py_tab_label && pygobject_check(py_tab_label, &PyGtkWidget_Type))
        tab_label = GTK_WIDGET(py_tab_label->obj);
    else if (py_tab_label) {
        PyErr_SetString(PyExc_TypeError, "tab_label should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_notebook_set_tab_label(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), (GtkWidget *) tab_label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_set_tab_label_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "tab_text", NULL };
    PyGObject *child;
    char *tab_text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.Notebook.set_tab_label_text", kwlist, &PyGtkWidget_Type, &child, &tab_text))
        return NULL;
    
    gtk_notebook_set_tab_label_text(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), tab_text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_tab_label_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    const gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Notebook.get_tab_label_text", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    ret = gtk_notebook_get_tab_label_text(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_menu_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Notebook.get_menu_label", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    ret = gtk_notebook_get_menu_label(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_notebook_set_menu_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "menu_label", NULL };
    PyGObject *child, *py_menu_label = NULL;
    GtkWidget *menu_label = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|O:Gtk.Notebook.set_menu_label", kwlist, &PyGtkWidget_Type, &child, &py_menu_label))
        return NULL;
    if ((PyObject *)py_menu_label == Py_None)
        menu_label = NULL;
    else if (py_menu_label && pygobject_check(py_menu_label, &PyGtkWidget_Type))
        menu_label = GTK_WIDGET(py_menu_label->obj);
    else if (py_menu_label) {
        PyErr_SetString(PyExc_TypeError, "menu_label should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_notebook_set_menu_label(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), (GtkWidget *) menu_label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_set_menu_label_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "menu_text", NULL };
    PyGObject *child;
    char *menu_text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.Notebook.set_menu_label_text", kwlist, &PyGtkWidget_Type, &child, &menu_text))
        return NULL;
    
    gtk_notebook_set_menu_label_text(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), menu_text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_menu_label_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    const gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Notebook.get_menu_label_text", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    ret = gtk_notebook_get_menu_label_text(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2172 "./gtk.override"
static PyObject *
_wrap_gtk_notebook_query_tab_label_packing(PyGObject *self, PyObject *args,
                                           PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkNotebook.query_tab_label_packing",
                                     kwlist, &child))
        return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError, "child must be a GtkWidget");
        return NULL;
    }
    gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(self->obj),
                                         GTK_WIDGET(child->obj),
                                         &expand, &fill, &pack_type);
    return Py_BuildValue("(iiN)", expand, fill,
			 pyg_enum_from_gtype(GTK_TYPE_PACK_TYPE, pack_type));
}
#line 66746 "gtk.c"


static PyObject *
_wrap_gtk_notebook_set_tab_label_packing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "expand", "fill", "pack_type", NULL };
    PyGObject *child;
    int expand, fill;
    GtkPackType pack_type;
    PyObject *py_pack_type = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iiO:Gtk.Notebook.set_tab_label_packing", kwlist, &PyGtkWidget_Type, &child, &expand, &fill, &py_pack_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PACK_TYPE, py_pack_type, (gpointer)&pack_type))
        return NULL;
    
    gtk_notebook_set_tab_label_packing(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), expand, fill, pack_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_reorder_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "position", NULL };
    PyGObject *child;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Notebook.reorder_child", kwlist, &PyGtkWidget_Type, &child, &position))
        return NULL;
    
    gtk_notebook_reorder_child(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_current_page(PyGObject *self)
{
    int ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkNotebook.get_current_page") < 0)
        return NULL;
    
    ret = gtk_notebook_current_page(GTK_NOTEBOOK(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_set_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_num", NULL };
    int page_num;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Notebook.set_page", kwlist, &page_num))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkNotebook.set_current_page") < 0)
        return NULL;
    
    gtk_notebook_set_page(GTK_NOTEBOOK(self->obj), page_num);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_set_group_id(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group_id", NULL };
    int group_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Notebook.set_group_id", kwlist, &group_id))
        return NULL;
    
    gtk_notebook_set_group_id(GTK_NOTEBOOK(self->obj), group_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_group_id(PyGObject *self)
{
    int ret;

    
    ret = gtk_notebook_get_group_id(GTK_NOTEBOOK(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_get_tab_reorderable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Notebook.get_tab_reorderable", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    ret = gtk_notebook_get_tab_reorderable(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_notebook_set_tab_reorderable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "reorderable", NULL };
    PyGObject *child;
    int reorderable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Notebook.set_tab_reorderable", kwlist, &PyGtkWidget_Type, &child, &reorderable))
        return NULL;
    
    gtk_notebook_set_tab_reorderable(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), reorderable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_tab_detachable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Notebook.get_tab_detachable", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    ret = gtk_notebook_get_tab_detachable(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_notebook_set_tab_detachable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "detachable", NULL };
    PyGObject *child;
    int detachable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Notebook.set_tab_detachable", kwlist, &PyGtkWidget_Type, &child, &detachable))
        return NULL;
    
    gtk_notebook_set_tab_detachable(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), detachable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_action_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pack_type", NULL };
    GtkPackType pack_type;
    PyObject *py_pack_type = NULL;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Notebook.get_action_widget", kwlist, &py_pack_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PACK_TYPE, py_pack_type, (gpointer)&pack_type))
        return NULL;
    
    ret = gtk_notebook_get_action_widget(GTK_NOTEBOOK(self->obj), pack_type);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_notebook_set_action_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "pack_type", NULL };
    PyGObject *widget;
    GtkPackType pack_type;
    PyObject *py_pack_type = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Notebook.set_action_widget", kwlist, &PyGtkWidget_Type, &widget, &py_pack_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PACK_TYPE, py_pack_type, (gpointer)&pack_type))
        return NULL;
    
    gtk_notebook_set_action_widget(GTK_NOTEBOOK(self->obj), GTK_WIDGET(widget->obj), pack_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_tab_hborder(PyGObject *self)
{
    int ret;

    
    ret = gtk_notebook_get_tab_hborder(GTK_NOTEBOOK(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_get_tab_vborder(PyGObject *self)
{
    int ret;

    
    ret = gtk_notebook_get_tab_vborder(GTK_NOTEBOOK(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_notebook_set_group_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group_name", NULL };
    char *group_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Notebook.set_group_name", kwlist, &group_name))
        return NULL;
    
    gtk_notebook_set_group_name(GTK_NOTEBOOK(self->obj), group_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_notebook_get_group_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_notebook_get_group_name(GTK_NOTEBOOK(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkNotebook__do_select_page(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "move_focus", NULL };
    PyGObject *self;
    int move_focus, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Notebook.select_page", kwlist, &PyGtkNotebook_Type, &self, &move_focus))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_NOTEBOOK_CLASS(klass)->select_page)
        ret = GTK_NOTEBOOK_CLASS(klass)->select_page(GTK_NOTEBOOK(self->obj), move_focus);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Notebook.select_page not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkNotebook__do_focus_tab(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "type", NULL };
    PyGObject *self;
    PyObject *py_type = NULL;
    int ret;
    GtkNotebookTab type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Notebook.focus_tab", kwlist, &PyGtkNotebook_Type, &self, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_NOTEBOOK_TAB, py_type, (gpointer)&type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_NOTEBOOK_CLASS(klass)->focus_tab)
        ret = GTK_NOTEBOOK_CLASS(klass)->focus_tab(GTK_NOTEBOOK(self->obj), type);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Notebook.focus_tab not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkNotebook__do_change_current_page(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "offset", NULL };
    PyGObject *self;
    int offset, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Notebook.change_current_page", kwlist, &PyGtkNotebook_Type, &self, &offset))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_NOTEBOOK_CLASS(klass)->change_current_page)
        ret = GTK_NOTEBOOK_CLASS(klass)->change_current_page(GTK_NOTEBOOK(self->obj), offset);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Notebook.change_current_page not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkNotebook__do_reorder_tab(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "direction", "move_to_last", NULL };
    PyGObject *self;
    PyObject *py_direction = NULL;
    int move_to_last, ret;
    GtkDirectionType direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oi:Gtk.Notebook.reorder_tab", kwlist, &PyGtkNotebook_Type, &self, &py_direction, &move_to_last))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, py_direction, (gpointer)&direction))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_NOTEBOOK_CLASS(klass)->reorder_tab)
        ret = GTK_NOTEBOOK_CLASS(klass)->reorder_tab(GTK_NOTEBOOK(self->obj), direction, move_to_last);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Notebook.reorder_tab not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkNotebook__do_insert_page(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "child", "tab_label", "menu_label", "position", NULL };
    PyGObject *self, *child, *tab_label, *menu_label;
    int position, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!O!i:Gtk.Notebook.insert_page", kwlist, &PyGtkNotebook_Type, &self, &PyGtkWidget_Type, &child, &PyGtkWidget_Type, &tab_label, &PyGtkWidget_Type, &menu_label, &position))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_NOTEBOOK_CLASS(klass)->insert_page)
        ret = GTK_NOTEBOOK_CLASS(klass)->insert_page(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), GTK_WIDGET(tab_label->obj), GTK_WIDGET(menu_label->obj), position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Notebook.insert_page not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyInt_FromLong(ret);
}

static const PyMethodDef _PyGtkNotebook_methods[] = {
    { "append_page", (PyCFunction)_wrap_gtk_notebook_append_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "append_page_menu", (PyCFunction)_wrap_gtk_notebook_append_page_menu, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend_page", (PyCFunction)_wrap_gtk_notebook_prepend_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend_page_menu", (PyCFunction)_wrap_gtk_notebook_prepend_page_menu, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_page", (PyCFunction)_wrap_gtk_notebook_insert_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_page_menu", (PyCFunction)_wrap_gtk_notebook_insert_page_menu, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_page", (PyCFunction)_wrap_gtk_notebook_remove_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_page", (PyCFunction)_wrap_gtk_notebook_get_current_page, METH_NOARGS,
      NULL },
    { "get_nth_page", (PyCFunction)_wrap_gtk_notebook_get_nth_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_n_pages", (PyCFunction)_wrap_gtk_notebook_get_n_pages, METH_NOARGS,
      NULL },
    { "page_num", (PyCFunction)_wrap_gtk_notebook_page_num, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_current_page", (PyCFunction)_wrap_gtk_notebook_set_current_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "next_page", (PyCFunction)_wrap_gtk_notebook_next_page, METH_NOARGS,
      NULL },
    { "prev_page", (PyCFunction)_wrap_gtk_notebook_prev_page, METH_NOARGS,
      NULL },
    { "set_show_border", (PyCFunction)_wrap_gtk_notebook_set_show_border, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_border", (PyCFunction)_wrap_gtk_notebook_get_show_border, METH_NOARGS,
      NULL },
    { "set_show_tabs", (PyCFunction)_wrap_gtk_notebook_set_show_tabs, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_tabs", (PyCFunction)_wrap_gtk_notebook_get_show_tabs, METH_NOARGS,
      NULL },
    { "set_tab_pos", (PyCFunction)_wrap_gtk_notebook_set_tab_pos, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tab_pos", (PyCFunction)_wrap_gtk_notebook_get_tab_pos, METH_NOARGS,
      NULL },
    { "set_homogeneous_tabs", (PyCFunction)_wrap_gtk_notebook_set_homogeneous_tabs, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tab_border", (PyCFunction)_wrap_gtk_notebook_set_tab_border, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tab_hborder", (PyCFunction)_wrap_gtk_notebook_set_tab_hborder, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tab_vborder", (PyCFunction)_wrap_gtk_notebook_set_tab_vborder, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_scrollable", (PyCFunction)_wrap_gtk_notebook_set_scrollable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_scrollable", (PyCFunction)_wrap_gtk_notebook_get_scrollable, METH_NOARGS,
      NULL },
    { "popup_enable", (PyCFunction)_wrap_gtk_notebook_popup_enable, METH_NOARGS,
      NULL },
    { "popup_disable", (PyCFunction)_wrap_gtk_notebook_popup_disable, METH_NOARGS,
      NULL },
    { "get_tab_label", (PyCFunction)_wrap_gtk_notebook_get_tab_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tab_label", (PyCFunction)_wrap_gtk_notebook_set_tab_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tab_label_text", (PyCFunction)_wrap_gtk_notebook_set_tab_label_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tab_label_text", (PyCFunction)_wrap_gtk_notebook_get_tab_label_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_menu_label", (PyCFunction)_wrap_gtk_notebook_get_menu_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_menu_label", (PyCFunction)_wrap_gtk_notebook_set_menu_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_menu_label_text", (PyCFunction)_wrap_gtk_notebook_set_menu_label_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_menu_label_text", (PyCFunction)_wrap_gtk_notebook_get_menu_label_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "query_tab_label_packing", (PyCFunction)_wrap_gtk_notebook_query_tab_label_packing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tab_label_packing", (PyCFunction)_wrap_gtk_notebook_set_tab_label_packing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reorder_child", (PyCFunction)_wrap_gtk_notebook_reorder_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "current_page", (PyCFunction)_wrap_gtk_notebook_current_page, METH_NOARGS,
      NULL },
    { "set_page", (PyCFunction)_wrap_gtk_notebook_set_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_group_id", (PyCFunction)_wrap_gtk_notebook_set_group_id, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_group_id", (PyCFunction)_wrap_gtk_notebook_get_group_id, METH_NOARGS,
      NULL },
    { "get_tab_reorderable", (PyCFunction)_wrap_gtk_notebook_get_tab_reorderable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tab_reorderable", (PyCFunction)_wrap_gtk_notebook_set_tab_reorderable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tab_detachable", (PyCFunction)_wrap_gtk_notebook_get_tab_detachable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tab_detachable", (PyCFunction)_wrap_gtk_notebook_set_tab_detachable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_action_widget", (PyCFunction)_wrap_gtk_notebook_get_action_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_action_widget", (PyCFunction)_wrap_gtk_notebook_set_action_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tab_hborder", (PyCFunction)_wrap_gtk_notebook_get_tab_hborder, METH_NOARGS,
      NULL },
    { "get_tab_vborder", (PyCFunction)_wrap_gtk_notebook_get_tab_vborder, METH_NOARGS,
      NULL },
    { "set_group_name", (PyCFunction)_wrap_gtk_notebook_set_group_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_group_name", (PyCFunction)_wrap_gtk_notebook_get_group_name, METH_NOARGS,
      NULL },
    { "do_select_page", (PyCFunction)_wrap_GtkNotebook__do_select_page, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_focus_tab", (PyCFunction)_wrap_GtkNotebook__do_focus_tab, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_change_current_page", (PyCFunction)_wrap_GtkNotebook__do_change_current_page, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_reorder_tab", (PyCFunction)_wrap_GtkNotebook__do_reorder_tab, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_insert_page", (PyCFunction)_wrap_GtkNotebook__do_insert_page, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_notebook__get_tab_pos(PyObject *self, void *closure)
{
    gint ret;

    ret = GTK_NOTEBOOK(pygobject_get(self))->tab_pos;
    return pyg_enum_from_gtype(GTK_TYPE_POSITION_TYPE, ret);
}

static const PyGetSetDef gtk_notebook_getsets[] = {
    { "tab_pos", (getter)_wrap_gtk_notebook__get_tab_pos, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkNotebook_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Notebook",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkNotebook_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_notebook_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_notebook_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gboolean
_wrap_GtkNotebook__proxy_do_select_page(GtkNotebook *self, gboolean move_focus)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_move_focus;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_move_focus = move_focus? Py_True : Py_False;
    
    py_args = PyTuple_New(1);
    Py_INCREF(py_move_focus);
    PyTuple_SET_ITEM(py_args, 0, py_move_focus);
    
    py_method = PyObject_GetAttrString(py_self, "do_select_page");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkNotebook__proxy_do_focus_tab(GtkNotebook *self, GtkNotebookTab type)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_type;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_type = pyg_enum_from_gtype(GTK_TYPE_NOTEBOOK_TAB, type);
    if (!py_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_type);
    
    py_method = PyObject_GetAttrString(py_self, "do_focus_tab");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkNotebook__proxy_do_change_current_page(GtkNotebook *self, gint offset)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_offset;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_offset = PyInt_FromLong(offset);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_offset);
    
    py_method = PyObject_GetAttrString(py_self, "do_change_current_page");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkNotebook__proxy_do_reorder_tab(GtkNotebook *self, GtkDirectionType direction, gboolean move_to_last)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_direction;
    PyObject *py_move_to_last;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_direction = pyg_enum_from_gtype(GTK_TYPE_DIRECTION_TYPE, direction);
    if (!py_direction) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_move_to_last = move_to_last? Py_True : Py_False;
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_direction);
    Py_INCREF(py_move_to_last);
    PyTuple_SET_ITEM(py_args, 1, py_move_to_last);
    
    py_method = PyObject_GetAttrString(py_self, "do_reorder_tab");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gint
_wrap_GtkNotebook__proxy_do_insert_page(GtkNotebook *self, GtkWidget*child, GtkWidget*tab_label, GtkWidget*menu_label, gint position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_child = NULL;
    PyObject *py_tab_label = NULL;
    PyObject *py_menu_label = NULL;
    PyObject *py_position;
    gint retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    if (child)
        py_child = pygobject_new((GObject *) child);
    else {
        Py_INCREF(Py_None);
        py_child = Py_None;
    }
    if (tab_label)
        py_tab_label = pygobject_new((GObject *) tab_label);
    else {
        Py_INCREF(Py_None);
        py_tab_label = Py_None;
    }
    if (menu_label)
        py_menu_label = pygobject_new((GObject *) menu_label);
    else {
        Py_INCREF(Py_None);
        py_menu_label = Py_None;
    }
    py_position = PyInt_FromLong(position);
    
    py_args = PyTuple_New(4);
    PyTuple_SET_ITEM(py_args, 0, py_child);
    PyTuple_SET_ITEM(py_args, 1, py_tab_label);
    PyTuple_SET_ITEM(py_args, 2, py_menu_label);
    PyTuple_SET_ITEM(py_args, 3, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_insert_page");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "i", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkNotebook_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkNotebookClass *klass = GTK_NOTEBOOK_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    /* overriding do_switch_page is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_page");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_page")))
            klass->select_page = _wrap_GtkNotebook__proxy_do_select_page;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_focus_tab");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "focus_tab")))
            klass->focus_tab = _wrap_GtkNotebook__proxy_do_focus_tab;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_change_current_page");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "change_current_page")))
            klass->change_current_page = _wrap_GtkNotebook__proxy_do_change_current_page;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_reorder_tab");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "reorder_tab")))
            klass->reorder_tab = _wrap_GtkNotebook__proxy_do_reorder_tab;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_insert_page");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "insert_page")))
            klass->insert_page = _wrap_GtkNotebook__proxy_do_insert_page;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkOldEditable ----------- */

static PyObject *
_wrap_gtk_old_editable_claim_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "claim", "time", NULL };
    int claim;
    unsigned long time = GDK_CURRENT_TIME;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i|k:Gtk.OldEditable.claim_selection", kwlist, &claim, &time))
        return NULL;
    
    gtk_old_editable_claim_selection(GTK_OLD_EDITABLE(self->obj), claim, time);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_old_editable_changed(PyGObject *self)
{
    
    gtk_old_editable_changed(GTK_OLD_EDITABLE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.OldEditable.activate", kwlist, &PyGtkOldEditable_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->activate)
        GTK_OLD_EDITABLE_CLASS(klass)->activate(GTK_OLD_EDITABLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_set_editable(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "is_editable", NULL };
    PyGObject *self;
    int is_editable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.OldEditable.set_editable", kwlist, &PyGtkOldEditable_Type, &self, &is_editable))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->set_editable)
        GTK_OLD_EDITABLE_CLASS(klass)->set_editable(GTK_OLD_EDITABLE(self->obj), is_editable);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.set_editable not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_move_cursor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "x", "y", NULL };
    PyGObject *self;
    int x, y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.OldEditable.move_cursor", kwlist, &PyGtkOldEditable_Type, &self, &x, &y))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->move_cursor)
        GTK_OLD_EDITABLE_CLASS(klass)->move_cursor(GTK_OLD_EDITABLE(self->obj), x, y);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.move_cursor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_move_word(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "n", NULL };
    PyGObject *self;
    int n;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.OldEditable.move_word", kwlist, &PyGtkOldEditable_Type, &self, &n))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->move_word)
        GTK_OLD_EDITABLE_CLASS(klass)->move_word(GTK_OLD_EDITABLE(self->obj), n);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.move_word not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_move_page(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "x", "y", NULL };
    PyGObject *self;
    int x, y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.OldEditable.move_page", kwlist, &PyGtkOldEditable_Type, &self, &x, &y))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->move_page)
        GTK_OLD_EDITABLE_CLASS(klass)->move_page(GTK_OLD_EDITABLE(self->obj), x, y);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.move_page not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_move_to_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "row", NULL };
    PyGObject *self;
    int row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.OldEditable.move_to_row", kwlist, &PyGtkOldEditable_Type, &self, &row))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->move_to_row)
        GTK_OLD_EDITABLE_CLASS(klass)->move_to_row(GTK_OLD_EDITABLE(self->obj), row);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.move_to_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_move_to_column(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "row", NULL };
    PyGObject *self;
    int row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.OldEditable.move_to_column", kwlist, &PyGtkOldEditable_Type, &self, &row))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->move_to_column)
        GTK_OLD_EDITABLE_CLASS(klass)->move_to_column(GTK_OLD_EDITABLE(self->obj), row);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.move_to_column not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_kill_char(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "direction", NULL };
    PyGObject *self;
    int direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.OldEditable.kill_char", kwlist, &PyGtkOldEditable_Type, &self, &direction))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->kill_char)
        GTK_OLD_EDITABLE_CLASS(klass)->kill_char(GTK_OLD_EDITABLE(self->obj), direction);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.kill_char not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_kill_word(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "direction", NULL };
    PyGObject *self;
    int direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.OldEditable.kill_word", kwlist, &PyGtkOldEditable_Type, &self, &direction))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->kill_word)
        GTK_OLD_EDITABLE_CLASS(klass)->kill_word(GTK_OLD_EDITABLE(self->obj), direction);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.kill_word not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_kill_line(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "direction", NULL };
    PyGObject *self;
    int direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.OldEditable.kill_line", kwlist, &PyGtkOldEditable_Type, &self, &direction))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->kill_line)
        GTK_OLD_EDITABLE_CLASS(klass)->kill_line(GTK_OLD_EDITABLE(self->obj), direction);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.kill_line not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_cut_clipboard(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.OldEditable.cut_clipboard", kwlist, &PyGtkOldEditable_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->cut_clipboard)
        GTK_OLD_EDITABLE_CLASS(klass)->cut_clipboard(GTK_OLD_EDITABLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.cut_clipboard not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_copy_clipboard(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.OldEditable.copy_clipboard", kwlist, &PyGtkOldEditable_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->copy_clipboard)
        GTK_OLD_EDITABLE_CLASS(klass)->copy_clipboard(GTK_OLD_EDITABLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.copy_clipboard not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_paste_clipboard(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.OldEditable.paste_clipboard", kwlist, &PyGtkOldEditable_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->paste_clipboard)
        GTK_OLD_EDITABLE_CLASS(klass)->paste_clipboard(GTK_OLD_EDITABLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.paste_clipboard not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_update_text(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "start_pos", "end_pos", NULL };
    PyGObject *self;
    int start_pos, end_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.OldEditable.update_text", kwlist, &PyGtkOldEditable_Type, &self, &start_pos, &end_pos))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->update_text)
        GTK_OLD_EDITABLE_CLASS(klass)->update_text(GTK_OLD_EDITABLE(self->obj), start_pos, end_pos);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.update_text not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_get_chars(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "start_pos", "end_pos", NULL };
    PyGObject *self;
    int start_pos, end_pos;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.OldEditable.get_chars", kwlist, &PyGtkOldEditable_Type, &self, &start_pos, &end_pos))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->get_chars)
        ret = GTK_OLD_EDITABLE_CLASS(klass)->get_chars(GTK_OLD_EDITABLE(self->obj), start_pos, end_pos);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.get_chars not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_set_selection(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "start_pos", "end_pos", NULL };
    PyGObject *self;
    int start_pos, end_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.OldEditable.set_selection", kwlist, &PyGtkOldEditable_Type, &self, &start_pos, &end_pos))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->set_selection)
        GTK_OLD_EDITABLE_CLASS(klass)->set_selection(GTK_OLD_EDITABLE(self->obj), start_pos, end_pos);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.set_selection not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOldEditable__do_set_position(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "position", NULL };
    PyGObject *self;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.OldEditable.set_position", kwlist, &PyGtkOldEditable_Type, &self, &position))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OLD_EDITABLE_CLASS(klass)->set_position)
        GTK_OLD_EDITABLE_CLASS(klass)->set_position(GTK_OLD_EDITABLE(self->obj), position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OldEditable.set_position not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkOldEditable_methods[] = {
    { "claim_selection", (PyCFunction)_wrap_gtk_old_editable_claim_selection, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "changed", (PyCFunction)_wrap_gtk_old_editable_changed, METH_NOARGS,
      NULL },
    { "do_activate", (PyCFunction)_wrap_GtkOldEditable__do_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_editable", (PyCFunction)_wrap_GtkOldEditable__do_set_editable, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_cursor", (PyCFunction)_wrap_GtkOldEditable__do_move_cursor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_word", (PyCFunction)_wrap_GtkOldEditable__do_move_word, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_page", (PyCFunction)_wrap_GtkOldEditable__do_move_page, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_to_row", (PyCFunction)_wrap_GtkOldEditable__do_move_to_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_to_column", (PyCFunction)_wrap_GtkOldEditable__do_move_to_column, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_kill_char", (PyCFunction)_wrap_GtkOldEditable__do_kill_char, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_kill_word", (PyCFunction)_wrap_GtkOldEditable__do_kill_word, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_kill_line", (PyCFunction)_wrap_GtkOldEditable__do_kill_line, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_cut_clipboard", (PyCFunction)_wrap_GtkOldEditable__do_cut_clipboard, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_copy_clipboard", (PyCFunction)_wrap_GtkOldEditable__do_copy_clipboard, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_paste_clipboard", (PyCFunction)_wrap_GtkOldEditable__do_paste_clipboard, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_update_text", (PyCFunction)_wrap_GtkOldEditable__do_update_text, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_chars", (PyCFunction)_wrap_GtkOldEditable__do_get_chars, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_selection", (PyCFunction)_wrap_GtkOldEditable__do_set_selection, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_position", (PyCFunction)_wrap_GtkOldEditable__do_set_position, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkOldEditable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.OldEditable",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkOldEditable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkOldEditable__proxy_do_activate(GtkOldEditable *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_set_editable(GtkOldEditable *self, gboolean is_editable)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_is_editable;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_is_editable = is_editable? Py_True : Py_False;
    
    py_args = PyTuple_New(1);
    Py_INCREF(py_is_editable);
    PyTuple_SET_ITEM(py_args, 0, py_is_editable);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_editable");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_move_cursor(GtkOldEditable *self, gint x, gint y)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_x);
    PyTuple_SET_ITEM(py_args, 1, py_y);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_cursor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_move_word(GtkOldEditable *self, gint n)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_n;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_n = PyInt_FromLong(n);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_n);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_word");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_move_page(GtkOldEditable *self, gint x, gint y)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_x);
    PyTuple_SET_ITEM(py_args, 1, py_y);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_page");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_move_to_row(GtkOldEditable *self, gint row)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_row;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_row = PyInt_FromLong(row);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_row);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_to_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_move_to_column(GtkOldEditable *self, gint row)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_row;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_row = PyInt_FromLong(row);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_row);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_to_column");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_kill_char(GtkOldEditable *self, gint direction)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_direction;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_direction = PyInt_FromLong(direction);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_direction);
    
    py_method = PyObject_GetAttrString(py_self, "do_kill_char");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_kill_word(GtkOldEditable *self, gint direction)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_direction;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_direction = PyInt_FromLong(direction);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_direction);
    
    py_method = PyObject_GetAttrString(py_self, "do_kill_word");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_kill_line(GtkOldEditable *self, gint direction)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_direction;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_direction = PyInt_FromLong(direction);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_direction);
    
    py_method = PyObject_GetAttrString(py_self, "do_kill_line");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_cut_clipboard(GtkOldEditable *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_cut_clipboard");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_copy_clipboard(GtkOldEditable *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_copy_clipboard");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_paste_clipboard(GtkOldEditable *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_paste_clipboard");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_update_text(GtkOldEditable *self, gint start_pos, gint end_pos)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_start_pos;
    PyObject *py_end_pos;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_start_pos = PyInt_FromLong(start_pos);
    py_end_pos = PyInt_FromLong(end_pos);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_start_pos);
    PyTuple_SET_ITEM(py_args, 1, py_end_pos);
    
    py_method = PyObject_GetAttrString(py_self, "do_update_text");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gchar*
_wrap_GtkOldEditable__proxy_do_get_chars(GtkOldEditable *self, gint start_pos, gint end_pos)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_start_pos;
    PyObject *py_end_pos;
    gchar* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_start_pos = PyInt_FromLong(start_pos);
    py_end_pos = PyInt_FromLong(end_pos);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_start_pos);
    PyTuple_SET_ITEM(py_args, 1, py_end_pos);
    
    py_method = PyObject_GetAttrString(py_self, "do_get_chars");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "s", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    retval = g_strdup(retval);
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkOldEditable__proxy_do_set_selection(GtkOldEditable *self, gint start_pos, gint end_pos)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_start_pos;
    PyObject *py_end_pos;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_start_pos = PyInt_FromLong(start_pos);
    py_end_pos = PyInt_FromLong(end_pos);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_start_pos);
    PyTuple_SET_ITEM(py_args, 1, py_end_pos);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_selection");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkOldEditable__proxy_do_set_position(GtkOldEditable *self, gint position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_position;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_position = PyInt_FromLong(position);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_position");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkOldEditable_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkOldEditableClass *klass = GTK_OLD_EDITABLE_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate")))
            klass->activate = _wrap_GtkOldEditable__proxy_do_activate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_editable");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_editable")))
            klass->set_editable = _wrap_GtkOldEditable__proxy_do_set_editable;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_cursor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_cursor")))
            klass->move_cursor = _wrap_GtkOldEditable__proxy_do_move_cursor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_word");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_word")))
            klass->move_word = _wrap_GtkOldEditable__proxy_do_move_word;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_page");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_page")))
            klass->move_page = _wrap_GtkOldEditable__proxy_do_move_page;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_to_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_to_row")))
            klass->move_to_row = _wrap_GtkOldEditable__proxy_do_move_to_row;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_to_column");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_to_column")))
            klass->move_to_column = _wrap_GtkOldEditable__proxy_do_move_to_column;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_kill_char");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "kill_char")))
            klass->kill_char = _wrap_GtkOldEditable__proxy_do_kill_char;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_kill_word");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "kill_word")))
            klass->kill_word = _wrap_GtkOldEditable__proxy_do_kill_word;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_kill_line");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "kill_line")))
            klass->kill_line = _wrap_GtkOldEditable__proxy_do_kill_line;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_cut_clipboard");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "cut_clipboard")))
            klass->cut_clipboard = _wrap_GtkOldEditable__proxy_do_cut_clipboard;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_copy_clipboard");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "copy_clipboard")))
            klass->copy_clipboard = _wrap_GtkOldEditable__proxy_do_copy_clipboard;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_paste_clipboard");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "paste_clipboard")))
            klass->paste_clipboard = _wrap_GtkOldEditable__proxy_do_paste_clipboard;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_update_text");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "update_text")))
            klass->update_text = _wrap_GtkOldEditable__proxy_do_update_text;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_get_chars");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "get_chars")))
            klass->get_chars = _wrap_GtkOldEditable__proxy_do_get_chars;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_selection");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_selection")))
            klass->set_selection = _wrap_GtkOldEditable__proxy_do_set_selection;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_position");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_position")))
            klass->set_position = _wrap_GtkOldEditable__proxy_do_set_position;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkOptionMenu ----------- */

static int
_wrap_gtk_option_menu_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.ComboBox") < 0)
        return -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.OptionMenu.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.OptionMenu object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_option_menu_get_menu(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_option_menu_get_menu(GTK_OPTION_MENU(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_option_menu_set_menu(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "menu", NULL };
    PyGObject *menu;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.OptionMenu.set_menu", kwlist, &PyGtkWidget_Type, &menu))
        return NULL;
    
    gtk_option_menu_set_menu(GTK_OPTION_MENU(self->obj), GTK_WIDGET(menu->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_option_menu_remove_menu(PyGObject *self)
{
    
    gtk_option_menu_remove_menu(GTK_OPTION_MENU(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_option_menu_get_history(PyGObject *self)
{
    int ret;

    
    ret = gtk_option_menu_get_history(GTK_OPTION_MENU(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_option_menu_set_history(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "index", NULL };
    PyObject *py_index = NULL;
    guint index = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.OptionMenu.set_history", kwlist, &py_index))
        return NULL;
    if (py_index) {
        if (PyLong_Check(py_index))
            index = PyLong_AsUnsignedLong(py_index);
        else if (PyInt_Check(py_index))
            index = PyInt_AsLong(py_index);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'index' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_option_menu_set_history(GTK_OPTION_MENU(self->obj), index);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkOptionMenu__do_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.OptionMenu.changed", kwlist, &PyGtkOptionMenu_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_OPTION_MENU_CLASS(klass)->changed)
        GTK_OPTION_MENU_CLASS(klass)->changed(GTK_OPTION_MENU(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.OptionMenu.changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkOptionMenu_methods[] = {
    { "get_menu", (PyCFunction)_wrap_gtk_option_menu_get_menu, METH_NOARGS,
      NULL },
    { "set_menu", (PyCFunction)_wrap_gtk_option_menu_set_menu, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_menu", (PyCFunction)_wrap_gtk_option_menu_remove_menu, METH_NOARGS,
      NULL },
    { "get_history", (PyCFunction)_wrap_gtk_option_menu_get_history, METH_NOARGS,
      NULL },
    { "set_history", (PyCFunction)_wrap_gtk_option_menu_set_history, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_changed", (PyCFunction)_wrap_GtkOptionMenu__do_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkOptionMenu_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.OptionMenu",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkOptionMenu_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_option_menu_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkOptionMenu__proxy_do_changed(GtkOptionMenu *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkOptionMenu_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkOptionMenuClass *klass = GTK_OPTION_MENU_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "changed")))
            klass->changed = _wrap_GtkOptionMenu__proxy_do_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkPixmap ----------- */

#line 5515 "./gtk.override"
static int
_wrap_gtk_pixmap_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixmap", "mask", NULL };
    PyGObject *pixmap, *py_mask;
    GdkPixmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O:GtkPixmap.__init__",
                                     kwlist, &PyGdkPixmap_Type, &pixmap, &py_mask))
        return -1;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkImage") < 0)
        return -1;
    if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if ((PyObject *)py_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return -1;
    }

    pygobject_construct(self, NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkPixmap object");
        return -1;
    }

    gtk_pixmap_set(GTK_PIXMAP(self->obj), GDK_PIXMAP(pixmap->obj), mask);

    return 0;
}
#line 69732 "gtk.c"


static PyObject *
_wrap_gtk_pixmap_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "val", "mask", NULL };
    PyGObject *val, *py_mask;
    GdkPixmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Pixmap.set", kwlist, &PyGdkPixmap_Type, &val, &py_mask))
        return NULL;
    if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if ((PyObject *)py_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return NULL;
    }
    
    gtk_pixmap_set(GTK_PIXMAP(self->obj), GDK_PIXMAP(val->obj), (GdkBitmap *) mask);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1631 "./gtk.override"
static PyObject *
_wrap_gtk_pixmap_get(PyGObject *self)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    gtk_pixmap_get(GTK_PIXMAP(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
                         pygobject_new((GObject *)mask));
}

#line 69769 "gtk.c"


static PyObject *
_wrap_gtk_pixmap_set_build_insensitive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "build", NULL };
    int build;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Pixmap.set_build_insensitive", kwlist, &build))
        return NULL;
    
    gtk_pixmap_set_build_insensitive(GTK_PIXMAP(self->obj), build);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkPixmap_methods[] = {
    { "set", (PyCFunction)_wrap_gtk_pixmap_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get", (PyCFunction)_wrap_gtk_pixmap_get, METH_NOARGS,
      NULL },
    { "set_build_insensitive", (PyCFunction)_wrap_gtk_pixmap_set_build_insensitive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkPixmap_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Pixmap",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkPixmap_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_pixmap_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkPlug ----------- */

#line 5548 "./gtk.override"
static int
_wrap_gtk_plug_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "socket_id", "display", NULL };
    gulong socket_id;
    PyGObject *display = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "k|O!:GtkPlug.__init__", kwlist,
                                     &socket_id, &PyGdkDisplay_Type, &display))
        return -1;

    pygobject_construct(self, NULL);

    if (display)
        gtk_plug_construct_for_display(GTK_PLUG(self->obj),
                                       GDK_DISPLAY(display->obj), socket_id);
    else
        gtk_plug_construct(GTK_PLUG(self->obj), socket_id);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkPlug object");
        return -1;
    }
    return 0;
}
#line 69871 "gtk.c"


static PyObject *
_wrap_gtk_plug_get_id(PyGObject *self)
{
    GdkNativeWindow ret;

    
    ret = gtk_plug_get_id(GTK_PLUG(self->obj));
    
    return PyLong_FromUnsignedLong((unsigned long)ret);

}

static PyObject *
_wrap_gtk_plug_get_embedded(PyGObject *self)
{
    int ret;

    
    ret = gtk_plug_get_embedded(GTK_PLUG(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_plug_get_socket_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_plug_get_socket_window(GTK_PLUG(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkPlug__do_embedded(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Plug.embedded", kwlist, &PyGtkPlug_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PLUG_CLASS(klass)->embedded)
        GTK_PLUG_CLASS(klass)->embedded(GTK_PLUG(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Plug.embedded not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkPlug_methods[] = {
    { "get_id", (PyCFunction)_wrap_gtk_plug_get_id, METH_NOARGS,
      NULL },
    { "get_embedded", (PyCFunction)_wrap_gtk_plug_get_embedded, METH_NOARGS,
      NULL },
    { "get_socket_window", (PyCFunction)_wrap_gtk_plug_get_socket_window, METH_NOARGS,
      NULL },
    { "do_embedded", (PyCFunction)_wrap_GtkPlug__do_embedded, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkPlug_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Plug",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkPlug_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_plug_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkPlug__proxy_do_embedded(GtkPlug *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_embedded");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkPlug_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkPlugClass *klass = GTK_PLUG_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_embedded");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "embedded")))
            klass->embedded = _wrap_GtkPlug__proxy_do_embedded;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkPreview ----------- */

static int
_wrap_gtk_preview_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    PyObject *py_type = NULL;
    GtkPreviewType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Preview.__init__", kwlist, &py_type))
        return -1;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkDrawingArea") < 0)
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_PREVIEW_TYPE, py_type, (gpointer)&type))
        return -1;
    self->obj = (GObject *)gtk_preview_new(type);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkPreview object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}

static PyObject *
_wrap_gtk_preview_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", "height", NULL };
    int width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Preview.size", kwlist, &width, &height))
        return NULL;
    
    gtk_preview_size(GTK_PREVIEW(self->obj), width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_preview_put(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "gc", "srcx", "srcy", "destx", "desty", "width", "height", NULL };
    PyGObject *window, *gc;
    int srcx, srcy, destx, desty, width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!iiiiii:Gtk.Preview.put", kwlist, &PyGdkWindow_Type, &window, &PyGdkGC_Type, &gc, &srcx, &srcy, &destx, &desty, &width, &height))
        return NULL;
    
    gtk_preview_put(GTK_PREVIEW(self->obj), GDK_WINDOW(window->obj), GDK_GC(gc->obj), srcx, srcy, destx, desty, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_preview_draw_row(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "data", "x", "y", "w", NULL };
    int x, y, w;
    guchar *data;
    Py_ssize_t data_len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s#iii:Gtk.Preview.draw_row", kwlist, &data, &data_len, &x, &y, &w))
        return NULL;
    
    gtk_preview_draw_row(GTK_PREVIEW(self->obj), data, x, y, w);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_preview_set_expand(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "expand", NULL };
    int expand;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Preview.set_expand", kwlist, &expand))
        return NULL;
    
    gtk_preview_set_expand(GTK_PREVIEW(self->obj), expand);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_preview_set_dither(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dither", NULL };
    PyObject *py_dither = NULL;
    GdkRgbDither dither;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Preview.set_dither", kwlist, &py_dither))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkPixbuf") < 0)
        return NULL;
    if (pyg_enum_get_value(GDK_TYPE_RGB_DITHER, py_dither, (gpointer)&dither))
        return NULL;
    
    gtk_preview_set_dither(GTK_PREVIEW(self->obj), dither);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkPreview_methods[] = {
    { "size", (PyCFunction)_wrap_gtk_preview_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "put", (PyCFunction)_wrap_gtk_preview_put, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "draw_row", (PyCFunction)_wrap_gtk_preview_draw_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_expand", (PyCFunction)_wrap_gtk_preview_set_expand, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_dither", (PyCFunction)_wrap_gtk_preview_set_dither, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkPreview_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Preview",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkPreview_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_preview_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkProgress ----------- */

static PyObject *
_wrap_gtk_progress_set_show_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_text", NULL };
    int show_text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Progress.set_show_text", kwlist, &show_text))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.set_show_text is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    gtk_progress_set_show_text(GTK_PROGRESS(self->obj), show_text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_set_text_alignment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x_align", "y_align", NULL };
    double x_align, y_align;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dd:Gtk.Progress.set_text_alignment", kwlist, &x_align, &y_align))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.set_text_alignment is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    gtk_progress_set_text_alignment(GTK_PROGRESS(self->obj), x_align, y_align);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_set_format_string(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "format", NULL };
    char *format;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Progress.set_format_string", kwlist, &format))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.set_format_string is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    gtk_progress_set_format_string(GTK_PROGRESS(self->obj), format);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_set_adjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *adjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Progress.set_adjustment", kwlist, &PyGtkAdjustment_Type, &adjustment))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.set_adjustment is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    gtk_progress_set_adjustment(GTK_PROGRESS(self->obj), GTK_ADJUSTMENT(adjustment->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_configure(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", "min", "max", NULL };
    double value, min, max;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ddd:Gtk.Progress.configure", kwlist, &value, &min, &max))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.configure is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    gtk_progress_configure(GTK_PROGRESS(self->obj), value, min, max);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_set_percentage(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "percentage", NULL };
    double percentage;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Progress.set_percentage", kwlist, &percentage))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.set_percentage is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    gtk_progress_set_percentage(GTK_PROGRESS(self->obj), percentage);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_set_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    double value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Progress.set_value", kwlist, &value))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.set_value is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    gtk_progress_set_value(GTK_PROGRESS(self->obj), value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_get_value(PyGObject *self)
{
    double ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.get_value is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    ret = gtk_progress_get_value(GTK_PROGRESS(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_progress_set_activity_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "activity_mode", NULL };
    int activity_mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Progress.set_activity_mode", kwlist, &activity_mode))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.set_activity_mode is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    gtk_progress_set_activity_mode(GTK_PROGRESS(self->obj), activity_mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_get_current_text(PyGObject *self)
{
    gchar *ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.get_current_text is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    ret = gtk_progress_get_current_text(GTK_PROGRESS(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_get_text_from_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    double value;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Progress.get_text_from_value", kwlist, &value))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.get_text_from_value is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    ret = gtk_progress_get_text_from_value(GTK_PROGRESS(self->obj), value);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_get_current_percentage(PyGObject *self)
{
    double ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.get_current_percentage is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    ret = gtk_progress_get_current_percentage(GTK_PROGRESS(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_progress_get_percentage_from_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    double value, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.Progress.get_percentage_from_value", kwlist, &value))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "gtk.Progress.get_percentage_from_value is deprecated, use gtk.ProgressBar methods") < 0)
        return NULL;
    
    ret = gtk_progress_get_percentage_from_value(GTK_PROGRESS(self->obj), value);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_GtkProgress__do_paint(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Progress.paint", kwlist, &PyGtkProgress_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PROGRESS_CLASS(klass)->paint)
        GTK_PROGRESS_CLASS(klass)->paint(GTK_PROGRESS(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Progress.paint not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkProgress__do_update(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Progress.update", kwlist, &PyGtkProgress_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PROGRESS_CLASS(klass)->update)
        GTK_PROGRESS_CLASS(klass)->update(GTK_PROGRESS(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Progress.update not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkProgress__do_act_mode_enter(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Progress.act_mode_enter", kwlist, &PyGtkProgress_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PROGRESS_CLASS(klass)->act_mode_enter)
        GTK_PROGRESS_CLASS(klass)->act_mode_enter(GTK_PROGRESS(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Progress.act_mode_enter not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkProgress_methods[] = {
    { "set_show_text", (PyCFunction)_wrap_gtk_progress_set_show_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_text_alignment", (PyCFunction)_wrap_gtk_progress_set_text_alignment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_format_string", (PyCFunction)_wrap_gtk_progress_set_format_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_adjustment", (PyCFunction)_wrap_gtk_progress_set_adjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "configure", (PyCFunction)_wrap_gtk_progress_configure, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_percentage", (PyCFunction)_wrap_gtk_progress_set_percentage, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_value", (PyCFunction)_wrap_gtk_progress_set_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_value", (PyCFunction)_wrap_gtk_progress_get_value, METH_NOARGS,
      NULL },
    { "set_activity_mode", (PyCFunction)_wrap_gtk_progress_set_activity_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_text", (PyCFunction)_wrap_gtk_progress_get_current_text, METH_NOARGS,
      NULL },
    { "get_text_from_value", (PyCFunction)_wrap_gtk_progress_get_text_from_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_percentage", (PyCFunction)_wrap_gtk_progress_get_current_percentage, METH_NOARGS,
      NULL },
    { "get_percentage_from_value", (PyCFunction)_wrap_gtk_progress_get_percentage_from_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_paint", (PyCFunction)_wrap_GtkProgress__do_paint, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_update", (PyCFunction)_wrap_GtkProgress__do_update, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_act_mode_enter", (PyCFunction)_wrap_GtkProgress__do_act_mode_enter, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkProgress_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Progress",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkProgress_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkProgress__proxy_do_paint(GtkProgress *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_paint");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkProgress__proxy_do_update(GtkProgress *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_update");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkProgress__proxy_do_act_mode_enter(GtkProgress *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_act_mode_enter");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkProgress_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkProgressClass *klass = GTK_PROGRESS_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_paint");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "paint")))
            klass->paint = _wrap_GtkProgress__proxy_do_paint;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_update");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "update")))
            klass->update = _wrap_GtkProgress__proxy_do_update;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_act_mode_enter");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "act_mode_enter")))
            klass->act_mode_enter = _wrap_GtkProgress__proxy_do_act_mode_enter;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkProgressBar ----------- */

#line 2866 "./gtk.override"
static int
_wrap_gtk_progress_bar_new_with_adjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkAdjustment *adjustment = NULL;
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkProgressBar.__init__", kwlist, &py_adjustment))
        return -1;
    if ((PyObject *)py_adjustment == Py_None)
        adjustment = NULL;
    else if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if (py_adjustment) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
	return -1;
    }


    if (adjustment)
        pygobject_construct(self, "adjustment", adjustment, NULL);
    else
        pygobject_construct(self, NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkProgressBar object");
	return -1;
    }
    return 0;
}
#line 70830 "gtk.c"


static PyObject *
_wrap_gtk_progress_bar_pulse(PyGObject *self)
{
    
    gtk_progress_bar_pulse(GTK_PROGRESS_BAR(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ProgressBar.set_text", kwlist, &text))
        return NULL;
    
    gtk_progress_bar_set_text(GTK_PROGRESS_BAR(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_set_fraction(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fraction", NULL };
    double fraction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.ProgressBar.set_fraction", kwlist, &fraction))
        return NULL;
    
    gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(self->obj), fraction);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_set_pulse_step(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fraction", NULL };
    double fraction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.ProgressBar.set_pulse_step", kwlist, &fraction))
        return NULL;
    
    gtk_progress_bar_set_pulse_step(GTK_PROGRESS_BAR(self->obj), fraction);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_set_orientation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "orientation", NULL };
    PyObject *py_orientation = NULL;
    GtkProgressBarOrientation orientation;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ProgressBar.set_orientation", kwlist, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PROGRESS_BAR_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    
    gtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(self->obj), orientation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_get_text(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_progress_bar_get_text(GTK_PROGRESS_BAR(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_get_fraction(PyGObject *self)
{
    double ret;

    
    ret = gtk_progress_bar_get_fraction(GTK_PROGRESS_BAR(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_progress_bar_get_pulse_step(PyGObject *self)
{
    double ret;

    
    ret = gtk_progress_bar_get_pulse_step(GTK_PROGRESS_BAR(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_progress_bar_get_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_progress_bar_get_orientation(GTK_PROGRESS_BAR(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_PROGRESS_BAR_ORIENTATION, ret);
}

static PyObject *
_wrap_gtk_progress_bar_set_bar_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "style", NULL };
    GtkProgressBarStyle style;
    PyObject *py_style = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ProgressBar.set_bar_style", kwlist, &py_style))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PROGRESS_BAR_STYLE, py_style, (gpointer)&style))
        return NULL;
    
    gtk_progress_bar_set_bar_style(GTK_PROGRESS_BAR(self->obj), style);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_set_discrete_blocks(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "blocks", NULL };
    PyObject *py_blocks = NULL;
    guint blocks = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ProgressBar.set_discrete_blocks", kwlist, &py_blocks))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (py_blocks) {
        if (PyLong_Check(py_blocks))
            blocks = PyLong_AsUnsignedLong(py_blocks);
        else if (PyInt_Check(py_blocks))
            blocks = PyInt_AsLong(py_blocks);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'blocks' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_progress_bar_set_discrete_blocks(GTK_PROGRESS_BAR(self->obj), blocks);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_set_activity_step(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "step", NULL };
    PyObject *py_step = NULL;
    guint step = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ProgressBar.set_activity_step", kwlist, &py_step))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (py_step) {
        if (PyLong_Check(py_step))
            step = PyLong_AsUnsignedLong(py_step);
        else if (PyInt_Check(py_step))
            step = PyInt_AsLong(py_step);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'step' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_progress_bar_set_activity_step(GTK_PROGRESS_BAR(self->obj), step);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_set_activity_blocks(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "blocks", NULL };
    PyObject *py_blocks = NULL;
    guint blocks = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ProgressBar.set_activity_blocks", kwlist, &py_blocks))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (py_blocks) {
        if (PyLong_Check(py_blocks))
            blocks = PyLong_AsUnsignedLong(py_blocks);
        else if (PyInt_Check(py_blocks))
            blocks = PyInt_AsLong(py_blocks);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'blocks' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_progress_bar_set_activity_blocks(GTK_PROGRESS_BAR(self->obj), blocks);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_update(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "percentage", NULL };
    double percentage;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.ProgressBar.update", kwlist, &percentage))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_progress_bar_update(GTK_PROGRESS_BAR(self->obj), percentage);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_set_ellipsize(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mode", NULL };
    PyObject *py_mode = NULL;
    PangoEllipsizeMode mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ProgressBar.set_ellipsize", kwlist, &py_mode))
        return NULL;
    if (pyg_enum_get_value(PANGO_TYPE_ELLIPSIZE_MODE, py_mode, (gpointer)&mode))
        return NULL;
    
    gtk_progress_bar_set_ellipsize(GTK_PROGRESS_BAR(self->obj), mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_progress_bar_get_ellipsize(PyGObject *self)
{
    gint ret;

    
    ret = gtk_progress_bar_get_ellipsize(GTK_PROGRESS_BAR(self->obj));
    
    return pyg_enum_from_gtype(PANGO_TYPE_ELLIPSIZE_MODE, ret);
}

static const PyMethodDef _PyGtkProgressBar_methods[] = {
    { "pulse", (PyCFunction)_wrap_gtk_progress_bar_pulse, METH_NOARGS,
      NULL },
    { "set_text", (PyCFunction)_wrap_gtk_progress_bar_set_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_fraction", (PyCFunction)_wrap_gtk_progress_bar_set_fraction, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_pulse_step", (PyCFunction)_wrap_gtk_progress_bar_set_pulse_step, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_orientation", (PyCFunction)_wrap_gtk_progress_bar_set_orientation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text", (PyCFunction)_wrap_gtk_progress_bar_get_text, METH_NOARGS,
      NULL },
    { "get_fraction", (PyCFunction)_wrap_gtk_progress_bar_get_fraction, METH_NOARGS,
      NULL },
    { "get_pulse_step", (PyCFunction)_wrap_gtk_progress_bar_get_pulse_step, METH_NOARGS,
      NULL },
    { "get_orientation", (PyCFunction)_wrap_gtk_progress_bar_get_orientation, METH_NOARGS,
      NULL },
    { "set_bar_style", (PyCFunction)_wrap_gtk_progress_bar_set_bar_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_discrete_blocks", (PyCFunction)_wrap_gtk_progress_bar_set_discrete_blocks, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_activity_step", (PyCFunction)_wrap_gtk_progress_bar_set_activity_step, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_activity_blocks", (PyCFunction)_wrap_gtk_progress_bar_set_activity_blocks, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "update", (PyCFunction)_wrap_gtk_progress_bar_update, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_ellipsize", (PyCFunction)_wrap_gtk_progress_bar_set_ellipsize, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_ellipsize", (PyCFunction)_wrap_gtk_progress_bar_get_ellipsize, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkProgressBar_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ProgressBar",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkProgressBar_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_progress_bar_new_with_adjustment,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkToggleAction ----------- */

static int
_wrap_gtk_toggle_action_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[4];
    PyObject *parsed_args[4] = {NULL, };
    char *arg_names[] = {"name", "label", "tooltip", "stock_id", NULL };
    char *prop_names[] = {"name", "label", "tooltip", "stock_id", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOO:gtk.ToggleAction.__init__" , arg_names , &parsed_args[0] , &parsed_args[1] , &parsed_args[2] , &parsed_args[3]))
        return -1;

    memset(params, 0, sizeof(GParameter)*4);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.ToggleAction object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_toggle_action_toggled(PyGObject *self)
{
    
    gtk_toggle_action_toggled(GTK_TOGGLE_ACTION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toggle_action_set_active(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "is_active", NULL };
    int is_active;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToggleAction.set_active", kwlist, &is_active))
        return NULL;
    
    gtk_toggle_action_set_active(GTK_TOGGLE_ACTION(self->obj), is_active);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toggle_action_get_active(PyGObject *self)
{
    int ret;

    
    ret = gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_toggle_action_set_draw_as_radio(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "draw_as_radio", NULL };
    int draw_as_radio;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToggleAction.set_draw_as_radio", kwlist, &draw_as_radio))
        return NULL;
    
    gtk_toggle_action_set_draw_as_radio(GTK_TOGGLE_ACTION(self->obj), draw_as_radio);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toggle_action_get_draw_as_radio(PyGObject *self)
{
    int ret;

    
    ret = gtk_toggle_action_get_draw_as_radio(GTK_TOGGLE_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkToggleAction__do_toggled(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToggleAction.toggled", kwlist, &PyGtkToggleAction_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TOGGLE_ACTION_CLASS(klass)->toggled)
        GTK_TOGGLE_ACTION_CLASS(klass)->toggled(GTK_TOGGLE_ACTION(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ToggleAction.toggled not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkToggleAction_methods[] = {
    { "toggled", (PyCFunction)_wrap_gtk_toggle_action_toggled, METH_NOARGS,
      NULL },
    { "set_active", (PyCFunction)_wrap_gtk_toggle_action_set_active, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_active", (PyCFunction)_wrap_gtk_toggle_action_get_active, METH_NOARGS,
      NULL },
    { "set_draw_as_radio", (PyCFunction)_wrap_gtk_toggle_action_set_draw_as_radio, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_draw_as_radio", (PyCFunction)_wrap_gtk_toggle_action_get_draw_as_radio, METH_NOARGS,
      NULL },
    { "do_toggled", (PyCFunction)_wrap_GtkToggleAction__do_toggled, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkToggleAction_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ToggleAction",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkToggleAction_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_toggle_action_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkToggleAction__proxy_do_toggled(GtkToggleAction *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggled");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkToggleAction_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkToggleActionClass *klass = GTK_TOGGLE_ACTION_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggled");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggled")))
            klass->toggled = _wrap_GtkToggleAction__proxy_do_toggled;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkRadioAction ----------- */

 static int
_wrap_gtk_radio_action_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[5];
    PyObject *parsed_args[5] = {NULL, };
    char *arg_names[] = {"name", "label", "tooltip", "stock_id", "value", NULL };
    char *prop_names[] = {"name", "label", "tooltip", "stock_id", "value", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOO:gtk.RadioAction.__init__" , arg_names , &parsed_args[0] , &parsed_args[1] , &parsed_args[2] , &parsed_args[3] , &parsed_args[4]))
        return -1;

    memset(params, 0, sizeof(GParameter)*5);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.RadioAction object");
        return -1;
    }
    return 0;
}

#line 5341 "./gtk.override"
static PyObject *
_wrap_gtk_radio_action_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "group", NULL };
    GSList *list;
    GtkRadioAction *group;
    PyObject *py_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkRadioAction.set_group",
				     kwlist, &py_group))
        return NULL;

    if (pygobject_check(py_group, &PyGtkRadioAction_Type)) {
	group = GTK_RADIO_ACTION(pygobject_get(py_group));
	list = gtk_radio_action_get_group(group);
	if (list == gtk_radio_action_get_group(GTK_RADIO_ACTION(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "radio action already in group");
	    return NULL;
	}
    } else if (py_group == Py_None) {
	list = NULL;
    } else {
	PyErr_SetString(PyExc_TypeError, "group must be a RadioAction or None");
	return NULL;
    }

    gtk_radio_action_set_group(GTK_RADIO_ACTION(self->obj), list);
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 71504 "gtk.c"


#line 5376 "./gtk.override"
static PyObject *
_wrap_gtk_radio_action_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_action_get_group(GTK_RADIO_ACTION(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
#line 71530 "gtk.c"


static PyObject *
_wrap_gtk_radio_action_get_current_value(PyGObject *self)
{
    int ret;

    
    ret = gtk_radio_action_get_current_value(GTK_RADIO_ACTION(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_radio_action_set_current_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "current_value", NULL };
    int current_value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RadioAction.set_current_value", kwlist, &current_value))
        return NULL;
    
    gtk_radio_action_set_current_value(GTK_RADIO_ACTION(self->obj), current_value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRadioAction__do_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "current", NULL };
    PyGObject *self, *current;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.RadioAction.changed", kwlist, &PyGtkRadioAction_Type, &self, &PyGtkRadioAction_Type, &current))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RADIO_ACTION_CLASS(klass)->changed)
        GTK_RADIO_ACTION_CLASS(klass)->changed(GTK_RADIO_ACTION(self->obj), GTK_RADIO_ACTION(current->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.RadioAction.changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkRadioAction_methods[] = {
    { "set_group", (PyCFunction)_wrap_gtk_radio_action_set_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_group", (PyCFunction)_wrap_gtk_radio_action_get_group, METH_NOARGS,
      NULL },
    { "get_current_value", (PyCFunction)_wrap_gtk_radio_action_get_current_value, METH_NOARGS,
      NULL },
    { "set_current_value", (PyCFunction)_wrap_gtk_radio_action_set_current_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_changed", (PyCFunction)_wrap_GtkRadioAction__do_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRadioAction_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RadioAction",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRadioAction_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_radio_action_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkRadioAction__proxy_do_changed(GtkRadioAction *self, GtkRadioAction*current)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_current = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (current)
        py_current = pygobject_new((GObject *) current);
    else {
        Py_INCREF(Py_None);
        py_current = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_current);
    
    py_method = PyObject_GetAttrString(py_self, "do_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkRadioAction_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkRadioActionClass *klass = GTK_RADIO_ACTION_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "changed")))
            klass->changed = _wrap_GtkRadioAction__proxy_do_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkRadioButton ----------- */

#line 1763 "./gtk.override"
static int
_wrap_gtk_radio_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "group", "label", "use_underline", NULL };
    PyObject *py_group = Py_None;
    gchar *label = NULL;
    GtkRadioButton *group;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"|OzO:GtkRadioButton.__init__",
                                     kwlist, &py_group, &label,
                                     &py_use_underline))
        return -1;
    if (py_group == Py_None)
        group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioButton_Type))
        group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    else {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkRadioButton or None");
        return -1;
    }
    /* various configs for create radio buttons ... */
    if (label == NULL) {
        if (group == NULL)
            pygobject_construct(self, NULL);
        else
            pygobject_construct(self, "group", group, NULL);
    } else {
        if (group == NULL)
            pygobject_construct(self,
                                "label", label, "use-underline",
                                PyObject_IsTrue(py_use_underline), NULL);
        else
            pygobject_construct(self,
                                "label", label, "group", group,
                                "use-underline",
                                PyObject_IsTrue(py_use_underline), NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioButton object");
        return -1;
    }
    return 0;
}
#line 71775 "gtk.c"


#line 1812 "./gtk.override"
static PyObject *
_wrap_gtk_radio_button_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
#line 71801 "gtk.c"


#line 3528 "./gtk.override"
static PyObject *
_wrap_gtk_radio_button_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs) {
    static char *kwlist[] = { "group", NULL };
    PyObject *py_group;
    GSList *list;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"O:GtkRadioButton.set_group",
                                     kwlist, &py_group))
        return NULL;

    if (pygobject_check(py_group, &PyGtkRadioButton_Type)) {
	group = GTK_RADIO_BUTTON(pygobject_get(py_group));
	list = gtk_radio_button_get_group(group);
	if (list == gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "radio button already in group");
	    return NULL;
	}
    } else if (py_group == Py_None) {
	list = NULL;
    } else {
	PyErr_SetString(PyExc_TypeError, "group must be a RadioGroup or None");
	return NULL;
    }

    gtk_radio_button_set_group(GTK_RADIO_BUTTON(self->obj), list);
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 71836 "gtk.c"


static PyObject *
_wrap_GtkRadioButton__do_group_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RadioButton.group_changed", kwlist, &PyGtkRadioButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RADIO_BUTTON_CLASS(klass)->group_changed)
        GTK_RADIO_BUTTON_CLASS(klass)->group_changed(GTK_RADIO_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.RadioButton.group_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkRadioButton_methods[] = {
    { "get_group", (PyCFunction)_wrap_gtk_radio_button_get_group, METH_NOARGS,
      NULL },
    { "set_group", (PyCFunction)_wrap_gtk_radio_button_set_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_group_changed", (PyCFunction)_wrap_GtkRadioButton__do_group_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRadioButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RadioButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRadioButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_radio_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkRadioButton__proxy_do_group_changed(GtkRadioButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_group_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkRadioButton_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkRadioButtonClass *klass = GTK_RADIO_BUTTON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_group_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "group_changed")))
            klass->group_changed = _wrap_GtkRadioButton__proxy_do_group_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkRadioMenuItem ----------- */

#line 1999 "./gtk.override"
static int
_wrap_gtk_radio_menu_item_new(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "group", "label", "use_underline", NULL };
    gchar *text = NULL;
    PyObject *py_group = Py_None;
    GtkRadioMenuItem *group;
    PyObject *py_use_underline = Py_True;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OzO:GtkRadioMenuItem.__init__", kwlist,
                                     &py_group, &text, &py_use_underline))
        return -1;
    if (py_group == Py_None)
        group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioMenuItem_Type))
        group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
    else {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkRadioMenuItem or None");
        return -1;
    }

    pygobject_construct(self, NULL);

    if (text) {
        GtkWidget *accel_label;
        accel_label = g_object_new(GTK_TYPE_ACCEL_LABEL, NULL);
        gtk_misc_set_alignment(GTK_MISC(accel_label), 0.0, 0.5);
        gtk_container_add(GTK_CONTAINER(self->obj), accel_label);
        if (PyObject_IsTrue(py_use_underline))
            gtk_label_set_text_with_mnemonic(GTK_LABEL(accel_label), text);
        else
            gtk_label_set_text(GTK_LABEL(accel_label), text);
        gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(accel_label),
                                         GTK_WIDGET(self->obj));
        gtk_widget_show(accel_label);
    }
    if (group)
        gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(self->obj),
                                      gtk_radio_menu_item_get_group(group));
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkRadioMenuItem object");
        return -1;
    }
    return 0;
}
#line 72041 "gtk.c"


static PyObject *
_wrap_gtk_radio_menu_item_new_from_widget(PyGObject *self)
{
    PyObject *py_ret;
    GtkWidget *ret;

    
    ret = gtk_radio_menu_item_new_from_widget(GTK_RADIO_MENU_ITEM(self->obj));
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_radio_menu_item_new_with_mnemonic_from_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;
    PyObject *py_ret;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RadioMenuItem.new_with_mnemonic_from_widget", kwlist, &label))
        return NULL;
    
    ret = gtk_radio_menu_item_new_with_mnemonic_from_widget(GTK_RADIO_MENU_ITEM(self->obj), label);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_radio_menu_item_new_with_label_from_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;
    PyObject *py_ret;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RadioMenuItem.new_with_label_from_widget", kwlist, &label))
        return NULL;
    
    ret = gtk_radio_menu_item_new_with_label_from_widget(GTK_RADIO_MENU_ITEM(self->obj), label);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

#line 3561 "./gtk.override"
static PyObject *
_wrap_gtk_radio_menu_item_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
#line 72120 "gtk.c"


#line 3585 "./gtk.override"
static PyObject *
_wrap_gtk_radio_menu_item_set_group(PyGObject *self, PyObject *args,
				    PyObject *kwargs) {
    static char *kwlist[] = { "group", NULL };
    PyObject *py_group;
    GSList *list;
    GtkRadioMenuItem *group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkRadioMenuItem.set_group",
                                     kwlist, &py_group))
        return NULL;
    
    if (pygobject_check(py_group, &PyGtkRadioMenuItem_Type)) {
	group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
	list = gtk_radio_menu_item_get_group(group);
	if (list == gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "radio menu item already in group");
	    return NULL;
	}
    } else if (py_group == Py_None) {
	list = NULL;
    } else {
	PyErr_SetString(PyExc_TypeError, "group must be a RadioMenuItem or None");
	return NULL;
    }

    gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(self->obj), list);
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 72156 "gtk.c"


static PyObject *
_wrap_GtkRadioMenuItem__do_group_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RadioMenuItem.group_changed", kwlist, &PyGtkRadioMenuItem_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RADIO_MENU_ITEM_CLASS(klass)->group_changed)
        GTK_RADIO_MENU_ITEM_CLASS(klass)->group_changed(GTK_RADIO_MENU_ITEM(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.RadioMenuItem.group_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkRadioMenuItem_methods[] = {
    { "new_from_widget", (PyCFunction)_wrap_gtk_radio_menu_item_new_from_widget, METH_NOARGS,
      NULL },
    { "new_with_mnemonic_from_widget", (PyCFunction)_wrap_gtk_radio_menu_item_new_with_mnemonic_from_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "new_with_label_from_widget", (PyCFunction)_wrap_gtk_radio_menu_item_new_with_label_from_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_group", (PyCFunction)_wrap_gtk_radio_menu_item_get_group, METH_NOARGS,
      NULL },
    { "set_group", (PyCFunction)_wrap_gtk_radio_menu_item_set_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_group_changed", (PyCFunction)_wrap_GtkRadioMenuItem__do_group_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRadioMenuItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RadioMenuItem",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRadioMenuItem_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_radio_menu_item_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkRadioMenuItem__proxy_do_group_changed(GtkRadioMenuItem *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_group_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkRadioMenuItem_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkRadioMenuItemClass *klass = GTK_RADIO_MENU_ITEM_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_group_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "group_changed")))
            klass->group_changed = _wrap_GtkRadioMenuItem__proxy_do_group_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkToggleToolButton ----------- */

#line 345 "gtktoolbar.override"
static int
_wrap_gtk_toggle_tool_button_new(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", NULL };
    char *stock_id = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkToggleToolButton.__init__",
				     kwlist, &stock_id))
        return -1;

    if (stock_id)
        pygobject_construct(self, "stock-id", stock_id, NULL);
    else
        pygobject_construct(self, NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkToggleToolButton object");
        return -1;
    }
    return 0;
}
#line 72342 "gtk.c"


static PyObject *
_wrap_gtk_toggle_tool_button_set_active(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "is_active", NULL };
    int is_active;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToggleToolButton.set_active", kwlist, &is_active))
        return NULL;
    
    gtk_toggle_tool_button_set_active(GTK_TOGGLE_TOOL_BUTTON(self->obj), is_active);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toggle_tool_button_get_active(PyGObject *self)
{
    int ret;

    
    ret = gtk_toggle_tool_button_get_active(GTK_TOGGLE_TOOL_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkToggleToolButton__do_toggled(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToggleToolButton.toggled", kwlist, &PyGtkToggleToolButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TOGGLE_TOOL_BUTTON_CLASS(klass)->toggled)
        GTK_TOGGLE_TOOL_BUTTON_CLASS(klass)->toggled(GTK_TOGGLE_TOOL_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ToggleToolButton.toggled not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkToggleToolButton_methods[] = {
    { "set_active", (PyCFunction)_wrap_gtk_toggle_tool_button_set_active, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_active", (PyCFunction)_wrap_gtk_toggle_tool_button_get_active, METH_NOARGS,
      NULL },
    { "do_toggled", (PyCFunction)_wrap_GtkToggleToolButton__do_toggled, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkToggleToolButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ToggleToolButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkToggleToolButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_toggle_tool_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkToggleToolButton__proxy_do_toggled(GtkToggleToolButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggled");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkToggleToolButton_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkToggleToolButtonClass *klass = GTK_TOGGLE_TOOL_BUTTON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggled");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggled")))
            klass->toggled = _wrap_GtkToggleToolButton__proxy_do_toggled;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkRadioToolButton ----------- */

#line 426 "gtktoolbar.override"
static int
_wrap_gtk_radio_tool_button_new(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "group", "stock_id", NULL };
    gchar *stock = NULL;
    PyObject *py_widget = Py_None;
    GtkRadioToolButton *widget = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oz:GtkRadioToolButton.__init__", kwlist,
                                     &py_widget, &stock))
        return -1;

    if (py_widget != Py_None) {
	if (pygobject_check(py_widget, &PyGtkRadioToolButton_Type))
	    widget = GTK_RADIO_TOOL_BUTTON(pygobject_get(py_widget));
	else {
	    PyErr_SetString(PyExc_TypeError,
			    "first argument must be a GtkRadioToolButton or None");
	    return -1;
	}
    }

    /* various configs for create radio tool buttons ... */
    if (stock == NULL) {
        if (widget == NULL)
            pygobject_construct(self, NULL);
        else
            pygobject_construct(self, "group", widget, NULL);
    } else {
        if (widget == NULL)
            pygobject_construct(self, "stock-id", stock, NULL);
        else
            pygobject_construct(self, "stock-id", stock, "group", widget, NULL);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkRadioToolButton object");
        return -1;
    }
    return 0;
}
#line 72568 "gtk.c"


#line 473 "gtktoolbar.override"
static PyObject *
_wrap_gtk_radio_tool_button_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "group", NULL };
    GSList *list;
    GtkRadioToolButton *group;
    PyObject *py_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkRadioToolButton.set_group",
				     kwlist, &py_group))
        return NULL;

    if (pygobject_check(py_group, &PyGtkRadioToolButton_Type)) {
	group = GTK_RADIO_TOOL_BUTTON(pygobject_get(py_group));
	list = gtk_radio_tool_button_get_group(group);
	if (list == gtk_radio_tool_button_get_group(GTK_RADIO_TOOL_BUTTON(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "radio tool button already in group");
	    return NULL;
	}
    } else if (py_group == Py_None) {
	list = NULL;
    } else {
	PyErr_SetString(PyExc_TypeError, "group must be a RadioToolButton or None");
	return NULL;
    }

    gtk_radio_tool_button_set_group(GTK_RADIO_TOOL_BUTTON(self->obj), list);
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 72605 "gtk.c"


#line 508 "gtktoolbar.override"
static PyObject *
_wrap_gtk_radio_tool_button_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_tool_button_get_group(GTK_RADIO_TOOL_BUTTON(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
#line 72631 "gtk.c"


static const PyMethodDef _PyGtkRadioToolButton_methods[] = {
    { "set_group", (PyCFunction)_wrap_gtk_radio_tool_button_set_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_group", (PyCFunction)_wrap_gtk_radio_tool_button_get_group, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRadioToolButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RadioToolButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRadioToolButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_radio_tool_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkRcStyle ----------- */

static PyObject *
_wrap_gtk_rc_add_widget_name_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pattern", NULL };
    char *pattern;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RcStyle.rc_add_widget_name_style", kwlist, &pattern))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_rc_add_widget_name_style(GTK_RC_STYLE(self->obj), pattern);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_add_widget_class_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pattern", NULL };
    char *pattern;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RcStyle.rc_add_widget_class_style", kwlist, &pattern))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_rc_add_widget_class_style(GTK_RC_STYLE(self->obj), pattern);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_add_class_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pattern", NULL };
    char *pattern;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RcStyle.rc_add_class_style", kwlist, &pattern))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_rc_add_class_style(GTK_RC_STYLE(self->obj), pattern);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_style_copy(PyGObject *self)
{
    PyObject *py_ret;
    GtkRcStyle *ret;

    
    ret = gtk_rc_style_copy(GTK_RC_STYLE(self->obj));
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_GtkRcStyle__do_create_rc_style(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    GtkRcStyle *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RcStyle.create_rc_style", kwlist, &PyGtkRcStyle_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RC_STYLE_CLASS(klass)->create_rc_style)
        ret = GTK_RC_STYLE_CLASS(klass)->create_rc_style(GTK_RC_STYLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.RcStyle.create_rc_style not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkRcStyle__do_merge(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "src", NULL };
    PyGObject *self, *src;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.RcStyle.merge", kwlist, &PyGtkRcStyle_Type, &self, &PyGtkRcStyle_Type, &src))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RC_STYLE_CLASS(klass)->merge)
        GTK_RC_STYLE_CLASS(klass)->merge(GTK_RC_STYLE(self->obj), GTK_RC_STYLE(src->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.RcStyle.merge not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRcStyle__do_create_style(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    GtkStyle *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RcStyle.create_style", kwlist, &PyGtkRcStyle_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RC_STYLE_CLASS(klass)->create_style)
        ret = GTK_RC_STYLE_CLASS(klass)->create_style(GTK_RC_STYLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.RcStyle.create_style not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkRcStyle_methods[] = {
    { "rc_add_widget_name_style", (PyCFunction)_wrap_gtk_rc_add_widget_name_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rc_add_widget_class_style", (PyCFunction)_wrap_gtk_rc_add_widget_class_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rc_add_class_style", (PyCFunction)_wrap_gtk_rc_add_class_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "copy", (PyCFunction)_wrap_gtk_rc_style_copy, METH_NOARGS,
      NULL },
    { "do_create_rc_style", (PyCFunction)_wrap_GtkRcStyle__do_create_rc_style, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_merge", (PyCFunction)_wrap_GtkRcStyle__do_merge, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_create_style", (PyCFunction)_wrap_GtkRcStyle__do_create_style, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 25 "gtkrcstyle.override"
static int
_wrap_gtk_rc_style__set_name(PyGObject *self, PyObject *value, void *closure)
{
    GtkRcStyle *rc_style = GTK_RC_STYLE(self->obj);
    gchar *name;
    PyObject *as_string;

    if (value == Py_None)
        name = NULL;
    else if ((as_string = PyObject_Str(value)) != NULL) {
        name = g_strdup(PyString_AsString(as_string));
        Py_DECREF(as_string);
    }
    else
        return -1;

    g_free(rc_style->name);
    rc_style->name = name;
    return 0;
}

#line 72865 "gtk.c"


static PyObject *
_wrap_gtk_rc_style__get_name(PyObject *self, void *closure)
{
    const gchar *ret;

    ret = GTK_RC_STYLE(pygobject_get(self))->name;
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 48 "gtkrcstyle.override"
static PyObject *
_wrap_gtk_rc_style__get_bg_pixmap_name(PyGObject *self, void *closure)
{
    GtkRcStyle *rc_style = GTK_RC_STYLE(self->obj);

    return _pygtk_rc_style_helper_new(rc_style, RC_STYLE_STRING_ARRAY, rc_style->bg_pixmap_name, 0);
}

#line 72889 "gtk.c"


#line 58 "gtkrcstyle.override"
static int
_wrap_gtk_rc_style__set_font_desc(PyGObject *self, PyObject *value, void *closure)
{
    GtkRcStyle *rc_style = GTK_RC_STYLE(self->obj);
    PangoFontDescription *font_desc;

    if (value == Py_None)
        font_desc = NULL;
    else if (pyg_boxed_check(value, PANGO_TYPE_FONT_DESCRIPTION))
        font_desc = pango_font_description_copy(pyg_boxed_get(value, PangoFontDescription));
    else {
        PyErr_SetString(PyExc_TypeError, "can only assign a pango.FontDescription or None");
        return -1;
    }

    pango_font_description_free(rc_style->font_desc);
    rc_style->font_desc = font_desc;
    return 0;
}

#line 72913 "gtk.c"


static PyObject *
_wrap_gtk_rc_style__get_font_desc(PyObject *self, void *closure)
{
    PangoFontDescription *ret;

    ret = GTK_RC_STYLE(pygobject_get(self))->font_desc;
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PANGO_TYPE_FONT_DESCRIPTION, ret, TRUE, TRUE);
}

#line 80 "gtkrcstyle.override"
static PyObject *
_wrap_gtk_rc_style__get_fg(PyGObject *self, void *closure)
{
    GtkRcStyle *rc_style = GTK_RC_STYLE(self->obj);

    return _pygtk_rc_style_helper_new(rc_style, RC_STYLE_COLOUR_ARRAY, rc_style->fg, GTK_RC_FG);
}

#line 72935 "gtk.c"


#line 90 "gtkrcstyle.override"
static PyObject *
_wrap_gtk_rc_style__get_bg(PyGObject *self, void *closure)
{
    GtkRcStyle *rc_style = GTK_RC_STYLE(self->obj);

    return _pygtk_rc_style_helper_new(rc_style, RC_STYLE_COLOUR_ARRAY, rc_style->bg, GTK_RC_BG);
}

#line 72947 "gtk.c"


#line 100 "gtkrcstyle.override"
static PyObject *
_wrap_gtk_rc_style__get_text(PyGObject *self, void *closure)
{
    GtkRcStyle *rc_style = GTK_RC_STYLE(self->obj);

    return _pygtk_rc_style_helper_new(rc_style, RC_STYLE_COLOUR_ARRAY, rc_style->text, GTK_RC_TEXT);
}

#line 72959 "gtk.c"


#line 110 "gtkrcstyle.override"
static PyObject *
_wrap_gtk_rc_style__get_base(PyGObject *self, void *closure)
{
    GtkRcStyle *rc_style = GTK_RC_STYLE(self->obj);

    return _pygtk_rc_style_helper_new(rc_style, RC_STYLE_COLOUR_ARRAY, rc_style->base, GTK_RC_BASE);
}

#line 72971 "gtk.c"


#line 120 "gtkrcstyle.override"
static int
_wrap_gtk_rc_style__set_xthickness(PyGObject *self, PyObject *value, void *closure)
{
    GtkRcStyle *rc_style = GTK_RC_STYLE(self->obj);

    if (PyInt_Check(value)) {
        rc_style->xthickness = PyInt_AsLong(value);
        return 0;
    }
    else {
        PyErr_SetString(PyExc_TypeError, "can only assign an int");
        return -1;
    }
}

#line 72990 "gtk.c"


static PyObject *
_wrap_gtk_rc_style__get_xthickness(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_RC_STYLE(pygobject_get(self))->xthickness;
    return PyInt_FromLong(ret);
}

#line 137 "gtkrcstyle.override"
static int
_wrap_gtk_rc_style__set_ythickness(PyGObject *self, PyObject *value, void *closure)
{
    GtkRcStyle *rc_style = GTK_RC_STYLE(self->obj);

    if (PyInt_Check(value)) {
        rc_style->ythickness = PyInt_AsLong(value);
        return 0;
    }
    else {
        PyErr_SetString(PyExc_TypeError, "can only assign an int");
        return -1;
    }
}
#line 73017 "gtk.c"


static PyObject *
_wrap_gtk_rc_style__get_ythickness(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_RC_STYLE(pygobject_get(self))->ythickness;
    return PyInt_FromLong(ret);
}

static const PyGetSetDef gtk_rc_style_getsets[] = {
    { "name", (getter)_wrap_gtk_rc_style__get_name, (setter)_wrap_gtk_rc_style__set_name },
    { "bg_pixmap_name", (getter)_wrap_gtk_rc_style__get_bg_pixmap_name, (setter)0 },
    { "font_desc", (getter)_wrap_gtk_rc_style__get_font_desc, (setter)_wrap_gtk_rc_style__set_font_desc },
    { "fg", (getter)_wrap_gtk_rc_style__get_fg, (setter)0 },
    { "bg", (getter)_wrap_gtk_rc_style__get_bg, (setter)0 },
    { "text", (getter)_wrap_gtk_rc_style__get_text, (setter)0 },
    { "base", (getter)_wrap_gtk_rc_style__get_base, (setter)0 },
    { "xthickness", (getter)_wrap_gtk_rc_style__get_xthickness, (setter)_wrap_gtk_rc_style__set_xthickness },
    { "ythickness", (getter)_wrap_gtk_rc_style__get_ythickness, (setter)_wrap_gtk_rc_style__set_ythickness },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkRcStyle_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RcStyle",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRcStyle_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_rc_style_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static GtkRcStyle*
_wrap_GtkRcStyle__proxy_do_create_rc_style(GtkRcStyle *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkRcStyle* retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_create_rc_style");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkRcStyle*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkRcStyle__proxy_do_merge(GtkRcStyle *self, GtkRcStyle*src)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_src = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (src)
        py_src = pygobject_new((GObject *) src);
    else {
        Py_INCREF(Py_None);
        py_src = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_src);
    
    py_method = PyObject_GetAttrString(py_self, "do_merge");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GtkStyle*
_wrap_GtkRcStyle__proxy_do_create_style(GtkRcStyle *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkStyle* retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_create_style");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkStyle*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkRcStyle_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkRcStyleClass *klass = GTK_RC_STYLE_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_create_rc_style");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "create_rc_style")))
            klass->create_rc_style = _wrap_GtkRcStyle__proxy_do_create_rc_style;
        Py_DECREF(o);
    }

    /* overriding do_parse is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_merge");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "merge")))
            klass->merge = _wrap_GtkRcStyle__proxy_do_merge;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_create_style");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "create_style")))
            klass->create_style = _wrap_GtkRcStyle__proxy_do_create_style;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkScrolledWindow ----------- */

 static int
_wrap_gtk_scrolled_window_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[2];
    PyObject *parsed_args[2] = {NULL, };
    char *arg_names[] = {"hadjustment", "vadjustment", NULL };
    char *prop_names[] = {"hadjustment", "vadjustment", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:gtk.ScrolledWindow.__init__" , arg_names , &parsed_args[0] , &parsed_args[1]))
        return -1;

    memset(params, 0, sizeof(GParameter)*2);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.ScrolledWindow object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_scrolled_window_set_hadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "hadjustment", NULL };
    PyGObject *py_hadjustment;
    GtkAdjustment *hadjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ScrolledWindow.set_hadjustment", kwlist, &py_hadjustment))
        return NULL;
    if (py_hadjustment && pygobject_check(py_hadjustment, &PyGtkAdjustment_Type))
        hadjustment = GTK_ADJUSTMENT(py_hadjustment->obj);
    else if ((PyObject *)py_hadjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "hadjustment should be a GtkAdjustment or None");
        return NULL;
    }
    
    gtk_scrolled_window_set_hadjustment(GTK_SCROLLED_WINDOW(self->obj), (GtkAdjustment *) hadjustment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scrolled_window_set_vadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "hadjustment", NULL };
    PyGObject *py_hadjustment;
    GtkAdjustment *hadjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ScrolledWindow.set_vadjustment", kwlist, &py_hadjustment))
        return NULL;
    if (py_hadjustment && pygobject_check(py_hadjustment, &PyGtkAdjustment_Type))
        hadjustment = GTK_ADJUSTMENT(py_hadjustment->obj);
    else if ((PyObject *)py_hadjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "hadjustment should be a GtkAdjustment or None");
        return NULL;
    }
    
    gtk_scrolled_window_set_vadjustment(GTK_SCROLLED_WINDOW(self->obj), (GtkAdjustment *) hadjustment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scrolled_window_get_hadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_scrolled_window_get_hadjustment(GTK_SCROLLED_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_scrolled_window_get_vadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_scrolled_window_get_hscrollbar(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_scrolled_window_get_hscrollbar(GTK_SCROLLED_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_scrolled_window_get_vscrollbar(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_scrolled_window_get_vscrollbar(GTK_SCROLLED_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_scrolled_window_set_policy(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "hscrollbar_policy", "vscrollbar_policy", NULL };
    PyObject *py_hscrollbar_policy = NULL, *py_vscrollbar_policy = NULL;
    GtkPolicyType hscrollbar_policy, vscrollbar_policy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.ScrolledWindow.set_policy", kwlist, &py_hscrollbar_policy, &py_vscrollbar_policy))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POLICY_TYPE, py_hscrollbar_policy, (gpointer)&hscrollbar_policy))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POLICY_TYPE, py_vscrollbar_policy, (gpointer)&vscrollbar_policy))
        return NULL;
    
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(self->obj), hscrollbar_policy, vscrollbar_policy);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3619 "./gtk.override"
static PyObject *
_wrap_gtk_scrolled_window_get_policy(PyGObject *self)
{
    GtkPolicyType hscrollbar_policy, vscrollbar_policy;

    gtk_scrolled_window_get_policy(GTK_SCROLLED_WINDOW(self->obj),
				   &hscrollbar_policy, &vscrollbar_policy);
    return Py_BuildValue("(NN)",
			 pyg_enum_from_gtype(GTK_TYPE_POLICY_TYPE, hscrollbar_policy),
			 pyg_enum_from_gtype(GTK_TYPE_POLICY_TYPE, vscrollbar_policy));
}
#line 73466 "gtk.c"


static PyObject *
_wrap_gtk_scrolled_window_set_placement(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window_placement", NULL };
    PyObject *py_window_placement = NULL;
    GtkCornerType window_placement;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ScrolledWindow.set_placement", kwlist, &py_window_placement))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_CORNER_TYPE, py_window_placement, (gpointer)&window_placement))
        return NULL;
    
    gtk_scrolled_window_set_placement(GTK_SCROLLED_WINDOW(self->obj), window_placement);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scrolled_window_get_placement(PyGObject *self)
{
    gint ret;

    
    ret = gtk_scrolled_window_get_placement(GTK_SCROLLED_WINDOW(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_CORNER_TYPE, ret);
}

static PyObject *
_wrap_gtk_scrolled_window_set_shadow_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    PyObject *py_type = NULL;
    GtkShadowType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ScrolledWindow.set_shadow_type", kwlist, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_type, (gpointer)&type))
        return NULL;
    
    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(self->obj), type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scrolled_window_get_shadow_type(PyGObject *self)
{
    gint ret;

    
    ret = gtk_scrolled_window_get_shadow_type(GTK_SCROLLED_WINDOW(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, ret);
}

static PyObject *
_wrap_gtk_scrolled_window_add_with_viewport(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ScrolledWindow.add_with_viewport", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(self->obj), GTK_WIDGET(child->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scrolled_window_unset_placement(PyGObject *self)
{
    
    gtk_scrolled_window_unset_placement(GTK_SCROLLED_WINDOW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkScrolledWindow__do_scroll_child(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll", "horizontal", NULL };
    PyGObject *self;
    PyObject *py_scroll = NULL;
    int horizontal, ret;
    GtkScrollType scroll;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oi:Gtk.ScrolledWindow.scroll_child", kwlist, &PyGtkScrolledWindow_Type, &self, &py_scroll, &horizontal))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll, (gpointer)&scroll))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_SCROLLED_WINDOW_CLASS(klass)->scroll_child)
        ret = GTK_SCROLLED_WINDOW_CLASS(klass)->scroll_child(GTK_SCROLLED_WINDOW(self->obj), scroll, horizontal);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ScrolledWindow.scroll_child not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkScrolledWindow__do_move_focus_out(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "direction", NULL };
    PyGObject *self;
    PyObject *py_direction = NULL;
    GtkDirectionType direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.ScrolledWindow.move_focus_out", kwlist, &PyGtkScrolledWindow_Type, &self, &py_direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, py_direction, (gpointer)&direction))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_SCROLLED_WINDOW_CLASS(klass)->move_focus_out)
        GTK_SCROLLED_WINDOW_CLASS(klass)->move_focus_out(GTK_SCROLLED_WINDOW(self->obj), direction);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.ScrolledWindow.move_focus_out not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkScrolledWindow_methods[] = {
    { "set_hadjustment", (PyCFunction)_wrap_gtk_scrolled_window_set_hadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_vadjustment", (PyCFunction)_wrap_gtk_scrolled_window_set_vadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_hadjustment", (PyCFunction)_wrap_gtk_scrolled_window_get_hadjustment, METH_NOARGS,
      NULL },
    { "get_vadjustment", (PyCFunction)_wrap_gtk_scrolled_window_get_vadjustment, METH_NOARGS,
      NULL },
    { "get_hscrollbar", (PyCFunction)_wrap_gtk_scrolled_window_get_hscrollbar, METH_NOARGS,
      NULL },
    { "get_vscrollbar", (PyCFunction)_wrap_gtk_scrolled_window_get_vscrollbar, METH_NOARGS,
      NULL },
    { "set_policy", (PyCFunction)_wrap_gtk_scrolled_window_set_policy, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_policy", (PyCFunction)_wrap_gtk_scrolled_window_get_policy, METH_NOARGS,
      NULL },
    { "set_placement", (PyCFunction)_wrap_gtk_scrolled_window_set_placement, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_placement", (PyCFunction)_wrap_gtk_scrolled_window_get_placement, METH_NOARGS,
      NULL },
    { "set_shadow_type", (PyCFunction)_wrap_gtk_scrolled_window_set_shadow_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_shadow_type", (PyCFunction)_wrap_gtk_scrolled_window_get_shadow_type, METH_NOARGS,
      NULL },
    { "add_with_viewport", (PyCFunction)_wrap_gtk_scrolled_window_add_with_viewport, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unset_placement", (PyCFunction)_wrap_gtk_scrolled_window_unset_placement, METH_NOARGS,
      NULL },
    { "do_scroll_child", (PyCFunction)_wrap_GtkScrolledWindow__do_scroll_child, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_focus_out", (PyCFunction)_wrap_GtkScrolledWindow__do_move_focus_out, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkScrolledWindow_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ScrolledWindow",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkScrolledWindow_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_scrolled_window_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gboolean
_wrap_GtkScrolledWindow__proxy_do_scroll_child(GtkScrolledWindow *self, GtkScrollType scroll, gboolean horizontal)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll;
    PyObject *py_horizontal;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_scroll = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll);
    if (!py_scroll) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_horizontal = horizontal? Py_True : Py_False;
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_scroll);
    Py_INCREF(py_horizontal);
    PyTuple_SET_ITEM(py_args, 1, py_horizontal);
    
    py_method = PyObject_GetAttrString(py_self, "do_scroll_child");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkScrolledWindow__proxy_do_move_focus_out(GtkScrolledWindow *self, GtkDirectionType direction)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_direction;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_direction = pyg_enum_from_gtype(GTK_TYPE_DIRECTION_TYPE, direction);
    if (!py_direction) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_direction);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_focus_out");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkScrolledWindow_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkScrolledWindowClass *klass = GTK_SCROLLED_WINDOW_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_scroll_child");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "scroll_child")))
            klass->scroll_child = _wrap_GtkScrolledWindow__proxy_do_scroll_child;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_focus_out");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_focus_out")))
            klass->move_focus_out = _wrap_GtkScrolledWindow__proxy_do_move_focus_out;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkSeparatorMenuItem ----------- */

 static int
_wrap_gtk_separator_menu_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.SeparatorMenuItem.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.SeparatorMenuItem object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkSeparatorMenuItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.SeparatorMenuItem",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_separator_menu_item_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkSeparatorToolItem ----------- */

static int
_wrap_gtk_separator_tool_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.SeparatorToolItem.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.SeparatorToolItem object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_separator_tool_item_get_draw(PyGObject *self)
{
    int ret;

    
    ret = gtk_separator_tool_item_get_draw(GTK_SEPARATOR_TOOL_ITEM(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_separator_tool_item_set_draw(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "draw", NULL };
    int draw;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.SeparatorToolItem.set_draw", kwlist, &draw))
        return NULL;
    
    gtk_separator_tool_item_set_draw(GTK_SEPARATOR_TOOL_ITEM(self->obj), draw);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkSeparatorToolItem_methods[] = {
    { "get_draw", (PyCFunction)_wrap_gtk_separator_tool_item_get_draw, METH_NOARGS,
      NULL },
    { "set_draw", (PyCFunction)_wrap_gtk_separator_tool_item_set_draw, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkSeparatorToolItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.SeparatorToolItem",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkSeparatorToolItem_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_separator_tool_item_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkSettings ----------- */

static PyObject *
_wrap_gtk_settings_set_string_property(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "v_string", "origin", NULL };
    char *name, *v_string, *origin;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sss:Gtk.Settings.set_string_property", kwlist, &name, &v_string, &origin))
        return NULL;
    
    gtk_settings_set_string_property(GTK_SETTINGS(self->obj), name, v_string, origin);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_settings_set_long_property(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "v_long", "origin", NULL };
    char *name, *origin;
    glong v_long;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sls:Gtk.Settings.set_long_property", kwlist, &name, &v_long, &origin))
        return NULL;
    
    gtk_settings_set_long_property(GTK_SETTINGS(self->obj), name, v_long, origin);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_settings_set_double_property(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "v_double", "origin", NULL };
    char *name, *origin;
    double v_double;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sds:Gtk.Settings.set_double_property", kwlist, &name, &v_double, &origin))
        return NULL;
    
    gtk_settings_set_double_property(GTK_SETTINGS(self->obj), name, v_double, origin);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkSettings_methods[] = {
    { "set_string_property", (PyCFunction)_wrap_gtk_settings_set_string_property, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_long_property", (PyCFunction)_wrap_gtk_settings_set_long_property, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_double_property", (PyCFunction)_wrap_gtk_settings_set_double_property, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkSettings_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Settings",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkSettings_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkSizeGroup ----------- */

static int
_wrap_gtk_size_group_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"mode", NULL };
    char *prop_names[] = {"mode", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:gtk.SizeGroup.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.SizeGroup object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_size_group_set_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mode", NULL };
    PyObject *py_mode = NULL;
    GtkSizeGroupMode mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.SizeGroup.set_mode", kwlist, &py_mode))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SIZE_GROUP_MODE, py_mode, (gpointer)&mode))
        return NULL;
    
    gtk_size_group_set_mode(GTK_SIZE_GROUP(self->obj), mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_size_group_get_mode(PyGObject *self)
{
    gint ret;

    
    ret = gtk_size_group_get_mode(GTK_SIZE_GROUP(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SIZE_GROUP_MODE, ret);
}

static PyObject *
_wrap_gtk_size_group_set_ignore_hidden(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "ignore_hidden", NULL };
    int ignore_hidden;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.SizeGroup.set_ignore_hidden", kwlist, &ignore_hidden))
        return NULL;
    
    gtk_size_group_set_ignore_hidden(GTK_SIZE_GROUP(self->obj), ignore_hidden);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_size_group_get_ignore_hidden(PyGObject *self)
{
    int ret;

    
    ret = gtk_size_group_get_ignore_hidden(GTK_SIZE_GROUP(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_size_group_add_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.SizeGroup.add_widget", kwlist, &PyGtkWidget_Type, &widget))
        return NULL;
    
    gtk_size_group_add_widget(GTK_SIZE_GROUP(self->obj), GTK_WIDGET(widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_size_group_remove_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.SizeGroup.remove_widget", kwlist, &PyGtkWidget_Type, &widget))
        return NULL;
    
    gtk_size_group_remove_widget(GTK_SIZE_GROUP(self->obj), GTK_WIDGET(widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 7566 "./gtk.override"
static PyObject *
_wrap_gtk_size_group_get_widgets(PyGObject *self)
{
    GSList *widgets;
    GtkWidget *widget;
    PyObject *py_widgets;
    guint count, i;

    widgets = gtk_size_group_get_widgets(GTK_SIZE_GROUP(self->obj));
    count = g_slist_length(widgets);
    py_widgets = PyList_New(count);
    for (i = 0; i < count; i++) {
        widget = g_slist_nth_data(widgets, i);
        PyList_SetItem(py_widgets, i, pygobject_new((GObject*)widget));
    }

    return py_widgets;
}
#line 74279 "gtk.c"


static const PyMethodDef _PyGtkSizeGroup_methods[] = {
    { "set_mode", (PyCFunction)_wrap_gtk_size_group_set_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_mode", (PyCFunction)_wrap_gtk_size_group_get_mode, METH_NOARGS,
      NULL },
    { "set_ignore_hidden", (PyCFunction)_wrap_gtk_size_group_set_ignore_hidden, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_ignore_hidden", (PyCFunction)_wrap_gtk_size_group_get_ignore_hidden, METH_NOARGS,
      NULL },
    { "add_widget", (PyCFunction)_wrap_gtk_size_group_add_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_widget", (PyCFunction)_wrap_gtk_size_group_remove_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_widgets", (PyCFunction)_wrap_gtk_size_group_get_widgets, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkSizeGroup_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.SizeGroup",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkSizeGroup_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_size_group_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkSocket ----------- */

 static int
_wrap_gtk_socket_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Socket.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Socket object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_socket_add_id(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window_id", NULL };
    unsigned long window_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"k:Gtk.Socket.add_id", kwlist, &window_id))
        return NULL;
    
    gtk_socket_add_id(GTK_SOCKET(self->obj), window_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_socket_get_id(PyGObject *self)
{
    GdkNativeWindow ret;

    
    ret = gtk_socket_get_id(GTK_SOCKET(self->obj));
    
    return PyLong_FromUnsignedLong((unsigned long)ret);

}

static PyObject *
_wrap_gtk_socket_steal(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "wid", NULL };
    unsigned long wid;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"k:Gtk.Socket.steal", kwlist, &wid))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_socket_steal(GTK_SOCKET(self->obj), wid);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_socket_get_plug_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_socket_get_plug_window(GTK_SOCKET(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkSocket__do_plug_added(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Socket.plug_added", kwlist, &PyGtkSocket_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_SOCKET_CLASS(klass)->plug_added)
        GTK_SOCKET_CLASS(klass)->plug_added(GTK_SOCKET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Socket.plug_added not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkSocket__do_plug_removed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Socket.plug_removed", kwlist, &PyGtkSocket_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_SOCKET_CLASS(klass)->plug_removed)
        ret = GTK_SOCKET_CLASS(klass)->plug_removed(GTK_SOCKET(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Socket.plug_removed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkSocket_methods[] = {
    { "add_id", (PyCFunction)_wrap_gtk_socket_add_id, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_id", (PyCFunction)_wrap_gtk_socket_get_id, METH_NOARGS,
      NULL },
    { "steal", (PyCFunction)_wrap_gtk_socket_steal, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_plug_window", (PyCFunction)_wrap_gtk_socket_get_plug_window, METH_NOARGS,
      NULL },
    { "do_plug_added", (PyCFunction)_wrap_GtkSocket__do_plug_added, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_plug_removed", (PyCFunction)_wrap_GtkSocket__do_plug_removed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkSocket_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Socket",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkSocket_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_socket_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkSocket__proxy_do_plug_added(GtkSocket *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_plug_added");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkSocket__proxy_do_plug_removed(GtkSocket *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_plug_removed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkSocket_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkSocketClass *klass = GTK_SOCKET_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_plug_added");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "plug_added")))
            klass->plug_added = _wrap_GtkSocket__proxy_do_plug_added;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_plug_removed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "plug_removed")))
            klass->plug_removed = _wrap_GtkSocket__proxy_do_plug_removed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkSpinButton ----------- */

static int
_wrap_gtk_spin_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[3];
    PyObject *parsed_args[3] = {NULL, };
    char *arg_names[] = {"adjustment", "climb_rate", "digits", NULL };
    char *prop_names[] = {"adjustment", "climb_rate", "digits", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOO:gtk.SpinButton.__init__" , arg_names , &parsed_args[0] , &parsed_args[1] , &parsed_args[2]))
        return -1;

    memset(params, 0, sizeof(GParameter)*3);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.SpinButton object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_spin_button_configure(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", "climb_rate", "digits", NULL };
    PyGObject *py_adjustment;
    double climb_rate;
    GtkAdjustment *adjustment = NULL;
    guint digits = 0;
    PyObject *py_digits = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OdO:Gtk.SpinButton.configure", kwlist, &py_adjustment, &climb_rate, &py_digits))
        return NULL;
    if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if ((PyObject *)py_adjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }
    if (py_digits) {
        if (PyLong_Check(py_digits))
            digits = PyLong_AsUnsignedLong(py_digits);
        else if (PyInt_Check(py_digits))
            digits = PyInt_AsLong(py_digits);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'digits' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_spin_button_configure(GTK_SPIN_BUTTON(self->obj), (GtkAdjustment *) adjustment, climb_rate, digits);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_spin_button_set_adjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *adjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.SpinButton.set_adjustment", kwlist, &PyGtkAdjustment_Type, &adjustment))
        return NULL;
    
    gtk_spin_button_set_adjustment(GTK_SPIN_BUTTON(self->obj), GTK_ADJUSTMENT(adjustment->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_spin_button_get_adjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_spin_button_get_adjustment(GTK_SPIN_BUTTON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_spin_button_set_digits(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "digits", NULL };
    PyObject *py_digits = NULL;
    guint digits = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.SpinButton.set_digits", kwlist, &py_digits))
        return NULL;
    if (py_digits) {
        if (PyLong_Check(py_digits))
            digits = PyLong_AsUnsignedLong(py_digits);
        else if (PyInt_Check(py_digits))
            digits = PyInt_AsLong(py_digits);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'digits' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_spin_button_set_digits(GTK_SPIN_BUTTON(self->obj), digits);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_spin_button_get_digits(PyGObject *self)
{
    guint ret;

    
    ret = gtk_spin_button_get_digits(GTK_SPIN_BUTTON(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_spin_button_set_increments(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "step", "page", NULL };
    double step, page;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dd:Gtk.SpinButton.set_increments", kwlist, &step, &page))
        return NULL;
    
    gtk_spin_button_set_increments(GTK_SPIN_BUTTON(self->obj), step, page);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 809 "./gtk.override"
static PyObject *
_wrap_gtk_spin_button_get_increments(PyGObject *self)
{
    gdouble step;
    gdouble page;

    gtk_spin_button_get_increments(GTK_SPIN_BUTTON(self->obj), &step, &page);
    return Py_BuildValue("(dd)", step, page);
}
#line 74828 "gtk.c"


static PyObject *
_wrap_gtk_spin_button_set_range(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "min", "max", NULL };
    double min, max;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dd:Gtk.SpinButton.set_range", kwlist, &min, &max))
        return NULL;
    
    gtk_spin_button_set_range(GTK_SPIN_BUTTON(self->obj), min, max);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 820 "./gtk.override"
static PyObject *
_wrap_gtk_spin_button_get_range(PyGObject *self)
{
    gdouble min;
    gdouble max;

    gtk_spin_button_get_range(GTK_SPIN_BUTTON(self->obj), &min, &max);
    return Py_BuildValue("(dd)", min, max);
}
#line 74856 "gtk.c"


static PyObject *
_wrap_gtk_spin_button_get_value(PyGObject *self)
{
    double ret;

    
    ret = gtk_spin_button_get_value(GTK_SPIN_BUTTON(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_spin_button_get_value_as_int(PyGObject *self)
{
    int ret;

    
    ret = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_spin_button_set_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    double value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.SpinButton.set_value", kwlist, &value))
        return NULL;
    
    gtk_spin_button_set_value(GTK_SPIN_BUTTON(self->obj), value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_spin_button_set_update_policy(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "policy", NULL };
    PyObject *py_policy = NULL;
    GtkSpinButtonUpdatePolicy policy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.SpinButton.set_update_policy", kwlist, &py_policy))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SPIN_BUTTON_UPDATE_POLICY, py_policy, (gpointer)&policy))
        return NULL;
    
    gtk_spin_button_set_update_policy(GTK_SPIN_BUTTON(self->obj), policy);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_spin_button_get_update_policy(PyGObject *self)
{
    guint ret;

    
    ret = gtk_spin_button_get_update_policy(GTK_SPIN_BUTTON(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_spin_button_set_numeric(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "numeric", NULL };
    int numeric;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.SpinButton.set_numeric", kwlist, &numeric))
        return NULL;
    
    gtk_spin_button_set_numeric(GTK_SPIN_BUTTON(self->obj), numeric);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_spin_button_get_numeric(PyGObject *self)
{
    int ret;

    
    ret = gtk_spin_button_get_numeric(GTK_SPIN_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_spin_button_spin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "direction", "increment", NULL };
    PyObject *py_direction = NULL;
    double increment = 1;
    GtkSpinType direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O|d:Gtk.SpinButton.spin", kwlist, &py_direction, &increment))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SPIN_TYPE, py_direction, (gpointer)&direction))
        return NULL;
    
    gtk_spin_button_spin(GTK_SPIN_BUTTON(self->obj), direction, increment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_spin_button_set_wrap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "wrap", NULL };
    int wrap;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.SpinButton.set_wrap", kwlist, &wrap))
        return NULL;
    
    gtk_spin_button_set_wrap(GTK_SPIN_BUTTON(self->obj), wrap);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_spin_button_get_wrap(PyGObject *self)
{
    int ret;

    
    ret = gtk_spin_button_get_wrap(GTK_SPIN_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_spin_button_set_snap_to_ticks(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "snap_to_ticks", NULL };
    int snap_to_ticks;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.SpinButton.set_snap_to_ticks", kwlist, &snap_to_ticks))
        return NULL;
    
    gtk_spin_button_set_snap_to_ticks(GTK_SPIN_BUTTON(self->obj), snap_to_ticks);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_spin_button_get_snap_to_ticks(PyGObject *self)
{
    int ret;

    
    ret = gtk_spin_button_get_snap_to_ticks(GTK_SPIN_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_spin_button_update(PyGObject *self)
{
    
    gtk_spin_button_update(GTK_SPIN_BUTTON(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkSpinButton__do_output(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.SpinButton.output", kwlist, &PyGtkSpinButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_SPIN_BUTTON_CLASS(klass)->output)
        ret = GTK_SPIN_BUTTON_CLASS(klass)->output(GTK_SPIN_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.SpinButton.output not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_GtkSpinButton__do_value_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.SpinButton.value_changed", kwlist, &PyGtkSpinButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_SPIN_BUTTON_CLASS(klass)->value_changed)
        GTK_SPIN_BUTTON_CLASS(klass)->value_changed(GTK_SPIN_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.SpinButton.value_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkSpinButton__do_change_value(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "scroll", NULL };
    PyGObject *self;
    PyObject *py_scroll = NULL;
    GtkScrollType scroll;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.SpinButton.change_value", kwlist, &PyGtkSpinButton_Type, &self, &py_scroll))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SCROLL_TYPE, py_scroll, (gpointer)&scroll))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_SPIN_BUTTON_CLASS(klass)->change_value)
        GTK_SPIN_BUTTON_CLASS(klass)->change_value(GTK_SPIN_BUTTON(self->obj), scroll);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.SpinButton.change_value not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkSpinButton__do_wrapped(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.SpinButton.wrapped", kwlist, &PyGtkSpinButton_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_SPIN_BUTTON_CLASS(klass)->wrapped)
        GTK_SPIN_BUTTON_CLASS(klass)->wrapped(GTK_SPIN_BUTTON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.SpinButton.wrapped not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkSpinButton_methods[] = {
    { "configure", (PyCFunction)_wrap_gtk_spin_button_configure, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_adjustment", (PyCFunction)_wrap_gtk_spin_button_set_adjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_adjustment", (PyCFunction)_wrap_gtk_spin_button_get_adjustment, METH_NOARGS,
      NULL },
    { "set_digits", (PyCFunction)_wrap_gtk_spin_button_set_digits, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_digits", (PyCFunction)_wrap_gtk_spin_button_get_digits, METH_NOARGS,
      NULL },
    { "set_increments", (PyCFunction)_wrap_gtk_spin_button_set_increments, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_increments", (PyCFunction)_wrap_gtk_spin_button_get_increments, METH_NOARGS,
      NULL },
    { "set_range", (PyCFunction)_wrap_gtk_spin_button_set_range, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_range", (PyCFunction)_wrap_gtk_spin_button_get_range, METH_NOARGS,
      NULL },
    { "get_value", (PyCFunction)_wrap_gtk_spin_button_get_value, METH_NOARGS,
      NULL },
    { "get_value_as_int", (PyCFunction)_wrap_gtk_spin_button_get_value_as_int, METH_NOARGS,
      NULL },
    { "set_value", (PyCFunction)_wrap_gtk_spin_button_set_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_update_policy", (PyCFunction)_wrap_gtk_spin_button_set_update_policy, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_update_policy", (PyCFunction)_wrap_gtk_spin_button_get_update_policy, METH_NOARGS,
      NULL },
    { "set_numeric", (PyCFunction)_wrap_gtk_spin_button_set_numeric, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_numeric", (PyCFunction)_wrap_gtk_spin_button_get_numeric, METH_NOARGS,
      NULL },
    { "spin", (PyCFunction)_wrap_gtk_spin_button_spin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_wrap", (PyCFunction)_wrap_gtk_spin_button_set_wrap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_wrap", (PyCFunction)_wrap_gtk_spin_button_get_wrap, METH_NOARGS,
      NULL },
    { "set_snap_to_ticks", (PyCFunction)_wrap_gtk_spin_button_set_snap_to_ticks, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_snap_to_ticks", (PyCFunction)_wrap_gtk_spin_button_get_snap_to_ticks, METH_NOARGS,
      NULL },
    { "update", (PyCFunction)_wrap_gtk_spin_button_update, METH_NOARGS,
      NULL },
    { "do_output", (PyCFunction)_wrap_GtkSpinButton__do_output, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_value_changed", (PyCFunction)_wrap_GtkSpinButton__do_value_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_change_value", (PyCFunction)_wrap_GtkSpinButton__do_change_value, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_wrapped", (PyCFunction)_wrap_GtkSpinButton__do_wrapped, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkSpinButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.SpinButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkSpinButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_spin_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gint
_wrap_GtkSpinButton__proxy_do_input(GtkSpinButton *self, gdouble*new_value)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gint retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_input");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    if (!PyArg_ParseTuple(py_retval, "id", &retval, new_value)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gint
_wrap_GtkSpinButton__proxy_do_output(GtkSpinButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gint retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_output");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "i", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkSpinButton__proxy_do_value_changed(GtkSpinButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_value_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkSpinButton__proxy_do_change_value(GtkSpinButton *self, GtkScrollType scroll)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_scroll;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_scroll = pyg_enum_from_gtype(GTK_TYPE_SCROLL_TYPE, scroll);
    if (!py_scroll) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_scroll);
    
    py_method = PyObject_GetAttrString(py_self, "do_change_value");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkSpinButton__proxy_do_wrapped(GtkSpinButton *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_wrapped");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkSpinButton_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkSpinButtonClass *klass = GTK_SPIN_BUTTON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_input");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "input")))
            klass->input = _wrap_GtkSpinButton__proxy_do_input;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_output");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "output")))
            klass->output = _wrap_GtkSpinButton__proxy_do_output;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_value_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "value_changed")))
            klass->value_changed = _wrap_GtkSpinButton__proxy_do_value_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_change_value");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "change_value")))
            klass->change_value = _wrap_GtkSpinButton__proxy_do_change_value;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_wrapped");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "wrapped")))
            klass->wrapped = _wrap_GtkSpinButton__proxy_do_wrapped;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkStatusbar ----------- */

 static int
_wrap_gtk_statusbar_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Statusbar.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Statusbar object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_statusbar_get_context_id(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "context_description", NULL };
    char *context_description;
    guint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Statusbar.get_context_id", kwlist, &context_description))
        return NULL;
    
    ret = gtk_statusbar_get_context_id(GTK_STATUSBAR(self->obj), context_description);
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_statusbar_push(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "context_id", "text", NULL };
    PyObject *py_context_id = NULL;
    char *text;
    guint context_id = 0, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Os:Gtk.Statusbar.push", kwlist, &py_context_id, &text))
        return NULL;
    if (py_context_id) {
        if (PyLong_Check(py_context_id))
            context_id = PyLong_AsUnsignedLong(py_context_id);
        else if (PyInt_Check(py_context_id))
            context_id = PyInt_AsLong(py_context_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'context_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_statusbar_push(GTK_STATUSBAR(self->obj), context_id, text);
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_statusbar_pop(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "context_id", NULL };
    PyObject *py_context_id = NULL;
    guint context_id = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Statusbar.pop", kwlist, &py_context_id))
        return NULL;
    if (py_context_id) {
        if (PyLong_Check(py_context_id))
            context_id = PyLong_AsUnsignedLong(py_context_id);
        else if (PyInt_Check(py_context_id))
            context_id = PyInt_AsLong(py_context_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'context_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_statusbar_pop(GTK_STATUSBAR(self->obj), context_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 24 "gtkstatusbar.override"

static PyObject *
_wrap_gtk_statusbar_remove(PyGObject *self, PyObject *args, PyObject *kwargs);

static PyObject *
_wrap_gtk_statusbar_remove_compatibility(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:gtk.Statusbar.remove", kwlist,
                                     &PyGtkWidget_Type, &widget)) {
        PyObject *exc_type, *exc_value, *exc_traceback;
        PyObject *result;

        PyErr_Fetch(&exc_type, &exc_value, &exc_traceback);

        /* For compatibility reasons, call remove_message().  See bug #564587. */
        result = _wrap_gtk_statusbar_remove(self, args, kwargs);
        if (result) {
            Py_XDECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_traceback);

            if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.Statusbar.remove_message")) {
                Py_DECREF(result);
                return NULL;
            }

            return result;
        }
        else {
            PyErr_Restore(exc_type, exc_value, exc_traceback);
            return NULL;
        }
    }

    gtk_container_remove(GTK_CONTAINER(self->obj), GTK_WIDGET(widget->obj));

    Py_INCREF(Py_None);
    return Py_None;
}
#line 75704 "gtk.c"


static PyObject *
_wrap_gtk_statusbar_remove(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "context_id", "message_id", NULL };
    PyObject *py_context_id = NULL, *py_message_id = NULL;
    guint context_id = 0, message_id = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Statusbar.remove_message", kwlist, &py_context_id, &py_message_id))
        return NULL;
    if (py_context_id) {
        if (PyLong_Check(py_context_id))
            context_id = PyLong_AsUnsignedLong(py_context_id);
        else if (PyInt_Check(py_context_id))
            context_id = PyInt_AsLong(py_context_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'context_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_message_id) {
        if (PyLong_Check(py_message_id))
            message_id = PyLong_AsUnsignedLong(py_message_id);
        else if (PyInt_Check(py_message_id))
            message_id = PyInt_AsLong(py_message_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'message_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_statusbar_remove(GTK_STATUSBAR(self->obj), context_id, message_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_statusbar_set_has_resize_grip(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Statusbar.set_has_resize_grip", kwlist, &setting))
        return NULL;
    
    gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_statusbar_get_has_resize_grip(PyGObject *self)
{
    int ret;

    
    ret = gtk_statusbar_get_has_resize_grip(GTK_STATUSBAR(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_statusbar_get_message_area(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_statusbar_get_message_area(GTK_STATUSBAR(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_statusbar_remove_all(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "context_id", NULL };
    PyObject *py_context_id = NULL;
    guint context_id = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Statusbar.remove_all", kwlist, &py_context_id))
        return NULL;
    if (py_context_id) {
        if (PyLong_Check(py_context_id))
            context_id = PyLong_AsUnsignedLong(py_context_id);
        else if (PyInt_Check(py_context_id))
            context_id = PyInt_AsLong(py_context_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'context_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_statusbar_remove_all(GTK_STATUSBAR(self->obj), context_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStatusbar__do_text_pushed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context_id", "text", NULL };
    PyGObject *self;
    PyObject *py_context_id = NULL;
    char *text;
    guint context_id = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Os:Gtk.Statusbar.text_pushed", kwlist, &PyGtkStatusbar_Type, &self, &py_context_id, &text))
        return NULL;
    if (py_context_id) {
        if (PyLong_Check(py_context_id))
            context_id = PyLong_AsUnsignedLong(py_context_id);
        else if (PyInt_Check(py_context_id))
            context_id = PyInt_AsLong(py_context_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'context_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STATUSBAR_CLASS(klass)->text_pushed)
        GTK_STATUSBAR_CLASS(klass)->text_pushed(GTK_STATUSBAR(self->obj), context_id, text);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Statusbar.text_pushed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStatusbar__do_text_popped(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context_id", "text", NULL };
    PyGObject *self;
    PyObject *py_context_id = NULL;
    char *text;
    guint context_id = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Os:Gtk.Statusbar.text_popped", kwlist, &PyGtkStatusbar_Type, &self, &py_context_id, &text))
        return NULL;
    if (py_context_id) {
        if (PyLong_Check(py_context_id))
            context_id = PyLong_AsUnsignedLong(py_context_id);
        else if (PyInt_Check(py_context_id))
            context_id = PyInt_AsLong(py_context_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'context_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STATUSBAR_CLASS(klass)->text_popped)
        GTK_STATUSBAR_CLASS(klass)->text_popped(GTK_STATUSBAR(self->obj), context_id, text);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Statusbar.text_popped not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkStatusbar_methods[] = {
    { "get_context_id", (PyCFunction)_wrap_gtk_statusbar_get_context_id, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "push", (PyCFunction)_wrap_gtk_statusbar_push, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "pop", (PyCFunction)_wrap_gtk_statusbar_pop, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove", (PyCFunction)_wrap_gtk_statusbar_remove_compatibility, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_message", (PyCFunction)_wrap_gtk_statusbar_remove, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_has_resize_grip", (PyCFunction)_wrap_gtk_statusbar_set_has_resize_grip, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_resize_grip", (PyCFunction)_wrap_gtk_statusbar_get_has_resize_grip, METH_NOARGS,
      NULL },
    { "get_message_area", (PyCFunction)_wrap_gtk_statusbar_get_message_area, METH_NOARGS,
      NULL },
    { "remove_all", (PyCFunction)_wrap_gtk_statusbar_remove_all, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_text_pushed", (PyCFunction)_wrap_GtkStatusbar__do_text_pushed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_text_popped", (PyCFunction)_wrap_GtkStatusbar__do_text_popped, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkStatusbar_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Statusbar",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkStatusbar_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_statusbar_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkStatusbar__proxy_do_text_pushed(GtkStatusbar *self, guint context_id, const gchar*text)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context_id;
    PyObject *py_text = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_context_id = PyInt_FromLong(context_id);
    if (text)
        py_text = PyString_FromString(text);
    if (!py_text) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_context_id);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_context_id);
    PyTuple_SET_ITEM(py_args, 1, py_text);
    
    py_method = PyObject_GetAttrString(py_self, "do_text_pushed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStatusbar__proxy_do_text_popped(GtkStatusbar *self, guint context_id, const gchar*text)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context_id;
    PyObject *py_text = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_context_id = PyInt_FromLong(context_id);
    if (text)
        py_text = PyString_FromString(text);
    if (!py_text) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_context_id);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_context_id);
    PyTuple_SET_ITEM(py_args, 1, py_text);
    
    py_method = PyObject_GetAttrString(py_self, "do_text_popped");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkStatusbar_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkStatusbarClass *klass = GTK_STATUSBAR_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_text_pushed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "text_pushed")))
            klass->text_pushed = _wrap_GtkStatusbar__proxy_do_text_pushed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_text_popped");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "text_popped")))
            klass->text_popped = _wrap_GtkStatusbar__proxy_do_text_popped;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkStyle ----------- */

static int
_wrap_gtk_style_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Style.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Style object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_style_copy(PyGObject *self)
{
    PyObject *py_ret;
    GtkStyle *ret;

    
    ret = gtk_style_copy(GTK_STYLE(self->obj));
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_style_attach(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", NULL };
    PyGObject *window;
    GtkStyle *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Style.attach", kwlist, &PyGdkWindow_Type, &window))
        return NULL;
    
    ret = gtk_style_attach(GTK_STYLE(self->obj), GDK_WINDOW(window->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_style_detach(PyGObject *self)
{
    
    gtk_style_detach(GTK_STYLE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_style_get_font(PyGObject *self)
{
    GdkFont *ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    ret = gtk_style_get_font(GTK_STYLE(self->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GDK_TYPE_FONT, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_style_set_font(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "font", NULL };
    GdkFont *font = NULL;
    PyObject *py_font;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Style.set_font", kwlist, &py_font))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_boxed_check(py_font, GDK_TYPE_FONT))
        font = pyg_boxed_get(py_font, GdkFont);
    else {
        PyErr_SetString(PyExc_TypeError, "font should be a GdkFont");
        return NULL;
    }
    
    gtk_style_set_font(GTK_STYLE(self->obj), font);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_style_set_background(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", NULL };
    PyGObject *window;
    PyObject *py_state_type = NULL;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Style.set_background", kwlist, &PyGdkWindow_Type, &window, &py_state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    
    gtk_style_set_background(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_style_apply_default_background(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "set_bg", "state_type", "area", "x", "y", "width", "height", NULL };
    PyGObject *window;
    int set_bg, x, y, width, height;
    GtkStateType state_type;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    PyObject *py_state_type = NULL, *py_area = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iOOiiii:Gtk.Style.apply_default_background", kwlist, &PyGdkWindow_Type, &window, &set_bg, &py_state_type, &py_area, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    
    gtk_style_apply_default_background(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), set_bg, state_type, area, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_style_lookup_icon_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", NULL };
    char *stock_id;
    GtkIconSet *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Style.lookup_icon_set", kwlist, &stock_id))
        return NULL;
    
    ret = gtk_style_lookup_icon_set(GTK_STYLE(self->obj), stock_id);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_ICON_SET, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_style_render_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "source", "direction", "state", "size", "widget", "detail", NULL };
    GtkIconSource *source = NULL;
    PyObject *py_source, *py_direction = NULL, *py_state = NULL, *py_size = NULL, *py_ret;
    GdkPixbuf *ret;
    char *detail = NULL;
    PyGObject *py_widget = NULL;
    GtkIconSize size;
    GtkWidget *widget = NULL;
    GtkTextDirection direction;
    GtkStateType state;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOOO|Oz:Gtk.Style.render_icon", kwlist, &py_source, &py_direction, &py_state, &py_size, &py_widget, &detail))
        return NULL;
    if (pyg_boxed_check(py_source, GTK_TYPE_ICON_SOURCE))
        source = pyg_boxed_get(py_source, GtkIconSource);
    else {
        PyErr_SetString(PyExc_TypeError, "source should be a GtkIconSource");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, py_direction, (gpointer)&direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state, (gpointer)&state))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    if ((PyObject *)py_widget == Py_None)
        widget = NULL;
    else if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if (py_widget) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    ret = gtk_style_render_icon(GTK_STYLE(self->obj), source, direction, state, size, (GtkWidget *) widget, detail);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_paint_hline(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "area", "widget", "detail", "x1", "x2", "y", NULL };
    PyObject *py_state_type = NULL, *py_area = Py_None;
    char *detail;
    int x1, x2, y;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOziii:Gtk.Style.paint_hline", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &py_widget, &detail, &x1, &x2, &y))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_hline(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, (GtkWidget *) widget, detail, x1, x2, y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_vline(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "area", "widget", "detail", "y1", "y2", "x", NULL };
    PyObject *py_state_type = NULL, *py_area = Py_None;
    char *detail;
    int y1, y2, x;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOziii:Gtk.Style.paint_vline", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &py_widget, &detail, &y1, &y2, &x))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_vline(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, (GtkWidget *) widget, detail, y1, y2, x);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_shadow(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiii:Gtk.Style.paint_shadow", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_shadow(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 539 "./gtk.override"
static PyObject *
_wrap_gtk_paint_polygon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "points", "fill", NULL };
    PyObject *window, *py_state_type, *py_shadow_type, *py_area;
    GtkStateType state_type;
    GtkShadowType shadow_type;
    GdkRectangle area;
    PyObject *widget;
    const gchar *detail;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;
    gboolean fill;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "O!OOOO!zOi:GdkStyle.paint_polygon",
                                     kwlist, &PyGdkWindow_Type, &window,
                                     &py_state_type, &py_shadow_type, &py_area,
                                     &PyGtkWidget_Type, &widget, &detail,
                                     &py_points, &fill))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type,
                           (gint *)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type,
                           (gint *)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (!PySequence_Check(py_points)) {
        PyErr_SetString(PyExc_TypeError, "points must be a sequence");
        return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
        PyObject *item = PySequence_GetItem(py_points, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "sequence members must be 2-tuples");
            g_free(points);
            return NULL;
        }
    }
    gtk_paint_polygon(GTK_STYLE(self->obj), GDK_WINDOW(pygobject_get(window)),
                      state_type, shadow_type, &area,
                      GTK_WIDGET(pygobject_get(widget)), detail,
                      points, npoints, fill);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 76498 "gtk.c"


static PyObject *
_wrap_gtk_paint_arrow(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "arrow_type", "fill", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None, *py_arrow_type = NULL;
    char *detail;
    int fill, x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;
    GtkArrowType arrow_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOzOiiiii:Gtk.Style.paint_arrow", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &py_arrow_type, &fill, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_ARROW_TYPE, py_arrow_type, (gpointer)&arrow_type))
        return NULL;
    
    gtk_paint_arrow(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, arrow_type, fill, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_diamond(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiii:Gtk.Style.paint_diamond", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_diamond(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_box(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiii:Gtk.Style.paint_box", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_box(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_flat_box(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiii:Gtk.Style.paint_flat_box", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_flat_box(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_check(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiii:Gtk.Style.paint_check", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_check(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_option(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiii:Gtk.Style.paint_option", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_option(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_tab(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiii:Gtk.Style.paint_tab", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_tab(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_shadow_gap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", "gap_side", "gap_x", "gap_width", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None, *py_gap_side = NULL;
    GtkPositionType gap_side;
    char *detail;
    int x, y, width, height, gap_x, gap_width;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiiiOii:Gtk.Style.paint_shadow_gap", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height, &py_gap_side, &gap_x, &gap_width))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_gap_side, (gpointer)&gap_side))
        return NULL;
    
    gtk_paint_shadow_gap(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height, gap_side, gap_x, gap_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_box_gap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", "gap_side", "gap_x", "gap_width", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None, *py_gap_side = NULL;
    GtkPositionType gap_side;
    char *detail;
    int x, y, width, height, gap_x, gap_width;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiiiOii:Gtk.Style.paint_box_gap", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height, &py_gap_side, &gap_x, &gap_width))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_gap_side, (gpointer)&gap_side))
        return NULL;
    
    gtk_paint_box_gap(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height, gap_side, gap_x, gap_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_extension(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", "gap_side", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None, *py_gap_side = NULL;
    GtkPositionType gap_side;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiiiO:Gtk.Style.paint_extension", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height, &py_gap_side))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_gap_side, (gpointer)&gap_side))
        return NULL;
    
    gtk_paint_extension(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height, gap_side);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_focus(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    PyObject *py_state_type = NULL, *py_area = Py_None;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOziiii:Gtk.Style.paint_focus", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &py_widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_focus(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, (GtkWidget *) widget, detail, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_slider(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", "orientation", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None, *py_orientation = NULL;
    GtkOrientation orientation;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiiiO:Gtk.Style.paint_slider", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    
    gtk_paint_slider(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height, orientation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_handle(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", "orientation", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area = Py_None, *py_orientation = NULL;
    GtkOrientation orientation;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOziiiiO:Gtk.Style.paint_handle", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &py_widget, &detail, &x, &y, &width, &height, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    
    gtk_paint_handle(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, (GtkWidget *) widget, detail, x, y, width, height, orientation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_expander(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "area", "widget", "detail", "x", "y", "expander_style", NULL };
    GtkExpanderStyle expander_style;
    PyObject *py_state_type = NULL, *py_area = Py_None, *py_expander_style = NULL;
    char *detail;
    int x, y;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOziiO:Gtk.Style.paint_expander", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &py_widget, &detail, &x, &y, &py_expander_style))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_EXPANDER_STYLE, py_expander_style, (gpointer)&expander_style))
        return NULL;
    
    gtk_paint_expander(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, (GtkWidget *) widget, detail, x, y, expander_style);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_layout(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "use_text", "area", "widget", "detail", "x", "y", "layout", NULL };
    PyObject *py_state_type = NULL, *py_area = Py_None;
    char *detail;
    int use_text, x, y;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget, *layout;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OiOOziiO!:Gtk.Style.paint_layout", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &use_text, &py_area, &py_widget, &detail, &x, &y, &PyPangoLayout_Type, &layout))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_layout(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, use_text, area, (GtkWidget *) widget, detail, x, y, PANGO_LAYOUT(layout->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_resize_grip(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "area", "widget", "detail", "edge", "x", "y", "width", "height", NULL };
    PyObject *py_state_type = NULL, *py_area = Py_None, *py_edge = NULL;
    GdkWindowEdge edge;
    char *detail;
    int x, y, width, height;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOzOiiii:Gtk.Style.paint_resize_grip", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &py_widget, &detail, &py_edge, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    if (pyg_enum_get_value(GDK_TYPE_WINDOW_EDGE, py_edge, (gpointer)&edge))
        return NULL;
    
    gtk_paint_resize_grip(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, (GtkWidget *) widget, detail, edge, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_style_apply_default_pixmap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "set_bg", "area", "x", "y", "width", "height", NULL };
    PyGObject *window;
    int set_bg, x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyObject *py_area;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iOiiii:Gtk.Style.apply_default_pixmap", kwlist, &PyGdkWindow_Type, &window, &set_bg, &py_area, &x, &y, &width, &height))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkStyle.apply_default_background") < 0)
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    
    gtk_style_apply_default_pixmap(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), set_bg, &area, x, y, width, height);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_paint_string(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "area", "widget", "detail", "x", "y", "string", NULL };
    PyObject *py_state_type = NULL, *py_area = Py_None;
    char *detail, *string;
    int x, y;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
    GtkWidget *widget = NULL;
    PyGObject *window, *py_widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOziis:Gtk.Style.paint_string", kwlist, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &py_widget, &detail, &x, &y, &string))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_paint_string(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, (GtkWidget *) widget, detail, x, y, string);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 261 "gtkstyle.override"
static PyObject *
_wrap_gtk_style_lookup_color(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "color_name", NULL };
    char *color_name;
    GdkColor color;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:GtkStyle.lookup_color",
                                     kwlist, &color_name))
        return NULL;

    if (gtk_style_lookup_color(GTK_STYLE(self->obj), color_name, &color))
        return pyg_boxed_new(GDK_TYPE_COLOR, &color, TRUE, TRUE);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 77198 "gtk.c"


static PyObject *
_wrap_GtkStyle__do_realize(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Style.realize", kwlist, &PyGtkStyle_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->realize)
        GTK_STYLE_CLASS(klass)->realize(GTK_STYLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.realize not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_unrealize(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Style.unrealize", kwlist, &PyGtkStyle_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->unrealize)
        GTK_STYLE_CLASS(klass)->unrealize(GTK_STYLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.unrealize not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_copy(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "src", NULL };
    PyGObject *self, *src;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Style.copy", kwlist, &PyGtkStyle_Type, &self, &PyGtkStyle_Type, &src))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->copy)
        GTK_STYLE_CLASS(klass)->copy(GTK_STYLE(self->obj), GTK_STYLE(src->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.copy not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_clone(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    GtkStyle *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Style.clone", kwlist, &PyGtkStyle_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->clone)
        ret = GTK_STYLE_CLASS(klass)->clone(GTK_STYLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.clone not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkStyle__do_init_from_rc(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "rc_style", NULL };
    PyGObject *self, *rc_style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Style.init_from_rc", kwlist, &PyGtkStyle_Type, &self, &PyGtkRcStyle_Type, &rc_style))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->init_from_rc)
        GTK_STYLE_CLASS(klass)->init_from_rc(GTK_STYLE(self->obj), GTK_RC_STYLE(rc_style->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.init_from_rc not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_set_background(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", NULL };
    PyGObject *self, *window;
    PyObject *py_state_type = NULL;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O:Gtk.Style.set_background", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->set_background)
        GTK_STYLE_CLASS(klass)->set_background(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.set_background not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_render_icon(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "source", "direction", "state", "size", "widget", "detail", NULL };
    GtkIconSource *source = NULL;
    PyObject *py_source, *py_direction = NULL, *py_state = NULL, *py_size = NULL;
    GdkPixbuf *ret;
    char *detail;
    GtkTextDirection direction;
    GtkIconSize size;
    PyGObject *self, *widget;
    GtkStateType state;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOOO!s:Gtk.Style.render_icon", kwlist, &PyGtkStyle_Type, &self, &py_source, &py_direction, &py_state, &py_size, &PyGtkWidget_Type, &widget, &detail))
        return NULL;
    if (pyg_boxed_check(py_source, GTK_TYPE_ICON_SOURCE))
        source = pyg_boxed_get(py_source, GtkIconSource);
    else {
        PyErr_SetString(PyExc_TypeError, "source should be a GtkIconSource");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, py_direction, (gpointer)&direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state, (gpointer)&state))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->render_icon)
        ret = GTK_STYLE_CLASS(klass)->render_icon(GTK_STYLE(self->obj), source, direction, state, size, GTK_WIDGET(widget->obj), detail);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.render_icon not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkStyle__do_draw_hline(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "area", "widget", "detail", "x1", "x2", "y", NULL };
    PyObject *py_state_type = NULL, *py_area;
    char *detail;
    int x1, x2, y;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOO!siii:Gtk.Style.draw_hline", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x1, &x2, &y))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_hline)
        GTK_STYLE_CLASS(klass)->draw_hline(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, &area, GTK_WIDGET(widget->obj), detail, x1, x2, y);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_hline not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_vline(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "area", "widget", "detail", "y1_", "y2_", "x", NULL };
    PyObject *py_state_type = NULL, *py_area;
    char *detail;
    int y1_, y2_, x;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOO!siii:Gtk.Style.draw_vline", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &y1_, &y2_, &x))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_vline)
        GTK_STYLE_CLASS(klass)->draw_vline(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, &area, GTK_WIDGET(widget->obj), detail, y1_, y2_, x);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_vline not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_shadow(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiii:Gtk.Style.draw_shadow", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_shadow)
        GTK_STYLE_CLASS(klass)->draw_shadow(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_shadow not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_arrow(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "arrow_type", "fill", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area, *py_arrow_type = NULL;
    char *detail;
    int fill, x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;
    GtkArrowType arrow_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!sOiiiii:Gtk.Style.draw_arrow", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &py_arrow_type, &fill, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ARROW_TYPE, py_arrow_type, (gpointer)&arrow_type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_arrow)
        GTK_STYLE_CLASS(klass)->draw_arrow(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, arrow_type, fill, x, y, width, height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_arrow not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_diamond(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiii:Gtk.Style.draw_diamond", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_diamond)
        GTK_STYLE_CLASS(klass)->draw_diamond(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_diamond not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_string(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "area", "widget", "detail", "x", "y", "string", NULL };
    PyObject *py_state_type = NULL, *py_area;
    char *detail, *string;
    int x, y;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOO!siis:Gtk.Style.draw_string", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &string))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_string)
        GTK_STYLE_CLASS(klass)->draw_string(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, &area, GTK_WIDGET(widget->obj), detail, x, y, string);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_string not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_box(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiii:Gtk.Style.draw_box", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_box)
        GTK_STYLE_CLASS(klass)->draw_box(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_box not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_flat_box(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiii:Gtk.Style.draw_flat_box", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_flat_box)
        GTK_STYLE_CLASS(klass)->draw_flat_box(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_flat_box not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_check(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiii:Gtk.Style.draw_check", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_check)
        GTK_STYLE_CLASS(klass)->draw_check(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_check not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_option(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiii:Gtk.Style.draw_option", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_option)
        GTK_STYLE_CLASS(klass)->draw_option(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_option not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_tab(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiii:Gtk.Style.draw_tab", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_tab)
        GTK_STYLE_CLASS(klass)->draw_tab(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_tab not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_shadow_gap(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", "gap_side", "gap_x", "gap_width", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area, *py_gap_side = NULL;
    GtkPositionType gap_side;
    char *detail;
    int x, y, width, height, gap_x, gap_width;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiiiOii:Gtk.Style.draw_shadow_gap", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height, &py_gap_side, &gap_x, &gap_width))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_gap_side, (gpointer)&gap_side))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_shadow_gap)
        GTK_STYLE_CLASS(klass)->draw_shadow_gap(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height, gap_side, gap_x, gap_width);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_shadow_gap not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_box_gap(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", "gap_side", "gap_x", "gap_width", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area, *py_gap_side = NULL;
    GtkPositionType gap_side;
    char *detail;
    int x, y, width, height, gap_x, gap_width;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiiiOii:Gtk.Style.draw_box_gap", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height, &py_gap_side, &gap_x, &gap_width))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_gap_side, (gpointer)&gap_side))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_box_gap)
        GTK_STYLE_CLASS(klass)->draw_box_gap(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height, gap_side, gap_x, gap_width);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_box_gap not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_extension(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", "gap_side", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area, *py_gap_side = NULL;
    GtkPositionType gap_side;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiiiO:Gtk.Style.draw_extension", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height, &py_gap_side))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_POSITION_TYPE, py_gap_side, (gpointer)&gap_side))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_extension)
        GTK_STYLE_CLASS(klass)->draw_extension(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height, gap_side);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_extension not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_focus(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "area", "widget", "detail", "x", "y", "width", "height", NULL };
    PyObject *py_state_type = NULL, *py_area;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOO!siiii:Gtk.Style.draw_focus", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_focus)
        GTK_STYLE_CLASS(klass)->draw_focus(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_focus not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_slider(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", "orientation", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area, *py_orientation = NULL;
    GtkOrientation orientation;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiiiO:Gtk.Style.draw_slider", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_slider)
        GTK_STYLE_CLASS(klass)->draw_slider(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height, orientation);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_slider not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_handle(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "shadow_type", "area", "widget", "detail", "x", "y", "width", "height", "orientation", NULL };
    GtkShadowType shadow_type;
    PyObject *py_state_type = NULL, *py_shadow_type = NULL, *py_area, *py_orientation = NULL;
    GtkOrientation orientation;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOOO!siiiiO:Gtk.Style.draw_handle", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_shadow_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &width, &height, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type, (gpointer)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_handle)
        GTK_STYLE_CLASS(klass)->draw_handle(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, &area, GTK_WIDGET(widget->obj), detail, x, y, width, height, orientation);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_handle not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_expander(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "area", "widget", "detail", "x", "y", "expander_style", NULL };
    GtkExpanderStyle expander_style;
    PyObject *py_state_type = NULL, *py_area, *py_expander_style = NULL;
    char *detail;
    int x, y;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOO!siiO:Gtk.Style.draw_expander", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &py_expander_style))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_EXPANDER_STYLE, py_expander_style, (gpointer)&expander_style))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_expander)
        GTK_STYLE_CLASS(klass)->draw_expander(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, &area, GTK_WIDGET(widget->obj), detail, x, y, expander_style);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_expander not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_layout(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "use_text", "area", "widget", "detail", "x", "y", "layout", NULL };
    PyObject *py_state_type = NULL, *py_area;
    char *detail;
    int use_text, x, y;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget, *layout;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OiOO!siiO!:Gtk.Style.draw_layout", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &use_text, &py_area, &PyGtkWidget_Type, &widget, &detail, &x, &y, &PyPangoLayout_Type, &layout))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_layout)
        GTK_STYLE_CLASS(klass)->draw_layout(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, use_text, &area, GTK_WIDGET(widget->obj), detail, x, y, PANGO_LAYOUT(layout->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_layout not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStyle__do_draw_resize_grip(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "window", "state_type", "area", "widget", "detail", "edge", "x", "y", "width", "height", NULL };
    PyObject *py_state_type = NULL, *py_area, *py_edge = NULL;
    GdkWindowEdge edge;
    char *detail;
    int x, y, width, height;
    GdkRectangle area = { 0, 0, 0, 0 };
    PyGObject *self, *window, *widget;
    GtkStateType state_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOO!sOiiii:Gtk.Style.draw_resize_grip", kwlist, &PyGtkStyle_Type, &self, &PyGdkWindow_Type, &window, &py_state_type, &py_area, &PyGtkWidget_Type, &widget, &detail, &py_edge, &x, &y, &width, &height))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type, (gpointer)&state_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (pyg_enum_get_value(GDK_TYPE_WINDOW_EDGE, py_edge, (gpointer)&edge))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STYLE_CLASS(klass)->draw_resize_grip)
        GTK_STYLE_CLASS(klass)->draw_resize_grip(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, &area, GTK_WIDGET(widget->obj), detail, edge, x, y, width, height);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Style.draw_resize_grip not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkStyle_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_style_copy, METH_NOARGS,
      NULL },
    { "attach", (PyCFunction)_wrap_gtk_style_attach, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "detach", (PyCFunction)_wrap_gtk_style_detach, METH_NOARGS,
      NULL },
    { "get_font", (PyCFunction)_wrap_gtk_style_get_font, METH_NOARGS,
      NULL },
    { "set_font", (PyCFunction)_wrap_gtk_style_set_font, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_background", (PyCFunction)_wrap_gtk_style_set_background, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "apply_default_background", (PyCFunction)_wrap_gtk_style_apply_default_background, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "lookup_icon_set", (PyCFunction)_wrap_gtk_style_lookup_icon_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "render_icon", (PyCFunction)_wrap_gtk_style_render_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_hline", (PyCFunction)_wrap_gtk_paint_hline, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_vline", (PyCFunction)_wrap_gtk_paint_vline, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_shadow", (PyCFunction)_wrap_gtk_paint_shadow, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_polygon", (PyCFunction)_wrap_gtk_paint_polygon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_arrow", (PyCFunction)_wrap_gtk_paint_arrow, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_diamond", (PyCFunction)_wrap_gtk_paint_diamond, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_box", (PyCFunction)_wrap_gtk_paint_box, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_flat_box", (PyCFunction)_wrap_gtk_paint_flat_box, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_check", (PyCFunction)_wrap_gtk_paint_check, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_option", (PyCFunction)_wrap_gtk_paint_option, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_tab", (PyCFunction)_wrap_gtk_paint_tab, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_shadow_gap", (PyCFunction)_wrap_gtk_paint_shadow_gap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_box_gap", (PyCFunction)_wrap_gtk_paint_box_gap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_extension", (PyCFunction)_wrap_gtk_paint_extension, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_focus", (PyCFunction)_wrap_gtk_paint_focus, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_slider", (PyCFunction)_wrap_gtk_paint_slider, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_handle", (PyCFunction)_wrap_gtk_paint_handle, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_expander", (PyCFunction)_wrap_gtk_paint_expander, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_layout", (PyCFunction)_wrap_gtk_paint_layout, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_resize_grip", (PyCFunction)_wrap_gtk_paint_resize_grip, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "apply_default_pixmap", (PyCFunction)_wrap_gtk_style_apply_default_pixmap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paint_string", (PyCFunction)_wrap_gtk_paint_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "lookup_color", (PyCFunction)_wrap_gtk_style_lookup_color, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_realize", (PyCFunction)_wrap_GtkStyle__do_realize, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unrealize", (PyCFunction)_wrap_GtkStyle__do_unrealize, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_copy", (PyCFunction)_wrap_GtkStyle__do_copy, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_clone", (PyCFunction)_wrap_GtkStyle__do_clone, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_init_from_rc", (PyCFunction)_wrap_GtkStyle__do_init_from_rc, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_background", (PyCFunction)_wrap_GtkStyle__do_set_background, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_render_icon", (PyCFunction)_wrap_GtkStyle__do_render_icon, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_hline", (PyCFunction)_wrap_GtkStyle__do_draw_hline, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_vline", (PyCFunction)_wrap_GtkStyle__do_draw_vline, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_shadow", (PyCFunction)_wrap_GtkStyle__do_draw_shadow, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_arrow", (PyCFunction)_wrap_GtkStyle__do_draw_arrow, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_diamond", (PyCFunction)_wrap_GtkStyle__do_draw_diamond, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_string", (PyCFunction)_wrap_GtkStyle__do_draw_string, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_box", (PyCFunction)_wrap_GtkStyle__do_draw_box, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_flat_box", (PyCFunction)_wrap_GtkStyle__do_draw_flat_box, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_check", (PyCFunction)_wrap_GtkStyle__do_draw_check, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_option", (PyCFunction)_wrap_GtkStyle__do_draw_option, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_tab", (PyCFunction)_wrap_GtkStyle__do_draw_tab, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_shadow_gap", (PyCFunction)_wrap_GtkStyle__do_draw_shadow_gap, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_box_gap", (PyCFunction)_wrap_GtkStyle__do_draw_box_gap, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_extension", (PyCFunction)_wrap_GtkStyle__do_draw_extension, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_focus", (PyCFunction)_wrap_GtkStyle__do_draw_focus, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_slider", (PyCFunction)_wrap_GtkStyle__do_draw_slider, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_handle", (PyCFunction)_wrap_GtkStyle__do_draw_handle, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_expander", (PyCFunction)_wrap_GtkStyle__do_draw_expander, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_layout", (PyCFunction)_wrap_GtkStyle__do_draw_layout, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_resize_grip", (PyCFunction)_wrap_GtkStyle__do_draw_resize_grip, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 24 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_fg(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->fg);
}
#line 78192 "gtk.c"


#line 33 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_bg(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->bg);
}
#line 78203 "gtk.c"


#line 42 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_light(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->light);
}
#line 78214 "gtk.c"


#line 51 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_dark(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->dark);
}
#line 78225 "gtk.c"


#line 60 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_mid(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->mid);
}
#line 78236 "gtk.c"


#line 69 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_text(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->text);
}
#line 78247 "gtk.c"


#line 78 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_base(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->base);
}
#line 78258 "gtk.c"


#line 87 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_text_aa(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->text_aa);
}
#line 78269 "gtk.c"


#line 96 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_white(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return pyg_boxed_new(GDK_TYPE_COLOR, &style->white, TRUE, TRUE);
}
static int
_wrap_gtk_style__set_white(PyGObject *self, PyObject *value, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    if (!pyg_boxed_check(value, GDK_TYPE_COLOR)) {
        PyErr_SetString(PyExc_TypeError, "can only assign a GdkColor");
        return -1;
    }
    style->white = *pyg_boxed_get(value, GdkColor);
    return 0;
}
#line 78292 "gtk.c"


#line 117 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_black(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return pyg_boxed_new(GDK_TYPE_COLOR, &style->black, TRUE, TRUE);
}
static int
_wrap_gtk_style__set_black(PyGObject *self, PyObject *value, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    if (!pyg_boxed_check(value, GDK_TYPE_COLOR)) {
        PyErr_SetString(PyExc_TypeError, "can only assign a GdkColor");
        return -1;
    }
    style->black = *pyg_boxed_get(value, GdkColor);
    return 0;
}
#line 78315 "gtk.c"


static PyObject *
_wrap_gtk_style__get_font_desc(PyObject *self, void *closure)
{
    PangoFontDescription *ret;

    ret = GTK_STYLE(pygobject_get(self))->font_desc;
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PANGO_TYPE_FONT_DESCRIPTION, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_style__get_xthickness(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_STYLE(pygobject_get(self))->xthickness;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_style__get_ythickness(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_STYLE(pygobject_get(self))->ythickness;
    return PyInt_FromLong(ret);
}

#line 138 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_fg_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->fg_gc);
}
#line 78354 "gtk.c"


#line 147 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_bg_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->bg_gc);
}
#line 78365 "gtk.c"


#line 156 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_light_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->light_gc);
}
#line 78376 "gtk.c"


#line 165 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_dark_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->dark_gc);
}
#line 78387 "gtk.c"


#line 174 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_mid_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->mid_gc);
}
#line 78398 "gtk.c"


#line 183 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_text_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->text_gc);
}
#line 78409 "gtk.c"


#line 192 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_base_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->base_gc);
}
#line 78420 "gtk.c"


#line 201 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_text_aa_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->text_aa_gc);
}
#line 78431 "gtk.c"


#line 210 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_white_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return pygobject_new((GObject *)style->white_gc);
}
static int
_wrap_gtk_style__set_white_gc(PyGObject *self, PyObject *value, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    if (!pygobject_check(value, &PyGdkGC_Type)) {
        PyErr_SetString(PyExc_TypeError, "can only assign a GdkGC");
        return -1;
    }
    style->white_gc = GDK_GC(pygobject_get(value));
    return 0;
}
#line 78454 "gtk.c"


#line 231 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_black_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return pygobject_new((GObject *)style->black_gc);
}
static int
_wrap_gtk_style__set_black_gc(PyGObject *self, PyObject *value, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    if (!pygobject_check(value, &PyGdkGC_Type)) {
        PyErr_SetString(PyExc_TypeError, "can only assign a GdkGC");
        return -1;
    }
    style->black_gc = GDK_GC(pygobject_get(value));
    return 0;
}
#line 78477 "gtk.c"


#line 252 "gtkstyle.override"
static PyObject *
_wrap_gtk_style__get_bg_pixmap(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_PIXMAP_ARRAY, style->bg_pixmap);
}
#line 78488 "gtk.c"


static const PyGetSetDef gtk_style_getsets[] = {
    { "fg", (getter)_wrap_gtk_style__get_fg, (setter)0 },
    { "bg", (getter)_wrap_gtk_style__get_bg, (setter)0 },
    { "light", (getter)_wrap_gtk_style__get_light, (setter)0 },
    { "dark", (getter)_wrap_gtk_style__get_dark, (setter)0 },
    { "mid", (getter)_wrap_gtk_style__get_mid, (setter)0 },
    { "text", (getter)_wrap_gtk_style__get_text, (setter)0 },
    { "base", (getter)_wrap_gtk_style__get_base, (setter)0 },
    { "text_aa", (getter)_wrap_gtk_style__get_text_aa, (setter)0 },
    { "white", (getter)_wrap_gtk_style__get_white, (setter)_wrap_gtk_style__set_white },
    { "black", (getter)_wrap_gtk_style__get_black, (setter)_wrap_gtk_style__set_black },
    { "font_desc", (getter)_wrap_gtk_style__get_font_desc, (setter)0 },
    { "xthickness", (getter)_wrap_gtk_style__get_xthickness, (setter)0 },
    { "ythickness", (getter)_wrap_gtk_style__get_ythickness, (setter)0 },
    { "fg_gc", (getter)_wrap_gtk_style__get_fg_gc, (setter)0 },
    { "bg_gc", (getter)_wrap_gtk_style__get_bg_gc, (setter)0 },
    { "light_gc", (getter)_wrap_gtk_style__get_light_gc, (setter)0 },
    { "dark_gc", (getter)_wrap_gtk_style__get_dark_gc, (setter)0 },
    { "mid_gc", (getter)_wrap_gtk_style__get_mid_gc, (setter)0 },
    { "text_gc", (getter)_wrap_gtk_style__get_text_gc, (setter)0 },
    { "base_gc", (getter)_wrap_gtk_style__get_base_gc, (setter)0 },
    { "text_aa_gc", (getter)_wrap_gtk_style__get_text_aa_gc, (setter)0 },
    { "white_gc", (getter)_wrap_gtk_style__get_white_gc, (setter)_wrap_gtk_style__set_white_gc },
    { "black_gc", (getter)_wrap_gtk_style__get_black_gc, (setter)_wrap_gtk_style__set_black_gc },
    { "bg_pixmap", (getter)_wrap_gtk_style__get_bg_pixmap, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkStyle_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Style",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkStyle_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_style_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_style_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkStyle__proxy_do_realize(GtkStyle *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_realize");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_unrealize(GtkStyle *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_unrealize");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_copy(GtkStyle *self, GtkStyle*src)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_src = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (src)
        py_src = pygobject_new((GObject *) src);
    else {
        Py_INCREF(Py_None);
        py_src = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_src);
    
    py_method = PyObject_GetAttrString(py_self, "do_copy");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GtkStyle*
_wrap_GtkStyle__proxy_do_clone(GtkStyle *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkStyle* retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_clone");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkStyle*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkStyle__proxy_do_init_from_rc(GtkStyle *self, GtkRcStyle*rc_style)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_rc_style = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (rc_style)
        py_rc_style = pygobject_new((GObject *) rc_style);
    else {
        Py_INCREF(Py_None);
        py_rc_style = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_rc_style);
    
    py_method = PyObject_GetAttrString(py_self, "do_init_from_rc");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_set_background(GtkStyle *self, GdkWindow*window, GtkStateType state_type)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_background");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GdkPixbuf*
_wrap_GtkStyle__proxy_do_render_icon(GtkStyle *self, const GtkIconSource*source, GtkTextDirection direction, GtkStateType state, GtkIconSize size, GtkWidget*widget, const gchar*detail)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_source;
    PyObject *py_direction;
    PyObject *py_state;
    PyObject *py_size;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    GdkPixbuf* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_source = pyg_boxed_new(GTK_TYPE_ICON_SOURCE, (GtkIconSource*) source, TRUE, TRUE);
    py_direction = pyg_enum_from_gtype(GTK_TYPE_TEXT_DIRECTION, direction);
    if (!py_direction) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_source);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_state = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state);
    if (!py_state) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_direction);
        Py_DECREF(py_source);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_size = pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, size);
    if (!py_size) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state);
        Py_DECREF(py_direction);
        Py_DECREF(py_source);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_size);
        Py_DECREF(py_state);
        Py_DECREF(py_direction);
        Py_DECREF(py_source);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    py_args = PyTuple_New(6);
    PyTuple_SET_ITEM(py_args, 0, py_source);
    PyTuple_SET_ITEM(py_args, 1, py_direction);
    PyTuple_SET_ITEM(py_args, 2, py_state);
    PyTuple_SET_ITEM(py_args, 3, py_size);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    
    py_method = PyObject_GetAttrString(py_self, "do_render_icon");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GdkPixbuf*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkStyle__proxy_do_draw_hline(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x1, gint x2, gint y)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x1;
    PyObject *py_x2;
    PyObject *py_y;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x1 = PyInt_FromLong(x1);
    py_x2 = PyInt_FromLong(x2);
    py_y = PyInt_FromLong(y);
    
    py_args = PyTuple_New(8);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_area);
    PyTuple_SET_ITEM(py_args, 3, py_widget);
    PyTuple_SET_ITEM(py_args, 4, py_detail);
    PyTuple_SET_ITEM(py_args, 5, py_x1);
    PyTuple_SET_ITEM(py_args, 6, py_x2);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_hline");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_vline(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint y1_, gint y2_, gint x)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_y1_;
    PyObject *py_y2_;
    PyObject *py_x;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_y1_ = PyInt_FromLong(y1_);
    py_y2_ = PyInt_FromLong(y2_);
    py_x = PyInt_FromLong(x);
    
    py_args = PyTuple_New(8);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_area);
    PyTuple_SET_ITEM(py_args, 3, py_widget);
    PyTuple_SET_ITEM(py_args, 4, py_detail);
    PyTuple_SET_ITEM(py_args, 5, py_y1_);
    PyTuple_SET_ITEM(py_args, 6, py_y2_);
    PyTuple_SET_ITEM(py_args, 7, py_x);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_vline");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_shadow(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(10);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_shadow");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_arrow(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, GtkArrowType arrow_type, gboolean fill, gint x, gint y, gint width, gint height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_arrow_type;
    PyObject *py_fill;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_arrow_type = pyg_enum_from_gtype(GTK_TYPE_ARROW_TYPE, arrow_type);
    if (!py_arrow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_detail);
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_fill = fill? Py_True : Py_False;
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(12);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_arrow_type);
    Py_INCREF(py_fill);
    PyTuple_SET_ITEM(py_args, 7, py_fill);
    PyTuple_SET_ITEM(py_args, 8, py_x);
    PyTuple_SET_ITEM(py_args, 9, py_y);
    PyTuple_SET_ITEM(py_args, 10, py_width);
    PyTuple_SET_ITEM(py_args, 11, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_arrow");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_diamond(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(10);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_diamond");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_string(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, const gchar*string)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_string = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    if (string)
        py_string = PyString_FromString(string);
    if (!py_string) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_y);
        Py_DECREF(py_x);
        Py_DECREF(py_detail);
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(8);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_area);
    PyTuple_SET_ITEM(py_args, 3, py_widget);
    PyTuple_SET_ITEM(py_args, 4, py_detail);
    PyTuple_SET_ITEM(py_args, 5, py_x);
    PyTuple_SET_ITEM(py_args, 6, py_y);
    PyTuple_SET_ITEM(py_args, 7, py_string);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_string");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_box(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(10);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_box");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_flat_box(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(10);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_flat_box");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_check(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(10);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_check");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_option(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(10);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_option");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_tab(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(10);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_tab");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_shadow_gap(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_gap_side;
    PyObject *py_gap_x;
    PyObject *py_gap_width;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    py_gap_side = pyg_enum_from_gtype(GTK_TYPE_POSITION_TYPE, gap_side);
    if (!py_gap_side) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_height);
        Py_DECREF(py_width);
        Py_DECREF(py_y);
        Py_DECREF(py_x);
        Py_DECREF(py_detail);
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_gap_x = PyInt_FromLong(gap_x);
    py_gap_width = PyInt_FromLong(gap_width);
    
    py_args = PyTuple_New(13);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    PyTuple_SET_ITEM(py_args, 10, py_gap_side);
    PyTuple_SET_ITEM(py_args, 11, py_gap_x);
    PyTuple_SET_ITEM(py_args, 12, py_gap_width);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_shadow_gap");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_box_gap(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_gap_side;
    PyObject *py_gap_x;
    PyObject *py_gap_width;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    py_gap_side = pyg_enum_from_gtype(GTK_TYPE_POSITION_TYPE, gap_side);
    if (!py_gap_side) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_height);
        Py_DECREF(py_width);
        Py_DECREF(py_y);
        Py_DECREF(py_x);
        Py_DECREF(py_detail);
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_gap_x = PyInt_FromLong(gap_x);
    py_gap_width = PyInt_FromLong(gap_width);
    
    py_args = PyTuple_New(13);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    PyTuple_SET_ITEM(py_args, 10, py_gap_side);
    PyTuple_SET_ITEM(py_args, 11, py_gap_x);
    PyTuple_SET_ITEM(py_args, 12, py_gap_width);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_box_gap");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_extension(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_gap_side;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    py_gap_side = pyg_enum_from_gtype(GTK_TYPE_POSITION_TYPE, gap_side);
    if (!py_gap_side) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_height);
        Py_DECREF(py_width);
        Py_DECREF(py_y);
        Py_DECREF(py_x);
        Py_DECREF(py_detail);
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(11);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    PyTuple_SET_ITEM(py_args, 10, py_gap_side);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_extension");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_focus(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(9);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_area);
    PyTuple_SET_ITEM(py_args, 3, py_widget);
    PyTuple_SET_ITEM(py_args, 4, py_detail);
    PyTuple_SET_ITEM(py_args, 5, py_x);
    PyTuple_SET_ITEM(py_args, 6, py_y);
    PyTuple_SET_ITEM(py_args, 7, py_width);
    PyTuple_SET_ITEM(py_args, 8, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_focus");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_slider(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height, GtkOrientation orientation)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_orientation;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    py_orientation = pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, orientation);
    if (!py_orientation) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_height);
        Py_DECREF(py_width);
        Py_DECREF(py_y);
        Py_DECREF(py_x);
        Py_DECREF(py_detail);
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(11);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    PyTuple_SET_ITEM(py_args, 10, py_orientation);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_slider");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_handle(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, gint width, gint height, GtkOrientation orientation)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_shadow_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_orientation;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_shadow_type = pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, shadow_type);
    if (!py_shadow_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    py_orientation = pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, orientation);
    if (!py_orientation) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_height);
        Py_DECREF(py_width);
        Py_DECREF(py_y);
        Py_DECREF(py_x);
        Py_DECREF(py_detail);
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_shadow_type);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(11);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_shadow_type);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    PyTuple_SET_ITEM(py_args, 10, py_orientation);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_handle");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_expander(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, GtkExpanderStyle expander_style)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_expander_style;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_expander_style = pyg_enum_from_gtype(GTK_TYPE_EXPANDER_STYLE, expander_style);
    if (!py_expander_style) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_y);
        Py_DECREF(py_x);
        Py_DECREF(py_detail);
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(8);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_area);
    PyTuple_SET_ITEM(py_args, 3, py_widget);
    PyTuple_SET_ITEM(py_args, 4, py_detail);
    PyTuple_SET_ITEM(py_args, 5, py_x);
    PyTuple_SET_ITEM(py_args, 6, py_y);
    PyTuple_SET_ITEM(py_args, 7, py_expander_style);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_expander");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_layout(GtkStyle *self, GdkWindow*window, GtkStateType state_type, gboolean use_text, GdkRectangle*area, GtkWidget*widget, const gchar*detail, gint x, gint y, PangoLayout*layout)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_use_text;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_layout = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_use_text = use_text? Py_True : Py_False;
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    if (layout)
        py_layout = pygobject_new((GObject *) layout);
    else {
        Py_INCREF(Py_None);
        py_layout = Py_None;
    }
    
    py_args = PyTuple_New(9);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    Py_INCREF(py_use_text);
    PyTuple_SET_ITEM(py_args, 2, py_use_text);
    PyTuple_SET_ITEM(py_args, 3, py_area);
    PyTuple_SET_ITEM(py_args, 4, py_widget);
    PyTuple_SET_ITEM(py_args, 5, py_detail);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_layout);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_layout");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkStyle__proxy_do_draw_resize_grip(GtkStyle *self, GdkWindow*window, GtkStateType state_type, GdkRectangle*area, GtkWidget*widget, const gchar*detail, GdkWindowEdge edge, gint x, gint y, gint width, gint height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_window = NULL;
    PyObject *py_state_type;
    PyObject *py_area;
    PyObject *py_widget = NULL;
    PyObject *py_detail = NULL;
    PyObject *py_edge;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_width;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (window)
        py_window = pygobject_new((GObject *) window);
    else {
        Py_INCREF(Py_None);
        py_window = Py_None;
    }
    py_state_type = pyg_enum_from_gtype(GTK_TYPE_STATE_TYPE, state_type);
    if (!py_state_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_area = pyg_boxed_new(GDK_TYPE_RECTANGLE, area, TRUE, TRUE);
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    if (detail)
        py_detail = PyString_FromString(detail);
    if (!py_detail) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_edge = pyg_enum_from_gtype(GDK_TYPE_WINDOW_EDGE, edge);
    if (!py_edge) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_detail);
        Py_DECREF(py_widget);
        Py_DECREF(py_area);
        Py_DECREF(py_state_type);
        Py_DECREF(py_window);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_width = PyInt_FromLong(width);
    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(10);
    PyTuple_SET_ITEM(py_args, 0, py_window);
    PyTuple_SET_ITEM(py_args, 1, py_state_type);
    PyTuple_SET_ITEM(py_args, 2, py_area);
    PyTuple_SET_ITEM(py_args, 3, py_widget);
    PyTuple_SET_ITEM(py_args, 4, py_detail);
    PyTuple_SET_ITEM(py_args, 5, py_edge);
    PyTuple_SET_ITEM(py_args, 6, py_x);
    PyTuple_SET_ITEM(py_args, 7, py_y);
    PyTuple_SET_ITEM(py_args, 8, py_width);
    PyTuple_SET_ITEM(py_args, 9, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_resize_grip");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkStyle_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkStyleClass *klass = GTK_STYLE_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_realize");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "realize")))
            klass->realize = _wrap_GtkStyle__proxy_do_realize;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_unrealize");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "unrealize")))
            klass->unrealize = _wrap_GtkStyle__proxy_do_unrealize;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_copy");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "copy")))
            klass->copy = _wrap_GtkStyle__proxy_do_copy;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_clone");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "clone")))
            klass->clone = _wrap_GtkStyle__proxy_do_clone;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_init_from_rc");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "init_from_rc")))
            klass->init_from_rc = _wrap_GtkStyle__proxy_do_init_from_rc;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_background");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_background")))
            klass->set_background = _wrap_GtkStyle__proxy_do_set_background;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_render_icon");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "render_icon")))
            klass->render_icon = _wrap_GtkStyle__proxy_do_render_icon;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_hline");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_hline")))
            klass->draw_hline = _wrap_GtkStyle__proxy_do_draw_hline;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_vline");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_vline")))
            klass->draw_vline = _wrap_GtkStyle__proxy_do_draw_vline;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_shadow");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_shadow")))
            klass->draw_shadow = _wrap_GtkStyle__proxy_do_draw_shadow;
        Py_DECREF(o);
    }

    /* overriding do_draw_polygon is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_arrow");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_arrow")))
            klass->draw_arrow = _wrap_GtkStyle__proxy_do_draw_arrow;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_diamond");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_diamond")))
            klass->draw_diamond = _wrap_GtkStyle__proxy_do_draw_diamond;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_string");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_string")))
            klass->draw_string = _wrap_GtkStyle__proxy_do_draw_string;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_box");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_box")))
            klass->draw_box = _wrap_GtkStyle__proxy_do_draw_box;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_flat_box");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_flat_box")))
            klass->draw_flat_box = _wrap_GtkStyle__proxy_do_draw_flat_box;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_check");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_check")))
            klass->draw_check = _wrap_GtkStyle__proxy_do_draw_check;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_option");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_option")))
            klass->draw_option = _wrap_GtkStyle__proxy_do_draw_option;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_tab");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_tab")))
            klass->draw_tab = _wrap_GtkStyle__proxy_do_draw_tab;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_shadow_gap");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_shadow_gap")))
            klass->draw_shadow_gap = _wrap_GtkStyle__proxy_do_draw_shadow_gap;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_box_gap");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_box_gap")))
            klass->draw_box_gap = _wrap_GtkStyle__proxy_do_draw_box_gap;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_extension");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_extension")))
            klass->draw_extension = _wrap_GtkStyle__proxy_do_draw_extension;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_focus");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_focus")))
            klass->draw_focus = _wrap_GtkStyle__proxy_do_draw_focus;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_slider");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_slider")))
            klass->draw_slider = _wrap_GtkStyle__proxy_do_draw_slider;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_handle");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_handle")))
            klass->draw_handle = _wrap_GtkStyle__proxy_do_draw_handle;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_expander");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_expander")))
            klass->draw_expander = _wrap_GtkStyle__proxy_do_draw_expander;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_layout");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_layout")))
            klass->draw_layout = _wrap_GtkStyle__proxy_do_draw_layout;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_resize_grip");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_resize_grip")))
            klass->draw_resize_grip = _wrap_GtkStyle__proxy_do_draw_resize_grip;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkTable ----------- */

#line 5493 "./gtk.override"
static int
_wrap_gtk_table_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *arg_names[] = {"rows", "columns", "homogeneous", NULL };
    int rows = 1, cols = 1;
    PyObject *homogeneous = Py_False;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iiO:gtk.Table.__init__", arg_names,
                                     &rows, &cols, &homogeneous))
        return -1;
    pygobject_construct(self, "n_rows", rows, "n_columns", cols,
                        "homogeneous", PyObject_IsTrue(homogeneous), NULL);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create gtk.Table object");
        return -1;
    }
    return 0;
}
#line 82003 "gtk.c"


static PyObject *
_wrap_gtk_table_resize(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "rows", "columns", NULL };
    PyObject *py_rows = NULL, *py_columns = NULL;
    guint rows = 0, columns = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Table.resize", kwlist, &py_rows, &py_columns))
        return NULL;
    if (py_rows) {
        if (PyLong_Check(py_rows))
            rows = PyLong_AsUnsignedLong(py_rows);
        else if (PyInt_Check(py_rows))
            rows = PyInt_AsLong(py_rows);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'rows' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_columns) {
        if (PyLong_Check(py_columns))
            columns = PyLong_AsUnsignedLong(py_columns);
        else if (PyInt_Check(py_columns))
            columns = PyInt_AsLong(py_columns);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'columns' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_table_resize(GTK_TABLE(self->obj), rows, columns);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_table_attach(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "left_attach", "right_attach", "top_attach", "bottom_attach", "xoptions", "yoptions", "xpadding", "ypadding", NULL };
    PyGObject *child;
    PyObject *py_left_attach = NULL, *py_right_attach = NULL, *py_top_attach = NULL, *py_bottom_attach = NULL, *py_xoptions = NULL, *py_yoptions = NULL, *py_xpadding = NULL, *py_ypadding = NULL;
    guint left_attach = 0, right_attach = 0, top_attach = 0, bottom_attach = 0, xpadding = 0, ypadding = 0;
    GtkAttachOptions xoptions = GTK_EXPAND|GTK_FILL, yoptions = GTK_EXPAND|GTK_FILL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOO|OOOO:Gtk.Table.attach", kwlist, &PyGtkWidget_Type, &child, &py_left_attach, &py_right_attach, &py_top_attach, &py_bottom_attach, &py_xoptions, &py_yoptions, &py_xpadding, &py_ypadding))
        return NULL;
    if (py_left_attach) {
        if (PyLong_Check(py_left_attach))
            left_attach = PyLong_AsUnsignedLong(py_left_attach);
        else if (PyInt_Check(py_left_attach))
            left_attach = PyInt_AsLong(py_left_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'left_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_right_attach) {
        if (PyLong_Check(py_right_attach))
            right_attach = PyLong_AsUnsignedLong(py_right_attach);
        else if (PyInt_Check(py_right_attach))
            right_attach = PyInt_AsLong(py_right_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'right_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_top_attach) {
        if (PyLong_Check(py_top_attach))
            top_attach = PyLong_AsUnsignedLong(py_top_attach);
        else if (PyInt_Check(py_top_attach))
            top_attach = PyInt_AsLong(py_top_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'top_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_bottom_attach) {
        if (PyLong_Check(py_bottom_attach))
            bottom_attach = PyLong_AsUnsignedLong(py_bottom_attach);
        else if (PyInt_Check(py_bottom_attach))
            bottom_attach = PyInt_AsLong(py_bottom_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'bottom_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_xoptions && pyg_flags_get_value(GTK_TYPE_ATTACH_OPTIONS, py_xoptions, (gpointer)&xoptions))
        return NULL;
    if (py_yoptions && pyg_flags_get_value(GTK_TYPE_ATTACH_OPTIONS, py_yoptions, (gpointer)&yoptions))
        return NULL;
    if (py_xpadding) {
        if (PyLong_Check(py_xpadding))
            xpadding = PyLong_AsUnsignedLong(py_xpadding);
        else if (PyInt_Check(py_xpadding))
            xpadding = PyInt_AsLong(py_xpadding);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'xpadding' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_ypadding) {
        if (PyLong_Check(py_ypadding))
            ypadding = PyLong_AsUnsignedLong(py_ypadding);
        else if (PyInt_Check(py_ypadding))
            ypadding = PyInt_AsLong(py_ypadding);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'ypadding' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_table_attach(GTK_TABLE(self->obj), GTK_WIDGET(child->obj), left_attach, right_attach, top_attach, bottom_attach, xoptions, yoptions, xpadding, ypadding);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_table_attach_defaults(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "left_attach", "right_attach", "top_attach", "bottom_attach", NULL };
    PyGObject *widget;
    PyObject *py_left_attach = NULL, *py_right_attach = NULL, *py_top_attach = NULL, *py_bottom_attach = NULL;
    guint left_attach = 0, right_attach = 0, top_attach = 0, bottom_attach = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOOO:Gtk.Table.attach_defaults", kwlist, &PyGtkWidget_Type, &widget, &py_left_attach, &py_right_attach, &py_top_attach, &py_bottom_attach))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use attach instead") < 0)
        return NULL;
    if (py_left_attach) {
        if (PyLong_Check(py_left_attach))
            left_attach = PyLong_AsUnsignedLong(py_left_attach);
        else if (PyInt_Check(py_left_attach))
            left_attach = PyInt_AsLong(py_left_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'left_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_right_attach) {
        if (PyLong_Check(py_right_attach))
            right_attach = PyLong_AsUnsignedLong(py_right_attach);
        else if (PyInt_Check(py_right_attach))
            right_attach = PyInt_AsLong(py_right_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'right_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_top_attach) {
        if (PyLong_Check(py_top_attach))
            top_attach = PyLong_AsUnsignedLong(py_top_attach);
        else if (PyInt_Check(py_top_attach))
            top_attach = PyInt_AsLong(py_top_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'top_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_bottom_attach) {
        if (PyLong_Check(py_bottom_attach))
            bottom_attach = PyLong_AsUnsignedLong(py_bottom_attach);
        else if (PyInt_Check(py_bottom_attach))
            bottom_attach = PyInt_AsLong(py_bottom_attach);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'bottom_attach' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_table_attach_defaults(GTK_TABLE(self->obj), GTK_WIDGET(widget->obj), left_attach, right_attach, top_attach, bottom_attach);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_table_set_row_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "spacing", NULL };
    PyObject *py_row = NULL, *py_spacing = NULL;
    guint row = 0, spacing = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Table.set_row_spacing", kwlist, &py_row, &py_spacing))
        return NULL;
    if (py_row) {
        if (PyLong_Check(py_row))
            row = PyLong_AsUnsignedLong(py_row);
        else if (PyInt_Check(py_row))
            row = PyInt_AsLong(py_row);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'row' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_spacing) {
        if (PyLong_Check(py_spacing))
            spacing = PyLong_AsUnsignedLong(py_spacing);
        else if (PyInt_Check(py_spacing))
            spacing = PyInt_AsLong(py_spacing);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'spacing' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_table_set_row_spacing(GTK_TABLE(self->obj), row, spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_table_get_row_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    PyObject *py_row = NULL;
    guint row = 0, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Table.get_row_spacing", kwlist, &py_row))
        return NULL;
    if (py_row) {
        if (PyLong_Check(py_row))
            row = PyLong_AsUnsignedLong(py_row);
        else if (PyInt_Check(py_row))
            row = PyInt_AsLong(py_row);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'row' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_table_get_row_spacing(GTK_TABLE(self->obj), row);
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_table_set_col_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "spacing", NULL };
    PyObject *py_column = NULL, *py_spacing = NULL;
    guint column = 0, spacing = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.Table.set_col_spacing", kwlist, &py_column, &py_spacing))
        return NULL;
    if (py_column) {
        if (PyLong_Check(py_column))
            column = PyLong_AsUnsignedLong(py_column);
        else if (PyInt_Check(py_column))
            column = PyInt_AsLong(py_column);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'column' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_spacing) {
        if (PyLong_Check(py_spacing))
            spacing = PyLong_AsUnsignedLong(py_spacing);
        else if (PyInt_Check(py_spacing))
            spacing = PyInt_AsLong(py_spacing);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'spacing' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_table_set_col_spacing(GTK_TABLE(self->obj), column, spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_table_get_col_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    PyObject *py_column = NULL;
    guint column = 0, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Table.get_col_spacing", kwlist, &py_column))
        return NULL;
    if (py_column) {
        if (PyLong_Check(py_column))
            column = PyLong_AsUnsignedLong(py_column);
        else if (PyInt_Check(py_column))
            column = PyInt_AsLong(py_column);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'column' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_table_get_col_spacing(GTK_TABLE(self->obj), column);
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_table_set_row_spacings(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "spacing", NULL };
    PyObject *py_spacing = NULL;
    guint spacing = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Table.set_row_spacings", kwlist, &py_spacing))
        return NULL;
    if (py_spacing) {
        if (PyLong_Check(py_spacing))
            spacing = PyLong_AsUnsignedLong(py_spacing);
        else if (PyInt_Check(py_spacing))
            spacing = PyInt_AsLong(py_spacing);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'spacing' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_table_set_row_spacings(GTK_TABLE(self->obj), spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_table_get_default_row_spacing(PyGObject *self)
{
    guint ret;

    
    ret = gtk_table_get_default_row_spacing(GTK_TABLE(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_table_set_col_spacings(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "spacing", NULL };
    PyObject *py_spacing = NULL;
    guint spacing = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Table.set_col_spacings", kwlist, &py_spacing))
        return NULL;
    if (py_spacing) {
        if (PyLong_Check(py_spacing))
            spacing = PyLong_AsUnsignedLong(py_spacing);
        else if (PyInt_Check(py_spacing))
            spacing = PyInt_AsLong(py_spacing);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'spacing' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_table_set_col_spacings(GTK_TABLE(self->obj), spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_table_get_default_col_spacing(PyGObject *self)
{
    guint ret;

    
    ret = gtk_table_get_default_col_spacing(GTK_TABLE(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_table_set_homogeneous(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "homogeneous", NULL };
    int homogeneous;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Table.set_homogeneous", kwlist, &homogeneous))
        return NULL;
    
    gtk_table_set_homogeneous(GTK_TABLE(self->obj), homogeneous);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_table_get_homogeneous(PyGObject *self)
{
    int ret;

    
    ret = gtk_table_get_homogeneous(GTK_TABLE(self->obj));
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkTable_methods[] = {
    { "resize", (PyCFunction)_wrap_gtk_table_resize, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "attach", (PyCFunction)_wrap_gtk_table_attach, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "attach_defaults", (PyCFunction)_wrap_gtk_table_attach_defaults, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_row_spacing", (PyCFunction)_wrap_gtk_table_set_row_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_row_spacing", (PyCFunction)_wrap_gtk_table_get_row_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_col_spacing", (PyCFunction)_wrap_gtk_table_set_col_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_col_spacing", (PyCFunction)_wrap_gtk_table_get_col_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_row_spacings", (PyCFunction)_wrap_gtk_table_set_row_spacings, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_default_row_spacing", (PyCFunction)_wrap_gtk_table_get_default_row_spacing, METH_NOARGS,
      NULL },
    { "set_col_spacings", (PyCFunction)_wrap_gtk_table_set_col_spacings, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_default_col_spacing", (PyCFunction)_wrap_gtk_table_get_default_col_spacing, METH_NOARGS,
      NULL },
    { "set_homogeneous", (PyCFunction)_wrap_gtk_table_set_homogeneous, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_homogeneous", (PyCFunction)_wrap_gtk_table_get_homogeneous, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Table",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_table_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTearoffMenuItem ----------- */

static int
_wrap_gtk_tearoff_menu_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.TearoffMenuItem.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.TearoffMenuItem object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkTearoffMenuItem_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TearoffMenuItem",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tearoff_menu_item_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTextBuffer ----------- */

static int
_wrap_gtk_text_buffer_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"table", NULL };
    char *prop_names[] = {"tag_table", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.TextBuffer.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.TextBuffer object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_text_buffer_get_line_count(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_buffer_get_line_count(GTK_TEXT_BUFFER(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_buffer_get_char_count(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_buffer_get_char_count(GTK_TEXT_BUFFER(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_buffer_get_tag_table(PyGObject *self)
{
    GtkTextTagTable *ret;

    
    ret = gtk_text_buffer_get_tag_table(GTK_TEXT_BUFFER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 763 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *text;
    static char *kwlist[] = { "text", "len", NULL };
    Py_ssize_t len;
    int oldlen = -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s#|i:GtkTextBuffer.set_text", kwlist,
                                     &text, &len, &oldlen)) {
        return NULL;
    }

    if (oldlen > 0) {
	if (oldlen > len) {
	    PyErr_SetString(PyExc_ValueError, "len greater than text length");
	    return NULL;
	}
	len = oldlen;
    }
    
    gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->obj), text, len);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 82645 "gtk.c"


#line 807 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_insert(PyGObject *self, PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "text", "len", NULL };
    PyObject *py_iter;
    char *text;
    Py_ssize_t len;
    int oldlen = -1;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Os#|i:GtkTextBuffer.insert",
                                     kwlist, &py_iter, &text, &len, &oldlen)) {
        return NULL;
    }

    if (oldlen > 0) {
	if (oldlen > len) {
	    PyErr_SetString(PyExc_ValueError, "len greater than text length");
	    return NULL;
	}
	len = oldlen;
    }

    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER)) {
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    } else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text, len);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 82683 "gtk.c"


#line 843 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_insert_at_cursor(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "text", "len", NULL };
    char *text;
    Py_ssize_t len;
    int oldlen = -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s#|i:GtkTextBuffer.insert_at_cursor",
                                     kwlist, &text, &len, &oldlen)) {
        return NULL;
    }

    if (oldlen > 0) {
	if (oldlen > len) {
	    PyErr_SetString(PyExc_ValueError, "len greater than text length");
	    return NULL;
	}
	len = oldlen;
    }
    
    gtk_text_buffer_insert_at_cursor(GTK_TEXT_BUFFER(self->obj), text, len);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 82714 "gtk.c"


#line 872 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_insert_interactive(PyGObject *self, PyObject *args,
                                         PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "text", "default_editable", "len", NULL };
    PyObject *py_iter;
    char *text;
    int default_editable, ret, oldlen = -1;
    Py_ssize_t len;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Os#i|i:GtkTextBuffer.insert_interactive",
                                     kwlist, &py_iter, &text, &len,
                                     &default_editable, &oldlen)) {
        return NULL;
    }

    if (oldlen > 0) {
	if (oldlen > len) {
	    PyErr_SetString(PyExc_ValueError, "len greater than text length");
	    return NULL;
	}
	if (oldlen > len) {
	    PyErr_SetString(PyExc_ValueError, "len greater than text length");
	    return NULL;
	}
	len = oldlen;
    }

    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER)) {
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    } else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    ret = gtk_text_buffer_insert_interactive(GTK_TEXT_BUFFER(self->obj), iter,
                                             text, len, default_editable);
    return PyBool_FromLong(ret);
}
#line 82758 "gtk.c"


#line 914 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_insert_interactive_at_cursor(PyGObject *self, PyObject *args,
                                                   PyObject *kwargs)
{
    static char *kwlist[] = { "text", "default_editable", "len", NULL };
    char *text;
    Py_ssize_t len;
    int default_editable, ret, oldlen = -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s#i|i:GtkTextBuffer.insert_interactive_at_cursor",
                                     kwlist, &text, &len, &default_editable, &oldlen)) {
        return NULL;
    }

    if (oldlen > 0) {
	len = oldlen;
    }

    ret = gtk_text_buffer_insert_interactive_at_cursor(GTK_TEXT_BUFFER(self->obj),
                                                       text, len, default_editable);
    return PyBool_FromLong(ret);
}
#line 82785 "gtk.c"


static PyObject *
_wrap_gtk_text_buffer_insert_range(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "start", "end", NULL };
    PyObject *py_iter, *py_start, *py_end;
    GtkTextIter *iter = NULL, *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOO:Gtk.TextBuffer.insert_range", kwlist, &py_iter, &py_start, &py_end))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_insert_range(GTK_TEXT_BUFFER(self->obj), iter, start, end);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_insert_range_interactive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "start", "end", "default_editable", NULL };
    PyObject *py_iter, *py_start, *py_end;
    int default_editable, ret;
    GtkTextIter *iter = NULL, *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOOi:Gtk.TextBuffer.insert_range_interactive", kwlist, &py_iter, &py_start, &py_end, &default_editable))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_buffer_insert_range_interactive(GTK_TEXT_BUFFER(self->obj), iter, start, end, default_editable);
    
    return PyBool_FromLong(ret);

}

#line 471 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_insert_with_tags(PyGObject *self, PyObject *args)
{
    PyObject *first, *py_iter;
    gint len, i, start_offset;
    Py_ssize_t text_len;
    gchar *text;
    GtkTextIter *iter, start;

    len = PyTuple_Size(args);
    if (len < 2) {
        PyErr_SetString(PyExc_TypeError,
            "GtkTextBuffer.insert_with_tags requires at least 2 arguments");
        return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "Os#:GtkTextBuffer.insert_with_tags",
                          &py_iter, &text, &text_len)) {
        Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER)) {
        PyErr_SetString(PyExc_TypeError, "iter must be a GtkTextIter");
        return NULL;
    }
    iter = pyg_boxed_get(py_iter, GtkTextIter);

    /* check types */
    for (i = 2; i < len; i++) {
        PyObject *item = PyTuple_GetItem(args, i);

        if (!pygobject_check(item, &PyGtkTextTag_Type)) {
            PyErr_SetString(PyExc_TypeError,
                            "additional argument must be a GtkTextTag");
            return NULL;
        }
    }

    start_offset = gtk_text_iter_get_offset(iter);
    gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text, text_len);
    gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),
                                       &start, start_offset);

    for (i = 2; i < len; i++) {
        PyObject *item = PyTuple_GetItem(args, i);
        GtkTextTag *tag = GTK_TEXT_TAG(pygobject_get(item));

        gtk_text_buffer_apply_tag(GTK_TEXT_BUFFER(self->obj), tag,&start,iter);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 82912 "gtk.c"


#line 527 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_insert_with_tags_by_name(PyGObject *self, PyObject *args)
{
    PyObject *first, *py_iter;
    gint len, i, start_offset;
    Py_ssize_t text_len;
    gchar *text;
    GtkTextIter *iter, start;

    len = PyTuple_Size(args);
    if (len < 2) {
        PyErr_SetString(PyExc_TypeError,
                        "GtkTextBuffer.insert_with_tags_by_name "
                        "requires at least 2 arguments");
        return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "Os#:GtkTextBuffer.insert_with_tags_by_name",
                          &py_iter, &text, &text_len)) {
        Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER)) {
        PyErr_SetString(PyExc_TypeError, "iter must be a GtkTextIter");
        return NULL;
    }
    iter = pyg_boxed_get(py_iter, GtkTextIter);

    /* check types */
    for (i = 2; i < len; i++) {
        PyObject *item = PyTuple_GetItem(args, i);

        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "additional argument must be a string");
            return NULL;
        }
    }

    start_offset = gtk_text_iter_get_offset(iter);
    gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text, text_len);
    gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),
                                       &start, start_offset);

    for (i = 2; i < len; i++) {
        PyObject *item = PyTuple_GetItem(args, i);
        const gchar *tagname = PyString_AsString(item);

        gtk_text_buffer_apply_tag_by_name(GTK_TEXT_BUFFER(self->obj),
                                          tagname, &start, iter);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 82972 "gtk.c"


static PyObject *
_wrap_gtk_text_buffer_delete(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start", "end", NULL };
    PyObject *py_start, *py_end;
    GtkTextIter *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TextBuffer.delete", kwlist, &py_start, &py_end))
        return NULL;
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_delete(GTK_TEXT_BUFFER(self->obj), start, end);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_delete_interactive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_iter", "end_iter", "default_editable", NULL };
    PyObject *py_start_iter, *py_end_iter;
    int default_editable, ret;
    GtkTextIter *start_iter = NULL, *end_iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOi:Gtk.TextBuffer.delete_interactive", kwlist, &py_start_iter, &py_end_iter, &default_editable))
        return NULL;
    if (pyg_boxed_check(py_start_iter, GTK_TYPE_TEXT_ITER))
        start_iter = pyg_boxed_get(py_start_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start_iter should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end_iter, GTK_TYPE_TEXT_ITER))
        end_iter = pyg_boxed_get(py_end_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end_iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_buffer_delete_interactive(GTK_TEXT_BUFFER(self->obj), start_iter, end_iter, default_editable);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_buffer_get_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start", "end", "include_hidden_chars", NULL };
    PyObject *py_start, *py_end;
    int include_hidden_chars = TRUE;
    gchar *ret;
    GtkTextIter *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO|i:Gtk.TextBuffer.get_text", kwlist, &py_start, &py_end, &include_hidden_chars))
        return NULL;
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_buffer_get_text(GTK_TEXT_BUFFER(self->obj), start, end, include_hidden_chars);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_get_slice(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start", "end", "include_hidden_chars", NULL };
    PyObject *py_start, *py_end;
    int include_hidden_chars = TRUE;
    gchar *ret;
    GtkTextIter *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO|i:Gtk.TextBuffer.get_slice", kwlist, &py_start, &py_end, &include_hidden_chars))
        return NULL;
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_buffer_get_slice(GTK_TEXT_BUFFER(self->obj), start, end, include_hidden_chars);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_insert_pixbuf(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "pixbuf", NULL };
    PyObject *py_iter;
    PyGObject *pixbuf;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO!:Gtk.TextBuffer.insert_pixbuf", kwlist, &py_iter, &PyGdkPixbuf_Type, &pixbuf))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_insert_pixbuf(GTK_TEXT_BUFFER(self->obj), iter, GDK_PIXBUF(pixbuf->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_insert_child_anchor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "anchor", NULL };
    PyObject *py_iter;
    PyGObject *anchor;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO!:Gtk.TextBuffer.insert_child_anchor", kwlist, &py_iter, &PyGtkTextChildAnchor_Type, &anchor))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_insert_child_anchor(GTK_TEXT_BUFFER(self->obj), iter, GTK_TEXT_CHILD_ANCHOR(anchor->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_create_child_anchor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTextChildAnchor *ret;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextBuffer.create_child_anchor", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_buffer_create_child_anchor(GTK_TEXT_BUFFER(self->obj), iter);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_text_buffer_create_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mark_name", "where", "left_gravity", NULL };
    char *mark_name;
    PyObject *py_where;
    int left_gravity = FALSE;
    GtkTextIter *where = NULL;
    GtkTextMark *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"zO|i:Gtk.TextBuffer.create_mark", kwlist, &mark_name, &py_where, &left_gravity))
        return NULL;
    if (pyg_boxed_check(py_where, GTK_TYPE_TEXT_ITER))
        where = pyg_boxed_get(py_where, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "where should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_buffer_create_mark(GTK_TEXT_BUFFER(self->obj), mark_name, where, left_gravity);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_text_buffer_move_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mark", "where", NULL };
    PyGObject *mark;
    PyObject *py_where;
    GtkTextIter *where = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TextBuffer.move_mark", kwlist, &PyGtkTextMark_Type, &mark, &py_where))
        return NULL;
    if (pyg_boxed_check(py_where, GTK_TYPE_TEXT_ITER))
        where = pyg_boxed_get(py_where, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "where should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_move_mark(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_MARK(mark->obj), where);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_delete_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mark", NULL };
    PyGObject *mark;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextBuffer.delete_mark", kwlist, &PyGtkTextMark_Type, &mark))
        return NULL;
    
    gtk_text_buffer_delete_mark(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_MARK(mark->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_get_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    GtkTextMark *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.TextBuffer.get_mark", kwlist, &name))
        return NULL;
    
    ret = gtk_text_buffer_get_mark(GTK_TEXT_BUFFER(self->obj), name);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_text_buffer_move_mark_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "where", NULL };
    char *name;
    PyObject *py_where;
    GtkTextIter *where = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO:Gtk.TextBuffer.move_mark_by_name", kwlist, &name, &py_where))
        return NULL;
    if (pyg_boxed_check(py_where, GTK_TYPE_TEXT_ITER))
        where = pyg_boxed_get(py_where, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "where should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_move_mark_by_name(GTK_TEXT_BUFFER(self->obj), name, where);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_delete_mark_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.TextBuffer.delete_mark_by_name", kwlist, &name))
        return NULL;
    
    gtk_text_buffer_delete_mark_by_name(GTK_TEXT_BUFFER(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_get_insert(PyGObject *self)
{
    GtkTextMark *ret;

    
    ret = gtk_text_buffer_get_insert(GTK_TEXT_BUFFER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_text_buffer_get_selection_bound(PyGObject *self)
{
    GtkTextMark *ret;

    
    ret = gtk_text_buffer_get_selection_bound(GTK_TEXT_BUFFER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_text_buffer_place_cursor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "where", NULL };
    PyObject *py_where;
    GtkTextIter *where = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextBuffer.place_cursor", kwlist, &py_where))
        return NULL;
    if (pyg_boxed_check(py_where, GTK_TYPE_TEXT_ITER))
        where = pyg_boxed_get(py_where, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "where should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_place_cursor(GTK_TEXT_BUFFER(self->obj), where);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_select_range(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "ins", "bound", NULL };
    PyObject *py_ins, *py_bound;
    GtkTextIter *ins = NULL, *bound = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TextBuffer.select_range", kwlist, &py_ins, &py_bound))
        return NULL;
    if (pyg_boxed_check(py_ins, GTK_TYPE_TEXT_ITER))
        ins = pyg_boxed_get(py_ins, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "ins should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_bound, GTK_TYPE_TEXT_ITER))
        bound = pyg_boxed_get(py_bound, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "bound should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_select_range(GTK_TEXT_BUFFER(self->obj), ins, bound);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_apply_tag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag", "start", "end", NULL };
    PyGObject *tag;
    PyObject *py_start, *py_end;
    GtkTextIter *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TextBuffer.apply_tag", kwlist, &PyGtkTextTag_Type, &tag, &py_start, &py_end))
        return NULL;
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_apply_tag(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_TAG(tag->obj), start, end);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_remove_tag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag", "start", "end", NULL };
    PyGObject *tag;
    PyObject *py_start, *py_end;
    GtkTextIter *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TextBuffer.remove_tag", kwlist, &PyGtkTextTag_Type, &tag, &py_start, &py_end))
        return NULL;
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_remove_tag(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_TAG(tag->obj), start, end);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_apply_tag_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "start", "end", NULL };
    char *name;
    PyObject *py_start, *py_end;
    GtkTextIter *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sOO:Gtk.TextBuffer.apply_tag_by_name", kwlist, &name, &py_start, &py_end))
        return NULL;
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_apply_tag_by_name(GTK_TEXT_BUFFER(self->obj), name, start, end);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_remove_tag_by_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "start", "end", NULL };
    char *name;
    PyObject *py_start, *py_end;
    GtkTextIter *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sOO:Gtk.TextBuffer.remove_tag_by_name", kwlist, &name, &py_start, &py_end))
        return NULL;
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_remove_tag_by_name(GTK_TEXT_BUFFER(self->obj), name, start, end);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_remove_all_tags(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start", "end", NULL };
    PyObject *py_start, *py_end;
    GtkTextIter *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TextBuffer.remove_all_tags", kwlist, &py_start, &py_end))
        return NULL;
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_remove_all_tags(GTK_TEXT_BUFFER(self->obj), start, end);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 585 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_create_tag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    gchar *tag_name = NULL;
    GtkTextTag *tag;
    GtkTextTagTable *table;

    if (!PyArg_ParseTuple(args, "|z:GtkTextBuffer.create_tag",
                          &tag_name)) {
        return NULL;
    }

    table = GTK_TEXT_TAG_TABLE(GTK_TEXT_BUFFER(self->obj)->tag_table);
    if (tag_name && table && g_hash_table_lookup(table->hash, tag_name)) {
        gchar buf[512];
        g_snprintf(buf, sizeof(buf),
                   "A tag named '%s' is already in the tag table",
                   tag_name);

        PyErr_SetString(PyExc_TypeError, buf);
        return NULL;
    }

    tag = gtk_text_buffer_create_tag(GTK_TEXT_BUFFER(self->obj),
                                     tag_name, NULL);

    /* set tag properties if any */
    if (kwargs) {
        Py_ssize_t i = 0;
        PyObject *prop, *val;

        while (PyDict_Next(kwargs, &i, &prop, &val)) {
            GParamSpec *pspec;
            GValue value = { 0, };
            gchar *prop_str = PyString_AsString(prop);

            pspec = g_object_class_find_property (G_OBJECT_GET_CLASS(tag),
                                                  prop_str);
            if (!pspec) {
                PyErr_Format(PyExc_TypeError,
                             "unsupported tag property `%s'",
                             prop_str);
                /* XXX: Free tag? */
                return NULL;
            }

            g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
            if (pyg_value_from_pyobject(&value, val) < 0) {
                PyErr_Format(PyExc_TypeError,
                     "could not convert tag property '%s' to correct type",
                             prop_str);
                /* XXX: Free tag? */
                return NULL;
            }
            g_object_set_property((GObject *)tag, prop_str, &value);
            g_value_unset(&value);
       }
    }
    return pygobject_new((GObject *)tag);
}
#line 83567 "gtk.c"


#line 647 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line_offset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", "char_offset", NULL };
    GtkTextIter iter;
    int line_number, char_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkTextBuffer.get_iter_at_line_offset", kwlist, &line_number, &char_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_line_offset(GTK_TEXT_BUFFER(self->obj), &iter,
                                            line_number, char_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
#line 83585 "gtk.c"


#line 663 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line_index(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", "byte_offset", NULL };
    GtkTextIter iter;
    int line_number, byte_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkTextBuffer.get_iter_at_line_index", kwlist, &line_number, &byte_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_line_index(GTK_TEXT_BUFFER(self->obj), &iter,
                                           line_number, byte_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
#line 83603 "gtk.c"


#line 679 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_offset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    int char_offset;
    static char *kwlist[] = { "char_offset", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkTextBuffer.get_iter_at_offset", kwlist, &char_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),
                                       &iter, char_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
#line 83621 "gtk.c"


#line 695 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    int line_number;
    static char *kwlist[] = { "line_number", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkTextBuffer.get_iter_at_line", kwlist, &line_number))
        return NULL;

    gtk_text_buffer_get_iter_at_line(GTK_TEXT_BUFFER(self->obj),
                                     &iter, line_number);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
#line 83639 "gtk.c"


#line 711 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_start_iter(PyGObject *self)
{
    GtkTextIter iter;

    gtk_text_buffer_get_start_iter(GTK_TEXT_BUFFER(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
#line 83651 "gtk.c"


#line 721 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_end_iter(PyGObject *self)
{
    GtkTextIter iter;

    gtk_text_buffer_get_end_iter(GTK_TEXT_BUFFER(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
#line 83663 "gtk.c"


#line 731 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_bounds(PyGObject *self)
{
    GtkTextIter start, end;

    gtk_text_buffer_get_bounds(GTK_TEXT_BUFFER(self->obj), &start, &end);
    return Py_BuildValue("(NN)",
                         pyg_boxed_new(GTK_TYPE_TEXT_ITER, &start, TRUE, TRUE),
                         pyg_boxed_new(GTK_TYPE_TEXT_ITER, &end, TRUE, TRUE));
}
#line 83677 "gtk.c"


#line 743 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyGObject *mark;
    static char *kwlist[] = { "mark", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextBuffer.get_iter_at_mark", kwlist, &mark))
        return NULL;
    if (!pygobject_check(mark, &PyGtkTextMark_Type)) {
        PyErr_SetString(PyExc_TypeError, "mark should be a GtkTextMark");
        return NULL;
    }

    gtk_text_buffer_get_iter_at_mark(GTK_TEXT_BUFFER(self->obj), &iter,
                                     GTK_TEXT_MARK(mark->obj));
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
#line 83699 "gtk.c"


#line 939 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_child_anchor(PyGObject *self, PyObject *args,
					       PyObject *kwargs)
{
    static char *kwlist[] = { "anchor", NULL };
    PyGObject *anchor;
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkTextBuffer.get_iter_at_child_anchor", kwlist, &PyGtkTextChildAnchor_Type, &anchor))
        return NULL;

    gtk_text_buffer_get_iter_at_child_anchor(GTK_TEXT_BUFFER(self->obj),
					     &iter,
					     GTK_TEXT_CHILD_ANCHOR(anchor->obj));
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
#line 83719 "gtk.c"


static PyObject *
_wrap_gtk_text_buffer_get_modified(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_buffer_get_modified(GTK_TEXT_BUFFER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_buffer_set_modified(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextBuffer.set_modified", kwlist, &setting))
        return NULL;
    
    gtk_text_buffer_set_modified(GTK_TEXT_BUFFER(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_add_selection_clipboard(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "clipboard", NULL };
    PyGObject *clipboard;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextBuffer.add_selection_clipboard", kwlist, &PyGtkClipboard_Type, &clipboard))
        return NULL;
    
    gtk_text_buffer_add_selection_clipboard(GTK_TEXT_BUFFER(self->obj), GTK_CLIPBOARD(clipboard->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_remove_selection_clipboard(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "clipboard", NULL };
    PyGObject *clipboard;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextBuffer.remove_selection_clipboard", kwlist, &PyGtkClipboard_Type, &clipboard))
        return NULL;
    
    gtk_text_buffer_remove_selection_clipboard(GTK_TEXT_BUFFER(self->obj), GTK_CLIPBOARD(clipboard->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_cut_clipboard(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "clipboard", "default_editable", NULL };
    PyGObject *clipboard;
    int default_editable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.TextBuffer.cut_clipboard", kwlist, &PyGtkClipboard_Type, &clipboard, &default_editable))
        return NULL;
    
    gtk_text_buffer_cut_clipboard(GTK_TEXT_BUFFER(self->obj), GTK_CLIPBOARD(clipboard->obj), default_editable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_copy_clipboard(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "clipboard", NULL };
    PyGObject *clipboard;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextBuffer.copy_clipboard", kwlist, &PyGtkClipboard_Type, &clipboard))
        return NULL;
    
    gtk_text_buffer_copy_clipboard(GTK_TEXT_BUFFER(self->obj), GTK_CLIPBOARD(clipboard->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_paste_clipboard(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "clipboard", "override_location", "default_editable", NULL };
    PyGObject *clipboard;
    PyObject *py_override_location = Py_None;
    int default_editable;
    GtkTextIter *override_location = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oi:Gtk.TextBuffer.paste_clipboard", kwlist, &PyGtkClipboard_Type, &clipboard, &py_override_location, &default_editable))
        return NULL;
    if (pyg_boxed_check(py_override_location, GTK_TYPE_TEXT_ITER))
        override_location = pyg_boxed_get(py_override_location, GtkTextIter);
    else if (py_override_location != Py_None) {
        PyErr_SetString(PyExc_TypeError, "override_location should be a GtkTextIter or None");
        return NULL;
    }
    
    gtk_text_buffer_paste_clipboard(GTK_TEXT_BUFFER(self->obj), GTK_CLIPBOARD(clipboard->obj), override_location, default_editable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 791 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_selection_bounds(PyGObject *self, PyObject *args)
{
    GtkTextIter start, end;

    if (!gtk_text_buffer_get_selection_bounds(GTK_TEXT_BUFFER(self->obj),
                                              &start, &end)) {
        return Py_BuildValue ("()");
    }

    return Py_BuildValue("(NN)",
                         pyg_boxed_new(GTK_TYPE_TEXT_ITER, &start, TRUE, TRUE),
                         pyg_boxed_new(GTK_TYPE_TEXT_ITER, &end, TRUE, TRUE));
}
#line 83849 "gtk.c"


static PyObject *
_wrap_gtk_text_buffer_delete_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "interactive", "default_editable", NULL };
    int interactive, default_editable, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.TextBuffer.delete_selection", kwlist, &interactive, &default_editable))
        return NULL;
    
    ret = gtk_text_buffer_delete_selection(GTK_TEXT_BUFFER(self->obj), interactive, default_editable);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_buffer_begin_user_action(PyGObject *self)
{
    
    gtk_text_buffer_begin_user_action(GTK_TEXT_BUFFER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_end_user_action(PyGObject *self)
{
    
    gtk_text_buffer_end_user_action(GTK_TEXT_BUFFER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_backspace(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "interactive", "default_editable", NULL };
    PyObject *py_iter;
    int interactive, default_editable, ret;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oii:Gtk.TextBuffer.backspace", kwlist, &py_iter, &interactive, &default_editable))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_buffer_backspace(GTK_TEXT_BUFFER(self->obj), iter, interactive, default_editable);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_buffer_get_has_selection(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_buffer_get_has_selection(GTK_TEXT_BUFFER(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 1302 "gtktextview.override"
static PyObject*
_wrap_gtk_text_buffer_get_copy_target_list(PyGObject *self)
{
    GtkTargetList *targets;
    PyObject *py_targets;

    targets = gtk_text_buffer_get_copy_target_list(GTK_TEXT_BUFFER(self->obj));
    py_targets = pygtk_target_list_to_list(targets);
    gtk_target_list_unref(targets);
    return py_targets;
}
#line 83934 "gtk.c"


#line 1315 "gtktextview.override"
static PyObject*
_wrap_gtk_text_buffer_get_paste_target_list(PyGObject *self)
{
    GtkTargetList *targets;
    PyObject *py_targets;

    targets = gtk_text_buffer_get_paste_target_list(GTK_TEXT_BUFFER(self->obj));
    py_targets = pygtk_target_list_to_list(targets);
    gtk_target_list_unref(targets);
    return py_targets;
}
#line 83949 "gtk.c"


#line 1501 "gtktextview.override"
static guint8*
pygtk_text_buffer_register_serialize_format_cb(GtkTextBuffer *register_buf,
                                               GtkTextBuffer *content_buf,
                                               const GtkTextIter *start,
                                               const GtkTextIter *end,
                                               gsize *length,
                                               gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_register_buf, *py_content_buf, *py_start, *py_end;
    PyObject *retobj;
    guint8 *ret;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_register_buf = pygobject_new((GObject*)register_buf);
    py_content_buf = pygobject_new((GObject*)content_buf);
    py_start = pyg_boxed_new(GTK_TYPE_TEXT_ITER, (gpointer)start, TRUE, TRUE);
    py_end = pyg_boxed_new(GTK_TYPE_TEXT_ITER, (gpointer)end, TRUE, TRUE);
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNNNO)",
                                     py_register_buf, py_content_buf,
                                     py_start, py_end,
                                     cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NNNN)", py_register_buf,
                                     py_content_buf, py_start, py_end);
    }

    if (retobj != NULL) {
        PyString_AsStringAndSize(retobj, (gchar**)&ret, (Py_ssize_t*) length);
        ret = g_memdup(ret, *length);
        Py_DECREF(retobj);
    } else {
        PyErr_Print();
        ret = NULL;
    }

    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_text_buffer_register_serialize_format(PyGObject *self,
                                                PyObject *args,
                                                PyObject *kwargs)
{
    static char *kwlist[] = { "mime_type", "function", "user_data",
                              NULL };
    PyObject *pyfunc, *pyarg = NULL, *ret;
    PyGtkCustomNotify *cunote;
    const gchar *mimetype;
    GdkAtom atom;
    gchar *name;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "sO|O:GtkTextBuffer.register_serialize_format",
                                     kwlist, &mimetype, &pyfunc, &pyarg))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "function must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
 
    atom = gtk_text_buffer_register_serialize_format(
        GTK_TEXT_BUFFER(self->obj), mimetype,
        pygtk_text_buffer_register_serialize_format_cb,
        cunote, pygtk_custom_destroy_notify);

    name = gdk_atom_name(atom);
    ret = PyString_FromString(name);
    g_free(name);
    return ret;
}
#line 84036 "gtk.c"


static PyObject *
_wrap_gtk_text_buffer_register_serialize_tagset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tagset_name", NULL };
    char *tagset_name = NULL;
    PyObject * py_ret;
    gchar * name;
    GdkAtom ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|z:Gtk.TextBuffer.register_serialize_tagset", kwlist, &tagset_name))
        return NULL;
    
    ret = gtk_text_buffer_register_serialize_tagset(GTK_TEXT_BUFFER(self->obj), tagset_name);
    
    name = gdk_atom_name(ret);
    py_ret = PyString_FromString(name);
    g_free(name);
    return py_ret;
}

#line 1417 "gtktextview.override"
static gint
pygtk_text_buffer_register_deserialize_format_cb(GtkTextBuffer *register_buf,
                                                 GtkTextBuffer *content_buf,
                                                 GtkTextIter *iter,
                                                 const guint8 *data,
                                                 gsize length,
                                                 gboolean create_tags,
                                                 gpointer user_data,
                                                 GError **error)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_register_buf, *py_content_buf, *py_iter, *py_data, *retobj;
    gboolean ret = FALSE;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_register_buf = pygobject_new((GObject*)register_buf);
    py_content_buf = pygobject_new((GObject*)content_buf);
    py_iter = pyg_boxed_new(GTK_TYPE_TEXT_ITER, iter, TRUE, TRUE);
    py_data = PyString_FromStringAndSize((char *) data, length);
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNNNiO)",
                                     py_register_buf, py_content_buf,
                                     py_iter, py_data, create_tags,
                                     cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NNNNi)", py_register_buf,
                                     py_content_buf, py_iter, py_data,
                                     create_tags);
    }

    if (retobj != NULL) {
        ret = PyInt_AsLong(retobj);
        Py_DECREF(retobj);
    } else {
        PyErr_Print();
    }

    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_text_buffer_register_deserialize_format(PyGObject *self,
                                                  PyObject *args,
                                                  PyObject *kwargs)
{
    static char *kwlist[] = { "mime_type", "function", "user_data", NULL };
    PyObject *pyfunc, *pyarg = NULL, *ret;
    PyGtkCustomNotify *cunote;
    const gchar *mimetype;
    GdkAtom atom;
    gchar *name;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "sO|O:GtkTextBuffer.register_deserialize_format",
                                     kwlist, &mimetype, &pyfunc, &pyarg))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "function must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
 
    atom = gtk_text_buffer_register_deserialize_format(
        GTK_TEXT_BUFFER(self->obj), mimetype,
        pygtk_text_buffer_register_deserialize_format_cb, cunote,
        pygtk_custom_destroy_notify);

    name = gdk_atom_name(atom);
    ret = PyString_FromString(name);
    g_free(name);
    return ret;
}
#line 84142 "gtk.c"


static PyObject *
_wrap_gtk_text_buffer_register_deserialize_tagset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tagset_name", NULL };
    char *tagset_name = NULL;
    PyObject * py_ret;
    gchar * name;
    GdkAtom ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|z:Gtk.TextBuffer.register_deserialize_tagset", kwlist, &tagset_name))
        return NULL;
    
    ret = gtk_text_buffer_register_deserialize_tagset(GTK_TEXT_BUFFER(self->obj), tagset_name);
    
    name = gdk_atom_name(ret);
    py_ret = PyString_FromString(name);
    g_free(name);
    return py_ret;
}

static PyObject *
_wrap_gtk_text_buffer_unregister_serialize_format(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "format", NULL };
    PyObject *py_format = NULL;
    GdkAtom format;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextBuffer.unregister_serialize_format", kwlist, &py_format))
        return NULL;
    format = pygdk_atom_from_pyobject(py_format);
    if (PyErr_Occurred())
        return NULL;
    
    gtk_text_buffer_unregister_serialize_format(GTK_TEXT_BUFFER(self->obj), format);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_unregister_deserialize_format(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "format", NULL };
    PyObject *py_format = NULL;
    GdkAtom format;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextBuffer.unregister_deserialize_format", kwlist, &py_format))
        return NULL;
    format = pygdk_atom_from_pyobject(py_format);
    if (PyErr_Occurred())
        return NULL;
    
    gtk_text_buffer_unregister_deserialize_format(GTK_TEXT_BUFFER(self->obj), format);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_deserialize_set_can_create_tags(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "format", "can_create_tags", NULL };
    PyObject *py_format = NULL;
    int can_create_tags;
    GdkAtom format;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.TextBuffer.deserialize_set_can_create_tags", kwlist, &py_format, &can_create_tags))
        return NULL;
    format = pygdk_atom_from_pyobject(py_format);
    if (PyErr_Occurred())
        return NULL;
    
    gtk_text_buffer_deserialize_set_can_create_tags(GTK_TEXT_BUFFER(self->obj), format, can_create_tags);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_buffer_deserialize_get_can_create_tags(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "format", NULL };
    PyObject *py_format = NULL;
    int ret;
    GdkAtom format;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextBuffer.deserialize_get_can_create_tags", kwlist, &py_format))
        return NULL;
    format = pygdk_atom_from_pyobject(py_format);
    if (PyErr_Occurred())
        return NULL;
    
    ret = gtk_text_buffer_deserialize_get_can_create_tags(GTK_TEXT_BUFFER(self->obj), format);
    
    return PyBool_FromLong(ret);

}

#line 1607 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_serialize_formats(PyGObject *self)
{
    GdkAtom *formats;
    gint n_formats, i;
    PyObject *py_formats;

    formats = gtk_text_buffer_get_serialize_formats(
        GTK_TEXT_BUFFER(self->obj), &n_formats);

    py_formats = PyList_New(n_formats);
    for (i = 0; i < n_formats; i++) {
        gchar *name = gdk_atom_name(formats[i]);
        PyList_SetItem(py_formats, i, PyString_FromString(name));
        g_free(name);
    }
    g_free(formats);
    return py_formats;
}
#line 84263 "gtk.c"


#line 1586 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_get_deserialize_formats(PyGObject *self)
{
    GdkAtom *formats;
    gint n_formats, i;
    PyObject *py_formats;

    formats = gtk_text_buffer_get_deserialize_formats(
        GTK_TEXT_BUFFER(self->obj), &n_formats);

    py_formats = PyList_New(n_formats);
    for (i = 0; i < n_formats; i++) {
        gchar *name = gdk_atom_name(formats[i]);
        PyList_SetItem(py_formats, i, PyString_FromString(name));
        g_free(name);
    }
    g_free(formats);
    return py_formats;
}
#line 84286 "gtk.c"


#line 1370 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_serialize(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "content_buffer", "format", "start", "end",
                              NULL };
    PyObject *py_format = NULL, *py_start, *py_end;
    GdkAtom format;
    gsize length;
    guint8 *ret;
    PyGObject *content_buffer;
    GtkTextIter *start = NULL, *end = NULL;
    PyObject *py_retval;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!OOO:GtkTextBuffer.serialize",
                                     kwlist, &PyGtkTextBuffer_Type,
                                     &content_buffer, &py_format, &py_start,
                                     &py_end))
        return NULL;

    format = pygdk_atom_from_pyobject(py_format);
    if (PyErr_Occurred())
        return NULL;

    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }

    ret = gtk_text_buffer_serialize(GTK_TEXT_BUFFER(self->obj),
                                      GTK_TEXT_BUFFER(content_buffer->obj),
                                      format, start, end, &length);
    py_retval = PyString_FromStringAndSize((char *) ret, (Py_ssize_t) length);
    g_free(ret);
    return py_retval;
}
#line 84335 "gtk.c"


#line 1328 "gtktextview.override"
static PyObject *
_wrap_gtk_text_buffer_deserialize(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "content_buffer", "format", "iter", "data",
                              NULL };
    Py_ssize_t length;
    PyObject *py_format = NULL, *py_iter;
    GdkAtom format;
    GError *error = NULL;
    int ret;
    guint8 *data;
    PyGObject *content_buffer;
    GtkTextIter *iter = NULL;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!OOs#:GtkTextBuffer.deserialize",
                                     kwlist, &PyGtkTextBuffer_Type,
                                     &content_buffer, &py_format, &py_iter,
                                     &data, &length))
        return NULL;

    format = pygdk_atom_from_pyobject(py_format);
    if (PyErr_Occurred())
        return NULL;

    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }

    ret = gtk_text_buffer_deserialize(GTK_TEXT_BUFFER(self->obj),
                                      GTK_TEXT_BUFFER(content_buffer->obj),
                                      format, iter, data, length, &error);
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);
}
#line 84379 "gtk.c"


static PyObject *
_wrap_gtk_text_buffer_add_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mark", "where", NULL };
    PyGObject *mark;
    PyObject *py_where;
    GtkTextIter *where = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TextBuffer.add_mark", kwlist, &PyGtkTextMark_Type, &mark, &py_where))
        return NULL;
    if (pyg_boxed_check(py_where, GTK_TYPE_TEXT_ITER))
        where = pyg_boxed_get(py_where, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "where should be a GtkTextIter");
        return NULL;
    }
    
    gtk_text_buffer_add_mark(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_MARK(mark->obj), where);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_insert_text(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "pos", "text", "length", NULL };
    PyGObject *self;
    PyObject *py_pos;
    char *text;
    GtkTextIter *pos = NULL;
    int length;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Osi:Gtk.TextBuffer.insert_text", kwlist, &PyGtkTextBuffer_Type, &self, &py_pos, &text, &length))
        return NULL;
    if (pyg_boxed_check(py_pos, GTK_TYPE_TEXT_ITER))
        pos = pyg_boxed_get(py_pos, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "pos should be a GtkTextIter");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->insert_text)
        GTK_TEXT_BUFFER_CLASS(klass)->insert_text(GTK_TEXT_BUFFER(self->obj), pos, text, length);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.insert_text not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_insert_pixbuf(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "pos", "pixbuf", NULL };
    PyGObject *self, *pixbuf;
    PyObject *py_pos;
    GtkTextIter *pos = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO!:Gtk.TextBuffer.insert_pixbuf", kwlist, &PyGtkTextBuffer_Type, &self, &py_pos, &PyGdkPixbuf_Type, &pixbuf))
        return NULL;
    if (pyg_boxed_check(py_pos, GTK_TYPE_TEXT_ITER))
        pos = pyg_boxed_get(py_pos, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "pos should be a GtkTextIter");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->insert_pixbuf)
        GTK_TEXT_BUFFER_CLASS(klass)->insert_pixbuf(GTK_TEXT_BUFFER(self->obj), pos, GDK_PIXBUF(pixbuf->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.insert_pixbuf not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_insert_child_anchor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "pos", "anchor", NULL };
    PyGObject *self, *anchor;
    PyObject *py_pos;
    GtkTextIter *pos = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO!:Gtk.TextBuffer.insert_child_anchor", kwlist, &PyGtkTextBuffer_Type, &self, &py_pos, &PyGtkTextChildAnchor_Type, &anchor))
        return NULL;
    if (pyg_boxed_check(py_pos, GTK_TYPE_TEXT_ITER))
        pos = pyg_boxed_get(py_pos, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "pos should be a GtkTextIter");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->insert_child_anchor)
        GTK_TEXT_BUFFER_CLASS(klass)->insert_child_anchor(GTK_TEXT_BUFFER(self->obj), pos, GTK_TEXT_CHILD_ANCHOR(anchor->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.insert_child_anchor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_delete_range(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "start", "end", NULL };
    PyGObject *self;
    PyObject *py_start, *py_end;
    GtkTextIter *start = NULL, *end = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TextBuffer.delete_range", kwlist, &PyGtkTextBuffer_Type, &self, &py_start, &py_end))
        return NULL;
    if (pyg_boxed_check(py_start, GTK_TYPE_TEXT_ITER))
        start = pyg_boxed_get(py_start, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end, GTK_TYPE_TEXT_ITER))
        end = pyg_boxed_get(py_end, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end should be a GtkTextIter");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->delete_range)
        GTK_TEXT_BUFFER_CLASS(klass)->delete_range(GTK_TEXT_BUFFER(self->obj), start, end);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.delete_range not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextBuffer.changed", kwlist, &PyGtkTextBuffer_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->changed)
        GTK_TEXT_BUFFER_CLASS(klass)->changed(GTK_TEXT_BUFFER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_modified_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextBuffer.modified_changed", kwlist, &PyGtkTextBuffer_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->modified_changed)
        GTK_TEXT_BUFFER_CLASS(klass)->modified_changed(GTK_TEXT_BUFFER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.modified_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_mark_set(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "location", "mark", NULL };
    PyGObject *self, *mark;
    PyObject *py_location;
    GtkTextIter *location = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO!:Gtk.TextBuffer.mark_set", kwlist, &PyGtkTextBuffer_Type, &self, &py_location, &PyGtkTextMark_Type, &mark))
        return NULL;
    if (pyg_boxed_check(py_location, GTK_TYPE_TEXT_ITER))
        location = pyg_boxed_get(py_location, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "location should be a GtkTextIter");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->mark_set)
        GTK_TEXT_BUFFER_CLASS(klass)->mark_set(GTK_TEXT_BUFFER(self->obj), location, GTK_TEXT_MARK(mark->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.mark_set not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_mark_deleted(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "mark", NULL };
    PyGObject *self, *mark;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.TextBuffer.mark_deleted", kwlist, &PyGtkTextBuffer_Type, &self, &PyGtkTextMark_Type, &mark))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->mark_deleted)
        GTK_TEXT_BUFFER_CLASS(klass)->mark_deleted(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_MARK(mark->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.mark_deleted not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_apply_tag(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "tag", "start_char", "end_char", NULL };
    PyGObject *self, *tag;
    PyObject *py_start_char, *py_end_char;
    GtkTextIter *start_char = NULL, *end_char = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OO:Gtk.TextBuffer.apply_tag", kwlist, &PyGtkTextBuffer_Type, &self, &PyGtkTextTag_Type, &tag, &py_start_char, &py_end_char))
        return NULL;
    if (pyg_boxed_check(py_start_char, GTK_TYPE_TEXT_ITER))
        start_char = pyg_boxed_get(py_start_char, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start_char should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end_char, GTK_TYPE_TEXT_ITER))
        end_char = pyg_boxed_get(py_end_char, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end_char should be a GtkTextIter");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->apply_tag)
        GTK_TEXT_BUFFER_CLASS(klass)->apply_tag(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_TAG(tag->obj), start_char, end_char);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.apply_tag not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_remove_tag(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "tag", "start_char", "end_char", NULL };
    PyGObject *self, *tag;
    PyObject *py_start_char, *py_end_char;
    GtkTextIter *start_char = NULL, *end_char = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OO:Gtk.TextBuffer.remove_tag", kwlist, &PyGtkTextBuffer_Type, &self, &PyGtkTextTag_Type, &tag, &py_start_char, &py_end_char))
        return NULL;
    if (pyg_boxed_check(py_start_char, GTK_TYPE_TEXT_ITER))
        start_char = pyg_boxed_get(py_start_char, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "start_char should be a GtkTextIter");
        return NULL;
    }
    if (pyg_boxed_check(py_end_char, GTK_TYPE_TEXT_ITER))
        end_char = pyg_boxed_get(py_end_char, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "end_char should be a GtkTextIter");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->remove_tag)
        GTK_TEXT_BUFFER_CLASS(klass)->remove_tag(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_TAG(tag->obj), start_char, end_char);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.remove_tag not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_begin_user_action(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextBuffer.begin_user_action", kwlist, &PyGtkTextBuffer_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->begin_user_action)
        GTK_TEXT_BUFFER_CLASS(klass)->begin_user_action(GTK_TEXT_BUFFER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.begin_user_action not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextBuffer__do_end_user_action(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextBuffer.end_user_action", kwlist, &PyGtkTextBuffer_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_BUFFER_CLASS(klass)->end_user_action)
        GTK_TEXT_BUFFER_CLASS(klass)->end_user_action(GTK_TEXT_BUFFER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextBuffer.end_user_action not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTextBuffer_methods[] = {
    { "get_line_count", (PyCFunction)_wrap_gtk_text_buffer_get_line_count, METH_NOARGS,
      NULL },
    { "get_char_count", (PyCFunction)_wrap_gtk_text_buffer_get_char_count, METH_NOARGS,
      NULL },
    { "get_tag_table", (PyCFunction)_wrap_gtk_text_buffer_get_tag_table, METH_NOARGS,
      NULL },
    { "set_text", (PyCFunction)_wrap_gtk_text_buffer_set_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert", (PyCFunction)_wrap_gtk_text_buffer_insert, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_at_cursor", (PyCFunction)_wrap_gtk_text_buffer_insert_at_cursor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_interactive", (PyCFunction)_wrap_gtk_text_buffer_insert_interactive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_interactive_at_cursor", (PyCFunction)_wrap_gtk_text_buffer_insert_interactive_at_cursor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_range", (PyCFunction)_wrap_gtk_text_buffer_insert_range, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_range_interactive", (PyCFunction)_wrap_gtk_text_buffer_insert_range_interactive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_with_tags", (PyCFunction)_wrap_gtk_text_buffer_insert_with_tags, METH_VARARGS,
      NULL },
    { "insert_with_tags_by_name", (PyCFunction)_wrap_gtk_text_buffer_insert_with_tags_by_name, METH_VARARGS,
      NULL },
    { "delete", (PyCFunction)_wrap_gtk_text_buffer_delete, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "delete_interactive", (PyCFunction)_wrap_gtk_text_buffer_delete_interactive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_text", (PyCFunction)_wrap_gtk_text_buffer_get_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_slice", (PyCFunction)_wrap_gtk_text_buffer_get_slice, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_pixbuf", (PyCFunction)_wrap_gtk_text_buffer_insert_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_child_anchor", (PyCFunction)_wrap_gtk_text_buffer_insert_child_anchor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "create_child_anchor", (PyCFunction)_wrap_gtk_text_buffer_create_child_anchor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "create_mark", (PyCFunction)_wrap_gtk_text_buffer_create_mark, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move_mark", (PyCFunction)_wrap_gtk_text_buffer_move_mark, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "delete_mark", (PyCFunction)_wrap_gtk_text_buffer_delete_mark, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_mark", (PyCFunction)_wrap_gtk_text_buffer_get_mark, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move_mark_by_name", (PyCFunction)_wrap_gtk_text_buffer_move_mark_by_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "delete_mark_by_name", (PyCFunction)_wrap_gtk_text_buffer_delete_mark_by_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_insert", (PyCFunction)_wrap_gtk_text_buffer_get_insert, METH_NOARGS,
      NULL },
    { "get_selection_bound", (PyCFunction)_wrap_gtk_text_buffer_get_selection_bound, METH_NOARGS,
      NULL },
    { "place_cursor", (PyCFunction)_wrap_gtk_text_buffer_place_cursor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_range", (PyCFunction)_wrap_gtk_text_buffer_select_range, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "apply_tag", (PyCFunction)_wrap_gtk_text_buffer_apply_tag, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_tag", (PyCFunction)_wrap_gtk_text_buffer_remove_tag, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "apply_tag_by_name", (PyCFunction)_wrap_gtk_text_buffer_apply_tag_by_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_tag_by_name", (PyCFunction)_wrap_gtk_text_buffer_remove_tag_by_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_all_tags", (PyCFunction)_wrap_gtk_text_buffer_remove_all_tags, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "create_tag", (PyCFunction)_wrap_gtk_text_buffer_create_tag, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_iter_at_line_offset", (PyCFunction)_wrap_gtk_text_buffer_get_iter_at_line_offset, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_iter_at_line_index", (PyCFunction)_wrap_gtk_text_buffer_get_iter_at_line_index, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_iter_at_offset", (PyCFunction)_wrap_gtk_text_buffer_get_iter_at_offset, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_iter_at_line", (PyCFunction)_wrap_gtk_text_buffer_get_iter_at_line, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_start_iter", (PyCFunction)_wrap_gtk_text_buffer_get_start_iter, METH_NOARGS,
      NULL },
    { "get_end_iter", (PyCFunction)_wrap_gtk_text_buffer_get_end_iter, METH_NOARGS,
      NULL },
    { "get_bounds", (PyCFunction)_wrap_gtk_text_buffer_get_bounds, METH_NOARGS,
      NULL },
    { "get_iter_at_mark", (PyCFunction)_wrap_gtk_text_buffer_get_iter_at_mark, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_iter_at_child_anchor", (PyCFunction)_wrap_gtk_text_buffer_get_iter_at_child_anchor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_modified", (PyCFunction)_wrap_gtk_text_buffer_get_modified, METH_NOARGS,
      NULL },
    { "set_modified", (PyCFunction)_wrap_gtk_text_buffer_set_modified, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_selection_clipboard", (PyCFunction)_wrap_gtk_text_buffer_add_selection_clipboard, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_selection_clipboard", (PyCFunction)_wrap_gtk_text_buffer_remove_selection_clipboard, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "cut_clipboard", (PyCFunction)_wrap_gtk_text_buffer_cut_clipboard, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "copy_clipboard", (PyCFunction)_wrap_gtk_text_buffer_copy_clipboard, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paste_clipboard", (PyCFunction)_wrap_gtk_text_buffer_paste_clipboard, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_selection_bounds", (PyCFunction)_wrap_gtk_text_buffer_get_selection_bounds, METH_NOARGS,
      NULL },
    { "delete_selection", (PyCFunction)_wrap_gtk_text_buffer_delete_selection, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "begin_user_action", (PyCFunction)_wrap_gtk_text_buffer_begin_user_action, METH_NOARGS,
      NULL },
    { "end_user_action", (PyCFunction)_wrap_gtk_text_buffer_end_user_action, METH_NOARGS,
      NULL },
    { "backspace", (PyCFunction)_wrap_gtk_text_buffer_backspace, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_selection", (PyCFunction)_wrap_gtk_text_buffer_get_has_selection, METH_NOARGS,
      NULL },
    { "get_copy_target_list", (PyCFunction)_wrap_gtk_text_buffer_get_copy_target_list, METH_NOARGS,
      NULL },
    { "get_paste_target_list", (PyCFunction)_wrap_gtk_text_buffer_get_paste_target_list, METH_NOARGS,
      NULL },
    { "register_serialize_format", (PyCFunction)_wrap_gtk_text_buffer_register_serialize_format, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "register_serialize_tagset", (PyCFunction)_wrap_gtk_text_buffer_register_serialize_tagset, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "register_deserialize_format", (PyCFunction)_wrap_gtk_text_buffer_register_deserialize_format, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "register_deserialize_tagset", (PyCFunction)_wrap_gtk_text_buffer_register_deserialize_tagset, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unregister_serialize_format", (PyCFunction)_wrap_gtk_text_buffer_unregister_serialize_format, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unregister_deserialize_format", (PyCFunction)_wrap_gtk_text_buffer_unregister_deserialize_format, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "deserialize_set_can_create_tags", (PyCFunction)_wrap_gtk_text_buffer_deserialize_set_can_create_tags, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "deserialize_get_can_create_tags", (PyCFunction)_wrap_gtk_text_buffer_deserialize_get_can_create_tags, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_serialize_formats", (PyCFunction)_wrap_gtk_text_buffer_get_serialize_formats, METH_NOARGS,
      NULL },
    { "get_deserialize_formats", (PyCFunction)_wrap_gtk_text_buffer_get_deserialize_formats, METH_NOARGS,
      NULL },
    { "serialize", (PyCFunction)_wrap_gtk_text_buffer_serialize, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "deserialize", (PyCFunction)_wrap_gtk_text_buffer_deserialize, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_mark", (PyCFunction)_wrap_gtk_text_buffer_add_mark, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_insert_text", (PyCFunction)_wrap_GtkTextBuffer__do_insert_text, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_insert_pixbuf", (PyCFunction)_wrap_GtkTextBuffer__do_insert_pixbuf, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_insert_child_anchor", (PyCFunction)_wrap_GtkTextBuffer__do_insert_child_anchor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_delete_range", (PyCFunction)_wrap_GtkTextBuffer__do_delete_range, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_changed", (PyCFunction)_wrap_GtkTextBuffer__do_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_modified_changed", (PyCFunction)_wrap_GtkTextBuffer__do_modified_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_mark_set", (PyCFunction)_wrap_GtkTextBuffer__do_mark_set, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_mark_deleted", (PyCFunction)_wrap_GtkTextBuffer__do_mark_deleted, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_apply_tag", (PyCFunction)_wrap_GtkTextBuffer__do_apply_tag, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_remove_tag", (PyCFunction)_wrap_GtkTextBuffer__do_remove_tag, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_begin_user_action", (PyCFunction)_wrap_GtkTextBuffer__do_begin_user_action, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_end_user_action", (PyCFunction)_wrap_GtkTextBuffer__do_end_user_action, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_text_buffer__get_tag_table(PyObject *self, void *closure)
{
    GtkTextTagTable *ret;

    ret = GTK_TEXT_BUFFER(pygobject_get(self))->tag_table;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyGetSetDef gtk_text_buffer_getsets[] = {
    { "tag_table", (getter)_wrap_gtk_text_buffer__get_tag_table, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkTextBuffer_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TextBuffer",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTextBuffer_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_text_buffer_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_text_buffer_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkTextBuffer__proxy_do_insert_text(GtkTextBuffer *self, GtkTextIter*pos, const gchar*text, gint length)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_pos;
    PyObject *py_text = NULL;
    PyObject *py_length;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_pos = pyg_boxed_new(GTK_TYPE_TEXT_ITER, pos, FALSE, FALSE);
    if (text)
        py_text = PyString_FromString(text);
    if (!py_text) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_pos);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_length = PyInt_FromLong(length);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_pos);
    PyTuple_SET_ITEM(py_args, 1, py_text);
    PyTuple_SET_ITEM(py_args, 2, py_length);
    
    py_method = PyObject_GetAttrString(py_self, "do_insert_text");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_insert_pixbuf(GtkTextBuffer *self, GtkTextIter*pos, GdkPixbuf*pixbuf)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_pos;
    PyObject *py_pixbuf = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_pos = pyg_boxed_new(GTK_TYPE_TEXT_ITER, pos, FALSE, FALSE);
    if (pixbuf)
        py_pixbuf = pygobject_new((GObject *) pixbuf);
    else {
        Py_INCREF(Py_None);
        py_pixbuf = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_pos);
    PyTuple_SET_ITEM(py_args, 1, py_pixbuf);
    
    py_method = PyObject_GetAttrString(py_self, "do_insert_pixbuf");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_insert_child_anchor(GtkTextBuffer *self, GtkTextIter*pos, GtkTextChildAnchor*anchor)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_pos;
    PyObject *py_anchor = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_pos = pyg_boxed_new(GTK_TYPE_TEXT_ITER, pos, FALSE, FALSE);
    if (anchor)
        py_anchor = pygobject_new((GObject *) anchor);
    else {
        Py_INCREF(Py_None);
        py_anchor = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_pos);
    PyTuple_SET_ITEM(py_args, 1, py_anchor);
    
    py_method = PyObject_GetAttrString(py_self, "do_insert_child_anchor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_delete_range(GtkTextBuffer *self, GtkTextIter*start, GtkTextIter*end)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_start;
    PyObject *py_end;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_start = pyg_boxed_new(GTK_TYPE_TEXT_ITER, start, FALSE, FALSE);
    py_end = pyg_boxed_new(GTK_TYPE_TEXT_ITER, end, FALSE, FALSE);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_start);
    PyTuple_SET_ITEM(py_args, 1, py_end);
    
    py_method = PyObject_GetAttrString(py_self, "do_delete_range");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_changed(GtkTextBuffer *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_modified_changed(GtkTextBuffer *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_modified_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_mark_set(GtkTextBuffer *self, const GtkTextIter*location, GtkTextMark*mark)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_location;
    PyObject *py_mark = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_location = pyg_boxed_new(GTK_TYPE_TEXT_ITER, (GtkTextIter*) location, TRUE, TRUE);
    if (mark)
        py_mark = pygobject_new((GObject *) mark);
    else {
        Py_INCREF(Py_None);
        py_mark = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_location);
    PyTuple_SET_ITEM(py_args, 1, py_mark);
    
    py_method = PyObject_GetAttrString(py_self, "do_mark_set");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_mark_deleted(GtkTextBuffer *self, GtkTextMark*mark)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_mark = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (mark)
        py_mark = pygobject_new((GObject *) mark);
    else {
        Py_INCREF(Py_None);
        py_mark = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_mark);
    
    py_method = PyObject_GetAttrString(py_self, "do_mark_deleted");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_apply_tag(GtkTextBuffer *self, GtkTextTag*tag, const GtkTextIter*start_char, const GtkTextIter*end_char)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_tag = NULL;
    PyObject *py_start_char;
    PyObject *py_end_char;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (tag)
        py_tag = pygobject_new((GObject *) tag);
    else {
        Py_INCREF(Py_None);
        py_tag = Py_None;
    }
    py_start_char = pyg_boxed_new(GTK_TYPE_TEXT_ITER, (GtkTextIter*) start_char, TRUE, TRUE);
    py_end_char = pyg_boxed_new(GTK_TYPE_TEXT_ITER, (GtkTextIter*) end_char, TRUE, TRUE);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_tag);
    PyTuple_SET_ITEM(py_args, 1, py_start_char);
    PyTuple_SET_ITEM(py_args, 2, py_end_char);
    
    py_method = PyObject_GetAttrString(py_self, "do_apply_tag");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_remove_tag(GtkTextBuffer *self, GtkTextTag*tag, const GtkTextIter*start_char, const GtkTextIter*end_char)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_tag = NULL;
    PyObject *py_start_char;
    PyObject *py_end_char;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (tag)
        py_tag = pygobject_new((GObject *) tag);
    else {
        Py_INCREF(Py_None);
        py_tag = Py_None;
    }
    py_start_char = pyg_boxed_new(GTK_TYPE_TEXT_ITER, (GtkTextIter*) start_char, TRUE, TRUE);
    py_end_char = pyg_boxed_new(GTK_TYPE_TEXT_ITER, (GtkTextIter*) end_char, TRUE, TRUE);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_tag);
    PyTuple_SET_ITEM(py_args, 1, py_start_char);
    PyTuple_SET_ITEM(py_args, 2, py_end_char);
    
    py_method = PyObject_GetAttrString(py_self, "do_remove_tag");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_begin_user_action(GtkTextBuffer *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_begin_user_action");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextBuffer__proxy_do_end_user_action(GtkTextBuffer *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_end_user_action");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkTextBuffer_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkTextBufferClass *klass = GTK_TEXT_BUFFER_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_insert_text");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "insert_text")))
            klass->insert_text = _wrap_GtkTextBuffer__proxy_do_insert_text;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_insert_pixbuf");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "insert_pixbuf")))
            klass->insert_pixbuf = _wrap_GtkTextBuffer__proxy_do_insert_pixbuf;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_insert_child_anchor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "insert_child_anchor")))
            klass->insert_child_anchor = _wrap_GtkTextBuffer__proxy_do_insert_child_anchor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_delete_range");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "delete_range")))
            klass->delete_range = _wrap_GtkTextBuffer__proxy_do_delete_range;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "changed")))
            klass->changed = _wrap_GtkTextBuffer__proxy_do_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_modified_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "modified_changed")))
            klass->modified_changed = _wrap_GtkTextBuffer__proxy_do_modified_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_mark_set");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "mark_set")))
            klass->mark_set = _wrap_GtkTextBuffer__proxy_do_mark_set;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_mark_deleted");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "mark_deleted")))
            klass->mark_deleted = _wrap_GtkTextBuffer__proxy_do_mark_deleted;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_apply_tag");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "apply_tag")))
            klass->apply_tag = _wrap_GtkTextBuffer__proxy_do_apply_tag;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_remove_tag");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "remove_tag")))
            klass->remove_tag = _wrap_GtkTextBuffer__proxy_do_remove_tag;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_begin_user_action");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "begin_user_action")))
            klass->begin_user_action = _wrap_GtkTextBuffer__proxy_do_begin_user_action;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_end_user_action");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "end_user_action")))
            klass->end_user_action = _wrap_GtkTextBuffer__proxy_do_end_user_action;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkTextChildAnchor ----------- */

 static int
_wrap_gtk_text_child_anchor_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.TextChildAnchor.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.TextChildAnchor object");
        return -1;
    }
    return 0;
}

#line 2613 "./gtk.override"
static PyObject *
_wrap_gtk_text_child_anchor_get_widgets(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *ret;

    list = gtk_text_child_anchor_get_widgets(GTK_TEXT_CHILD_ANCHOR(self->obj));

    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        GtkWidget *widget = tmp->data;
        PyObject *item = pygobject_new((GObject *)widget);

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    g_list_free(list);
    return ret;
}
#line 85915 "gtk.c"


static PyObject *
_wrap_gtk_text_child_anchor_get_deleted(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_child_anchor_get_deleted(GTK_TEXT_CHILD_ANCHOR(self->obj));
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkTextChildAnchor_methods[] = {
    { "get_widgets", (PyCFunction)_wrap_gtk_text_child_anchor_get_widgets, METH_NOARGS,
      NULL },
    { "get_deleted", (PyCFunction)_wrap_gtk_text_child_anchor_get_deleted, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTextChildAnchor_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TextChildAnchor",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTextChildAnchor_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_text_child_anchor_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTextMark ----------- */

static int
_wrap_gtk_text_mark_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[2];
    PyObject *parsed_args[2] = {NULL, };
    char *arg_names[] = {"name", "left_gravity", NULL };
    char *prop_names[] = {"name", "left_gravity", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:gtk.TextMark.__init__" , arg_names , &parsed_args[0] , &parsed_args[1]))
        return -1;

    memset(params, 0, sizeof(GParameter)*2);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.TextMark object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_text_mark_set_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextMark.set_visible", kwlist, &setting))
        return NULL;
    
    gtk_text_mark_set_visible(GTK_TEXT_MARK(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_mark_get_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_mark_get_visible(GTK_TEXT_MARK(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_mark_get_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_text_mark_get_name(GTK_TEXT_MARK(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_mark_get_deleted(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_mark_get_deleted(GTK_TEXT_MARK(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_mark_get_buffer(PyGObject *self)
{
    GtkTextBuffer *ret;

    
    ret = gtk_text_mark_get_buffer(GTK_TEXT_MARK(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_text_mark_get_left_gravity(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_mark_get_left_gravity(GTK_TEXT_MARK(self->obj));
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkTextMark_methods[] = {
    { "set_visible", (PyCFunction)_wrap_gtk_text_mark_set_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible", (PyCFunction)_wrap_gtk_text_mark_get_visible, METH_NOARGS,
      NULL },
    { "get_name", (PyCFunction)_wrap_gtk_text_mark_get_name, METH_NOARGS,
      NULL },
    { "get_deleted", (PyCFunction)_wrap_gtk_text_mark_get_deleted, METH_NOARGS,
      NULL },
    { "get_buffer", (PyCFunction)_wrap_gtk_text_mark_get_buffer, METH_NOARGS,
      NULL },
    { "get_left_gravity", (PyCFunction)_wrap_gtk_text_mark_get_left_gravity, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTextMark_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TextMark",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTextMark_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_text_mark_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTextTag ----------- */

 static int
_wrap_gtk_text_tag_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"name", NULL };
    char *prop_names[] = {"name", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.TextTag.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.TextTag object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_text_tag_get_priority(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_tag_get_priority(GTK_TEXT_TAG(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_tag_set_priority(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "priority", NULL };
    int priority;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextTag.set_priority", kwlist, &priority))
        return NULL;
    
    gtk_text_tag_set_priority(GTK_TEXT_TAG(self->obj), priority);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_tag_event(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event_object", "event", "iter", NULL };
    PyGObject *event_object;
    GdkEvent *event = NULL;
    int ret;
    GtkTextIter *iter = NULL;
    PyObject *py_event, *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TextTag.event", kwlist, &PyGObject_Type, &event_object, &py_event, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_tag_event(GTK_TEXT_TAG(self->obj), G_OBJECT(event_object->obj), event, iter);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTextTag__do_event(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "event_object", "event", "iter", NULL };
    PyGObject *self, *event_object;
    GdkEvent *event = NULL;
    int ret;
    GtkTextIter *iter = NULL;
    PyObject *py_event, *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OO:Gtk.TextTag.event", kwlist, &PyGtkTextTag_Type, &self, &PyGObject_Type, &event_object, &py_event, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_TAG_CLASS(klass)->event)
        ret = GTK_TEXT_TAG_CLASS(klass)->event(GTK_TEXT_TAG(self->obj), G_OBJECT(event_object->obj), event, iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextTag.event not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkTextTag_methods[] = {
    { "get_priority", (PyCFunction)_wrap_gtk_text_tag_get_priority, METH_NOARGS,
      NULL },
    { "set_priority", (PyCFunction)_wrap_gtk_text_tag_set_priority, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "event", (PyCFunction)_wrap_gtk_text_tag_event, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_event", (PyCFunction)_wrap_GtkTextTag__do_event, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTextTag_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TextTag",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTextTag_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_text_tag_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gboolean
_wrap_GtkTextTag__proxy_do_event(GtkTextTag *self, GObject*event_object, GdkEvent*event, const GtkTextIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event_object = NULL;
    PyObject *py_event;
    PyObject *py_iter;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (event_object)
        py_event_object = pygobject_new((GObject *) event_object);
    else {
        Py_INCREF(Py_None);
        py_event_object = Py_None;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    py_iter = pyg_boxed_new(GTK_TYPE_TEXT_ITER, (GtkTextIter*) iter, TRUE, TRUE);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_event_object);
    PyTuple_SET_ITEM(py_args, 1, py_event);
    PyTuple_SET_ITEM(py_args, 2, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_event");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkTextTag_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkTextTagClass *klass = GTK_TEXT_TAG_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_event");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "event")))
            klass->event = _wrap_GtkTextTag__proxy_do_event;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkTextTagTable ----------- */

 static int
_wrap_gtk_text_tag_table_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.TextTagTable.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.TextTagTable object");
        return -1;
    }
    return 0;
}

#line 957 "gtktextview.override"
static PyObject *
_wrap_gtk_text_tag_table_add(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag", NULL };
    GtkTextTag *tag;
    GtkTextTagTable *table;
    PyGObject *pytag;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkTextTagTable.add",
				     kwlist, &PyGtkTextTag_Type, &pytag)) {
        return NULL;
    }

    tag = GTK_TEXT_TAG(pytag->obj);
    table = GTK_TEXT_TAG_TABLE(self->obj);

    if (tag->table) {
        gchar buf[512];
        g_snprintf(buf, sizeof(buf),
                   "The tag is already in a tag table");

        PyErr_SetString(PyExc_ValueError, buf);
        return NULL;
    }

    if (tag->name && table && g_hash_table_lookup(table->hash, tag->name)) {
        gchar buf[512];
        g_snprintf(buf, sizeof(buf),
                   "A tag named '%s' is already in the tag table",
                   tag->name);

        PyErr_SetString(PyExc_ValueError, buf);
        return NULL;
    }

    gtk_text_tag_table_add(table, tag);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 86503 "gtk.c"


#line 999 "gtktextview.override"
static PyObject *
_wrap_gtk_text_tag_table_remove(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "tag", NULL };
    GtkTextTag *tag;
    GtkTextTagTable *table;
    PyGObject *pytag;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkTextTagTable.remove",
				     kwlist, &PyGtkTextTag_Type, &pytag)) {
        return NULL;
    }

    tag = GTK_TEXT_TAG(pytag->obj);
    table = GTK_TEXT_TAG_TABLE(self->obj);

    if (tag->table != table) {
        gchar buf[512];
	if (tag->name)
	    g_snprintf(buf, sizeof(buf),
		       "The tag named '%s' is not in the tag table",
		       tag->name);
	else
	    g_snprintf(buf, sizeof(buf),
		       "The tag is not in the tag table");

        PyErr_SetString(PyExc_ValueError, buf);
        return NULL;
    }

    gtk_text_tag_table_remove(table, tag);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 86544 "gtk.c"


static PyObject *
_wrap_gtk_text_tag_table_lookup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    GtkTextTag *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.TextTagTable.lookup", kwlist, &name))
        return NULL;
    
    ret = gtk_text_tag_table_lookup(GTK_TEXT_TAG_TABLE(self->obj), name);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 1116 "gtktextview.override"
static void
pygtk_text_tag_table_foreach_cb(GtkTextTag *tag, gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *callback, *args, *ret;

    state = pyg_gil_state_ensure();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NO)",
			 pygobject_new((GObject *)tag),
			 PyTuple_GetItem((PyObject *)user_data, 1));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_DECREF(args);
    Py_XDECREF(ret);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_text_tag_table_foreach(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data",  NULL };
    PyObject *func, *data, *py_data = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|O:GtkTextTagTable.foreach",
				     kwlist, &func, &py_data)) {
        return NULL;
    }
    if (!PyCallable_Check(func)) {
	PyErr_SetString(PyExc_TypeError, "func must be callable");
	return NULL;
    }

    data = Py_BuildValue("(OO)", func, py_data);
    
    gtk_text_tag_table_foreach(GTK_TEXT_TAG_TABLE(self->obj),
			       pygtk_text_tag_table_foreach_cb,
			       (gpointer)data);
    Py_DECREF(data);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 86608 "gtk.c"


static PyObject *
_wrap_gtk_text_tag_table_get_size(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_tag_table_get_size(GTK_TEXT_TAG_TABLE(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_GtkTextTagTable__do_tag_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "tag", "size_changed", NULL };
    PyGObject *self, *tag;
    int size_changed;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!i:Gtk.TextTagTable.tag_changed", kwlist, &PyGtkTextTagTable_Type, &self, &PyGtkTextTag_Type, &tag, &size_changed))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_TAG_TABLE_CLASS(klass)->tag_changed)
        GTK_TEXT_TAG_TABLE_CLASS(klass)->tag_changed(GTK_TEXT_TAG_TABLE(self->obj), GTK_TEXT_TAG(tag->obj), size_changed);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextTagTable.tag_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextTagTable__do_tag_added(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "tag", NULL };
    PyGObject *self, *tag;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.TextTagTable.tag_added", kwlist, &PyGtkTextTagTable_Type, &self, &PyGtkTextTag_Type, &tag))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_TAG_TABLE_CLASS(klass)->tag_added)
        GTK_TEXT_TAG_TABLE_CLASS(klass)->tag_added(GTK_TEXT_TAG_TABLE(self->obj), GTK_TEXT_TAG(tag->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextTagTable.tag_added not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextTagTable__do_tag_removed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "tag", NULL };
    PyGObject *self, *tag;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.TextTagTable.tag_removed", kwlist, &PyGtkTextTagTable_Type, &self, &PyGtkTextTag_Type, &tag))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_TAG_TABLE_CLASS(klass)->tag_removed)
        GTK_TEXT_TAG_TABLE_CLASS(klass)->tag_removed(GTK_TEXT_TAG_TABLE(self->obj), GTK_TEXT_TAG(tag->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextTagTable.tag_removed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTextTagTable_methods[] = {
    { "add", (PyCFunction)_wrap_gtk_text_tag_table_add, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove", (PyCFunction)_wrap_gtk_text_tag_table_remove, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "lookup", (PyCFunction)_wrap_gtk_text_tag_table_lookup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "foreach", (PyCFunction)_wrap_gtk_text_tag_table_foreach, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_size", (PyCFunction)_wrap_gtk_text_tag_table_get_size, METH_NOARGS,
      NULL },
    { "do_tag_changed", (PyCFunction)_wrap_GtkTextTagTable__do_tag_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_tag_added", (PyCFunction)_wrap_GtkTextTagTable__do_tag_added, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_tag_removed", (PyCFunction)_wrap_GtkTextTagTable__do_tag_removed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTextTagTable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TextTagTable",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTextTagTable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_text_tag_table_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkTextTagTable__proxy_do_tag_changed(GtkTextTagTable *self, GtkTextTag*tag, gboolean size_changed)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_tag = NULL;
    PyObject *py_size_changed;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (tag)
        py_tag = pygobject_new((GObject *) tag);
    else {
        Py_INCREF(Py_None);
        py_tag = Py_None;
    }
    py_size_changed = size_changed? Py_True : Py_False;
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_tag);
    Py_INCREF(py_size_changed);
    PyTuple_SET_ITEM(py_args, 1, py_size_changed);
    
    py_method = PyObject_GetAttrString(py_self, "do_tag_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextTagTable__proxy_do_tag_added(GtkTextTagTable *self, GtkTextTag*tag)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_tag = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (tag)
        py_tag = pygobject_new((GObject *) tag);
    else {
        Py_INCREF(Py_None);
        py_tag = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_tag);
    
    py_method = PyObject_GetAttrString(py_self, "do_tag_added");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextTagTable__proxy_do_tag_removed(GtkTextTagTable *self, GtkTextTag*tag)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_tag = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (tag)
        py_tag = pygobject_new((GObject *) tag);
    else {
        Py_INCREF(Py_None);
        py_tag = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_tag);
    
    py_method = PyObject_GetAttrString(py_self, "do_tag_removed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkTextTagTable_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkTextTagTableClass *klass = GTK_TEXT_TAG_TABLE_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_tag_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "tag_changed")))
            klass->tag_changed = _wrap_GtkTextTagTable__proxy_do_tag_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_tag_added");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "tag_added")))
            klass->tag_added = _wrap_GtkTextTagTable__proxy_do_tag_added;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_tag_removed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "tag_removed")))
            klass->tag_removed = _wrap_GtkTextTagTable__proxy_do_tag_removed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkTextView ----------- */

static int
_wrap_gtk_text_view_new_with_buffer(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"buffer", NULL };
    char *prop_names[] = {"buffer", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.TextView.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.TextView object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_text_view_set_buffer(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    PyGObject *py_buffer;
    GtkTextBuffer *buffer = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.set_buffer", kwlist, &py_buffer))
        return NULL;
    if (py_buffer && pygobject_check(py_buffer, &PyGtkTextBuffer_Type))
        buffer = GTK_TEXT_BUFFER(py_buffer->obj);
    else if ((PyObject *)py_buffer != Py_None) {
        PyErr_SetString(PyExc_TypeError, "buffer should be a GtkTextBuffer or None");
        return NULL;
    }
    
    gtk_text_view_set_buffer(GTK_TEXT_VIEW(self->obj), (GtkTextBuffer *) buffer);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_buffer(PyGObject *self)
{
    GtkTextBuffer *ret;

    
    ret = gtk_text_view_get_buffer(GTK_TEXT_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_text_view_scroll_to_iter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "within_margin", "use_align", "xalign", "yalign", NULL };
    PyObject *py_iter;
    double within_margin, xalign = 0.5, yalign = 0.5;
    int use_align = FALSE, ret;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Od|idd:Gtk.TextView.scroll_to_iter", kwlist, &py_iter, &within_margin, &use_align, &xalign, &yalign))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_view_scroll_to_iter(GTK_TEXT_VIEW(self->obj), iter, within_margin, use_align, xalign, yalign);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_scroll_to_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mark", "within_margin", "use_align", "xalign", "yalign", NULL };
    PyGObject *mark;
    double within_margin, xalign = 0.5, yalign = 0.5;
    int use_align = FALSE;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!d|idd:Gtk.TextView.scroll_to_mark", kwlist, &PyGtkTextMark_Type, &mark, &within_margin, &use_align, &xalign, &yalign))
        return NULL;
    
    gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(self->obj), GTK_TEXT_MARK(mark->obj), within_margin, use_align, xalign, yalign);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_scroll_mark_onscreen(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mark", NULL };
    PyGObject *mark;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextView.scroll_mark_onscreen", kwlist, &PyGtkTextMark_Type, &mark))
        return NULL;
    
    gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(self->obj), GTK_TEXT_MARK(mark->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_move_mark_onscreen(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mark", NULL };
    PyGObject *mark;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextView.move_mark_onscreen", kwlist, &PyGtkTextMark_Type, &mark))
        return NULL;
    
    ret = gtk_text_view_move_mark_onscreen(GTK_TEXT_VIEW(self->obj), GTK_TEXT_MARK(mark->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_place_cursor_onscreen(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_place_cursor_onscreen(GTK_TEXT_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 28 "gtktextview.override"
static PyObject *
_wrap_gtk_text_view_get_visible_rect(PyGObject *self)
{
    GdkRectangle visible_rect;

    gtk_text_view_get_visible_rect(GTK_TEXT_VIEW(self->obj), &visible_rect);
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &visible_rect, TRUE, TRUE);
}
#line 87156 "gtk.c"


static PyObject *
_wrap_gtk_text_view_set_cursor_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextView.set_cursor_visible", kwlist, &setting))
        return NULL;
    
    gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_cursor_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_get_cursor_visible(GTK_TEXT_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 82 "gtktextview.override"
static PyObject *
_wrap_gtk_text_view_get_iter_location(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GdkRectangle location;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkTextView.get_iter_location",
                                     kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    gtk_text_view_get_iter_location(GTK_TEXT_VIEW(self->obj), iter, &location);
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &location, TRUE, TRUE);
}
#line 87209 "gtk.c"


#line 151 "gtktextview.override"
static PyObject *
_wrap_gtk_text_view_get_iter_at_location(PyGObject *self, PyObject *args,
                                         PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    GtkTextIter iter;
    gint x, y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "ii:GtkTextView.get_iter_at_location",
                                     kwlist, &x, &y))
        return NULL;
    gtk_text_view_get_iter_at_location(GTK_TEXT_VIEW(self->obj),
                                       &iter, x, y);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
#line 87229 "gtk.c"


#line 1282 "gtktextview.override"
static PyObject *
_wrap_gtk_text_view_get_iter_at_position(PyGObject *self, PyObject *args,
                                         PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    GtkTextIter iter;
    gint x, y, trailing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "ii:GtkTextView.get_iter_at_position",
                                     kwlist, &x, &y))
        return NULL;
    gtk_text_view_get_iter_at_position(GTK_TEXT_VIEW(self->obj),
                                       &iter, &trailing, x, y);
    return Py_BuildValue("Oi",
                          pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE),
                          trailing);
}
#line 87251 "gtk.c"


#line 126 "gtktextview.override"
static PyObject *
_wrap_gtk_text_view_get_line_yrange(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    GtkTextIter *iter = NULL;
    gint y = -1, height = -1;
    PyObject *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkTextView.get_line_yrange",
                                     kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    gtk_text_view_get_line_yrange(GTK_TEXT_VIEW(self->obj),
                                  iter, &y, &height);
    return Py_BuildValue("(ii)", y, height);
}
#line 87278 "gtk.c"


#line 106 "gtktextview.override"
static PyObject *
_wrap_gtk_text_view_get_line_at_y(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "y", NULL };
    GtkTextIter iter;
    gint y, line_top;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "i:GtkTextView.get_line_at_y",
                                     kwlist, &y))
        return NULL;
    gtk_text_view_get_line_at_y(GTK_TEXT_VIEW(self->obj),
                                &iter, y, &line_top);
    return Py_BuildValue("(Ni)",
                         pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE),
                         line_top);
}
#line 87300 "gtk.c"


#line 38 "gtktextview.override"
static PyObject *
_wrap_gtk_text_view_buffer_to_window_coords(PyGObject *self, PyObject *args,
                                            PyObject *kwargs)
{
    static char *kwlist[] = { "win", "buffer_x", "buffer_y", NULL };
    GtkTextWindowType win;
    gint buffer_x, buffer_y, window_x = 0, window_y = 0;
    PyObject *py_win;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oii:GtkTextView.buffer_to_window_coords",
                                     kwlist, &py_win, &buffer_x, &buffer_y))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, py_win, (gint *)&win))
        return NULL;
    gtk_text_view_buffer_to_window_coords(GTK_TEXT_VIEW(self->obj), win,
                                          buffer_x, buffer_y,
                                          &window_x, &window_y);
    return Py_BuildValue("(ii)", window_x, window_y);
}
#line 87324 "gtk.c"


#line 60 "gtktextview.override"
static PyObject *
_wrap_gtk_text_view_window_to_buffer_coords(PyGObject *self, PyObject *args,
                                            PyObject *kwargs)
{
    static char *kwlist[] = { "win", "window_x", "window_y", NULL };
    GtkTextWindowType win;
    gint window_x, window_y, buffer_x = 0, buffer_y = 0;
    PyObject *py_win;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oii:GtkTextView.window_to_buffer_coords",
                                     kwlist, &py_win, &window_x, &window_y))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, py_win, (gint *)&win))
        return NULL;
    gtk_text_view_window_to_buffer_coords(GTK_TEXT_VIEW(self->obj), win,
                                          window_x, window_y,
                                          &buffer_x, &buffer_y);
    return Py_BuildValue("(ii)", buffer_x, buffer_y);
}
#line 87348 "gtk.c"


static PyObject *
_wrap_gtk_text_view_get_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "win", NULL };
    PyObject *py_win = NULL;
    GtkTextWindowType win;
    GdkWindow *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.get_window", kwlist, &py_win))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, py_win, (gpointer)&win))
        return NULL;
    
    ret = gtk_text_view_get_window(GTK_TEXT_VIEW(self->obj), win);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_text_view_get_window_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", NULL };
    PyGObject *window;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextView.get_window_type", kwlist, &PyGdkWindow_Type, &window))
        return NULL;
    
    ret = gtk_text_view_get_window_type(GTK_TEXT_VIEW(self->obj), GDK_WINDOW(window->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_TEXT_WINDOW_TYPE, ret);
}

#line 169 "gtktextview.override"
static PyObject *
_wrap_gtk_text_view_set_border_window_size(PyGObject *self, PyObject *args,
					   PyObject *kwargs)
{
    static char *kwlist[] = { "type", "size", NULL };
    PyObject *py_type = NULL;
    int size;
    GtkTextWindowType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oi:GtkTextView.set_border_window_size",
				     kwlist, &py_type, &size))
        return NULL;

    if (size < 0) {
        PyErr_SetString(PyExc_ValueError, "size must be >= 0");
	return NULL;
    }

    if (pyg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, py_type, (gint *)&type))
        return NULL;

    switch (type)
    {
    case GTK_TEXT_WINDOW_LEFT:
    case GTK_TEXT_WINDOW_RIGHT:
    case GTK_TEXT_WINDOW_TOP:
    case GTK_TEXT_WINDOW_BOTTOM:
	gtk_text_view_set_border_window_size(GTK_TEXT_VIEW(self->obj), type,
					     size);
	break;
    default:
        PyErr_SetString(PyExc_ValueError, "type must be one of: "
			"gtk.TEXT_WINDOW_LEFT, gtk.TEXT_WINDOW_RIGHT, "
			"gtk.TEXT_WINDOW_TOP or gtk.TEXT_WINDOW_BOTTOM");
	return NULL;
    }
	
    Py_INCREF(Py_None);
    return Py_None;
}
#line 87427 "gtk.c"


static PyObject *
_wrap_gtk_text_view_get_border_window_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    PyObject *py_type = NULL;
    int ret;
    GtkTextWindowType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.get_border_window_size", kwlist, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, py_type, (gpointer)&type))
        return NULL;
    
    ret = gtk_text_view_get_border_window_size(GTK_TEXT_VIEW(self->obj), type);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_view_forward_display_line(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    int ret;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.forward_display_line", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_view_forward_display_line(GTK_TEXT_VIEW(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_backward_display_line(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    int ret;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.backward_display_line", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_view_backward_display_line(GTK_TEXT_VIEW(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_forward_display_line_end(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    int ret;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.forward_display_line_end", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_view_forward_display_line_end(GTK_TEXT_VIEW(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_backward_display_line_start(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    int ret;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.backward_display_line_start", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_view_backward_display_line_start(GTK_TEXT_VIEW(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_starts_display_line(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    int ret;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.starts_display_line", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_view_starts_display_line(GTK_TEXT_VIEW(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_move_visually(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "count", NULL };
    PyObject *py_iter;
    int count, ret;
    GtkTextIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.TextView.move_visually", kwlist, &py_iter, &count))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER))
        iter = pyg_boxed_get(py_iter, GtkTextIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTextIter");
        return NULL;
    }
    
    ret = gtk_text_view_move_visually(GTK_TEXT_VIEW(self->obj), iter, count);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_add_child_at_anchor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "anchor", NULL };
    PyGObject *child, *anchor;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.TextView.add_child_at_anchor", kwlist, &PyGtkWidget_Type, &child, &PyGtkTextChildAnchor_Type, &anchor))
        return NULL;
    
    gtk_text_view_add_child_at_anchor(GTK_TEXT_VIEW(self->obj), GTK_WIDGET(child->obj), GTK_TEXT_CHILD_ANCHOR(anchor->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_add_child_in_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "which_window", "xpos", "ypos", NULL };
    PyGObject *child;
    PyObject *py_which_window = NULL;
    int xpos, ypos;
    GtkTextWindowType which_window;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oii:Gtk.TextView.add_child_in_window", kwlist, &PyGtkWidget_Type, &child, &py_which_window, &xpos, &ypos))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, py_which_window, (gpointer)&which_window))
        return NULL;
    
    gtk_text_view_add_child_in_window(GTK_TEXT_VIEW(self->obj), GTK_WIDGET(child->obj), which_window, xpos, ypos);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_move_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "xpos", "ypos", NULL };
    PyGObject *child;
    int xpos, ypos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.TextView.move_child", kwlist, &PyGtkWidget_Type, &child, &xpos, &ypos))
        return NULL;
    
    gtk_text_view_move_child(GTK_TEXT_VIEW(self->obj), GTK_WIDGET(child->obj), xpos, ypos);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_set_wrap_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "wrap_mode", NULL };
    PyObject *py_wrap_mode = NULL;
    GtkWrapMode wrap_mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.set_wrap_mode", kwlist, &py_wrap_mode))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_WRAP_MODE, py_wrap_mode, (gpointer)&wrap_mode))
        return NULL;
    
    gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(self->obj), wrap_mode);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_wrap_mode(PyGObject *self)
{
    gint ret;

    
    ret = gtk_text_view_get_wrap_mode(GTK_TEXT_VIEW(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_WRAP_MODE, ret);
}

static PyObject *
_wrap_gtk_text_view_set_editable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextView.set_editable", kwlist, &setting))
        return NULL;
    
    gtk_text_view_set_editable(GTK_TEXT_VIEW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_editable(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_get_editable(GTK_TEXT_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_set_overwrite(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "overwrite", NULL };
    int overwrite;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextView.set_overwrite", kwlist, &overwrite))
        return NULL;
    
    gtk_text_view_set_overwrite(GTK_TEXT_VIEW(self->obj), overwrite);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_overwrite(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_get_overwrite(GTK_TEXT_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_set_accepts_tab(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accepts_tab", NULL };
    int accepts_tab;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextView.set_accepts_tab", kwlist, &accepts_tab))
        return NULL;
    
    gtk_text_view_set_accepts_tab(GTK_TEXT_VIEW(self->obj), accepts_tab);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_accepts_tab(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_get_accepts_tab(GTK_TEXT_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_set_pixels_above_lines(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixels_above_lines", NULL };
    int pixels_above_lines;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextView.set_pixels_above_lines", kwlist, &pixels_above_lines))
        return NULL;
    
    gtk_text_view_set_pixels_above_lines(GTK_TEXT_VIEW(self->obj), pixels_above_lines);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_pixels_above_lines(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_get_pixels_above_lines(GTK_TEXT_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_view_set_pixels_below_lines(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixels_below_lines", NULL };
    int pixels_below_lines;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextView.set_pixels_below_lines", kwlist, &pixels_below_lines))
        return NULL;
    
    gtk_text_view_set_pixels_below_lines(GTK_TEXT_VIEW(self->obj), pixels_below_lines);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_pixels_below_lines(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_get_pixels_below_lines(GTK_TEXT_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_view_set_pixels_inside_wrap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixels_inside_wrap", NULL };
    int pixels_inside_wrap;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextView.set_pixels_inside_wrap", kwlist, &pixels_inside_wrap))
        return NULL;
    
    gtk_text_view_set_pixels_inside_wrap(GTK_TEXT_VIEW(self->obj), pixels_inside_wrap);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_pixels_inside_wrap(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_get_pixels_inside_wrap(GTK_TEXT_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_view_set_justification(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "justification", NULL };
    PyObject *py_justification = NULL;
    GtkJustification justification;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.set_justification", kwlist, &py_justification))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_JUSTIFICATION, py_justification, (gpointer)&justification))
        return NULL;
    
    gtk_text_view_set_justification(GTK_TEXT_VIEW(self->obj), justification);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_justification(PyGObject *self)
{
    gint ret;

    
    ret = gtk_text_view_get_justification(GTK_TEXT_VIEW(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_JUSTIFICATION, ret);
}

static PyObject *
_wrap_gtk_text_view_set_left_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "left_margin", NULL };
    int left_margin;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextView.set_left_margin", kwlist, &left_margin))
        return NULL;
    
    gtk_text_view_set_left_margin(GTK_TEXT_VIEW(self->obj), left_margin);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_left_margin(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_get_left_margin(GTK_TEXT_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_view_set_right_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "right_margin", NULL };
    int right_margin;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextView.set_right_margin", kwlist, &right_margin))
        return NULL;
    
    gtk_text_view_set_right_margin(GTK_TEXT_VIEW(self->obj), right_margin);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_right_margin(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_get_right_margin(GTK_TEXT_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_view_set_indent(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "indent", NULL };
    int indent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TextView.set_indent", kwlist, &indent))
        return NULL;
    
    gtk_text_view_set_indent(GTK_TEXT_VIEW(self->obj), indent);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_indent(PyGObject *self)
{
    int ret;

    
    ret = gtk_text_view_get_indent(GTK_TEXT_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_text_view_set_tabs(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tabs", NULL };
    PyObject *py_tabs;
    PangoTabArray *tabs = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.set_tabs", kwlist, &py_tabs))
        return NULL;
    if (pyg_boxed_check(py_tabs, PANGO_TYPE_TAB_ARRAY))
        tabs = pyg_boxed_get(py_tabs, PangoTabArray);
    else {
        PyErr_SetString(PyExc_TypeError, "tabs should be a PangoTabArray");
        return NULL;
    }
    
    gtk_text_view_set_tabs(GTK_TEXT_VIEW(self->obj), tabs);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_text_view_get_tabs(PyGObject *self)
{
    PangoTabArray *ret;

    
    ret = gtk_text_view_get_tabs(GTK_TEXT_VIEW(self->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PANGO_TYPE_TAB_ARRAY, ret, TRUE, TRUE);
}

#line 1269 "gtktextview.override"
/* Workaround gtk bug #317455; moreover, copy_boxed should have been FALSE
 * in the first place (missing caller-owns-return in the defs) */
static PyObject *
_wrap_gtk_text_view_get_default_attributes(PyGObject *self)
{
    GtkTextAttributes *ret;

    ret = gtk_text_view_get_default_attributes(GTK_TEXT_VIEW(self->obj));
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_TEXT_ATTRIBUTES, ret, FALSE, TRUE);
}
#line 87978 "gtk.c"


static PyObject *
_wrap_gtk_text_view_get_hadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_text_view_get_hadjustment(GTK_TEXT_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_text_view_get_vadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_text_view_get_vadjustment(GTK_TEXT_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_text_view_im_context_filter_keypress(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", NULL };
    GdkEvent *event = NULL;
    PyObject *py_event;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TextView.im_context_filter_keypress", kwlist, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    ret = gtk_text_view_im_context_filter_keypress(GTK_TEXT_VIEW(self->obj), (GdkEventKey *)event);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_text_view_reset_im_context(PyGObject *self)
{
    
    gtk_text_view_reset_im_context(GTK_TEXT_VIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_set_scroll_adjustments(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "hadjustment", "vadjustment", NULL };
    PyGObject *self, *hadjustment, *vadjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!:Gtk.TextView.set_scroll_adjustments", kwlist, &PyGtkTextView_Type, &self, &PyGtkAdjustment_Type, &hadjustment, &PyGtkAdjustment_Type, &vadjustment))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->set_scroll_adjustments)
        GTK_TEXT_VIEW_CLASS(klass)->set_scroll_adjustments(GTK_TEXT_VIEW(self->obj), GTK_ADJUSTMENT(hadjustment->obj), GTK_ADJUSTMENT(vadjustment->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.set_scroll_adjustments not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_populate_popup(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "menu", NULL };
    PyGObject *self, *menu;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.TextView.populate_popup", kwlist, &PyGtkTextView_Type, &self, &PyGtkMenu_Type, &menu))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->populate_popup)
        GTK_TEXT_VIEW_CLASS(klass)->populate_popup(GTK_TEXT_VIEW(self->obj), GTK_MENU(menu->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.populate_popup not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_move_cursor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "step", "count", "extend_selection", NULL };
    PyGObject *self;
    PyObject *py_step = NULL;
    GtkMovementStep step;
    int count, extend_selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oii:Gtk.TextView.move_cursor", kwlist, &PyGtkTextView_Type, &self, &py_step, &count, &extend_selection))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_MOVEMENT_STEP, py_step, (gpointer)&step))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->move_cursor)
        GTK_TEXT_VIEW_CLASS(klass)->move_cursor(GTK_TEXT_VIEW(self->obj), step, count, extend_selection);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.move_cursor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_page_horizontally(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "count", "extend_selection", NULL };
    PyGObject *self;
    int count, extend_selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.TextView.page_horizontally", kwlist, &PyGtkTextView_Type, &self, &count, &extend_selection))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->page_horizontally)
        GTK_TEXT_VIEW_CLASS(klass)->page_horizontally(GTK_TEXT_VIEW(self->obj), count, extend_selection);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.page_horizontally not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_set_anchor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextView.set_anchor", kwlist, &PyGtkTextView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->set_anchor)
        GTK_TEXT_VIEW_CLASS(klass)->set_anchor(GTK_TEXT_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.set_anchor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_insert_at_cursor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "str", NULL };
    PyGObject *self;
    char *str;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.TextView.insert_at_cursor", kwlist, &PyGtkTextView_Type, &self, &str))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->insert_at_cursor)
        GTK_TEXT_VIEW_CLASS(klass)->insert_at_cursor(GTK_TEXT_VIEW(self->obj), str);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.insert_at_cursor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_delete_from_cursor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "type", "count", NULL };
    PyGObject *self;
    PyObject *py_type = NULL;
    int count;
    GtkDeleteType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oi:Gtk.TextView.delete_from_cursor", kwlist, &PyGtkTextView_Type, &self, &py_type, &count))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_DELETE_TYPE, py_type, (gpointer)&type))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->delete_from_cursor)
        GTK_TEXT_VIEW_CLASS(klass)->delete_from_cursor(GTK_TEXT_VIEW(self->obj), type, count);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.delete_from_cursor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_backspace(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextView.backspace", kwlist, &PyGtkTextView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->backspace)
        GTK_TEXT_VIEW_CLASS(klass)->backspace(GTK_TEXT_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.backspace not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_cut_clipboard(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextView.cut_clipboard", kwlist, &PyGtkTextView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->cut_clipboard)
        GTK_TEXT_VIEW_CLASS(klass)->cut_clipboard(GTK_TEXT_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.cut_clipboard not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_copy_clipboard(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextView.copy_clipboard", kwlist, &PyGtkTextView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->copy_clipboard)
        GTK_TEXT_VIEW_CLASS(klass)->copy_clipboard(GTK_TEXT_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.copy_clipboard not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_paste_clipboard(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextView.paste_clipboard", kwlist, &PyGtkTextView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->paste_clipboard)
        GTK_TEXT_VIEW_CLASS(klass)->paste_clipboard(GTK_TEXT_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.paste_clipboard not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_toggle_overwrite(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TextView.toggle_overwrite", kwlist, &PyGtkTextView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->toggle_overwrite)
        GTK_TEXT_VIEW_CLASS(klass)->toggle_overwrite(GTK_TEXT_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.toggle_overwrite not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTextView__do_move_focus(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "direction", NULL };
    PyGObject *self;
    PyObject *py_direction = NULL;
    GtkDirectionType direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TextView.move_focus", kwlist, &PyGtkTextView_Type, &self, &py_direction))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, py_direction, (gpointer)&direction))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TEXT_VIEW_CLASS(klass)->move_focus)
        GTK_TEXT_VIEW_CLASS(klass)->move_focus(GTK_TEXT_VIEW(self->obj), direction);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TextView.move_focus not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTextView_methods[] = {
    { "set_buffer", (PyCFunction)_wrap_gtk_text_view_set_buffer, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_buffer", (PyCFunction)_wrap_gtk_text_view_get_buffer, METH_NOARGS,
      NULL },
    { "scroll_to_iter", (PyCFunction)_wrap_gtk_text_view_scroll_to_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "scroll_to_mark", (PyCFunction)_wrap_gtk_text_view_scroll_to_mark, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "scroll_mark_onscreen", (PyCFunction)_wrap_gtk_text_view_scroll_mark_onscreen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move_mark_onscreen", (PyCFunction)_wrap_gtk_text_view_move_mark_onscreen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "place_cursor_onscreen", (PyCFunction)_wrap_gtk_text_view_place_cursor_onscreen, METH_NOARGS,
      NULL },
    { "get_visible_rect", (PyCFunction)_wrap_gtk_text_view_get_visible_rect, METH_NOARGS,
      NULL },
    { "set_cursor_visible", (PyCFunction)_wrap_gtk_text_view_set_cursor_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_cursor_visible", (PyCFunction)_wrap_gtk_text_view_get_cursor_visible, METH_NOARGS,
      NULL },
    { "get_iter_location", (PyCFunction)_wrap_gtk_text_view_get_iter_location, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_iter_at_location", (PyCFunction)_wrap_gtk_text_view_get_iter_at_location, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_iter_at_position", (PyCFunction)_wrap_gtk_text_view_get_iter_at_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_line_yrange", (PyCFunction)_wrap_gtk_text_view_get_line_yrange, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_line_at_y", (PyCFunction)_wrap_gtk_text_view_get_line_at_y, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "buffer_to_window_coords", (PyCFunction)_wrap_gtk_text_view_buffer_to_window_coords, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "window_to_buffer_coords", (PyCFunction)_wrap_gtk_text_view_window_to_buffer_coords, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_window", (PyCFunction)_wrap_gtk_text_view_get_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_window_type", (PyCFunction)_wrap_gtk_text_view_get_window_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_border_window_size", (PyCFunction)_wrap_gtk_text_view_set_border_window_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_border_window_size", (PyCFunction)_wrap_gtk_text_view_get_border_window_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_display_line", (PyCFunction)_wrap_gtk_text_view_forward_display_line, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_display_line", (PyCFunction)_wrap_gtk_text_view_backward_display_line, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "forward_display_line_end", (PyCFunction)_wrap_gtk_text_view_forward_display_line_end, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "backward_display_line_start", (PyCFunction)_wrap_gtk_text_view_backward_display_line_start, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "starts_display_line", (PyCFunction)_wrap_gtk_text_view_starts_display_line, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move_visually", (PyCFunction)_wrap_gtk_text_view_move_visually, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_child_at_anchor", (PyCFunction)_wrap_gtk_text_view_add_child_at_anchor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_child_in_window", (PyCFunction)_wrap_gtk_text_view_add_child_in_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move_child", (PyCFunction)_wrap_gtk_text_view_move_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_wrap_mode", (PyCFunction)_wrap_gtk_text_view_set_wrap_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_wrap_mode", (PyCFunction)_wrap_gtk_text_view_get_wrap_mode, METH_NOARGS,
      NULL },
    { "set_editable", (PyCFunction)_wrap_gtk_text_view_set_editable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_editable", (PyCFunction)_wrap_gtk_text_view_get_editable, METH_NOARGS,
      NULL },
    { "set_overwrite", (PyCFunction)_wrap_gtk_text_view_set_overwrite, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_overwrite", (PyCFunction)_wrap_gtk_text_view_get_overwrite, METH_NOARGS,
      NULL },
    { "set_accepts_tab", (PyCFunction)_wrap_gtk_text_view_set_accepts_tab, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_accepts_tab", (PyCFunction)_wrap_gtk_text_view_get_accepts_tab, METH_NOARGS,
      NULL },
    { "set_pixels_above_lines", (PyCFunction)_wrap_gtk_text_view_set_pixels_above_lines, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_pixels_above_lines", (PyCFunction)_wrap_gtk_text_view_get_pixels_above_lines, METH_NOARGS,
      NULL },
    { "set_pixels_below_lines", (PyCFunction)_wrap_gtk_text_view_set_pixels_below_lines, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_pixels_below_lines", (PyCFunction)_wrap_gtk_text_view_get_pixels_below_lines, METH_NOARGS,
      NULL },
    { "set_pixels_inside_wrap", (PyCFunction)_wrap_gtk_text_view_set_pixels_inside_wrap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_pixels_inside_wrap", (PyCFunction)_wrap_gtk_text_view_get_pixels_inside_wrap, METH_NOARGS,
      NULL },
    { "set_justification", (PyCFunction)_wrap_gtk_text_view_set_justification, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_justification", (PyCFunction)_wrap_gtk_text_view_get_justification, METH_NOARGS,
      NULL },
    { "set_left_margin", (PyCFunction)_wrap_gtk_text_view_set_left_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_left_margin", (PyCFunction)_wrap_gtk_text_view_get_left_margin, METH_NOARGS,
      NULL },
    { "set_right_margin", (PyCFunction)_wrap_gtk_text_view_set_right_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_right_margin", (PyCFunction)_wrap_gtk_text_view_get_right_margin, METH_NOARGS,
      NULL },
    { "set_indent", (PyCFunction)_wrap_gtk_text_view_set_indent, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_indent", (PyCFunction)_wrap_gtk_text_view_get_indent, METH_NOARGS,
      NULL },
    { "set_tabs", (PyCFunction)_wrap_gtk_text_view_set_tabs, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tabs", (PyCFunction)_wrap_gtk_text_view_get_tabs, METH_NOARGS,
      NULL },
    { "get_default_attributes", (PyCFunction)_wrap_gtk_text_view_get_default_attributes, METH_NOARGS,
      NULL },
    { "get_hadjustment", (PyCFunction)_wrap_gtk_text_view_get_hadjustment, METH_NOARGS,
      NULL },
    { "get_vadjustment", (PyCFunction)_wrap_gtk_text_view_get_vadjustment, METH_NOARGS,
      NULL },
    { "im_context_filter_keypress", (PyCFunction)_wrap_gtk_text_view_im_context_filter_keypress, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reset_im_context", (PyCFunction)_wrap_gtk_text_view_reset_im_context, METH_NOARGS,
      NULL },
    { "do_set_scroll_adjustments", (PyCFunction)_wrap_GtkTextView__do_set_scroll_adjustments, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_populate_popup", (PyCFunction)_wrap_GtkTextView__do_populate_popup, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_cursor", (PyCFunction)_wrap_GtkTextView__do_move_cursor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_page_horizontally", (PyCFunction)_wrap_GtkTextView__do_page_horizontally, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_anchor", (PyCFunction)_wrap_GtkTextView__do_set_anchor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_insert_at_cursor", (PyCFunction)_wrap_GtkTextView__do_insert_at_cursor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_delete_from_cursor", (PyCFunction)_wrap_GtkTextView__do_delete_from_cursor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_backspace", (PyCFunction)_wrap_GtkTextView__do_backspace, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_cut_clipboard", (PyCFunction)_wrap_GtkTextView__do_cut_clipboard, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_copy_clipboard", (PyCFunction)_wrap_GtkTextView__do_copy_clipboard, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_paste_clipboard", (PyCFunction)_wrap_GtkTextView__do_paste_clipboard, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toggle_overwrite", (PyCFunction)_wrap_GtkTextView__do_toggle_overwrite, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_focus", (PyCFunction)_wrap_GtkTextView__do_move_focus, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTextView_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TextView",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTextView_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_text_view_new_with_buffer,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkTextView__proxy_do_set_scroll_adjustments(GtkTextView *self, GtkAdjustment*hadjustment, GtkAdjustment*vadjustment)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_hadjustment = NULL;
    PyObject *py_vadjustment = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (hadjustment)
        py_hadjustment = pygobject_new((GObject *) hadjustment);
    else {
        Py_INCREF(Py_None);
        py_hadjustment = Py_None;
    }
    if (vadjustment)
        py_vadjustment = pygobject_new((GObject *) vadjustment);
    else {
        Py_INCREF(Py_None);
        py_vadjustment = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_hadjustment);
    PyTuple_SET_ITEM(py_args, 1, py_vadjustment);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_scroll_adjustments");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_populate_popup(GtkTextView *self, GtkMenu*menu)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_menu = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (menu)
        py_menu = pygobject_new((GObject *) menu);
    else {
        Py_INCREF(Py_None);
        py_menu = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_menu);
    
    py_method = PyObject_GetAttrString(py_self, "do_populate_popup");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_move_cursor(GtkTextView *self, GtkMovementStep step, gint count, gboolean extend_selection)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_step;
    PyObject *py_count;
    PyObject *py_extend_selection;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_step = pyg_enum_from_gtype(GTK_TYPE_MOVEMENT_STEP, step);
    if (!py_step) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_count = PyInt_FromLong(count);
    py_extend_selection = extend_selection? Py_True : Py_False;
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_step);
    PyTuple_SET_ITEM(py_args, 1, py_count);
    Py_INCREF(py_extend_selection);
    PyTuple_SET_ITEM(py_args, 2, py_extend_selection);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_cursor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_page_horizontally(GtkTextView *self, gint count, gboolean extend_selection)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_count;
    PyObject *py_extend_selection;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_count = PyInt_FromLong(count);
    py_extend_selection = extend_selection? Py_True : Py_False;
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_count);
    Py_INCREF(py_extend_selection);
    PyTuple_SET_ITEM(py_args, 1, py_extend_selection);
    
    py_method = PyObject_GetAttrString(py_self, "do_page_horizontally");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_set_anchor(GtkTextView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_set_anchor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_insert_at_cursor(GtkTextView *self, const gchar*str)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_str = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (str)
        py_str = PyString_FromString(str);
    if (!py_str) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_str);
    
    py_method = PyObject_GetAttrString(py_self, "do_insert_at_cursor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_delete_from_cursor(GtkTextView *self, GtkDeleteType type, gint count)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_type;
    PyObject *py_count;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_type = pyg_enum_from_gtype(GTK_TYPE_DELETE_TYPE, type);
    if (!py_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_count = PyInt_FromLong(count);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_type);
    PyTuple_SET_ITEM(py_args, 1, py_count);
    
    py_method = PyObject_GetAttrString(py_self, "do_delete_from_cursor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_backspace(GtkTextView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_backspace");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_cut_clipboard(GtkTextView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_cut_clipboard");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_copy_clipboard(GtkTextView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_copy_clipboard");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_paste_clipboard(GtkTextView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_paste_clipboard");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_toggle_overwrite(GtkTextView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_overwrite");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTextView__proxy_do_move_focus(GtkTextView *self, GtkDirectionType direction)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_direction;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_direction = pyg_enum_from_gtype(GTK_TYPE_DIRECTION_TYPE, direction);
    if (!py_direction) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_direction);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_focus");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkTextView_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkTextViewClass *klass = GTK_TEXT_VIEW_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_scroll_adjustments");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_scroll_adjustments")))
            klass->set_scroll_adjustments = _wrap_GtkTextView__proxy_do_set_scroll_adjustments;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_populate_popup");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "populate_popup")))
            klass->populate_popup = _wrap_GtkTextView__proxy_do_populate_popup;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_cursor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_cursor")))
            klass->move_cursor = _wrap_GtkTextView__proxy_do_move_cursor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_page_horizontally");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "page_horizontally")))
            klass->page_horizontally = _wrap_GtkTextView__proxy_do_page_horizontally;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_anchor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_anchor")))
            klass->set_anchor = _wrap_GtkTextView__proxy_do_set_anchor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_insert_at_cursor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "insert_at_cursor")))
            klass->insert_at_cursor = _wrap_GtkTextView__proxy_do_insert_at_cursor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_delete_from_cursor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "delete_from_cursor")))
            klass->delete_from_cursor = _wrap_GtkTextView__proxy_do_delete_from_cursor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_backspace");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "backspace")))
            klass->backspace = _wrap_GtkTextView__proxy_do_backspace;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_cut_clipboard");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "cut_clipboard")))
            klass->cut_clipboard = _wrap_GtkTextView__proxy_do_cut_clipboard;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_copy_clipboard");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "copy_clipboard")))
            klass->copy_clipboard = _wrap_GtkTextView__proxy_do_copy_clipboard;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_paste_clipboard");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "paste_clipboard")))
            klass->paste_clipboard = _wrap_GtkTextView__proxy_do_paste_clipboard;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_overwrite");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_overwrite")))
            klass->toggle_overwrite = _wrap_GtkTextView__proxy_do_toggle_overwrite;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_focus");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_focus")))
            klass->move_focus = _wrap_GtkTextView__proxy_do_move_focus;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkToolbar ----------- */

 static int
_wrap_gtk_toolbar_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Toolbar.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Toolbar object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_toolbar_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item", "pos", NULL };
    PyGObject *item;
    int pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Toolbar.insert", kwlist, &PyGtkToolItem_Type, &item, &pos))
        return NULL;
    
    gtk_toolbar_insert(GTK_TOOLBAR(self->obj), GTK_TOOL_ITEM(item->obj), pos);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_get_item_index(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item", NULL };
    PyGObject *item;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Toolbar.get_item_index", kwlist, &PyGtkToolItem_Type, &item))
        return NULL;
    
    ret = gtk_toolbar_get_item_index(GTK_TOOLBAR(self->obj), GTK_TOOL_ITEM(item->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_toolbar_get_n_items(PyGObject *self)
{
    int ret;

    
    ret = gtk_toolbar_get_n_items(GTK_TOOLBAR(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_toolbar_get_nth_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "n", NULL };
    int n;
    GtkToolItem *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Toolbar.get_nth_item", kwlist, &n))
        return NULL;
    
    ret = gtk_toolbar_get_nth_item(GTK_TOOLBAR(self->obj), n);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_toolbar_get_drop_index(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    int x, y, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Toolbar.get_drop_index", kwlist, &x, &y))
        return NULL;
    
    ret = gtk_toolbar_get_drop_index(GTK_TOOLBAR(self->obj), x, y);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_toolbar_set_drop_highlight_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tool_item", "index", NULL };
    GtkToolItem *tool_item = NULL;
    PyGObject *py_tool_item;
    int index;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.Toolbar.set_drop_highlight_item", kwlist, &py_tool_item, &index))
        return NULL;
    if (py_tool_item && pygobject_check(py_tool_item, &PyGtkToolItem_Type))
        tool_item = GTK_TOOL_ITEM(py_tool_item->obj);
    else if ((PyObject *)py_tool_item != Py_None) {
        PyErr_SetString(PyExc_TypeError, "tool_item should be a GtkToolItem or None");
        return NULL;
    }
    
    gtk_toolbar_set_drop_highlight_item(GTK_TOOLBAR(self->obj), (GtkToolItem *) tool_item, index);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_set_show_arrow(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_arrow", NULL };
    int show_arrow;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Toolbar.set_show_arrow", kwlist, &show_arrow))
        return NULL;
    
    gtk_toolbar_set_show_arrow(GTK_TOOLBAR(self->obj), show_arrow);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_get_show_arrow(PyGObject *self)
{
    int ret;

    
    ret = gtk_toolbar_get_show_arrow(GTK_TOOLBAR(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_toolbar_get_relief_style(PyGObject *self)
{
    gint ret;

    
    ret = gtk_toolbar_get_relief_style(GTK_TOOLBAR(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_RELIEF_STYLE, ret);
}

#line 11 "gtktoolbar.override"
static PyObject *
_wrap_gtk_toolbar_append_item(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
                              "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param = NULL, *py_ret;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOO|O:GtkToolbar.append_item", kwlist,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "forth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_append_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
                                  tooltip_private_text, icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
#line 89668 "gtk.c"


#line 51 "gtktoolbar.override"
static PyObject *
_wrap_gtk_toolbar_prepend_item(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
                              "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param, *py_ret;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOOO:GtkToolbar.prepend_item", kwlist,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "forth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_prepend_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
                                  tooltip_private_text, icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
#line 89710 "gtk.c"


#line 91 "gtktoolbar.override"
static PyObject *
_wrap_gtk_toolbar_insert_item(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
                              "icon", "callback", "user_data", "position",
                              NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param, *py_ret;
    GtkWidget *icon = NULL, *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOOOi:GtkToolbar.insert_item", kwlist,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "forth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_insert_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
                                  tooltip_private_text, icon, NULL, NULL,
                                  position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
#line 89755 "gtk.c"


#line 134 "gtktoolbar.override"
static PyObject *
_wrap_gtk_toolbar_insert_stock(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "tooltip_text", "tooltip_private_text",
                              "callback", "user_data", "position",
                              NULL };
    char *stock_id, *tooltip_text, *tooltip_private_text;
    PyObject *callback, *param, *py_ret;
    GtkWidget *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOOi:GtkToolbar.insert_stock", kwlist,
                                     &stock_id, &tooltip_text,
                                     &tooltip_private_text,
                                     &callback, &param, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;

    ret = gtk_toolbar_insert_stock(GTK_TOOLBAR(self->obj), stock_id, tooltip_text,
                                  tooltip_private_text, NULL, NULL,
                                  position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
#line 89793 "gtk.c"


static PyObject *
_wrap_gtk_toolbar_append_space(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_toolbar_append_space(GTK_TOOLBAR(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_prepend_space(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_toolbar_prepend_space(GTK_TOOLBAR(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_insert_space(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Toolbar.insert_space", kwlist, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_toolbar_insert_space(GTK_TOOLBAR(self->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_remove_space(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Toolbar.remove_space", kwlist, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_toolbar_remove_space(GTK_TOOLBAR(self->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 170 "gtktoolbar.override"
static PyObject *
_wrap_gtk_toolbar_append_element(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
                              "tooltip_private_text", "icon", "callback",
                              "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOzzzOOO:GtkToolbar.append_element",
                                     kwlist,
                                     &py_type, &py_widget,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
                           py_type, (gint *)&type))
        return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sixth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_append_element(GTK_TOOLBAR(self->obj), type, widget,
                                     text, tooltip_text, tooltip_private_text,
                                     icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
        (type == GTK_TOOLBAR_CHILD_BUTTON ||
         type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
         type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
#line 89911 "gtk.c"


#line 228 "gtktoolbar.override"
static PyObject *
_wrap_gtk_toolbar_prepend_element(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
                              "tooltip_private_text", "icon", "callback",
                              "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOzzzOOO:GtkToolbar.prepend_element",
                                     kwlist,
                                     &py_type, &py_widget,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
                           py_type, (gint *)&type))
        return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sixth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_prepend_element(GTK_TOOLBAR(self->obj), type, widget,
                                      text, tooltip_text, tooltip_private_text,
                                      icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
        (type == GTK_TOOLBAR_CHILD_BUTTON ||
         type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
         type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
#line 89971 "gtk.c"


#line 286 "gtktoolbar.override"
static PyObject *
_wrap_gtk_toolbar_insert_element(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
                              "tooltip_private_text", "icon", "callback",
                              "user_data", "position", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOzzzOOOi:GtkToolbar.insert_element",
                                     kwlist,
                                     &py_type, &py_widget,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
                           py_type, (gint *)&type))
        return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sixth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_insert_element(GTK_TOOLBAR(self->obj), type, widget,
                                     text, tooltip_text, tooltip_private_text,
                                     icon, NULL, NULL, position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
        (type == GTK_TOOLBAR_CHILD_BUTTON ||
         type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
         type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
#line 90032 "gtk.c"


static PyObject *
_wrap_gtk_toolbar_append_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "tooltip_text", "tooltip_private_text", NULL };
    PyGObject *widget;
    char *tooltip_text, *tooltip_private_text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!zz:Gtk.Toolbar.append_widget", kwlist, &PyGtkWidget_Type, &widget, &tooltip_text, &tooltip_private_text))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_toolbar_append_widget(GTK_TOOLBAR(self->obj), GTK_WIDGET(widget->obj), tooltip_text, tooltip_private_text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_prepend_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "tooltip_text", "tooltip_private_text", NULL };
    PyGObject *widget;
    char *tooltip_text, *tooltip_private_text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!zz:Gtk.Toolbar.prepend_widget", kwlist, &PyGtkWidget_Type, &widget, &tooltip_text, &tooltip_private_text))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_toolbar_prepend_widget(GTK_TOOLBAR(self->obj), GTK_WIDGET(widget->obj), tooltip_text, tooltip_private_text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_insert_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "tooltip_text", "tooltip_private_text", "position", NULL };
    PyGObject *widget;
    char *tooltip_text, *tooltip_private_text;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!zzi:Gtk.Toolbar.insert_widget", kwlist, &PyGtkWidget_Type, &widget, &tooltip_text, &tooltip_private_text, &position))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_toolbar_insert_widget(GTK_TOOLBAR(self->obj), GTK_WIDGET(widget->obj), tooltip_text, tooltip_private_text, position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_set_orientation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "orientation", NULL };
    GtkOrientation orientation;
    PyObject *py_orientation = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Toolbar.set_orientation", kwlist, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    
    gtk_toolbar_set_orientation(GTK_TOOLBAR(self->obj), orientation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_set_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "style", NULL };
    PyObject *py_style = NULL;
    GtkToolbarStyle style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Toolbar.set_style", kwlist, &py_style))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_STYLE, py_style, (gpointer)&style))
        return NULL;
    
    gtk_toolbar_set_style(GTK_TOOLBAR(self->obj), style);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_set_icon_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_size", NULL };
    PyObject *py_icon_size = NULL;
    GtkIconSize icon_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Toolbar.set_icon_size", kwlist, &py_icon_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_icon_size, (gpointer)&icon_size))
        return NULL;
    
    gtk_toolbar_set_icon_size(GTK_TOOLBAR(self->obj), icon_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_set_tooltips(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "enable", NULL };
    int enable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Toolbar.set_tooltips", kwlist, &enable))
        return NULL;
    
    gtk_toolbar_set_tooltips(GTK_TOOLBAR(self->obj), enable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_unset_style(PyGObject *self)
{
    
    gtk_toolbar_unset_style(GTK_TOOLBAR(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_unset_icon_size(PyGObject *self)
{
    
    gtk_toolbar_unset_icon_size(GTK_TOOLBAR(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_toolbar_get_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_toolbar_get_orientation(GTK_TOOLBAR(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, ret);
}

static PyObject *
_wrap_gtk_toolbar_get_style(PyGObject *self)
{
    gint ret;

    
    ret = gtk_toolbar_get_style(GTK_TOOLBAR(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_TOOLBAR_STYLE, ret);
}

static PyObject *
_wrap_gtk_toolbar_get_icon_size(PyGObject *self)
{
    gint ret;

    
    ret = gtk_toolbar_get_icon_size(GTK_TOOLBAR(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, ret);
}

static PyObject *
_wrap_gtk_toolbar_get_tooltips(PyGObject *self)
{
    int ret;

    
    ret = gtk_toolbar_get_tooltips(GTK_TOOLBAR(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkToolbar__do_orientation_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "orientation", NULL };
    PyGObject *self;
    GtkOrientation orientation;
    PyObject *py_orientation = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Toolbar.orientation_changed", kwlist, &PyGtkToolbar_Type, &self, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TOOLBAR_CLASS(klass)->orientation_changed)
        GTK_TOOLBAR_CLASS(klass)->orientation_changed(GTK_TOOLBAR(self->obj), orientation);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Toolbar.orientation_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkToolbar__do_style_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "style", NULL };
    PyGObject *self;
    PyObject *py_style = NULL;
    GtkToolbarStyle style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Toolbar.style_changed", kwlist, &PyGtkToolbar_Type, &self, &py_style))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_STYLE, py_style, (gpointer)&style))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TOOLBAR_CLASS(klass)->style_changed)
        GTK_TOOLBAR_CLASS(klass)->style_changed(GTK_TOOLBAR(self->obj), style);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Toolbar.style_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkToolbar__do_popup_context_menu(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "x", "y", "button_number", NULL };
    PyGObject *self;
    int x, y, button_number, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iii:Gtk.Toolbar.popup_context_menu", kwlist, &PyGtkToolbar_Type, &self, &x, &y, &button_number))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TOOLBAR_CLASS(klass)->popup_context_menu)
        ret = GTK_TOOLBAR_CLASS(klass)->popup_context_menu(GTK_TOOLBAR(self->obj), x, y, button_number);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Toolbar.popup_context_menu not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkToolbar_methods[] = {
    { "insert", (PyCFunction)_wrap_gtk_toolbar_insert, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_item_index", (PyCFunction)_wrap_gtk_toolbar_get_item_index, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_n_items", (PyCFunction)_wrap_gtk_toolbar_get_n_items, METH_NOARGS,
      NULL },
    { "get_nth_item", (PyCFunction)_wrap_gtk_toolbar_get_nth_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_drop_index", (PyCFunction)_wrap_gtk_toolbar_get_drop_index, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_drop_highlight_item", (PyCFunction)_wrap_gtk_toolbar_set_drop_highlight_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_show_arrow", (PyCFunction)_wrap_gtk_toolbar_set_show_arrow, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_arrow", (PyCFunction)_wrap_gtk_toolbar_get_show_arrow, METH_NOARGS,
      NULL },
    { "get_relief_style", (PyCFunction)_wrap_gtk_toolbar_get_relief_style, METH_NOARGS,
      NULL },
    { "append_item", (PyCFunction)_wrap_gtk_toolbar_append_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend_item", (PyCFunction)_wrap_gtk_toolbar_prepend_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_item", (PyCFunction)_wrap_gtk_toolbar_insert_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_stock", (PyCFunction)_wrap_gtk_toolbar_insert_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "append_space", (PyCFunction)_wrap_gtk_toolbar_append_space, METH_NOARGS,
      NULL },
    { "prepend_space", (PyCFunction)_wrap_gtk_toolbar_prepend_space, METH_NOARGS,
      NULL },
    { "insert_space", (PyCFunction)_wrap_gtk_toolbar_insert_space, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_space", (PyCFunction)_wrap_gtk_toolbar_remove_space, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "append_element", (PyCFunction)_wrap_gtk_toolbar_append_element, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend_element", (PyCFunction)_wrap_gtk_toolbar_prepend_element, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_element", (PyCFunction)_wrap_gtk_toolbar_insert_element, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "append_widget", (PyCFunction)_wrap_gtk_toolbar_append_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend_widget", (PyCFunction)_wrap_gtk_toolbar_prepend_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_widget", (PyCFunction)_wrap_gtk_toolbar_insert_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_orientation", (PyCFunction)_wrap_gtk_toolbar_set_orientation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_style", (PyCFunction)_wrap_gtk_toolbar_set_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_size", (PyCFunction)_wrap_gtk_toolbar_set_icon_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tooltips", (PyCFunction)_wrap_gtk_toolbar_set_tooltips, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unset_style", (PyCFunction)_wrap_gtk_toolbar_unset_style, METH_NOARGS,
      NULL },
    { "unset_icon_size", (PyCFunction)_wrap_gtk_toolbar_unset_icon_size, METH_NOARGS,
      NULL },
    { "get_orientation", (PyCFunction)_wrap_gtk_toolbar_get_orientation, METH_NOARGS,
      NULL },
    { "get_style", (PyCFunction)_wrap_gtk_toolbar_get_style, METH_NOARGS,
      NULL },
    { "get_icon_size", (PyCFunction)_wrap_gtk_toolbar_get_icon_size, METH_NOARGS,
      NULL },
    { "get_tooltips", (PyCFunction)_wrap_gtk_toolbar_get_tooltips, METH_NOARGS,
      NULL },
    { "do_orientation_changed", (PyCFunction)_wrap_GtkToolbar__do_orientation_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_style_changed", (PyCFunction)_wrap_GtkToolbar__do_style_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_popup_context_menu", (PyCFunction)_wrap_GtkToolbar__do_popup_context_menu, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkToolbar_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Toolbar",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkToolbar_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_toolbar_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkToolbar__proxy_do_orientation_changed(GtkToolbar *self, GtkOrientation orientation)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_orientation;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_orientation = pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, orientation);
    if (!py_orientation) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_orientation);
    
    py_method = PyObject_GetAttrString(py_self, "do_orientation_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkToolbar__proxy_do_style_changed(GtkToolbar *self, GtkToolbarStyle style)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_style;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_style = pyg_enum_from_gtype(GTK_TYPE_TOOLBAR_STYLE, style);
    if (!py_style) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_style);
    
    py_method = PyObject_GetAttrString(py_self, "do_style_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkToolbar__proxy_do_popup_context_menu(GtkToolbar *self, gint x, gint y, gint button_number)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_x;
    PyObject *py_y;
    PyObject *py_button_number;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_x = PyInt_FromLong(x);
    py_y = PyInt_FromLong(y);
    py_button_number = PyInt_FromLong(button_number);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_x);
    PyTuple_SET_ITEM(py_args, 1, py_y);
    PyTuple_SET_ITEM(py_args, 2, py_button_number);
    
    py_method = PyObject_GetAttrString(py_self, "do_popup_context_menu");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkToolbar_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkToolbarClass *klass = GTK_TOOLBAR_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_orientation_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "orientation_changed")))
            klass->orientation_changed = _wrap_GtkToolbar__proxy_do_orientation_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_style_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "style_changed")))
            klass->style_changed = _wrap_GtkToolbar__proxy_do_style_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_popup_context_menu");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "popup_context_menu")))
            klass->popup_context_menu = _wrap_GtkToolbar__proxy_do_popup_context_menu;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkTooltips ----------- */

static int
_wrap_gtk_tooltips_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (PyErr_Warn(PyExc_DeprecationWarning, "Use the new widget gtk.Tooltip") < 0)
        return -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Tooltips.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Tooltips object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_tooltips_enable(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "Use the new widget gtk.Tooltip") < 0)
        return NULL;
    
    gtk_tooltips_enable(GTK_TOOLTIPS(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltips_disable(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "Use the new widget gtk.Tooltip") < 0)
        return NULL;
    
    gtk_tooltips_disable(GTK_TOOLTIPS(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltips_set_delay(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "delay", NULL };
    PyObject *py_delay = NULL;
    guint delay = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Tooltips.set_delay", kwlist, &py_delay))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "Use the new widget gtk.Tooltip") < 0)
        return NULL;
    if (py_delay) {
        if (PyLong_Check(py_delay))
            delay = PyLong_AsUnsignedLong(py_delay);
        else if (PyInt_Check(py_delay))
            delay = PyInt_AsLong(py_delay);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'delay' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_tooltips_set_delay(GTK_TOOLTIPS(self->obj), delay);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltips_set_tip(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "tip_text", "tip_private", NULL };
    PyGObject *widget;
    char *tip_text, *tip_private = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!z|z:Gtk.Tooltips.set_tip", kwlist, &PyGtkWidget_Type, &widget, &tip_text, &tip_private))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "Use the new widget gtk.Tooltip") < 0)
        return NULL;
    
    gtk_tooltips_set_tip(GTK_TOOLTIPS(self->obj), GTK_WIDGET(widget->obj), tip_text, tip_private);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltips_force_window(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "Use the new widget gtk.Tooltip") < 0)
        return NULL;
    
    gtk_tooltips_force_window(GTK_TOOLTIPS(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTooltips_methods[] = {
    { "enable", (PyCFunction)_wrap_gtk_tooltips_enable, METH_NOARGS,
      NULL },
    { "disable", (PyCFunction)_wrap_gtk_tooltips_disable, METH_NOARGS,
      NULL },
    { "set_delay", (PyCFunction)_wrap_gtk_tooltips_set_delay, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tip", (PyCFunction)_wrap_gtk_tooltips_set_tip, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "force_window", (PyCFunction)_wrap_gtk_tooltips_force_window, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

static PyObject *
_wrap_gtk_tooltips__get_tip_window(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_TOOLTIPS(pygobject_get(self))->tip_window;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tooltips__get_tip_label(PyObject *self, void *closure)
{
    GtkWidget *ret;

    ret = GTK_TOOLTIPS(pygobject_get(self))->tip_label;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 3211 "./gtk.override"
static PyObject *
_wrap_gtk_tooltips__get_active_tips_data(PyGObject *self, void *closure)
{
    GtkTooltips *tips = GTK_TOOLTIPS(self->obj);
    GtkTooltipsData *data = tips->active_tips_data;

    if (data == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return Py_BuildValue("NNss",
                         pygobject_new((GObject *)data->tooltips),
                         pygobject_new((GObject *)data->widget),
                         data->tip_text,
                         data->tip_private);
}
#line 90829 "gtk.c"


#line 3230 "./gtk.override"
static PyObject *
_wrap_gtk_tooltips__get_tips_data_list(PyGObject *self, void *closure)
{
    return PyList_New(0);
}
#line 90838 "gtk.c"


static PyObject *
_wrap_gtk_tooltips__get_delay(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_TOOLTIPS(pygobject_get(self))->delay;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_tooltips__get_enabled(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_TOOLTIPS(pygobject_get(self))->enabled;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_tooltips__get_use_sticky_delay(PyObject *self, void *closure)
{
    guint ret;

    ret = GTK_TOOLTIPS(pygobject_get(self))->use_sticky_delay;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_tooltips__get_timer_tag(PyObject *self, void *closure)
{
    int ret;

    ret = GTK_TOOLTIPS(pygobject_get(self))->timer_tag;
    return PyInt_FromLong(ret);
}

static const PyGetSetDef gtk_tooltips_getsets[] = {
    { "tip_window", (getter)_wrap_gtk_tooltips__get_tip_window, (setter)0 },
    { "tip_label", (getter)_wrap_gtk_tooltips__get_tip_label, (setter)0 },
    { "active_tips_data", (getter)_wrap_gtk_tooltips__get_active_tips_data, (setter)0 },
    { "tips_data_list", (getter)_wrap_gtk_tooltips__get_tips_data_list, (setter)0 },
    { "delay", (getter)_wrap_gtk_tooltips__get_delay, (setter)0 },
    { "enabled", (getter)_wrap_gtk_tooltips__get_enabled, (setter)0 },
    { "use_sticky_delay", (getter)_wrap_gtk_tooltips__get_use_sticky_delay, (setter)0 },
    { "timer_tag", (getter)_wrap_gtk_tooltips__get_timer_tag, (setter)0 },
    { NULL, (getter)0, (setter)0 },
};

PyTypeObject G_GNUC_INTERNAL PyGtkTooltips_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Tooltips",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTooltips_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)gtk_tooltips_getsets,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tooltips_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTreeModelFilter ----------- */

#line 2890 "gtktreeview.override"
static gboolean
pygtk_tree_model_filter_visible_cb(GtkTreeModel *model, GtkTreeIter *iter,
				   gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *py_model, *py_iter, *retobj;
    gboolean ret = FALSE;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_model = pygobject_new((GObject *)model);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter,  FALSE, FALSE);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNO)", py_model,
                                     py_iter, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NN)", py_model,
                                     py_iter);
    }
    if (retobj)
        ret = retobj == Py_True ? TRUE : FALSE;
    if (PyErr_Occurred()) {
        PyErr_Print();
    }
    Py_XDECREF(retobj);

    pyg_gil_state_release(state);
    return ret;    
}
static PyObject *
_wrap_gtk_tree_model_filter_set_visible_func(PyGObject *self, PyObject *args,
					     PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|O:GtkTreeModelFilter.set_visible_func",
				     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }
    cunote = g_new(PyGtkCustomNotify, 1);
    Py_INCREF(pyfunc);
    cunote->func = pyfunc;
    Py_XINCREF(pyarg);
    cunote->data = pyarg;

    gtk_tree_model_filter_set_visible_func(GTK_TREE_MODEL_FILTER(self->obj),
					   pygtk_tree_model_filter_visible_cb,
					   (gpointer)cunote,
					   pygtk_custom_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 91002 "gtk.c"


#line 3224 "gtktreeview.override"
static void
pygtk_filter_modify_func_marshal(GtkTreeModel *model, GtkTreeIter *iter,
                                 GValue *value, gint column, gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *py_value, *py_model, *py_iter;

    g_assert (cunote->func);

    state = pyg_gil_state_ensure();

    py_model = pygobject_new((GObject *)model);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter,  FALSE, FALSE);
    if (cunote->data)
        py_value = PyEval_CallFunction(cunote->func, "(NNiO)",
                                     py_model, py_iter, column, cunote->data);
    else
        py_value = PyEval_CallFunction(cunote->func, "(NNi)",
                                     py_model, py_iter, column);

    if (PyErr_Occurred()) {
        PyErr_Print();
    } else if (pyg_value_from_pyobject(value, py_value)) {
        PyErr_Format(PyExc_TypeError,
                     "value is of the wrong type for column %i", column);
        PyErr_Print();
    }

    Py_XDECREF(py_value);

    pyg_gil_state_release(state);
}

static PyObject *
_wrap_gtk_tree_model_filter_set_modify_func(PyGObject *self, PyObject *args,
                                            PyObject *kwargs)
{
    static char *kwlist[] = { "types", "func", "data", NULL };
    GType *types;
    PyObject *py_types, *py_func, *py_arg = NULL;
    PyGtkCustomNotify *cunote;
    gint tlen, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO|O:GtkTreeModelFilter.set_modify_func",
				     kwlist, &py_types, &py_func, &py_arg))
        return NULL;

    if (!PyCallable_Check(py_func)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }
    if (!PySequence_Check(py_types) || (tlen = PySequence_Size(py_types)) <= 0) {
        PyErr_SetString(PyExc_TypeError,
                        "types must be a tuple containing one or more arguments");
        return NULL;
    }

    types = g_new0(GType, tlen);
    for (i = 0; i < tlen; i++) {
        PyObject *item = PySequence_GetItem(py_types, i);

        types[i] = pyg_type_from_object(item);
        if (types[i] == 0) {
            Py_DECREF(item);
            g_free(types);
            return NULL;
        }
        Py_DECREF(item);
    }

    cunote = g_new(PyGtkCustomNotify, 1);
    Py_INCREF(py_func);
    cunote->func = py_func;
    Py_XINCREF(py_arg);
    cunote->data = py_arg;

    gtk_tree_model_filter_set_modify_func(GTK_TREE_MODEL_FILTER(self->obj),
                                          tlen, types,
                                          pygtk_filter_modify_func_marshal,
                                          cunote,
                                          pygtk_custom_destroy_notify);

    g_free(types);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 91095 "gtk.c"


static PyObject *
_wrap_gtk_tree_model_filter_set_visible_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeModelFilter.set_visible_column", kwlist, &column))
        return NULL;
    
    gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_model_filter_get_model(PyGObject *self)
{
    GtkTreeModel *ret;

    
    ret = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 2955 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_filter_convert_child_iter_to_iter(PyGObject *self,
						     PyObject *args,
						     PyObject *kwargs)
{
    static char *kwlist[] = { "child_iter", NULL };
    PyObject *py_child_iter;
    GtkTreeIter iter, *child_iter;
    GtkTreePath *child_path, *path;
    GtkTreeModel *child_model;
    GtkTreeModelFilter *filter = GTK_TREE_MODEL_FILTER(self->obj);

    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "O:GtkTreeModelFilter.convert_child_iter_to_iter",
	kwlist, &py_child_iter))
        return NULL;
    if (pyg_boxed_check(py_child_iter, GTK_TYPE_TREE_ITER))
        child_iter = pyg_boxed_get(py_child_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "child_iter should be a GtkTreeIter");
        return NULL;
    }

    child_model = gtk_tree_model_filter_get_model(filter);
    child_path = gtk_tree_model_get_path(child_model, child_iter);
    if (child_path == NULL) {
        PyErr_SetString(PyExc_ValueError, "child_iter invalid");
        return NULL;
    }
	
    path = gtk_tree_model_filter_convert_child_path_to_path(filter,
							    child_path);
    gtk_tree_path_free (child_path);
    if (path == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "couldn't convert child_iter");
        return NULL;
    }
    
    gtk_tree_model_filter_convert_child_iter_to_iter(
	GTK_TREE_MODEL_FILTER(self->obj), &iter, child_iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 91168 "gtk.c"


#line 2999 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_filter_convert_iter_to_child_iter(PyGObject *self,
						     PyObject *args,
						     PyObject *kwargs)
{
    static char *kwlist[] = { "filter_iter", NULL };
    PyObject *py_filter_iter;
    GtkTreeIter iter, *filter_iter;

    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "O:GtkTreeModelFilter.convert_iter_to_child_iter",
	kwlist, &py_filter_iter))
        return NULL;
    if (pyg_boxed_check(py_filter_iter, GTK_TYPE_TREE_ITER))
        filter_iter = pyg_boxed_get(py_filter_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError,
			"filter_iter should be a GtkTreeIter");
        return NULL;
    }
    gtk_tree_model_filter_convert_iter_to_child_iter(
	GTK_TREE_MODEL_FILTER(self->obj), &iter, filter_iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 91196 "gtk.c"


static PyObject *
_wrap_gtk_tree_model_filter_convert_child_path_to_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child_path", NULL };
    PyObject *py_child_path;
    GtkTreePath *child_path, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModelFilter.convert_child_path_to_path", kwlist, &py_child_path))
        return NULL;
    child_path = pygtk_tree_path_from_pyobject(py_child_path);
    if (!child_path) {
        PyErr_SetString(PyExc_TypeError, "could not convert child_path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_model_filter_convert_child_path_to_path(GTK_TREE_MODEL_FILTER(self->obj), child_path);
    
    if (child_path)
        gtk_tree_path_free(child_path);
    if (ret) {
        PyObject *py_ret = pygtk_tree_path_to_pyobject(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_model_filter_convert_path_to_child_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filter_path", NULL };
    PyObject *py_filter_path;
    GtkTreePath *filter_path, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModelFilter.convert_path_to_child_path", kwlist, &py_filter_path))
        return NULL;
    filter_path = pygtk_tree_path_from_pyobject(py_filter_path);
    if (!filter_path) {
        PyErr_SetString(PyExc_TypeError, "could not convert filter_path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_model_filter_convert_path_to_child_path(GTK_TREE_MODEL_FILTER(self->obj), filter_path);
    
    if (filter_path)
        gtk_tree_path_free(filter_path);
    if (ret) {
        PyObject *py_ret = pygtk_tree_path_to_pyobject(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_model_filter_refilter(PyGObject *self)
{
    
    gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_model_filter_clear_cache(PyGObject *self)
{
    
    gtk_tree_model_filter_clear_cache(GTK_TREE_MODEL_FILTER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTreeModelFilter_methods[] = {
    { "set_visible_func", (PyCFunction)_wrap_gtk_tree_model_filter_set_visible_func, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_modify_func", (PyCFunction)_wrap_gtk_tree_model_filter_set_modify_func, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_visible_column", (PyCFunction)_wrap_gtk_tree_model_filter_set_visible_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_model", (PyCFunction)_wrap_gtk_tree_model_filter_get_model, METH_NOARGS,
      NULL },
    { "convert_child_iter_to_iter", (PyCFunction)_wrap_gtk_tree_model_filter_convert_child_iter_to_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_iter_to_child_iter", (PyCFunction)_wrap_gtk_tree_model_filter_convert_iter_to_child_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_child_path_to_path", (PyCFunction)_wrap_gtk_tree_model_filter_convert_child_path_to_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_path_to_child_path", (PyCFunction)_wrap_gtk_tree_model_filter_convert_path_to_child_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "refilter", (PyCFunction)_wrap_gtk_tree_model_filter_refilter, METH_NOARGS,
      NULL },
    { "clear_cache", (PyCFunction)_wrap_gtk_tree_model_filter_clear_cache, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeModelFilter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeModelFilter",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeModelFilter_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTreeModelSort ----------- */

static int
_wrap_gtk_tree_model_sort_new_with_model(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"child_model", NULL };
    char *prop_names[] = {"model", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:gtk.TreeModelSort.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.TreeModelSort object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_tree_model_sort_get_model(PyGObject *self)
{
    GtkTreeModel *ret;

    
    ret = gtk_tree_model_sort_get_model(GTK_TREE_MODEL_SORT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tree_model_sort_convert_child_path_to_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child_path", NULL };
    PyObject *py_child_path;
    GtkTreePath *child_path, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModelSort.convert_child_path_to_path", kwlist, &py_child_path))
        return NULL;
    child_path = pygtk_tree_path_from_pyobject(py_child_path);
    if (!child_path) {
        PyErr_SetString(PyExc_TypeError, "could not convert child_path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_model_sort_convert_child_path_to_path(GTK_TREE_MODEL_SORT(self->obj), child_path);
    
    if (child_path)
        gtk_tree_path_free(child_path);
    if (ret) {
        PyObject *py_ret = pygtk_tree_path_to_pyobject(ret);
        gtk_tree_path_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2582 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_sort_convert_child_iter_to_iter(PyGObject *self,
						     PyObject *args,
						     PyObject *kwargs)
{
    static char *kwlist[] = { "sort_iter", "child_iter", NULL };
    PyObject *py_sort_iter = Py_None, *py_child_iter;
    GtkTreeIter iter, *sort_iter, *child_iter = NULL;

    sort_iter = &iter;
    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "OO:GtkTreeModelSort.convert_child_iter_to_iter",
	kwlist, &py_sort_iter, &py_child_iter))
        return NULL;
    if (pyg_boxed_check(py_sort_iter, GTK_TYPE_TREE_ITER))
        sort_iter = pyg_boxed_get(py_sort_iter, GtkTreeIter);
    else if (py_sort_iter != Py_None) {
        PyErr_SetString(PyExc_TypeError,
			"sort_iter should be a GtkTreeIter or None");
        return NULL;
    }
    if (pyg_boxed_check(py_child_iter, GTK_TYPE_TREE_ITER))
        child_iter = pyg_boxed_get(py_child_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "child_iter should be a GtkTreeIter");
        return NULL;
    }
    gtk_tree_model_sort_convert_child_iter_to_iter(
	GTK_TREE_MODEL_SORT(self->obj), sort_iter, child_iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, sort_iter, TRUE, TRUE);
}
#line 91448 "gtk.c"


static PyObject *
_wrap_gtk_tree_model_sort_convert_path_to_child_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sorted_path", NULL };
    PyObject *py_sorted_path;
    GtkTreePath *sorted_path, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModelSort.convert_path_to_child_path", kwlist, &py_sorted_path))
        return NULL;
    sorted_path = pygtk_tree_path_from_pyobject(py_sorted_path);
    if (!sorted_path) {
        PyErr_SetString(PyExc_TypeError, "could not convert sorted_path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_model_sort_convert_path_to_child_path(GTK_TREE_MODEL_SORT(self->obj), sorted_path);
    
    if (sorted_path)
        gtk_tree_path_free(sorted_path);
    if (ret) {
        PyObject *py_ret = pygtk_tree_path_to_pyobject(ret);
        gtk_tree_path_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2615 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_sort_convert_iter_to_child_iter(PyGObject *self,
						     PyObject *args,
						     PyObject *kwargs)
{
    static char *kwlist[] = { "child_iter", "sorted_iter", NULL };
    PyObject *py_child_iter = Py_None, *py_sorted_iter;
    GtkTreeIter iter, *child_iter, *sorted_iter = NULL;

    child_iter = &iter;
    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "OO:GtkTreeModelSort.convert_iter_to_child_iter",
	kwlist, &py_child_iter, &py_sorted_iter))
        return NULL;
    if (pyg_boxed_check(py_child_iter, GTK_TYPE_TREE_ITER))
        child_iter = pyg_boxed_get(py_child_iter, GtkTreeIter);
    else if (py_child_iter != Py_None) {
        PyErr_SetString(PyExc_TypeError,
			"child_iter should be a GtkTreeIter or None");
        return NULL;
    }
    if (pyg_boxed_check(py_sorted_iter, GTK_TYPE_TREE_ITER))
        sorted_iter = pyg_boxed_get(py_sorted_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError,
			"sorted_iter should be a GtkTreeIter");
        return NULL;
    }
    gtk_tree_model_sort_convert_iter_to_child_iter(
	GTK_TREE_MODEL_SORT(self->obj), child_iter, sorted_iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, child_iter, TRUE, TRUE);
}
#line 91512 "gtk.c"


static PyObject *
_wrap_gtk_tree_model_sort_reset_default_sort_func(PyGObject *self)
{
    
    gtk_tree_model_sort_reset_default_sort_func(GTK_TREE_MODEL_SORT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_model_sort_clear_cache(PyGObject *self)
{
    
    gtk_tree_model_sort_clear_cache(GTK_TREE_MODEL_SORT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_model_sort_iter_is_valid(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModelSort.iter_is_valid", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_tree_model_sort_iter_is_valid(GTK_TREE_MODEL_SORT(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkTreeModelSort_methods[] = {
    { "get_model", (PyCFunction)_wrap_gtk_tree_model_sort_get_model, METH_NOARGS,
      NULL },
    { "convert_child_path_to_path", (PyCFunction)_wrap_gtk_tree_model_sort_convert_child_path_to_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_child_iter_to_iter", (PyCFunction)_wrap_gtk_tree_model_sort_convert_child_iter_to_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_path_to_child_path", (PyCFunction)_wrap_gtk_tree_model_sort_convert_path_to_child_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_iter_to_child_iter", (PyCFunction)_wrap_gtk_tree_model_sort_convert_iter_to_child_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reset_default_sort_func", (PyCFunction)_wrap_gtk_tree_model_sort_reset_default_sort_func, METH_NOARGS,
      NULL },
    { "clear_cache", (PyCFunction)_wrap_gtk_tree_model_sort_clear_cache, METH_NOARGS,
      NULL },
    { "iter_is_valid", (PyCFunction)_wrap_gtk_tree_model_sort_iter_is_valid, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeModelSort_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeModelSort",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeModelSort_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tree_model_sort_new_with_model,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTreeSelection ----------- */

static PyObject *
_wrap_gtk_tree_selection_set_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    PyObject *py_type = NULL;
    GtkSelectionMode type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeSelection.set_mode", kwlist, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SELECTION_MODE, py_type, (gpointer)&type))
        return NULL;
    
    gtk_tree_selection_set_mode(GTK_TREE_SELECTION(self->obj), type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_selection_get_mode(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tree_selection_get_mode(GTK_TREE_SELECTION(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SELECTION_MODE, ret);
}

#line 644 "gtktreeview.override"
static gboolean
pygtk_tree_selection_marshal(GtkTreeSelection *selection,
                             GtkTreeModel *model,
                             GtkTreePath *path,
                             gboolean path_currently_selected,
                             gpointer data)
{
    PyGILState_STATE state;
    gboolean retval = FALSE;
    PyGtkCustomNotify *cunote = data;
    PyObject *pypath, *retobj;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    pypath = pygtk_tree_path_to_pyobject(path);
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NO)", pypath,
                                     cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(N)", pypath);

    if (retobj == NULL) {
        PyErr_Print();
    }

    Py_DECREF(pypath);
    if (retobj) {
        if(retobj == Py_None);
        else if(PyInt_Check(retobj))
            retval = PyInt_AsLong(retobj) && TRUE;
        else if(PyLong_Check(retobj))
            retval = PyLong_AsLongLong(retobj) && TRUE;
        else if(PyString_Check(retobj))
            retval = PyString_GET_SIZE(retobj) && TRUE;

        Py_DECREF(retobj);
    }


    pyg_gil_state_release(state);

    return retval;
}
static gboolean
pygtk_tree_selection_marshal_full(GtkTreeSelection *selection,
                                  GtkTreeModel *model,
                                  GtkTreePath *path,
                                  gboolean path_currently_selected,
                                  gpointer data)
{
    PyGILState_STATE state;
    gboolean retval = FALSE;
    PyGtkCustomNotify *cunote = data;
    PyObject *pyselection, *pymodel, *pypath, *retobj;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    pyselection = pygobject_new((GObject*)selection);
    pymodel = pygobject_new((GObject*)model);
    pypath = pygtk_tree_path_to_pyobject(path);
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NNNNO)", pyselection,
                                     pymodel, pypath,
                                     PyBool_FromLong(path_currently_selected),
                                     cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(NNNN)", pyselection,
                                     pymodel, pypath,
                                     PyBool_FromLong(path_currently_selected));

    if (retobj == NULL) {
        PyErr_Print();
    }

    Py_DECREF(pypath);
    if (retobj) {
        if(retobj == Py_None);
        else if(PyInt_Check(retobj))
            retval = PyInt_AsLong(retobj) && TRUE;
        else if(PyLong_Check(retobj))
            retval = PyLong_AsLongLong(retobj) && TRUE;
        else if(PyString_Check(retobj))
            retval = PyString_GET_SIZE(retobj) && TRUE;

        Py_DECREF(retobj);
    }


    pyg_gil_state_release(state);

    return retval;
}
static PyObject *
_wrap_gtk_tree_selection_set_select_function(PyGObject *self, PyObject *args,
                                             PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", "full", NULL };
    PyObject *pyfunc, *pyarg = NULL, *pyfull = Py_False;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OO:GtkTreeSelection.set_select_function",
                                     kwlist, &pyfunc, &pyarg, &pyfull))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
    if (PyObject_IsTrue(pyfull))
        gtk_tree_selection_set_select_function(GTK_TREE_SELECTION(self->obj),
                                               pygtk_tree_selection_marshal_full,
                                               cunote,
                                               pygtk_custom_destroy_notify);
    else
        gtk_tree_selection_set_select_function(GTK_TREE_SELECTION(self->obj),
                                               pygtk_tree_selection_marshal,
                                               cunote,
                                               pygtk_custom_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 91787 "gtk.c"


static PyObject *
_wrap_gtk_tree_selection_get_tree_view(PyGObject *self)
{
    GtkTreeView *ret;

    
    ret = gtk_tree_selection_get_tree_view(GTK_TREE_SELECTION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 537 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_selection_get_selected(PyGObject *self)
{
    GtkTreeModel *model;
    GtkTreeIter iter;
    GtkSelectionMode mode;

    mode = gtk_tree_selection_get_mode(GTK_TREE_SELECTION(self->obj));
    if (mode == GTK_SELECTION_MULTIPLE) {
        PyErr_SetString(PyExc_TypeError,
                        "GtkTreeSelection.get_selected can not be used when"
                        " selection mode is gtk.SELECTION_MULTIPLE");
        return NULL;
    }

    if (gtk_tree_selection_get_selected(GTK_TREE_SELECTION(self->obj),
                                        &model, &iter)) {
        return Py_BuildValue("(NN)",
                             pygobject_new((GObject *)model),
                             pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter,
                                           TRUE, TRUE));
    } else {
	return Py_BuildValue ("(NO)",
                              pygobject_new((GObject *)model),
                              Py_None);
    }
}
#line 91830 "gtk.c"


#line 566 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_selection_get_selected_rows(PyGObject *self)
{
    GtkTreeModel *model = NULL;
    GList *selected, *tmp;
    PyObject *py_selected;

    selected = gtk_tree_selection_get_selected_rows
	(GTK_TREE_SELECTION(self->obj), &model);
    py_selected = PyList_New(0);
    for (tmp = selected; tmp != NULL; tmp = tmp->next) {
	GtkTreePath *path = tmp->data;
	PyObject *item = pygtk_tree_path_to_pyobject(path);

	PyList_Append(py_selected, item);
	Py_DECREF(item);
	gtk_tree_path_free(path);
    }
    g_list_free(selected);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)model), py_selected);
}
#line 91855 "gtk.c"


static PyObject *
_wrap_gtk_tree_selection_count_selected_rows(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_selection_count_selected_rows(GTK_TREE_SELECTION(self->obj));
    
    return PyInt_FromLong(ret);
}

#line 589 "gtktreeview.override"

static void
pygtk_tree_selection_foreach_marshal(GtkTreeModel *model,
                                     GtkTreePath *path,
                                     GtkTreeIter *iter,
                                     gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *py_model, *py_path, *py_iter, *retobj;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_model = pygobject_new((GObject *)model);
    py_path = pygtk_tree_path_to_pyobject(path);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NNOO)",
                                     py_model, py_path, py_iter,
                                     cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(NNO)",
                                     py_model, py_path, py_iter);

    if (retobj == NULL) {
        PyErr_Print();
    }
    pygtk_boxed_unref_shared(py_iter);
    Py_XDECREF(retobj);

    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_tree_selection_selected_foreach(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;

    if(!PyArg_ParseTuple(args, "O|O:GtkTreeSelection.selected_foreach",
                         &pyfunc, &pyarg))
        return NULL;

    cunote.func = pyfunc;
    cunote.data = pyarg;
    gtk_tree_selection_selected_foreach(GTK_TREE_SELECTION(self->obj),
                                        pygtk_tree_selection_foreach_marshal,
                                        &cunote);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 91923 "gtk.c"


static PyObject *
_wrap_gtk_tree_selection_select_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeSelection.select_path", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_tree_selection_select_path(GTK_TREE_SELECTION(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_selection_unselect_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeSelection.unselect_path", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_tree_selection_unselect_path(GTK_TREE_SELECTION(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_selection_select_iter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeSelection.select_iter", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_tree_selection_select_iter(GTK_TREE_SELECTION(self->obj), iter);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_selection_unselect_iter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeSelection.unselect_iter", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_tree_selection_unselect_iter(GTK_TREE_SELECTION(self->obj), iter);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_selection_path_is_selected(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    int ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeSelection.path_is_selected", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_selection_path_is_selected(GTK_TREE_SELECTION(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_selection_iter_is_selected(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeSelection.iter_is_selected", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_tree_selection_iter_is_selected(GTK_TREE_SELECTION(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

#line 3160 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_selection_select_all(PyGObject *self)
{
    GtkSelectionMode mode;
 
    mode = gtk_tree_selection_get_mode(GTK_TREE_SELECTION(self->obj));
    if (mode != GTK_SELECTION_MULTIPLE) {
        PyErr_SetString(PyExc_TypeError,
                        "gtk.TreeSelection.select_all requires that"
                        " selection mode is gtk.SELECTION_MULTIPLE");
        return NULL;
    }
 
    gtk_tree_selection_select_all(GTK_TREE_SELECTION(self->obj));
    Py_INCREF(Py_None);
    return Py_None;
}
#line 92081 "gtk.c"


static PyObject *
_wrap_gtk_tree_selection_unselect_all(PyGObject *self)
{
    
    gtk_tree_selection_unselect_all(GTK_TREE_SELECTION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3179 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_selection_select_range(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "start_path", "end_path", NULL };
    PyObject *py_start_path, *py_end_path;
    GtkTreePath *start_path, *end_path;
    GtkSelectionMode mode;

    mode = gtk_tree_selection_get_mode(GTK_TREE_SELECTION(self->obj));
    if (mode != GTK_SELECTION_MULTIPLE) {
        PyErr_SetString(PyExc_TypeError,
                        "gtk.TreeSelection.select_range requires that"
                        " selection mode is gtk.SELECTION_MULTIPLE");
        return NULL;
    }

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:GtkTreeSelection.select_range",
                                     kwlist, &py_start_path, &py_end_path))
        return NULL;
    start_path = pygtk_tree_path_from_pyobject(py_start_path);
    if (!start_path) {
        PyErr_SetString(PyExc_TypeError,
                        "could not convert start_path to a GtkTreePath");
        return NULL;
    }
    end_path = pygtk_tree_path_from_pyobject(py_end_path);
    if (!end_path) {
        gtk_tree_path_free(start_path);
        PyErr_SetString(PyExc_TypeError,
                        "could not convert end_path to a GtkTreePath");
        return NULL;
    }
    gtk_tree_selection_select_range(GTK_TREE_SELECTION(self->obj),
                                    start_path, end_path);

    gtk_tree_path_free(start_path);
    gtk_tree_path_free(end_path);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 92138 "gtk.c"


static PyObject *
_wrap_gtk_tree_selection_unselect_range(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_path", "end_path", NULL };
    PyObject *py_start_path, *py_end_path;
    GtkTreePath *start_path, *end_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeSelection.unselect_range", kwlist, &py_start_path, &py_end_path))
        return NULL;
    start_path = pygtk_tree_path_from_pyobject(py_start_path);
    if (!start_path) {
        PyErr_SetString(PyExc_TypeError, "could not convert start_path to a GtkTreePath");
        return NULL;
    }
    end_path = pygtk_tree_path_from_pyobject(py_end_path);
    if (!end_path) {
        PyErr_SetString(PyExc_TypeError, "could not convert end_path to a GtkTreePath");
        return NULL;
    }
    
    gtk_tree_selection_unselect_range(GTK_TREE_SELECTION(self->obj), start_path, end_path);
    
    if (start_path)
        gtk_tree_path_free(start_path);
    if (end_path)
        gtk_tree_path_free(end_path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeSelection__do_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeSelection.changed", kwlist, &PyGtkTreeSelection_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_SELECTION_CLASS(klass)->changed)
        GTK_TREE_SELECTION_CLASS(klass)->changed(GTK_TREE_SELECTION(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeSelection.changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTreeSelection_methods[] = {
    { "set_mode", (PyCFunction)_wrap_gtk_tree_selection_set_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_mode", (PyCFunction)_wrap_gtk_tree_selection_get_mode, METH_NOARGS,
      NULL },
    { "set_select_function", (PyCFunction)_wrap_gtk_tree_selection_set_select_function, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tree_view", (PyCFunction)_wrap_gtk_tree_selection_get_tree_view, METH_NOARGS,
      NULL },
    { "get_selected", (PyCFunction)_wrap_gtk_tree_selection_get_selected, METH_NOARGS,
      NULL },
    { "get_selected_rows", (PyCFunction)_wrap_gtk_tree_selection_get_selected_rows, METH_NOARGS,
      NULL },
    { "count_selected_rows", (PyCFunction)_wrap_gtk_tree_selection_count_selected_rows, METH_NOARGS,
      NULL },
    { "selected_foreach", (PyCFunction)_wrap_gtk_tree_selection_selected_foreach, METH_VARARGS,
      NULL },
    { "select_path", (PyCFunction)_wrap_gtk_tree_selection_select_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_path", (PyCFunction)_wrap_gtk_tree_selection_unselect_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_iter", (PyCFunction)_wrap_gtk_tree_selection_select_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_iter", (PyCFunction)_wrap_gtk_tree_selection_unselect_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "path_is_selected", (PyCFunction)_wrap_gtk_tree_selection_path_is_selected, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "iter_is_selected", (PyCFunction)_wrap_gtk_tree_selection_iter_is_selected, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_all", (PyCFunction)_wrap_gtk_tree_selection_select_all, METH_NOARGS,
      NULL },
    { "unselect_all", (PyCFunction)_wrap_gtk_tree_selection_unselect_all, METH_NOARGS,
      NULL },
    { "select_range", (PyCFunction)_wrap_gtk_tree_selection_select_range, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_range", (PyCFunction)_wrap_gtk_tree_selection_unselect_range, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_changed", (PyCFunction)_wrap_GtkTreeSelection__do_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeSelection_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeSelection",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeSelection_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkTreeSelection__proxy_do_changed(GtkTreeSelection *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkTreeSelection_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkTreeSelectionClass *klass = GTK_TREE_SELECTION_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "changed")))
            klass->changed = _wrap_GtkTreeSelection__proxy_do_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkTreeStore ----------- */

#line 1959 "gtktreeview.override"
static int
_wrap_gtk_tree_store_new(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    if (len == 0) {
        PyErr_SetString(PyExc_TypeError, "GtkTreeStore requires at least one argument");
        return -1;
    }

    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
        PyObject *item = PyTuple_GetItem(args, i);

        column_types[i] = pyg_type_from_object(item);
        if (column_types[i] == 0) {
            g_free(column_types);
            return -1;
        }
    }

    pygobject_construct(self, NULL);
    gtk_tree_store_set_column_types(GTK_TREE_STORE(self->obj), len, column_types);
    g_free(column_types);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkTreeStore object");
        return -1;
    }
    return 0;
}
#line 92390 "gtk.c"


#line 3638 "gtktreeview.override"
static PyObject*
_wrap_gtk_tree_store_set_column_types(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    if (len == 0) {
        PyErr_SetString(PyExc_TypeError,
                        "GtkTreeStore set_column_types requires at least one argument");
        return NULL;
    }

    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
        PyObject *item = PyTuple_GetItem(args, i);

        column_types[i] = pyg_type_from_object(item);
        if (column_types[i] == 0) {
            g_free(column_types);
	    return NULL;
        }
    }
    
    gtk_tree_store_set_column_types(GTK_TREE_STORE(self->obj), len,
                                    column_types);
    g_free(column_types);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 92425 "gtk.c"


#line 2056 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_store_set_value(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *pyvalue;
    gint column;
    GValue value = { 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OiO:GtkTreeStore.set_value",
                                     kwlist, &iter, &column, &pyvalue))
        return NULL;
    if (column < 0 ||
        column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
        PyErr_SetString(PyExc_ValueError, "column number is out of range");
        return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
        PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
        return NULL;
    }
    g_value_init(&value,
                 gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
                                                column));
    if (pyg_value_from_pyobject(&value, pyvalue)) {
        PyErr_SetString(PyExc_TypeError,
                        "value is of the wrong type for this column");
        return NULL;
    }
    gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),
                             pyg_boxed_get(iter, GtkTreeIter), column, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 92465 "gtk.c"


#line 1997 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_store_set(PyGObject *self, PyObject *args)
{
    PyObject *iter;
    int len, i;

    len = PyTuple_Size(args);
    if (len == 0) {
        PyErr_SetString(PyExc_TypeError, "GtkTreeStore.set requires at least three arguments");
        return NULL;
    }

    iter = PyTuple_GetItem(args, 0);
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
        PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
        return NULL;
    }

    if ((len - 1) % 2) {
        PyErr_SetString(PyExc_TypeError,
                        "Argument list must be column, value pairs.  No -1 "
                        "termination is needed.");
        return NULL;
    }
    for (i = 1; i < len; i+=2) {
        gint column;
        GValue value = { 0 };
        PyObject *py_column = PyTuple_GetItem(args, i);
        PyObject *py_value = PyTuple_GetItem(args, i + 1);

        if (!PyInt_Check(py_column)) {
            PyErr_SetString(PyExc_TypeError,
                            "Expected numeric argument for column.");
            return NULL;
        }
        column = PyInt_AsLong(py_column);
        if (column < 0 ||
            column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
            PyErr_SetString(PyExc_ValueError, "column number is out of range");
            return NULL;
        }
        g_value_init(&value,
                     gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
                                                    column));
        if (pyg_value_from_pyobject(&value, py_value)) {
            PyErr_SetString(PyExc_TypeError,
                            "value is of the wrong type for this column");
            return NULL;
        }
        gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),
                                 pyg_boxed_get(iter, GtkTreeIter), column,
                                 &value);
        g_value_unset(&value);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 92526 "gtk.c"


static PyObject *
_wrap_gtk_tree_store_remove(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeStore.remove", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_tree_store_remove(GTK_TREE_STORE(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

#line 2097 "gtktreeview.override"
#if GTK_CHECK_VERSION(2, 10, 0)
static PyObject *
_wrap_gtk_tree_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "position", "row", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;
    gint position;
    PyObject *items = NULL;
    gint n_columns = 0;
    gint *columns = NULL;
    GValue *values = NULL;
    gint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi|O:GtkTreeStore.insert",
                                     kwlist, &py_parent, &position, &items))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "parent must be a GtkTreeIter or None");
        return NULL;
    }
    if (items) {
	if (!PySequence_Check(items)) {
	    PyErr_SetString(PyExc_TypeError, "expecting a sequence");
	    return NULL;
	}
	
	n_columns = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
	if (PySequence_Length(items) != n_columns) {
	    PyErr_SetString(PyExc_ValueError, "row sequence has wrong length");
	    return NULL;
	}
    }

    columns = g_new0(gint, n_columns);
    values = g_new0(GValue, n_columns);
    for (i = 0; i < n_columns; i++) {
	PyObject *item;

	item = PySequence_GetItem(items, i);
	if (!item)
	    return NULL;

	g_value_init(&values[i],
                     gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
                                                    i));
	
	if (pyg_value_from_pyobject(&values[i], item)) {
	    Py_DECREF(item);
	    PyErr_SetString(PyExc_TypeError,
			    "value is of wrong type for this column");
	    return NULL;
	}

	columns[i] = i;
	    
	Py_DECREF(item);
    }
    
    gtk_tree_store_insert_with_valuesv(GTK_TREE_STORE(self->obj), &iter,
                                       parent, position, columns, values,
				       n_columns);
    
    for (i = 0; i < n_columns; i++) {
	g_value_unset(&values[i]);
    }
    if (values)
	g_free(values);
    if (columns)
	g_free(columns);

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#else
static PyObject *
_wrap_gtk_tree_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "position", "row", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;
    gint position;
    PyObject *row = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi|O:GtkTreeStore.insert",
                                     kwlist, &py_parent, &position, &row))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "parent must be a GtkTreeIter or None");
        return NULL;
    }
    gtk_tree_store_insert(GTK_TREE_STORE(self->obj), &iter, parent, position);

    /* optionally set items in the new row */
    if (row != Py_None &&
        _pygtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter, row) < 0)
        return NULL;

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#endif    
#line 92659 "gtk.c"


#line 2205 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_store_insert_before(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", "row", NULL };
    PyObject *py_parent, *py_sibling;
    GtkTreeIter iter, *parent = NULL, *sibling = NULL;
    PyObject *row = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|O:GtkTreeStore.insert_before",
                                     kwlist, &py_parent, &py_sibling, &row))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "parent must be a GtkTreeIter or None");
        return NULL;
    }
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
        sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sibling must be a GtkTreeIter or None");
        return NULL;
    }
    gtk_tree_store_insert_before(GTK_TREE_STORE(self->obj), &iter, parent,
                                 sibling);

    /* optionally set items in the new row */
    if (row != Py_None &&
        _pygtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter, row) < 0)
        return NULL;

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 92700 "gtk.c"


#line 2244 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_store_insert_after(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", "row", NULL };
    PyObject *py_parent, *py_sibling;
    GtkTreeIter iter, *parent = NULL, *sibling = NULL;
    PyObject *row = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|O:GtkTreeStore.insert_after",
                                     kwlist, &py_parent, &py_sibling, &row))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "parent must be a GtkTreeIter or None");
        return NULL;
    }
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
        sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sibling must be a GtkTreeIter or None");
        return NULL;
    }
    gtk_tree_store_insert_after(GTK_TREE_STORE(self->obj), &iter, parent,
                                sibling);

    /* optionally set items in the new row */
    if (row != Py_None &&
        _pygtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter, row) < 0)
        return NULL;

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 92741 "gtk.c"


#line 2283 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_store_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "row", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;
    PyObject *row = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:GtkTreeStore.prepend",
                                     kwlist, &py_parent, &row))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "parent must be a GtkTreeIter or None");
        return NULL;
    }
    gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);

    /* optionally set items in the new row */
    if (row != Py_None &&
        _pygtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter, row) < 0)
        return NULL;

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 92772 "gtk.c"


#line 2312 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_store_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "row", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;
    PyObject *row = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:GtkTreeStore.append",
                                     kwlist, &py_parent, &row))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "parent must be a GtkTreeIter or None");
        return NULL;
    }
    gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);

    /* optionally set items in the new row */
    if (row != Py_None &&
        _pygtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter, row) < 0)
        return NULL;

    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
#line 92803 "gtk.c"


static PyObject *
_wrap_gtk_tree_store_is_ancestor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "descendant", NULL };
    PyObject *py_iter, *py_descendant;
    GtkTreeIter *iter = NULL, *descendant = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeStore.is_ancestor", kwlist, &py_iter, &py_descendant))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    if (pyg_boxed_check(py_descendant, GTK_TYPE_TREE_ITER))
        descendant = pyg_boxed_get(py_descendant, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "descendant should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_tree_store_is_ancestor(GTK_TREE_STORE(self->obj), iter, descendant);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_store_iter_depth(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeStore.iter_depth", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_tree_store_iter_depth(GTK_TREE_STORE(self->obj), iter);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_store_clear(PyGObject *self)
{
    
    gtk_tree_store_clear(GTK_TREE_STORE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_store_iter_is_valid(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeStore.iter_is_valid", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_tree_store_iter_is_valid(GTK_TREE_STORE(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

#line 3050 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_store_reorder(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "new_order", NULL };
    PyObject *list, *pyparent;
    gint *new_order;
    GtkTreeStore *store;
    GtkTreeIter *parent = NULL;
    int i, slen;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO!:gtk.TreeStore.reorder", kwlist,
				     &pyparent, &PyList_Type, &list))
	return NULL;

    if (pyparent != Py_None) {
	if (pyg_boxed_check(pyparent, GTK_TYPE_TREE_ITER)) {
	    parent = pyg_boxed_get(pyparent, GtkTreeIter);
	} else {
	    PyErr_SetString(PyExc_TypeError,
			    "parent must be a valid gtk.TreeIter or None");
	    return NULL;
	}
    }
    store = GTK_TREE_STORE(self->obj);
    slen = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(self->obj), parent);
    if (PyList_Size(list) < slen) {
        PyErr_SetString(PyExc_TypeError,
			"list size must be >= the number of "
			"children of parent");
        return NULL;
    }

    new_order = g_new0(gint, slen);
    for (i = 0; i < slen; i++) {
	PyObject *item = PyList_GetItem(list, i);
	int index;
	if (!PyInt_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "all items must be of type int");
	    g_free(new_order);
	    return NULL;
	}
	index = PyInt_AsLong(item);
	if (index < 0 || index >= slen) {
	    PyErr_SetString(PyExc_ValueError, "position index out of range");
	    g_free(new_order);
	    return NULL;
	}
	new_order[i] = index;
    }
    gtk_tree_store_reorder(GTK_TREE_STORE(self->obj), parent, new_order);

    g_free(new_order);
    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 92948 "gtk.c"


static PyObject *
_wrap_gtk_tree_store_swap(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "a", "b", NULL };
    PyObject *py_a, *py_b;
    GtkTreeIter *a = NULL, *b = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeStore.swap", kwlist, &py_a, &py_b))
        return NULL;
    if (pyg_boxed_check(py_a, GTK_TYPE_TREE_ITER))
        a = pyg_boxed_get(py_a, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "a should be a GtkTreeIter");
        return NULL;
    }
    if (pyg_boxed_check(py_b, GTK_TYPE_TREE_ITER))
        b = pyg_boxed_get(py_b, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "b should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_tree_store_swap(GTK_TREE_STORE(self->obj), a, b);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_store_move_after(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "position", NULL };
    PyObject *py_iter, *py_position = Py_None;
    GtkTreeIter *iter = NULL, *position = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeStore.move_after", kwlist, &py_iter, &py_position))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    if (pyg_boxed_check(py_position, GTK_TYPE_TREE_ITER))
        position = pyg_boxed_get(py_position, GtkTreeIter);
    else if (py_position != Py_None) {
        PyErr_SetString(PyExc_TypeError, "position should be a GtkTreeIter or None");
        return NULL;
    }
    
    gtk_tree_store_move_after(GTK_TREE_STORE(self->obj), iter, position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_store_move_before(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "position", NULL };
    PyObject *py_iter, *py_position = Py_None;
    GtkTreeIter *iter = NULL, *position = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeStore.move_before", kwlist, &py_iter, &py_position))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    if (pyg_boxed_check(py_position, GTK_TYPE_TREE_ITER))
        position = pyg_boxed_get(py_position, GtkTreeIter);
    else if (py_position != Py_None) {
        PyErr_SetString(PyExc_TypeError, "position should be a GtkTreeIter or None");
        return NULL;
    }
    
    gtk_tree_store_move_before(GTK_TREE_STORE(self->obj), iter, position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTreeStore_methods[] = {
    { "set_column_types", (PyCFunction)_wrap_gtk_tree_store_set_column_types, METH_VARARGS,
      NULL },
    { "set_value", (PyCFunction)_wrap_gtk_tree_store_set_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set", (PyCFunction)_wrap_gtk_tree_store_set, METH_VARARGS,
      NULL },
    { "remove", (PyCFunction)_wrap_gtk_tree_store_remove, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert", (PyCFunction)_wrap_gtk_tree_store_insert, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_before", (PyCFunction)_wrap_gtk_tree_store_insert_before, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_after", (PyCFunction)_wrap_gtk_tree_store_insert_after, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend", (PyCFunction)_wrap_gtk_tree_store_prepend, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "append", (PyCFunction)_wrap_gtk_tree_store_append, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "is_ancestor", (PyCFunction)_wrap_gtk_tree_store_is_ancestor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "iter_depth", (PyCFunction)_wrap_gtk_tree_store_iter_depth, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "clear", (PyCFunction)_wrap_gtk_tree_store_clear, METH_NOARGS,
      NULL },
    { "iter_is_valid", (PyCFunction)_wrap_gtk_tree_store_iter_is_valid, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reorder", (PyCFunction)_wrap_gtk_tree_store_reorder, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "swap", (PyCFunction)_wrap_gtk_tree_store_swap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move_after", (PyCFunction)_wrap_gtk_tree_store_move_after, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move_before", (PyCFunction)_wrap_gtk_tree_store_move_before, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeStore_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeStore",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeStore_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tree_store_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTreeView ----------- */

 static int
_wrap_gtk_tree_view_new_with_model(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"model", NULL };
    char *prop_names[] = {"model", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.TreeView.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.TreeView object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_tree_view_get_model(PyGObject *self)
{
    GtkTreeModel *ret;

    
    ret = gtk_tree_view_get_model(GTK_TREE_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tree_view_set_model(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *py_model = NULL;
    GtkTreeModel *model = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.TreeView.set_model", kwlist, &py_model))
        return NULL;
    if ((PyObject *)py_model == Py_None)
        model = NULL;
    else if (py_model && pygobject_check(py_model, &PyGtkTreeModel_Type))
        model = GTK_TREE_MODEL(py_model->obj);
    else if (py_model) {
        PyErr_SetString(PyExc_TypeError, "model should be a GtkTreeModel or None");
        return NULL;
    }
    
    gtk_tree_view_set_model(GTK_TREE_VIEW(self->obj), (GtkTreeModel *) model);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_selection(PyGObject *self)
{
    GtkTreeSelection *ret;

    
    ret = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tree_view_get_hadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_tree_view_get_hadjustment(GTK_TREE_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tree_view_set_hadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment;
    GtkAdjustment *adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeView.set_hadjustment", kwlist, &py_adjustment))
        return NULL;
    if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if ((PyObject *)py_adjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }
    
    gtk_tree_view_set_hadjustment(GTK_TREE_VIEW(self->obj), (GtkAdjustment *) adjustment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_vadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_tree_view_get_vadjustment(GTK_TREE_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tree_view_set_vadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment;
    GtkAdjustment *adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeView.set_vadjustment", kwlist, &py_adjustment))
        return NULL;
    if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if ((PyObject *)py_adjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }
    
    gtk_tree_view_set_vadjustment(GTK_TREE_VIEW(self->obj), (GtkAdjustment *) adjustment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_headers_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_headers_visible(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_set_headers_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "headers_visible", NULL };
    int headers_visible;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_headers_visible", kwlist, &headers_visible))
        return NULL;
    
    gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(self->obj), headers_visible);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_columns_autosize(PyGObject *self)
{
    
    gtk_tree_view_columns_autosize(GTK_TREE_VIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_set_headers_clickable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "active", NULL };
    int active;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_headers_clickable", kwlist, &active))
        return NULL;
    
    gtk_tree_view_set_headers_clickable(GTK_TREE_VIEW(self->obj), active);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_set_rules_hint(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_rules_hint", kwlist, &setting))
        return NULL;
    
    gtk_tree_view_set_rules_hint(GTK_TREE_VIEW(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_rules_hint(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_rules_hint(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_append_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    PyGObject *column;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeView.append_column", kwlist, &PyGtkTreeViewColumn_Type, &column))
        return NULL;
    
    ret = gtk_tree_view_append_column(GTK_TREE_VIEW(self->obj), GTK_TREE_VIEW_COLUMN(column->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_remove_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    PyGObject *column;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeView.remove_column", kwlist, &PyGtkTreeViewColumn_Type, &column))
        return NULL;
    
    ret = gtk_tree_view_remove_column(GTK_TREE_VIEW(self->obj), GTK_TREE_VIEW_COLUMN(column->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_insert_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "position", NULL };
    PyGObject *column;
    int position, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.TreeView.insert_column", kwlist, &PyGtkTreeViewColumn_Type, &column, &position))
        return NULL;
    
    ret = gtk_tree_view_insert_column(GTK_TREE_VIEW(self->obj), GTK_TREE_VIEW_COLUMN(column->obj), position);
    
    return PyInt_FromLong(ret);
}

#line 341 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_insert_column_with_attributes(PyGObject *self, PyObject *args,
                                                  PyObject *kwargs)
{
    gint position, columns, real_position;
    GtkTreeViewColumn *column;
    GtkCellRenderer *cell;
    PyObject *py_cell, *key, *item;
    const char *title;
    Py_ssize_t i = 0;

    if (!PyArg_ParseTuple(args,
                          "isO!:GtkTreeView.insert_column_with_attributes",
                          &position, &title, &PyGtkCellRenderer_Type, &py_cell))
        return NULL;

    cell = GTK_CELL_RENDERER(pygobject_get(py_cell));

    columns =
        gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW(self->obj),
                                                     position, title, cell,
                                                     NULL);
    if (position == -1) {
        real_position = columns - 1;
    } else {
        real_position = position;
    }

    column = gtk_tree_view_get_column (GTK_TREE_VIEW(self->obj),
                                       real_position);

    if (kwargs) {
        while (PyDict_Next(kwargs, &i, &key, &item)) {
            gchar *attr = PyString_AsString(key);

            if (!PyInt_Check(item)) {
                gchar err[128];
                g_snprintf(err, sizeof(err),
                           "%s must be an integer column number", attr);
                PyErr_SetString(PyExc_TypeError, err);
                return NULL;
            }
            gtk_tree_view_column_add_attribute(column, cell, attr,
                                               PyInt_AsLong(item));
        }
    }
    return pygobject_new ((GObject *) column);
}
#line 93441 "gtk.c"


#line 262 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_insert_column_with_data_func (PyGObject *self,
                                                  PyObject *args,
                                                  PyObject *kwargs)
{
    int position;
    gchar *title;
    PyObject *pycell,*pyfunc, *pyarg = NULL;
    GtkCellRenderer *cell;
    PyGtkCustomNotify *cunote;
    gint retval;

    if (!PyArg_ParseTuple(args,
                          "isOO|O:GtkTreeView.insert_column_with_data_func",
                          &position, &title, &pycell, &pyfunc, &pyarg))
        return NULL;

    if (pygobject_check(pycell, &PyGtkCellRenderer_Type))
        cell = GTK_CELL_RENDERER(pygobject_get(pycell));
    else {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkCellRenderer");
        return NULL;
    }

    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);

    retval = gtk_tree_view_insert_column_with_data_func (
        GTK_TREE_VIEW (self->obj),
        position,
        title,
        cell,
        (GtkTreeCellDataFunc)pygtk_cell_data_func_marshal,
        cunote,
        pygtk_custom_destroy_notify);
    return PyInt_FromLong(retval);
}
#line 93486 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_get_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "n", NULL };
    int n;
    GtkTreeViewColumn *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.get_column", kwlist, &n))
        return NULL;
    
    ret = gtk_tree_view_get_column(GTK_TREE_VIEW(self->obj), n);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 509 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_get_columns(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *py_list;

    list = gtk_tree_view_get_columns(GTK_TREE_VIEW(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        g_list_free(list);
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        PyObject *gtk_obj = pygobject_new(G_OBJECT(tmp->data));

        if (gtk_obj == NULL) {
            g_list_free(list);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    g_list_free(list);
    return py_list;
}
#line 93532 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_move_column_after(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", "base_column", NULL };
    PyGObject *column, *py_base_column;
    GtkTreeViewColumn *base_column = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeView.move_column_after", kwlist, &PyGtkTreeViewColumn_Type, &column, &py_base_column))
        return NULL;
    if (py_base_column && pygobject_check(py_base_column, &PyGtkTreeViewColumn_Type))
        base_column = GTK_TREE_VIEW_COLUMN(py_base_column->obj);
    else if ((PyObject *)py_base_column != Py_None) {
        PyErr_SetString(PyExc_TypeError, "base_column should be a GtkTreeViewColumn or None");
        return NULL;
    }
    
    gtk_tree_view_move_column_after(GTK_TREE_VIEW(self->obj), GTK_TREE_VIEW_COLUMN(column->obj), (GtkTreeViewColumn *) base_column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_set_expander_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    PyGObject *column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeView.set_expander_column", kwlist, &PyGtkTreeViewColumn_Type, &column))
        return NULL;
    
    gtk_tree_view_set_expander_column(GTK_TREE_VIEW(self->obj), GTK_TREE_VIEW_COLUMN(column->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_expander_column(PyGObject *self)
{
    GtkTreeViewColumn *ret;

    
    ret = gtk_tree_view_get_expander_column(GTK_TREE_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 3315 "gtktreeview.override"
static gboolean
pygtk_column_drag_func_marshal(GtkTreeView *tree_view,
                               GtkTreeViewColumn *column,
                               GtkTreeViewColumn *prev_column,
                               GtkTreeViewColumn *next_column,
                               gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *py_tree_view, *py_column, *py_prev_column, *py_next_column;
    PyObject *retobj;
    gboolean ret = FALSE;

    g_assert (cunote->func);

    state = pyg_gil_state_ensure();

    py_tree_view = pygobject_new((GObject *)tree_view);
    py_column = pygobject_new((GObject *)column);
    py_prev_column = pygobject_new((GObject *)prev_column);
    /* Workaround for drag part of GTK+ bug #143355 */
    if (prev_column == next_column)
        next_column = NULL;
    py_next_column = pygobject_new((GObject *)next_column);
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NNNNO)",
                                     py_tree_view, py_column, py_prev_column,
                                     py_next_column, cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(NNNN)",
                                     py_tree_view, py_column, py_prev_column,
                                     py_next_column);

    if (retobj)
        ret = retobj == Py_True ? TRUE : FALSE;
    if (PyErr_Occurred()) {
        PyErr_Print();
    }
    Py_XDECREF(retobj);

    pyg_gil_state_release(state);
    return ret;    
}
static PyObject *
_wrap_gtk_tree_view_set_column_drag_function(PyGObject *self, PyObject *args,
                                             PyObject *kwargs)
{
    static char *kwlist[] = { "func", "user_data", NULL };
    PyObject *py_func = NULL, *py_arg = NULL;
    PyGtkCustomNotify *cunote;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|OO:GtkTreeView.set_column_drag_func",
				     kwlist, &py_func, &py_arg))
        return NULL;

    if (!py_func || py_func == Py_None) {
        gtk_tree_view_set_column_drag_function(GTK_TREE_VIEW(self->obj),
                                               NULL, NULL, NULL);
        Py_INCREF(Py_None);
        return Py_None;
    }

    if (!PyCallable_Check(py_func)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }

    cunote = g_new(PyGtkCustomNotify, 1);
    Py_INCREF(py_func);
    cunote->func = py_func;
    Py_XINCREF(py_arg);
    cunote->data = py_arg;

    gtk_tree_view_set_column_drag_function(GTK_TREE_VIEW(self->obj),
                                           pygtk_column_drag_func_marshal,
                                           cunote,
                                           pygtk_custom_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 93666 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_scroll_to_point(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tree_x", "tree_y", NULL };
    int tree_x, tree_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.TreeView.scroll_to_point", kwlist, &tree_x, &tree_y))
        return NULL;
    
    gtk_tree_view_scroll_to_point(GTK_TREE_VIEW(self->obj), tree_x, tree_y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_scroll_to_cell(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "column", "use_align", "row_align", "col_align", NULL };
    GtkTreePath *path;
    PyObject *py_path;
    double row_align = 0.0, col_align = 0.0;
    GtkTreeViewColumn *column = NULL;
    int use_align = FALSE;
    PyGObject *py_column = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O|Oidd:Gtk.TreeView.scroll_to_cell", kwlist, &py_path, &py_column, &use_align, &row_align, &col_align))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if ((PyObject *)py_column == Py_None)
        column = NULL;
    else if (py_column && pygobject_check(py_column, &PyGtkTreeViewColumn_Type))
        column = GTK_TREE_VIEW_COLUMN(py_column->obj);
    else if (py_column) {
        PyErr_SetString(PyExc_TypeError, "column should be a GtkTreeViewColumn or None");
        return NULL;
    }
    
    gtk_tree_view_scroll_to_cell(GTK_TREE_VIEW(self->obj), path, (GtkTreeViewColumn *) column, use_align, row_align, col_align);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_row_activated(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "column", NULL };
    PyObject *py_path;
    PyGObject *column;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO!:Gtk.TreeView.row_activated", kwlist, &py_path, &PyGtkTreeViewColumn_Type, &column))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_tree_view_row_activated(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj));
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_expand_all(PyGObject *self)
{
    
    gtk_tree_view_expand_all(GTK_TREE_VIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_collapse_all(PyGObject *self)
{
    
    gtk_tree_view_collapse_all(GTK_TREE_VIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_expand_to_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeView.expand_to_path", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_tree_view_expand_to_path(GTK_TREE_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_expand_row(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "open_all", NULL };
    PyObject *py_path;
    int open_all, ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.TreeView.expand_row", kwlist, &py_path, &open_all))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_view_expand_row(GTK_TREE_VIEW(self->obj), path, open_all);
    
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_collapse_row(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeView.collapse_row", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_tree_view_collapse_row(GTK_TREE_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2828 "gtktreeview.override"

typedef struct {
    PyObject *func;
    PyObject *user_data;
} _map_expanded_rows_data_t;

static void map_expanded_rows_cb(GtkTreeView *tree_view, GtkTreePath *path,
			         gpointer user_data)
{
    PyObject *py_path, *py_view, *ret;
    _map_expanded_rows_data_t *data =
	(_map_expanded_rows_data_t *) user_data;

    /* If exception is pending, just return */
    if (PyErr_Occurred())
        return;

    py_path = pygtk_tree_path_to_pyobject(path);
    if (py_path == NULL)
        return;
    py_view = pygobject_new((GObject *)tree_view);
    if (py_view == NULL) {
        Py_DECREF(py_path);
        return;
    }
    if (data->user_data)
	ret = PyObject_CallFunction(data->func, "NNO", py_view, py_path, data->user_data);
    else
	ret = PyObject_CallFunction(data->func, "NN", py_view, py_path);
    Py_XDECREF(ret);
}

static PyObject *
_wrap_gtk_tree_view_map_expanded_rows(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL };
    _map_expanded_rows_data_t data = { NULL, NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkTreeView.map_expanded_rows",
                                     kwlist,
                                     &data.func, &data.user_data))
        return NULL;
	
    if (!PyCallable_Check(data.func)) {
        PyErr_SetString(PyExc_TypeError, "func must be callable");
	return NULL;
    }

    gtk_tree_view_map_expanded_rows(GTK_TREE_VIEW(self->obj), map_expanded_rows_cb,
                                    &data);

    /* Return NULL if exception occurred in the callback */
    if (PyErr_Occurred())
        return NULL;
				    
    Py_INCREF(Py_None);
    return Py_None;
}
#line 93894 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_row_expanded(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    int ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeView.row_expanded", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_view_row_expanded(GTK_TREE_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_set_reorderable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "reorderable", NULL };
    int reorderable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_reorderable", kwlist, &reorderable))
        return NULL;
    
    gtk_tree_view_set_reorderable(GTK_TREE_VIEW(self->obj), reorderable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_reorderable(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_reorderable(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_set_cursor(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "focus_column", "start_editing", NULL };
    PyObject *py_path;
    GtkTreeViewColumn *focus_column = NULL;
    int start_editing = FALSE;
    PyGObject *py_focus_column = NULL;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O|Oi:Gtk.TreeView.set_cursor", kwlist, &py_path, &py_focus_column, &start_editing))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if ((PyObject *)py_focus_column == Py_None)
        focus_column = NULL;
    else if (py_focus_column && pygobject_check(py_focus_column, &PyGtkTreeViewColumn_Type))
        focus_column = GTK_TREE_VIEW_COLUMN(py_focus_column->obj);
    else if (py_focus_column) {
        PyErr_SetString(PyExc_TypeError, "focus_column should be a GtkTreeViewColumn or None");
        return NULL;
    }
    
    gtk_tree_view_set_cursor(GTK_TREE_VIEW(self->obj), path, (GtkTreeViewColumn *) focus_column, start_editing);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_set_cursor_on_cell(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "focus_column", "focus_cell", "start_editing", NULL };
    GtkTreePath *path;
    PyObject *py_path;
    GtkTreeViewColumn *focus_column = NULL;
    int start_editing = FALSE;
    PyGObject *py_focus_column = NULL, *py_focus_cell = NULL;
    GtkCellRenderer *focus_cell = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O|OOi:Gtk.TreeView.set_cursor_on_cell", kwlist, &py_path, &py_focus_column, &py_focus_cell, &start_editing))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if ((PyObject *)py_focus_column == Py_None)
        focus_column = NULL;
    else if (py_focus_column && pygobject_check(py_focus_column, &PyGtkTreeViewColumn_Type))
        focus_column = GTK_TREE_VIEW_COLUMN(py_focus_column->obj);
    else if (py_focus_column) {
        PyErr_SetString(PyExc_TypeError, "focus_column should be a GtkTreeViewColumn or None");
        return NULL;
    }
    if ((PyObject *)py_focus_cell == Py_None)
        focus_cell = NULL;
    else if (py_focus_cell && pygobject_check(py_focus_cell, &PyGtkCellRenderer_Type))
        focus_cell = GTK_CELL_RENDERER(py_focus_cell->obj);
    else if (py_focus_cell) {
        PyErr_SetString(PyExc_TypeError, "focus_cell should be a GtkCellRenderer or None");
        return NULL;
    }
    
    gtk_tree_view_set_cursor_on_cell(GTK_TREE_VIEW(self->obj), path, (GtkTreeViewColumn *) focus_column, (GtkCellRenderer *) focus_cell, start_editing);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 480 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_get_cursor(PyGObject *self)
{
    PyObject *py_path;
    PyObject *py_column;
    GtkTreePath *path;
    GtkTreeViewColumn *column;

    gtk_tree_view_get_cursor(GTK_TREE_VIEW(self->obj),
                             &path, &column);

    if (path != NULL) {
        py_path = pygtk_tree_path_to_pyobject(path);
    } else {
        Py_INCREF(Py_None);
        py_path = Py_None;
    }

    if (column != NULL) {
        py_column = pygobject_new((GObject*)column);
    } else {
        Py_INCREF(Py_None);
        py_column = Py_None;
    }

    return Py_BuildValue("(NN)", py_path, py_column);
}
#line 94053 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_get_bin_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_tree_view_get_bin_window(GTK_TREE_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 305 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_get_path_at_pos(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    gint x, y;
    GtkTreePath *path;
    GtkTreeViewColumn *column;
    gint cell_x, cell_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "ii:GtkTreeView.get_path_at_pos",
                                     kwlist, &x, &y))
        return NULL;
    if (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(self->obj), x, y,
                                      &path, &column, &cell_x, &cell_y)) {
        PyObject *ret = PyTuple_New(4);

        if (path) {
            PyTuple_SetItem(ret, 0, pygtk_tree_path_to_pyobject(path));
            gtk_tree_path_free(path);
        } else {
            Py_INCREF(Py_None);
            PyTuple_SetItem(ret, 0, Py_None);
        }
        PyTuple_SetItem(ret, 1, pygobject_new((GObject *)column));
        PyTuple_SetItem(ret, 2, PyInt_FromLong(cell_x));
        PyTuple_SetItem(ret, 3, PyInt_FromLong(cell_y));
        return ret;
    } else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
#line 94103 "gtk.c"


#line 402 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_get_cell_area(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "column", NULL };
    PyObject *py_path;
    PyGObject *column;
    GdkRectangle rect;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!:GtkTreeView.get_cell_area", kwlist, &py_path, &PyGtkTreeViewColumn_Type, &column))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj), &rect);
    if (path)
        gtk_tree_path_free(path);
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE);
}
#line 94128 "gtk.c"


#line 425 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_get_background_area(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "column", NULL };
    PyObject *py_path;
    PyGObject *column;
    GdkRectangle rect;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!:GtkTreeView.get_background_area", kwlist, &py_path, &PyGtkTreeViewColumn_Type, &column))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    gtk_tree_view_get_background_area(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj), &rect);
    if (path)
        gtk_tree_path_free(path);
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE);
}
#line 94153 "gtk.c"


#line 391 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_get_visible_rect(PyGObject *self)
{
    GdkRectangle visible_rect;

    gtk_tree_view_get_visible_rect(GTK_TREE_VIEW(self->obj), &visible_rect);

    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &visible_rect, TRUE, TRUE);
}
#line 94166 "gtk.c"


#line 448 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_widget_to_tree_coords(PyGObject *self, PyObject *args)
{
    gint wx, wy, tx, ty;

    if (!PyArg_ParseTuple(args, "ii:GtkTreeView.widget_to_tree_coords",
                          &wx, &wy)) {
        return NULL;
    }

    gtk_tree_view_widget_to_tree_coords(GTK_TREE_VIEW(self->obj), wx, wy, &tx, &ty);

    return Py_BuildValue("(ii)", tx, ty);
}
#line 94184 "gtk.c"


#line 464 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_tree_to_widget_coords(PyGObject *self, PyObject *args)
{
    gint tx, ty, wx, wy;

    if (!PyArg_ParseTuple(args, "ii:GtkTreeView.tree_to_widget_coords",
                          &tx, &ty)) {
        return NULL;
    }

    gtk_tree_view_tree_to_widget_coords(GTK_TREE_VIEW(self->obj), tx, ty, &wx, &wy);

    return Py_BuildValue("(ii)", wx, wy);
}
#line 94202 "gtk.c"


#line 2649 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_enable_model_drag_source(PyGObject *self, PyObject *args,
                                             PyObject *kwargs)
{
    static char *kwlist[] = { "start_button_mask", "targets", "actions", NULL };
    PyObject *py_sbmask, *py_targets, *py_actions;
    GdkModifierType sbmask;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO:GtkTreeView.enable_model_drag_source",
                                     kwlist,
                                     &py_sbmask, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,
                             py_sbmask, (gint *)&sbmask))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!PySequence_Check(py_targets)) {
        PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
        return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_GetItem(py_targets, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
            return NULL;
        }
    }
    gtk_tree_view_enable_model_drag_source(GTK_TREE_VIEW(self->obj),
                                           sbmask, targets, n_targets, actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 94252 "gtk.c"


#line 2697 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_enable_model_drag_dest(PyGObject *self, PyObject *args,
                                           PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "actions", NULL };
    PyObject *py_targets, *py_actions;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:GtkTreeView.enable_model_drag_dest",
                                     kwlist,
                                     &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!PySequence_Check(py_targets)) {
        PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
        return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_GetItem(py_targets, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
            return NULL;
        }
    }
    gtk_tree_view_enable_model_drag_dest(GTK_TREE_VIEW(self->obj),
                                         targets, n_targets, actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 94298 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_unset_rows_drag_source(PyGObject *self)
{
    
    gtk_tree_view_unset_rows_drag_source(GTK_TREE_VIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_unset_rows_drag_dest(PyGObject *self)
{
    
    gtk_tree_view_unset_rows_drag_dest(GTK_TREE_VIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2761 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_set_drag_dest_row(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "path", "pos", NULL };
    PyObject *py_path;
    gint py_pos;
    GtkTreePath *path;
    GtkTreeViewDropPosition pos;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oi:GtkTreeView.set_drag_dest_row",
                                     kwlist,
                                     &py_path, &py_pos))
        return NULL;
    
    if (py_path == Py_None)
        path = NULL;
    else {
        path = pygtk_tree_path_from_pyobject(py_path);
        if (!path) {
            PyErr_SetString(PyExc_TypeError,
                            "set_drag_dest_row must be a TreePath");
            return NULL;
        }
    }
    pos = (GtkTreeViewDropPosition) py_pos;
    gtk_tree_view_set_drag_dest_row(GTK_TREE_VIEW(self->obj), path, pos);
    gtk_tree_path_free(path);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 94355 "gtk.c"


#line 2741 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_get_drag_dest_row(PyGObject *self)
{
    GtkTreePath *path;
    GtkTreeViewDropPosition pos;

    gtk_tree_view_get_drag_dest_row(GTK_TREE_VIEW(self->obj), &path, &pos);
    if (path) {
        PyObject *py_path = pygtk_tree_path_to_pyobject(path);
        gint py_pos = (gint) pos;
        gtk_tree_path_free(path);
        return Py_BuildValue("(NN)", py_path,
			     pyg_enum_from_gtype(GTK_TYPE_TREE_VIEW_DROP_POSITION, py_pos));
    } else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
#line 94377 "gtk.c"


#line 2796 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_get_dest_row_at_pos(PyGObject *self, PyObject *args,
					PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    GtkTreePath *path;
    GtkTreeViewDropPosition pos;

    gint x,y;
    gboolean r;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "ii:GtkTreeView.get_drag_dest_row_at_pos",
                                     kwlist,
                                     &x, &y))
        return NULL;


    r = gtk_tree_view_get_dest_row_at_pos(GTK_TREE_VIEW(self->obj), x, y, &path, &pos);
    if (r && path) {
        PyObject *py_path = pygtk_tree_path_to_pyobject(path);
        gint py_pos = (gint) pos;
        gtk_tree_path_free(path);
        return Py_BuildValue("(NN)", py_path,
			     pyg_enum_from_gtype(GTK_TYPE_TREE_VIEW_DROP_POSITION, py_pos));
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 94411 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_create_row_drag_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GdkPixmap *ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeView.create_row_drag_icon", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_view_create_row_drag_icon(GTK_TREE_VIEW(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tree_view_set_enable_search(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "enable_search", NULL };
    int enable_search;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_enable_search", kwlist, &enable_search))
        return NULL;
    
    gtk_tree_view_set_enable_search(GTK_TREE_VIEW(self->obj), enable_search);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_enable_search(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_enable_search(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_get_search_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_search_column(GTK_TREE_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_set_search_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_search_column", kwlist, &column))
        return NULL;
    
    gtk_tree_view_set_search_column(GTK_TREE_VIEW(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3398 "gtktreeview.override"
static gboolean
pygtk_set_search_equal_func_marshal(GtkTreeModel *model,
                                    gint column,
                                    const gchar *key,
                                    GtkTreeIter *iter,
                                    gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *py_model, *py_column, *py_key, *py_iter;
    PyObject *retobj;
    gboolean ret = FALSE;

      /* gracefully guard against NULL values */
    g_return_val_if_fail(cunote->func, TRUE);
    g_return_val_if_fail(key, TRUE);
    g_return_val_if_fail(iter, TRUE);

    state = pyg_gil_state_ensure();

    py_model = pygobject_new((GObject *)model);
    py_column = PyInt_FromLong(column);
    py_key = PyString_FromString(key);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter,  FALSE, FALSE);

    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NNNNO)",
                                     py_model, py_column, py_key, py_iter,
                                     cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(NNNN)",
                                     py_model, py_column, py_key, py_iter);

    if (retobj)
        ret = (PyObject_IsTrue(retobj)? TRUE : FALSE);
    if (PyErr_Occurred()) {
        PyErr_Print();
    }
    Py_XDECREF(retobj);

    pyg_gil_state_release(state);
    return ret;    
}

static PyObject *
_wrap_gtk_tree_view_set_search_equal_func(PyGObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    static char *kwlist[] = { "func", "user_data", NULL };
    PyObject *py_func = NULL, *py_arg = NULL;
    PyGtkCustomNotify *cunote;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|OO:GtkTreeView.set_search_equal_func",
				     kwlist, &py_func, &py_arg))
        return NULL;

    if (!py_func || py_func == Py_None) {
        gtk_tree_view_set_search_equal_func(GTK_TREE_VIEW(self->obj),
                                               NULL, NULL, NULL);
        Py_INCREF(Py_None);
        return Py_None;
    }

    if (!PyCallable_Check(py_func)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }

    cunote = g_new(PyGtkCustomNotify, 1);
    Py_INCREF(py_func);
    cunote->func = py_func;
    Py_XINCREF(py_arg);
    cunote->data = py_arg;

    gtk_tree_view_set_search_equal_func(GTK_TREE_VIEW(self->obj),
                                        pygtk_set_search_equal_func_marshal,
                                        cunote,
                                        pygtk_custom_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 94574 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_set_fixed_height_mode(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "enable", NULL };
    int enable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_fixed_height_mode", kwlist, &enable))
        return NULL;
    
    gtk_tree_view_set_fixed_height_mode(GTK_TREE_VIEW(self->obj), enable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_fixed_height_mode(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_fixed_height_mode(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_set_hover_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "hover", NULL };
    int hover;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_hover_selection", kwlist, &hover))
        return NULL;
    
    gtk_tree_view_set_hover_selection(GTK_TREE_VIEW(self->obj), hover);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_hover_selection(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_hover_selection(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_set_hover_expand(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "expand", NULL };
    int expand;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_hover_expand", kwlist, &expand))
        return NULL;
    
    gtk_tree_view_set_hover_expand(GTK_TREE_VIEW(self->obj), expand);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_hover_expand(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_hover_expand(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 3482 "gtktreeview.override"
static gboolean
pygtk_set_row_separator_func_marshal(GtkTreeModel *model,
                                     GtkTreeIter *iter,
                                     gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *py_model, *py_iter;
    PyObject *retobj;
    gboolean ret = FALSE;

    g_assert (cunote->func);

    state = pyg_gil_state_ensure();

    py_model = pygobject_new((GObject *)model);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter,  FALSE, FALSE);

    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NNO)",
                                     py_model, py_iter, cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(NN)",
                                     py_model, py_iter);

    if (retobj)
        ret = retobj == Py_True ? TRUE : FALSE;
    if (PyErr_Occurred()) {
        PyErr_Print();
    }
    Py_XDECREF(retobj);

    pyg_gil_state_release(state);
    return ret;    
}

static PyObject *
_wrap_gtk_tree_view_set_row_separator_func(PyGObject *self, PyObject *args,
                                           PyObject *kwargs)
{
    static char *kwlist[] = { "func", "user_data", NULL };
    PyObject *py_func = NULL, *py_arg = NULL;
    PyGtkCustomNotify *cunote;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|OO:GtkTreeView.set_row_separator_func",
				     kwlist, &py_func, &py_arg))
        return NULL;

    if (!py_func || py_func == Py_None) {
        gtk_tree_view_set_row_separator_func(GTK_TREE_VIEW(self->obj),
                                             NULL, NULL, NULL);
        Py_INCREF(Py_None);
        return Py_None;
    }

    if (!PyCallable_Check(py_func)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }

    cunote = g_new(PyGtkCustomNotify, 1);
    Py_INCREF(py_func);
    cunote->func = py_func;
    Py_XINCREF(py_arg);
    cunote->data = py_arg;

    gtk_tree_view_set_row_separator_func(GTK_TREE_VIEW(self->obj),
                                         pygtk_set_row_separator_func_marshal,
                                         cunote,
                                         pygtk_custom_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 94733 "gtk.c"


#line 3558 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_get_visible_range(PyGObject *self)
{
    GtkTreePath *start_path, *end_path;
    gboolean r;
    
    r = gtk_tree_view_get_visible_range(GTK_TREE_VIEW(self->obj),
					&start_path, &end_path);
    if (r) {
        PyObject *py_start_path = pygtk_tree_path_to_pyobject(start_path);
        PyObject *py_end_path = pygtk_tree_path_to_pyobject(end_path);
        gtk_tree_path_free(start_path);
        gtk_tree_path_free(end_path); 
       return Py_BuildValue("(NN)", py_start_path, py_end_path);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 94756 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_get_headers_clickable(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_headers_clickable(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_get_search_entry(PyGObject *self)
{
    GtkEntry *ret;

    
    ret = gtk_tree_view_get_search_entry(GTK_TREE_VIEW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tree_view_set_search_entry(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entry", NULL };
    PyGObject *py_entry = NULL;
    GtkEntry *entry = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.TreeView.set_search_entry", kwlist, &py_entry))
        return NULL;
    if ((PyObject *)py_entry == Py_None)
        entry = NULL;
    else if (py_entry && pygobject_check(py_entry, &PyGtkEntry_Type))
        entry = GTK_ENTRY(py_entry->obj);
    else if (py_entry) {
        PyErr_SetString(PyExc_TypeError, "entry should be a GtkEntry or None");
        return NULL;
    }
    
    gtk_tree_view_set_search_entry(GTK_TREE_VIEW(self->obj), (GtkEntry *) entry);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3579 "gtktreeview.override"
static void
pygtk_tree_view_set_search_position_func_cb(GtkTreeView *treeview,
                                            GtkWidget *search_dialog,
                                            gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *retobj;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NNO)",
                                     pygobject_new((GObject*)treeview),
                                     pygobject_new((GObject*)search_dialog),
                                     cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(NN)",
                                     pygobject_new((GObject*)treeview),
                                     pygobject_new((GObject*)search_dialog));

    if (retobj == NULL) {
        PyErr_Print();
    }

    Py_XDECREF(retobj);

    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_tree_view_set_search_position_func(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;

    if(!PyArg_ParseTuple(args, "O|O:GtkTreeView.set_search_position_func",
                         &pyfunc, &pyarg))
        return NULL;

    if (pyfunc != Py_None) {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);
        gtk_tree_view_set_search_position_func(
            GTK_TREE_VIEW(self->obj),
            pygtk_tree_view_set_search_position_func_cb, cunote,
            pygtk_custom_destroy_notify);
    } else
        gtk_tree_view_set_search_position_func(GTK_TREE_VIEW(self->obj),
                                               NULL, NULL, NULL);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 94865 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_set_rubber_banding(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "enable", NULL };
    int enable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_rubber_banding", kwlist, &enable))
        return NULL;
    
    gtk_tree_view_set_rubber_banding(GTK_TREE_VIEW(self->obj), enable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_rubber_banding(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_rubber_banding(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_get_grid_lines(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tree_view_get_grid_lines(GTK_TREE_VIEW(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_TREE_VIEW_GRID_LINES, ret);
}

static PyObject *
_wrap_gtk_tree_view_set_grid_lines(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "grid_lines", NULL };
    GtkTreeViewGridLines grid_lines;
    PyObject *py_grid_lines = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeView.set_grid_lines", kwlist, &py_grid_lines))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TREE_VIEW_GRID_LINES, py_grid_lines, (gpointer)&grid_lines))
        return NULL;
    
    gtk_tree_view_set_grid_lines(GTK_TREE_VIEW(self->obj), grid_lines);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_enable_tree_lines(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_enable_tree_lines(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_set_enable_tree_lines(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "enabled", NULL };
    int enabled;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_enable_tree_lines", kwlist, &enabled))
        return NULL;
    
    gtk_tree_view_set_enable_tree_lines(GTK_TREE_VIEW(self->obj), enabled);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3692 "gtktreeview.override"
static PyObject*
_wrap_gtk_tree_view_convert_widget_to_tree_coords(PyGObject *self,
                                                  PyObject *args,
                                                  PyObject *kwargs)
{
    static char *kwlist[] = { "widget_x", "widget_y", NULL };
    gint widget_x, widget_y, tree_x = 0, tree_y = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                        "ii:GtkTreeView.convert_widget_to_tree_coords",
                        kwlist, &widget_x, &widget_y))
        return NULL;
    
    gtk_tree_view_convert_widget_to_tree_coords(GTK_TREE_VIEW(self->obj),
                                                widget_x, widget_y,
                                                &tree_x, &tree_y);
    
    return Py_BuildValue("(ii)", tree_x, tree_y);
}
#line 94971 "gtk.c"


#line 3713 "gtktreeview.override"
static PyObject*
_wrap_gtk_tree_view_convert_tree_to_widget_coords(PyGObject *self,
                                                  PyObject *args,
                                                  PyObject *kwargs)
{
    static char *kwlist[] = { "tree_x", "tree_y", NULL };
    gint tree_x, tree_y, widget_x = 0, widget_y = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                        "ii:GtkTreeView.convert_tree_to_widget_coords",
                        kwlist, &tree_x, &tree_y))
        return NULL;
    
    gtk_tree_view_convert_tree_to_widget_coords(GTK_TREE_VIEW(self->obj),
                                                tree_x, tree_y,
                                                &widget_x, &widget_y);
    
    return Py_BuildValue("(ii)", widget_x, widget_y);
}
#line 94994 "gtk.c"


#line 3671 "gtktreeview.override"
static PyObject*
_wrap_gtk_tree_view_convert_widget_to_bin_window_coords(PyGObject *self,
                                                        PyObject *args,
                                                        PyObject *kwargs)
{
    static char *kwlist[] = { "widget_x", "widget_y", NULL };
    gint widget_x, widget_y, window_x = 0, window_y = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                        "ii:GtkTreeView.convert_widget_to_bin_window_coords",
                        kwlist, &widget_x, &widget_y))
        return NULL;
    
    gtk_tree_view_convert_widget_to_bin_window_coords(GTK_TREE_VIEW(self->obj),
                                          widget_x, widget_y,
                                          &window_x, &window_y);
    
    return Py_BuildValue("(ii)", window_x, window_y);
}
#line 95017 "gtk.c"


#line 3755 "gtktreeview.override"
static PyObject*
_wrap_gtk_tree_view_convert_bin_window_to_widget_coords(PyGObject *self,
                                                        PyObject *args,
                                                        PyObject *kwargs)
{
    static char *kwlist[] = { "window_x", "window_y", NULL };
    gint window_x, window_y, widget_x = 0, widget_y = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                        "ii:GtkTreeView.convert_bin_window_to_widget_coords",
                        kwlist, &window_x, &window_y))
        return NULL;
    
    gtk_tree_view_convert_bin_window_to_widget_coords(GTK_TREE_VIEW(self->obj),
                                                      window_x, window_y,
                                                      &widget_x, &widget_y);
    
    return Py_BuildValue("(ii)", widget_x, widget_y);
}
#line 95040 "gtk.c"


#line 3734 "gtktreeview.override"
static PyObject*
_wrap_gtk_tree_view_convert_tree_to_bin_window_coords(PyGObject *self,
                                                      PyObject *args,
                                                      PyObject *kwargs)
{
    static char *kwlist[] = { "tree_x", "tree_y", NULL };
    gint tree_x, tree_y, window_x = 0, window_y = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                        "ii:GtkTreeView.convert_tree_to_bin_window_coords",
                        kwlist, &tree_x, &tree_y))
        return NULL;
    
    gtk_tree_view_convert_tree_to_bin_window_coords(GTK_TREE_VIEW(self->obj),
                                                    tree_x, tree_y,
                                                    &window_x, &window_y);
    
    return Py_BuildValue("(ii)", window_x, window_y);
}
#line 95063 "gtk.c"


#line 3776 "gtktreeview.override"
static PyObject*
_wrap_gtk_tree_view_convert_bin_window_to_tree_coords(PyGObject *self,
                                                      PyObject *args,
                                                      PyObject *kwargs)
{
    static char *kwlist[] = { "window_x", "window_y", NULL };
    gint window_x, window_y, tree_x = 0, tree_y = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                        "ii:GtkTreeView.convert_bin_window_to_tree_coords",
                        kwlist, &window_x, &window_y))
        return NULL;
    
    gtk_tree_view_convert_bin_window_to_tree_coords(GTK_TREE_VIEW(self->obj),
                                                    window_x, window_y,
                                                    &tree_x, &tree_y);
    
    return Py_BuildValue("(ii)", tree_x, tree_y);
}
#line 95086 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_set_show_expanders(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "enabled", NULL };
    int enabled;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_show_expanders", kwlist, &enabled))
        return NULL;
    
    gtk_tree_view_set_show_expanders(GTK_TREE_VIEW(self->obj), enabled);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_show_expanders(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_show_expanders(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_set_level_indentation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "indentation", NULL };
    int indentation;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_level_indentation", kwlist, &indentation))
        return NULL;
    
    gtk_tree_view_set_level_indentation(GTK_TREE_VIEW(self->obj), indentation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_level_indentation(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_level_indentation(GTK_TREE_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_is_rubber_banding_active(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_is_rubber_banding_active(GTK_TREE_VIEW(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 3797 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_get_tooltip_context(PyGObject *self,
                                        PyObject *args,
                                        PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", "keyboard_tip", NULL };
    
    gboolean        ret;
    PyObject        *py_ret = Py_None, *py_keyboard_tip = Py_True;
    gint            x, y;
    GtkTreeModel    *tree_model;
    GtkTreePath     *path;
    GtkTreeIter     iter;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                        "iiO:GtkTreeView.get_tooltip_context",
                        kwlist, &x, &y, &py_keyboard_tip))
        return NULL;
    
    ret = gtk_tree_view_get_tooltip_context(GTK_TREE_VIEW(self->obj), &x, &y,
                                            PyObject_IsTrue(py_keyboard_tip),
                                            &tree_model,
                                            &path, &iter);
    if (ret) {
        py_ret = Py_BuildValue("(NNN)",
                               pygobject_new((GObject *)tree_model),
                               pygtk_tree_path_to_pyobject(path),
                               pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter,
                                             TRUE, TRUE));

        gtk_tree_path_free(path);
        return py_ret;
    }
    Py_INCREF(py_ret);    
    return py_ret;
}
#line 95191 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_set_tooltip_column(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "column", NULL };
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeView.set_tooltip_column", kwlist, &column))
        return NULL;
    
    gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(self->obj), column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_get_tooltip_column(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_get_tooltip_column(GTK_TREE_VIEW(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_set_tooltip_row(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tooltip", "path", NULL };
    PyGObject *tooltip;
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeView.set_tooltip_row", kwlist, &PyGtkTooltip_Type, &tooltip, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_tree_view_set_tooltip_row(GTK_TREE_VIEW(self->obj), GTK_TOOLTIP(tooltip->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_set_tooltip_cell(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tooltip", "path", "column", "cell", NULL };
    PyGObject *tooltip, *py_column, *py_cell;
    PyObject *py_path = Py_None;
    GtkTreeViewColumn *column = NULL;
    GtkCellRenderer *cell = NULL;
    GtkTreePath *path = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOO:Gtk.TreeView.set_tooltip_cell", kwlist, &PyGtkTooltip_Type, &tooltip, &py_path, &py_column, &py_cell))
        return NULL;
    if (py_path != Py_None) {
        path = pygtk_tree_path_from_pyobject(py_path);
        if (!path) {
            PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
            return NULL;
        }
    }
    if (py_column && pygobject_check(py_column, &PyGtkTreeViewColumn_Type))
        column = GTK_TREE_VIEW_COLUMN(py_column->obj);
    else if ((PyObject *)py_column != Py_None) {
        PyErr_SetString(PyExc_TypeError, "column should be a GtkTreeViewColumn or None");
        return NULL;
    }
    if (py_cell && pygobject_check(py_cell, &PyGtkCellRenderer_Type))
        cell = GTK_CELL_RENDERER(py_cell->obj);
    else if ((PyObject *)py_cell != Py_None) {
        PyErr_SetString(PyExc_TypeError, "cell should be a GtkCellRenderer or None");
        return NULL;
    }
    
    gtk_tree_view_set_tooltip_cell(GTK_TREE_VIEW(self->obj), GTK_TOOLTIP(tooltip->obj), path, (GtkTreeViewColumn *) column, (GtkCellRenderer *) cell);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeView__do_set_scroll_adjustments(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "hadjustment", "vadjustment", NULL };
    PyGObject *self, *hadjustment, *vadjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!:Gtk.TreeView.set_scroll_adjustments", kwlist, &PyGtkTreeView_Type, &self, &PyGtkAdjustment_Type, &hadjustment, &PyGtkAdjustment_Type, &vadjustment))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->set_scroll_adjustments)
        GTK_TREE_VIEW_CLASS(klass)->set_scroll_adjustments(GTK_TREE_VIEW(self->obj), GTK_ADJUSTMENT(hadjustment->obj), GTK_ADJUSTMENT(vadjustment->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.set_scroll_adjustments not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeView__do_row_activated(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "path", "column", NULL };
    PyGObject *self, *column;
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO!:Gtk.TreeView.row_activated", kwlist, &PyGtkTreeView_Type, &self, &py_path, &PyGtkTreeViewColumn_Type, &column))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->row_activated)
        GTK_TREE_VIEW_CLASS(klass)->row_activated(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.row_activated not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeView__do_test_expand_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "iter", "path", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    int ret;
    GtkTreePath *path;
    PyObject *py_iter, *py_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeView.test_expand_row", kwlist, &PyGtkTreeView_Type, &self, &py_iter, &py_path))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->test_expand_row)
        ret = GTK_TREE_VIEW_CLASS(klass)->test_expand_row(GTK_TREE_VIEW(self->obj), iter, path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.test_expand_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeView__do_test_collapse_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "iter", "path", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    int ret;
    GtkTreePath *path;
    PyObject *py_iter, *py_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeView.test_collapse_row", kwlist, &PyGtkTreeView_Type, &self, &py_iter, &py_path))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->test_collapse_row)
        ret = GTK_TREE_VIEW_CLASS(klass)->test_collapse_row(GTK_TREE_VIEW(self->obj), iter, path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.test_collapse_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeView__do_row_expanded(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "iter", "path", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    GtkTreePath *path;
    PyObject *py_iter, *py_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeView.row_expanded", kwlist, &PyGtkTreeView_Type, &self, &py_iter, &py_path))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->row_expanded)
        GTK_TREE_VIEW_CLASS(klass)->row_expanded(GTK_TREE_VIEW(self->obj), iter, path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.row_expanded not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeView__do_row_collapsed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "iter", "path", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    GtkTreePath *path;
    PyObject *py_iter, *py_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeView.row_collapsed", kwlist, &PyGtkTreeView_Type, &self, &py_iter, &py_path))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->row_collapsed)
        GTK_TREE_VIEW_CLASS(klass)->row_collapsed(GTK_TREE_VIEW(self->obj), iter, path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.row_collapsed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeView__do_columns_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeView.columns_changed", kwlist, &PyGtkTreeView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->columns_changed)
        GTK_TREE_VIEW_CLASS(klass)->columns_changed(GTK_TREE_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.columns_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeView__do_cursor_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeView.cursor_changed", kwlist, &PyGtkTreeView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->cursor_changed)
        GTK_TREE_VIEW_CLASS(klass)->cursor_changed(GTK_TREE_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.cursor_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeView__do_move_cursor(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "step", "count", NULL };
    PyGObject *self;
    PyObject *py_step = NULL;
    GtkMovementStep step;
    int count, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oi:Gtk.TreeView.move_cursor", kwlist, &PyGtkTreeView_Type, &self, &py_step, &count))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_MOVEMENT_STEP, py_step, (gpointer)&step))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->move_cursor)
        ret = GTK_TREE_VIEW_CLASS(klass)->move_cursor(GTK_TREE_VIEW(self->obj), step, count);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.move_cursor not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeView__do_select_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeView.select_all", kwlist, &PyGtkTreeView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->select_all)
        ret = GTK_TREE_VIEW_CLASS(klass)->select_all(GTK_TREE_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.select_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeView__do_unselect_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeView.unselect_all", kwlist, &PyGtkTreeView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->unselect_all)
        ret = GTK_TREE_VIEW_CLASS(klass)->unselect_all(GTK_TREE_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.unselect_all not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeView__do_select_cursor_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "start_editing", NULL };
    PyGObject *self;
    int start_editing, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.TreeView.select_cursor_row", kwlist, &PyGtkTreeView_Type, &self, &start_editing))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->select_cursor_row)
        ret = GTK_TREE_VIEW_CLASS(klass)->select_cursor_row(GTK_TREE_VIEW(self->obj), start_editing);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.select_cursor_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeView__do_toggle_cursor_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeView.toggle_cursor_row", kwlist, &PyGtkTreeView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->toggle_cursor_row)
        ret = GTK_TREE_VIEW_CLASS(klass)->toggle_cursor_row(GTK_TREE_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.toggle_cursor_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeView__do_expand_collapse_cursor_row(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "logical", "expand", "open_all", NULL };
    PyGObject *self;
    int logical, expand, open_all, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iii:Gtk.TreeView.expand_collapse_cursor_row", kwlist, &PyGtkTreeView_Type, &self, &logical, &expand, &open_all))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->expand_collapse_cursor_row)
        ret = GTK_TREE_VIEW_CLASS(klass)->expand_collapse_cursor_row(GTK_TREE_VIEW(self->obj), logical, expand, open_all);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.expand_collapse_cursor_row not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeView__do_select_cursor_parent(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeView.select_cursor_parent", kwlist, &PyGtkTreeView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->select_cursor_parent)
        ret = GTK_TREE_VIEW_CLASS(klass)->select_cursor_parent(GTK_TREE_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.select_cursor_parent not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeView__do_start_interactive_search(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeView.start_interactive_search", kwlist, &PyGtkTreeView_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_CLASS(klass)->start_interactive_search)
        ret = GTK_TREE_VIEW_CLASS(klass)->start_interactive_search(GTK_TREE_VIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeView.start_interactive_search not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkTreeView_methods[] = {
    { "get_model", (PyCFunction)_wrap_gtk_tree_view_get_model, METH_NOARGS,
      NULL },
    { "set_model", (PyCFunction)_wrap_gtk_tree_view_set_model, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_selection", (PyCFunction)_wrap_gtk_tree_view_get_selection, METH_NOARGS,
      NULL },
    { "get_hadjustment", (PyCFunction)_wrap_gtk_tree_view_get_hadjustment, METH_NOARGS,
      NULL },
    { "set_hadjustment", (PyCFunction)_wrap_gtk_tree_view_set_hadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_vadjustment", (PyCFunction)_wrap_gtk_tree_view_get_vadjustment, METH_NOARGS,
      NULL },
    { "set_vadjustment", (PyCFunction)_wrap_gtk_tree_view_set_vadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_headers_visible", (PyCFunction)_wrap_gtk_tree_view_get_headers_visible, METH_NOARGS,
      NULL },
    { "set_headers_visible", (PyCFunction)_wrap_gtk_tree_view_set_headers_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "columns_autosize", (PyCFunction)_wrap_gtk_tree_view_columns_autosize, METH_NOARGS,
      NULL },
    { "set_headers_clickable", (PyCFunction)_wrap_gtk_tree_view_set_headers_clickable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_rules_hint", (PyCFunction)_wrap_gtk_tree_view_set_rules_hint, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_rules_hint", (PyCFunction)_wrap_gtk_tree_view_get_rules_hint, METH_NOARGS,
      NULL },
    { "append_column", (PyCFunction)_wrap_gtk_tree_view_append_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_column", (PyCFunction)_wrap_gtk_tree_view_remove_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_column", (PyCFunction)_wrap_gtk_tree_view_insert_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_column_with_attributes", (PyCFunction)_wrap_gtk_tree_view_insert_column_with_attributes, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_column_with_data_func", (PyCFunction)_wrap_gtk_tree_view_insert_column_with_data_func, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_column", (PyCFunction)_wrap_gtk_tree_view_get_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_columns", (PyCFunction)_wrap_gtk_tree_view_get_columns, METH_NOARGS,
      NULL },
    { "move_column_after", (PyCFunction)_wrap_gtk_tree_view_move_column_after, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_expander_column", (PyCFunction)_wrap_gtk_tree_view_set_expander_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_expander_column", (PyCFunction)_wrap_gtk_tree_view_get_expander_column, METH_NOARGS,
      NULL },
    { "set_column_drag_function", (PyCFunction)_wrap_gtk_tree_view_set_column_drag_function, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "scroll_to_point", (PyCFunction)_wrap_gtk_tree_view_scroll_to_point, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "scroll_to_cell", (PyCFunction)_wrap_gtk_tree_view_scroll_to_cell, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "row_activated", (PyCFunction)_wrap_gtk_tree_view_row_activated, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "expand_all", (PyCFunction)_wrap_gtk_tree_view_expand_all, METH_NOARGS,
      NULL },
    { "collapse_all", (PyCFunction)_wrap_gtk_tree_view_collapse_all, METH_NOARGS,
      NULL },
    { "expand_to_path", (PyCFunction)_wrap_gtk_tree_view_expand_to_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "expand_row", (PyCFunction)_wrap_gtk_tree_view_expand_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "collapse_row", (PyCFunction)_wrap_gtk_tree_view_collapse_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "map_expanded_rows", (PyCFunction)_wrap_gtk_tree_view_map_expanded_rows, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "row_expanded", (PyCFunction)_wrap_gtk_tree_view_row_expanded, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_reorderable", (PyCFunction)_wrap_gtk_tree_view_set_reorderable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_reorderable", (PyCFunction)_wrap_gtk_tree_view_get_reorderable, METH_NOARGS,
      NULL },
    { "set_cursor", (PyCFunction)_wrap_gtk_tree_view_set_cursor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_cursor_on_cell", (PyCFunction)_wrap_gtk_tree_view_set_cursor_on_cell, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_cursor", (PyCFunction)_wrap_gtk_tree_view_get_cursor, METH_NOARGS,
      NULL },
    { "get_bin_window", (PyCFunction)_wrap_gtk_tree_view_get_bin_window, METH_NOARGS,
      NULL },
    { "get_path_at_pos", (PyCFunction)_wrap_gtk_tree_view_get_path_at_pos, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_cell_area", (PyCFunction)_wrap_gtk_tree_view_get_cell_area, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_background_area", (PyCFunction)_wrap_gtk_tree_view_get_background_area, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible_rect", (PyCFunction)_wrap_gtk_tree_view_get_visible_rect, METH_NOARGS,
      NULL },
    { "widget_to_tree_coords", (PyCFunction)_wrap_gtk_tree_view_widget_to_tree_coords, METH_VARARGS,
      NULL },
    { "tree_to_widget_coords", (PyCFunction)_wrap_gtk_tree_view_tree_to_widget_coords, METH_VARARGS,
      NULL },
    { "enable_model_drag_source", (PyCFunction)_wrap_gtk_tree_view_enable_model_drag_source, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "enable_model_drag_dest", (PyCFunction)_wrap_gtk_tree_view_enable_model_drag_dest, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unset_rows_drag_source", (PyCFunction)_wrap_gtk_tree_view_unset_rows_drag_source, METH_NOARGS,
      NULL },
    { "unset_rows_drag_dest", (PyCFunction)_wrap_gtk_tree_view_unset_rows_drag_dest, METH_NOARGS,
      NULL },
    { "set_drag_dest_row", (PyCFunction)_wrap_gtk_tree_view_set_drag_dest_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_drag_dest_row", (PyCFunction)_wrap_gtk_tree_view_get_drag_dest_row, METH_NOARGS,
      NULL },
    { "get_dest_row_at_pos", (PyCFunction)_wrap_gtk_tree_view_get_dest_row_at_pos, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "create_row_drag_icon", (PyCFunction)_wrap_gtk_tree_view_create_row_drag_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_enable_search", (PyCFunction)_wrap_gtk_tree_view_set_enable_search, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_enable_search", (PyCFunction)_wrap_gtk_tree_view_get_enable_search, METH_NOARGS,
      NULL },
    { "get_search_column", (PyCFunction)_wrap_gtk_tree_view_get_search_column, METH_NOARGS,
      NULL },
    { "set_search_column", (PyCFunction)_wrap_gtk_tree_view_set_search_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_search_equal_func", (PyCFunction)_wrap_gtk_tree_view_set_search_equal_func, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_fixed_height_mode", (PyCFunction)_wrap_gtk_tree_view_set_fixed_height_mode, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_fixed_height_mode", (PyCFunction)_wrap_gtk_tree_view_get_fixed_height_mode, METH_NOARGS,
      NULL },
    { "set_hover_selection", (PyCFunction)_wrap_gtk_tree_view_set_hover_selection, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_hover_selection", (PyCFunction)_wrap_gtk_tree_view_get_hover_selection, METH_NOARGS,
      NULL },
    { "set_hover_expand", (PyCFunction)_wrap_gtk_tree_view_set_hover_expand, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_hover_expand", (PyCFunction)_wrap_gtk_tree_view_get_hover_expand, METH_NOARGS,
      NULL },
    { "set_row_separator_func", (PyCFunction)_wrap_gtk_tree_view_set_row_separator_func, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible_range", (PyCFunction)_wrap_gtk_tree_view_get_visible_range, METH_NOARGS,
      NULL },
    { "get_headers_clickable", (PyCFunction)_wrap_gtk_tree_view_get_headers_clickable, METH_NOARGS,
      NULL },
    { "get_search_entry", (PyCFunction)_wrap_gtk_tree_view_get_search_entry, METH_NOARGS,
      NULL },
    { "set_search_entry", (PyCFunction)_wrap_gtk_tree_view_set_search_entry, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_search_position_func", (PyCFunction)_wrap_gtk_tree_view_set_search_position_func, METH_VARARGS,
      NULL },
    { "set_rubber_banding", (PyCFunction)_wrap_gtk_tree_view_set_rubber_banding, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_rubber_banding", (PyCFunction)_wrap_gtk_tree_view_get_rubber_banding, METH_NOARGS,
      NULL },
    { "get_grid_lines", (PyCFunction)_wrap_gtk_tree_view_get_grid_lines, METH_NOARGS,
      NULL },
    { "set_grid_lines", (PyCFunction)_wrap_gtk_tree_view_set_grid_lines, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_enable_tree_lines", (PyCFunction)_wrap_gtk_tree_view_get_enable_tree_lines, METH_NOARGS,
      NULL },
    { "set_enable_tree_lines", (PyCFunction)_wrap_gtk_tree_view_set_enable_tree_lines, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_widget_to_tree_coords", (PyCFunction)_wrap_gtk_tree_view_convert_widget_to_tree_coords, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_tree_to_widget_coords", (PyCFunction)_wrap_gtk_tree_view_convert_tree_to_widget_coords, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_widget_to_bin_window_coords", (PyCFunction)_wrap_gtk_tree_view_convert_widget_to_bin_window_coords, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_bin_window_to_widget_coords", (PyCFunction)_wrap_gtk_tree_view_convert_bin_window_to_widget_coords, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_tree_to_bin_window_coords", (PyCFunction)_wrap_gtk_tree_view_convert_tree_to_bin_window_coords, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "convert_bin_window_to_tree_coords", (PyCFunction)_wrap_gtk_tree_view_convert_bin_window_to_tree_coords, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_show_expanders", (PyCFunction)_wrap_gtk_tree_view_set_show_expanders, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_expanders", (PyCFunction)_wrap_gtk_tree_view_get_show_expanders, METH_NOARGS,
      NULL },
    { "set_level_indentation", (PyCFunction)_wrap_gtk_tree_view_set_level_indentation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_level_indentation", (PyCFunction)_wrap_gtk_tree_view_get_level_indentation, METH_NOARGS,
      NULL },
    { "is_rubber_banding_active", (PyCFunction)_wrap_gtk_tree_view_is_rubber_banding_active, METH_NOARGS,
      NULL },
    { "get_tooltip_context", (PyCFunction)_wrap_gtk_tree_view_get_tooltip_context, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tooltip_column", (PyCFunction)_wrap_gtk_tree_view_set_tooltip_column, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tooltip_column", (PyCFunction)_wrap_gtk_tree_view_get_tooltip_column, METH_NOARGS,
      NULL },
    { "set_tooltip_row", (PyCFunction)_wrap_gtk_tree_view_set_tooltip_row, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tooltip_cell", (PyCFunction)_wrap_gtk_tree_view_set_tooltip_cell, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_set_scroll_adjustments", (PyCFunction)_wrap_GtkTreeView__do_set_scroll_adjustments, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_row_activated", (PyCFunction)_wrap_GtkTreeView__do_row_activated, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_test_expand_row", (PyCFunction)_wrap_GtkTreeView__do_test_expand_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_test_collapse_row", (PyCFunction)_wrap_GtkTreeView__do_test_collapse_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_row_expanded", (PyCFunction)_wrap_GtkTreeView__do_row_expanded, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_row_collapsed", (PyCFunction)_wrap_GtkTreeView__do_row_collapsed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_columns_changed", (PyCFunction)_wrap_GtkTreeView__do_columns_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_cursor_changed", (PyCFunction)_wrap_GtkTreeView__do_cursor_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_move_cursor", (PyCFunction)_wrap_GtkTreeView__do_move_cursor, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_all", (PyCFunction)_wrap_GtkTreeView__do_select_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unselect_all", (PyCFunction)_wrap_GtkTreeView__do_unselect_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_cursor_row", (PyCFunction)_wrap_GtkTreeView__do_select_cursor_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_toggle_cursor_row", (PyCFunction)_wrap_GtkTreeView__do_toggle_cursor_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_expand_collapse_cursor_row", (PyCFunction)_wrap_GtkTreeView__do_expand_collapse_cursor_row, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_cursor_parent", (PyCFunction)_wrap_GtkTreeView__do_select_cursor_parent, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_start_interactive_search", (PyCFunction)_wrap_GtkTreeView__do_start_interactive_search, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeView_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeView",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeView_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tree_view_new_with_model,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkTreeView__proxy_do_set_scroll_adjustments(GtkTreeView *self, GtkAdjustment*hadjustment, GtkAdjustment*vadjustment)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_hadjustment = NULL;
    PyObject *py_vadjustment = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (hadjustment)
        py_hadjustment = pygobject_new((GObject *) hadjustment);
    else {
        Py_INCREF(Py_None);
        py_hadjustment = Py_None;
    }
    if (vadjustment)
        py_vadjustment = pygobject_new((GObject *) vadjustment);
    else {
        Py_INCREF(Py_None);
        py_vadjustment = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_hadjustment);
    PyTuple_SET_ITEM(py_args, 1, py_vadjustment);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_scroll_adjustments");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTreeView__proxy_do_row_activated(GtkTreeView *self, GtkTreePath*path, GtkTreeViewColumn*column)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path;
    PyObject *py_column = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (column)
        py_column = pygobject_new((GObject *) column);
    else {
        Py_INCREF(Py_None);
        py_column = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    PyTuple_SET_ITEM(py_args, 1, py_column);
    
    py_method = PyObject_GetAttrString(py_self, "do_row_activated");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkTreeView__proxy_do_test_expand_row(GtkTreeView *self, GtkTreeIter*iter, GtkTreePath*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    PyObject *py_path;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_iter);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    PyTuple_SET_ITEM(py_args, 1, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_test_expand_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeView__proxy_do_test_collapse_row(GtkTreeView *self, GtkTreeIter*iter, GtkTreePath*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    PyObject *py_path;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_iter);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    PyTuple_SET_ITEM(py_args, 1, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_test_collapse_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkTreeView__proxy_do_row_expanded(GtkTreeView *self, GtkTreeIter*iter, GtkTreePath*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    PyObject *py_path;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_iter);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    PyTuple_SET_ITEM(py_args, 1, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_row_expanded");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTreeView__proxy_do_row_collapsed(GtkTreeView *self, GtkTreeIter*iter, GtkTreePath*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    PyObject *py_path;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_iter);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    PyTuple_SET_ITEM(py_args, 1, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_row_collapsed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTreeView__proxy_do_columns_changed(GtkTreeView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_columns_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTreeView__proxy_do_cursor_changed(GtkTreeView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_cursor_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkTreeView__proxy_do_move_cursor(GtkTreeView *self, GtkMovementStep step, gint count)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_step;
    PyObject *py_count;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_step = pyg_enum_from_gtype(GTK_TYPE_MOVEMENT_STEP, step);
    if (!py_step) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_count = PyInt_FromLong(count);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_step);
    PyTuple_SET_ITEM(py_args, 1, py_count);
    
    py_method = PyObject_GetAttrString(py_self, "do_move_cursor");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeView__proxy_do_select_all(GtkTreeView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_select_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeView__proxy_do_unselect_all(GtkTreeView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_unselect_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeView__proxy_do_select_cursor_row(GtkTreeView *self, gboolean start_editing)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_start_editing;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_start_editing = start_editing? Py_True : Py_False;
    
    py_args = PyTuple_New(1);
    Py_INCREF(py_start_editing);
    PyTuple_SET_ITEM(py_args, 0, py_start_editing);
    
    py_method = PyObject_GetAttrString(py_self, "do_select_cursor_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeView__proxy_do_toggle_cursor_row(GtkTreeView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_toggle_cursor_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeView__proxy_do_expand_collapse_cursor_row(GtkTreeView *self, gboolean logical, gboolean expand, gboolean open_all)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_logical;
    PyObject *py_expand;
    PyObject *py_open_all;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_logical = logical? Py_True : Py_False;
    py_expand = expand? Py_True : Py_False;
    py_open_all = open_all? Py_True : Py_False;
    
    py_args = PyTuple_New(3);
    Py_INCREF(py_logical);
    PyTuple_SET_ITEM(py_args, 0, py_logical);
    Py_INCREF(py_expand);
    PyTuple_SET_ITEM(py_args, 1, py_expand);
    Py_INCREF(py_open_all);
    PyTuple_SET_ITEM(py_args, 2, py_open_all);
    
    py_method = PyObject_GetAttrString(py_self, "do_expand_collapse_cursor_row");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeView__proxy_do_select_cursor_parent(GtkTreeView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_select_cursor_parent");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeView__proxy_do_start_interactive_search(GtkTreeView *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_start_interactive_search");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkTreeView_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkTreeViewClass *klass = GTK_TREE_VIEW_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_scroll_adjustments");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_scroll_adjustments")))
            klass->set_scroll_adjustments = _wrap_GtkTreeView__proxy_do_set_scroll_adjustments;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_row_activated");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "row_activated")))
            klass->row_activated = _wrap_GtkTreeView__proxy_do_row_activated;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_test_expand_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "test_expand_row")))
            klass->test_expand_row = _wrap_GtkTreeView__proxy_do_test_expand_row;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_test_collapse_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "test_collapse_row")))
            klass->test_collapse_row = _wrap_GtkTreeView__proxy_do_test_collapse_row;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_row_expanded");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "row_expanded")))
            klass->row_expanded = _wrap_GtkTreeView__proxy_do_row_expanded;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_row_collapsed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "row_collapsed")))
            klass->row_collapsed = _wrap_GtkTreeView__proxy_do_row_collapsed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_columns_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "columns_changed")))
            klass->columns_changed = _wrap_GtkTreeView__proxy_do_columns_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_cursor_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "cursor_changed")))
            klass->cursor_changed = _wrap_GtkTreeView__proxy_do_cursor_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_move_cursor");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "move_cursor")))
            klass->move_cursor = _wrap_GtkTreeView__proxy_do_move_cursor;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_all")))
            klass->select_all = _wrap_GtkTreeView__proxy_do_select_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_unselect_all");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "unselect_all")))
            klass->unselect_all = _wrap_GtkTreeView__proxy_do_unselect_all;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_cursor_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_cursor_row")))
            klass->select_cursor_row = _wrap_GtkTreeView__proxy_do_select_cursor_row;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_toggle_cursor_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "toggle_cursor_row")))
            klass->toggle_cursor_row = _wrap_GtkTreeView__proxy_do_toggle_cursor_row;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_expand_collapse_cursor_row");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "expand_collapse_cursor_row")))
            klass->expand_collapse_cursor_row = _wrap_GtkTreeView__proxy_do_expand_collapse_cursor_row;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_select_cursor_parent");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "select_cursor_parent")))
            klass->select_cursor_parent = _wrap_GtkTreeView__proxy_do_select_cursor_parent;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_start_interactive_search");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "start_interactive_search")))
            klass->start_interactive_search = _wrap_GtkTreeView__proxy_do_start_interactive_search;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkTreeViewColumn ----------- */

#line 78 "gtktreeview.override"
static int
_wrap_gtk_tree_view_column_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    PyObject *py_cell = NULL, *key, *item;
    GtkTreeViewColumn *tvc;
    gchar *title = NULL;
    GtkCellRenderer *cell = NULL;
    Py_ssize_t i = 0;

    if (!PyArg_ParseTuple(args, "|zO:GtkTreeViewColumn.__init__", &title,
                          &py_cell))
        return -1;
    if (py_cell != NULL) {
        if (pygobject_check(py_cell, &PyGtkCellRenderer_Type))
            cell = GTK_CELL_RENDERER(pygobject_get(py_cell));
        else if (py_cell != Py_None) {
            PyErr_SetString(PyExc_TypeError,
                            "cell must be a GtkCellRenderer or None");
            return -1;
        }
    }

    pygobject_construct(self, "title", title, NULL);
    tvc = GTK_TREE_VIEW_COLUMN(self->obj);

    if (cell)
        gtk_tree_view_column_pack_start(tvc, cell, TRUE);

    if (kwargs) {
        while (PyDict_Next(kwargs, &i, &key, &item)) {
            gchar *attr = PyString_AsString(key);

            if (!PyInt_Check(item)) {
                gchar err[128];
                g_snprintf(err, sizeof(err),
                           "%s must be an integer column number", attr);
                PyErr_SetString(PyExc_TypeError, err);
                g_object_unref(tvc);
                self->obj = NULL;
                return -1;
            }

            if (PyBool_Check(item)) {
                g_warning("column number is a boolean, but will be interpreted "
                          "as an integer; this is likely not what you intended");
            }

            gtk_tree_view_column_add_attribute(tvc, cell, attr,
                                               PyInt_AsLong(item));
        }
    }
    return 0;
}
#line 97282 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_column_queue_resize(PyGObject *self)
{
    
    gtk_tree_view_column_queue_resize(GTK_TREE_VIEW_COLUMN(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 162 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_column_get_cell_renderers(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *ret;

    list = gtk_tree_view_column_get_cell_renderers(
                        GTK_TREE_VIEW_COLUMN(self->obj));

    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        GtkWidget *renderer = tmp->data;
        PyObject *item = pygobject_new((GObject *)renderer);

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    g_list_free(list);
    return ret;
}
#line 97316 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_column_add_attribute(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cell_renderer", "attribute", "column", NULL };
    PyGObject *cell_renderer;
    char *attribute;
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!si:Gtk.TreeViewColumn.add_attribute", kwlist, &PyGtkCellRenderer_Type, &cell_renderer, &attribute, &column))
        return NULL;
    
    gtk_tree_view_column_add_attribute(GTK_TREE_VIEW_COLUMN(self->obj), GTK_CELL_RENDERER(cell_renderer->obj), attribute, column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_clear_attributes(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cell_renderer", NULL };
    PyGObject *cell_renderer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeViewColumn.clear_attributes", kwlist, &PyGtkCellRenderer_Type, &cell_renderer))
        return NULL;
    
    gtk_tree_view_column_clear_attributes(GTK_TREE_VIEW_COLUMN(self->obj), GTK_CELL_RENDERER(cell_renderer->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_set_spacing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "spacing", NULL };
    int spacing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_spacing", kwlist, &spacing))
        return NULL;
    
    gtk_tree_view_column_set_spacing(GTK_TREE_VIEW_COLUMN(self->obj), spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_spacing(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_spacing(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_column_set_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible", NULL };
    int visible;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_visible", kwlist, &visible))
        return NULL;
    
    gtk_tree_view_column_set_visible(GTK_TREE_VIEW_COLUMN(self->obj), visible);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_visible(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_column_set_resizable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "resizable", NULL };
    int resizable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_resizable", kwlist, &resizable))
        return NULL;
    
    gtk_tree_view_column_set_resizable(GTK_TREE_VIEW_COLUMN(self->obj), resizable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_resizable(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_resizable(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_column_set_sizing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    GtkTreeViewColumnSizing type;
    PyObject *py_type = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeViewColumn.set_sizing", kwlist, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TREE_VIEW_COLUMN_SIZING, py_type, (gpointer)&type))
        return NULL;
    
    gtk_tree_view_column_set_sizing(GTK_TREE_VIEW_COLUMN(self->obj), type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_sizing(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_sizing(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_column_get_width(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_width(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_column_get_fixed_width(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_fixed_width(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_column_set_fixed_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fixed_width", NULL };
    int fixed_width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_fixed_width", kwlist, &fixed_width))
        return NULL;
    
    gtk_tree_view_column_set_fixed_width(GTK_TREE_VIEW_COLUMN(self->obj), fixed_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_set_min_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "min_width", NULL };
    int min_width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_min_width", kwlist, &min_width))
        return NULL;
    
    gtk_tree_view_column_set_min_width(GTK_TREE_VIEW_COLUMN(self->obj), min_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_min_width(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_min_width(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_column_set_max_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "max_width", NULL };
    int max_width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_max_width", kwlist, &max_width))
        return NULL;
    
    gtk_tree_view_column_set_max_width(GTK_TREE_VIEW_COLUMN(self->obj), max_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_max_width(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_max_width(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_column_clicked(PyGObject *self)
{
    
    gtk_tree_view_column_clicked(GTK_TREE_VIEW_COLUMN(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_set_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "title", NULL };
    char *title;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.TreeViewColumn.set_title", kwlist, &title))
        return NULL;
    
    gtk_tree_view_column_set_title(GTK_TREE_VIEW_COLUMN(self->obj), title);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_title(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_tree_view_column_get_title(GTK_TREE_VIEW_COLUMN(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_set_expand(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "expand", NULL };
    int expand;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_expand", kwlist, &expand))
        return NULL;
    
    gtk_tree_view_column_set_expand(GTK_TREE_VIEW_COLUMN(self->obj), expand);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_expand(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_expand(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_column_set_clickable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "active", NULL };
    int active;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_clickable", kwlist, &active))
        return NULL;
    
    gtk_tree_view_column_set_clickable(GTK_TREE_VIEW_COLUMN(self->obj), active);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_clickable(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_clickable(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_column_set_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *py_widget;
    GtkWidget *widget = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeViewColumn.set_widget", kwlist, &py_widget))
        return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    
    gtk_tree_view_column_set_widget(GTK_TREE_VIEW_COLUMN(self->obj), (GtkWidget *) widget);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_tree_view_column_get_widget(GTK_TREE_VIEW_COLUMN(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tree_view_column_set_alignment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "xalign", NULL };
    double xalign;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.TreeViewColumn.set_alignment", kwlist, &xalign))
        return NULL;
    
    gtk_tree_view_column_set_alignment(GTK_TREE_VIEW_COLUMN(self->obj), xalign);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_alignment(PyGObject *self)
{
    double ret;

    
    ret = gtk_tree_view_column_get_alignment(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_tree_view_column_set_reorderable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "reorderable", NULL };
    int reorderable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_reorderable", kwlist, &reorderable))
        return NULL;
    
    gtk_tree_view_column_set_reorderable(GTK_TREE_VIEW_COLUMN(self->obj), reorderable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_reorderable(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_reorderable(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_column_set_sort_column_id(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sort_column_id", NULL };
    int sort_column_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_sort_column_id", kwlist, &sort_column_id))
        return NULL;
    
    gtk_tree_view_column_set_sort_column_id(GTK_TREE_VIEW_COLUMN(self->obj), sort_column_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_sort_column_id(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_sort_column_id(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_view_column_set_sort_indicator(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeViewColumn.set_sort_indicator", kwlist, &setting))
        return NULL;
    
    gtk_tree_view_column_set_sort_indicator(GTK_TREE_VIEW_COLUMN(self->obj), setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_sort_indicator(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_get_sort_indicator(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_column_set_sort_order(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "order", NULL };
    PyObject *py_order = NULL;
    GtkSortType order;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeViewColumn.set_sort_order", kwlist, &py_order))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SORT_TYPE, py_order, (gpointer)&order))
        return NULL;
    
    gtk_tree_view_column_set_sort_order(GTK_TREE_VIEW_COLUMN(self->obj), order);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_view_column_get_sort_order(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tree_view_column_get_sort_order(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SORT_TYPE, ret);
}

static PyObject *
_wrap_gtk_tree_view_column_cell_set_cell_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tree_model", "iter", "is_expander", "is_expanded", NULL };
    PyGObject *tree_model;
    GtkTreeIter *iter = NULL;
    int is_expander, is_expanded;
    PyObject *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Oii:Gtk.TreeViewColumn.cell_set_cell_data", kwlist, &PyGtkTreeModel_Type, &tree_model, &py_iter, &is_expander, &is_expanded))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_tree_view_column_cell_set_cell_data(GTK_TREE_VIEW_COLUMN(self->obj), GTK_TREE_MODEL(tree_model->obj), iter, is_expander, is_expanded);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 133 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_column_cell_get_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cell_area", NULL };
    PyObject *py_cell_area = Py_None;
    GdkRectangle cell_area = { 0, 0, 0, 0};
    gint x_offset = 0, y_offset = 0, width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|O:GtkTreeViewColumn.cell_get_size",
				     kwlist, &py_cell_area))
        return NULL;

    if (py_cell_area != Py_None) {
        if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
            return NULL;
    }
	
    gtk_tree_view_column_cell_get_size(GTK_TREE_VIEW_COLUMN(self->obj),
                                       (py_cell_area == Py_None) ? NULL : &cell_area,
                                       &x_offset, &y_offset, &width, &height);

    return Py_BuildValue("(Niiii)",
                         pyg_boxed_new(GDK_TYPE_RECTANGLE,
                                       &cell_area, TRUE, TRUE),
                         x_offset, y_offset, width, height);
}
#line 97863 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_column_cell_is_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_view_column_cell_is_visible(GTK_TREE_VIEW_COLUMN(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_view_column_focus_cell(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cell", NULL };
    PyGObject *cell;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeViewColumn.focus_cell", kwlist, &PyGtkCellRenderer_Type, &cell))
        return NULL;
    
    gtk_tree_view_column_focus_cell(GTK_TREE_VIEW_COLUMN(self->obj), GTK_CELL_RENDERER(cell->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3025 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_view_column_cell_get_position(PyGObject *self, PyObject *args,
					     PyObject *kwargs)
{
    static char *kwlist[] = { "cell_renderer", NULL };
    PyGObject *py_cell;
    gint start, width;


    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkTreeViewColumn.cell_get_position",
				     kwlist, &PyGtkCellRenderer_Type,
				     &py_cell))
        return NULL;

    if (gtk_tree_view_column_cell_get_position(GTK_TREE_VIEW_COLUMN(self->obj),
					       GTK_CELL_RENDERER(py_cell->obj),
					       &start, &width))
	return Py_BuildValue("(ii)", start, width);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 97917 "gtk.c"


static PyObject *
_wrap_gtk_tree_view_column_get_tree_view(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_tree_view_column_get_tree_view(GTK_TREE_VIEW_COLUMN(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkTreeViewColumn__do_clicked(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeViewColumn.clicked", kwlist, &PyGtkTreeViewColumn_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_TREE_VIEW_COLUMN_CLASS(klass)->clicked)
        GTK_TREE_VIEW_COLUMN_CLASS(klass)->clicked(GTK_TREE_VIEW_COLUMN(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.TreeViewColumn.clicked not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTreeViewColumn_methods[] = {
    { "queue_resize", (PyCFunction)_wrap_gtk_tree_view_column_queue_resize, METH_NOARGS,
      NULL },
    { "get_cell_renderers", (PyCFunction)_wrap_gtk_tree_view_column_get_cell_renderers, METH_NOARGS,
      NULL },
    { "add_attribute", (PyCFunction)_wrap_gtk_tree_view_column_add_attribute, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "clear_attributes", (PyCFunction)_wrap_gtk_tree_view_column_clear_attributes, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_spacing", (PyCFunction)_wrap_gtk_tree_view_column_set_spacing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_spacing", (PyCFunction)_wrap_gtk_tree_view_column_get_spacing, METH_NOARGS,
      NULL },
    { "set_visible", (PyCFunction)_wrap_gtk_tree_view_column_set_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible", (PyCFunction)_wrap_gtk_tree_view_column_get_visible, METH_NOARGS,
      NULL },
    { "set_resizable", (PyCFunction)_wrap_gtk_tree_view_column_set_resizable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_resizable", (PyCFunction)_wrap_gtk_tree_view_column_get_resizable, METH_NOARGS,
      NULL },
    { "set_sizing", (PyCFunction)_wrap_gtk_tree_view_column_set_sizing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_sizing", (PyCFunction)_wrap_gtk_tree_view_column_get_sizing, METH_NOARGS,
      NULL },
    { "get_width", (PyCFunction)_wrap_gtk_tree_view_column_get_width, METH_NOARGS,
      NULL },
    { "get_fixed_width", (PyCFunction)_wrap_gtk_tree_view_column_get_fixed_width, METH_NOARGS,
      NULL },
    { "set_fixed_width", (PyCFunction)_wrap_gtk_tree_view_column_set_fixed_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_min_width", (PyCFunction)_wrap_gtk_tree_view_column_set_min_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_min_width", (PyCFunction)_wrap_gtk_tree_view_column_get_min_width, METH_NOARGS,
      NULL },
    { "set_max_width", (PyCFunction)_wrap_gtk_tree_view_column_set_max_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_max_width", (PyCFunction)_wrap_gtk_tree_view_column_get_max_width, METH_NOARGS,
      NULL },
    { "clicked", (PyCFunction)_wrap_gtk_tree_view_column_clicked, METH_NOARGS,
      NULL },
    { "set_title", (PyCFunction)_wrap_gtk_tree_view_column_set_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_title", (PyCFunction)_wrap_gtk_tree_view_column_get_title, METH_NOARGS,
      NULL },
    { "set_expand", (PyCFunction)_wrap_gtk_tree_view_column_set_expand, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_expand", (PyCFunction)_wrap_gtk_tree_view_column_get_expand, METH_NOARGS,
      NULL },
    { "set_clickable", (PyCFunction)_wrap_gtk_tree_view_column_set_clickable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_clickable", (PyCFunction)_wrap_gtk_tree_view_column_get_clickable, METH_NOARGS,
      NULL },
    { "set_widget", (PyCFunction)_wrap_gtk_tree_view_column_set_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_widget", (PyCFunction)_wrap_gtk_tree_view_column_get_widget, METH_NOARGS,
      NULL },
    { "set_alignment", (PyCFunction)_wrap_gtk_tree_view_column_set_alignment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_alignment", (PyCFunction)_wrap_gtk_tree_view_column_get_alignment, METH_NOARGS,
      NULL },
    { "set_reorderable", (PyCFunction)_wrap_gtk_tree_view_column_set_reorderable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_reorderable", (PyCFunction)_wrap_gtk_tree_view_column_get_reorderable, METH_NOARGS,
      NULL },
    { "set_sort_column_id", (PyCFunction)_wrap_gtk_tree_view_column_set_sort_column_id, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_sort_column_id", (PyCFunction)_wrap_gtk_tree_view_column_get_sort_column_id, METH_NOARGS,
      NULL },
    { "set_sort_indicator", (PyCFunction)_wrap_gtk_tree_view_column_set_sort_indicator, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_sort_indicator", (PyCFunction)_wrap_gtk_tree_view_column_get_sort_indicator, METH_NOARGS,
      NULL },
    { "set_sort_order", (PyCFunction)_wrap_gtk_tree_view_column_set_sort_order, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_sort_order", (PyCFunction)_wrap_gtk_tree_view_column_get_sort_order, METH_NOARGS,
      NULL },
    { "cell_set_cell_data", (PyCFunction)_wrap_gtk_tree_view_column_cell_set_cell_data, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "cell_get_size", (PyCFunction)_wrap_gtk_tree_view_column_cell_get_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "cell_is_visible", (PyCFunction)_wrap_gtk_tree_view_column_cell_is_visible, METH_NOARGS,
      NULL },
    { "focus_cell", (PyCFunction)_wrap_gtk_tree_view_column_focus_cell, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "cell_get_position", (PyCFunction)_wrap_gtk_tree_view_column_cell_get_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_tree_view", (PyCFunction)_wrap_gtk_tree_view_column_get_tree_view, METH_NOARGS,
      NULL },
    { "do_clicked", (PyCFunction)_wrap_GtkTreeViewColumn__do_clicked, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeViewColumn_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeViewColumn",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeViewColumn_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tree_view_column_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkTreeViewColumn__proxy_do_clicked(GtkTreeViewColumn *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_clicked");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkTreeViewColumn_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkTreeViewColumnClass *klass = GTK_TREE_VIEW_COLUMN_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_clicked");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "clicked")))
            klass->clicked = _wrap_GtkTreeViewColumn__proxy_do_clicked;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkUIManager ----------- */

 static int
_wrap_gtk_ui_manager_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.UIManager.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.UIManager object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_ui_manager_set_add_tearoffs(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "add_tearoffs", NULL };
    int add_tearoffs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.UIManager.set_add_tearoffs", kwlist, &add_tearoffs))
        return NULL;
    
    gtk_ui_manager_set_add_tearoffs(GTK_UI_MANAGER(self->obj), add_tearoffs);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ui_manager_get_add_tearoffs(PyGObject *self)
{
    int ret;

    
    ret = gtk_ui_manager_get_add_tearoffs(GTK_UI_MANAGER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_ui_manager_insert_action_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action_group", "pos", NULL };
    PyGObject *action_group;
    int pos = -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|i:Gtk.UIManager.insert_action_group", kwlist, &PyGtkActionGroup_Type, &action_group, &pos))
        return NULL;
    
    gtk_ui_manager_insert_action_group(GTK_UI_MANAGER(self->obj), GTK_ACTION_GROUP(action_group->obj), pos);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ui_manager_remove_action_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action_group", NULL };
    PyGObject *action_group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.UIManager.remove_action_group", kwlist, &PyGtkActionGroup_Type, &action_group))
        return NULL;
    
    gtk_ui_manager_remove_action_group(GTK_UI_MANAGER(self->obj), GTK_ACTION_GROUP(action_group->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3990 "./gtk.override"
static PyObject *
_wrap_gtk_ui_manager_get_action_groups(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *ret;

    list = gtk_ui_manager_get_action_groups(GTK_UI_MANAGER(self->obj));
    
    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        PyObject *item = pygobject_new(G_OBJECT(tmp->data));

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    
    return ret;
}
#line 98265 "gtk.c"


static PyObject *
_wrap_gtk_ui_manager_get_accel_group(PyGObject *self)
{
    GtkAccelGroup *ret;

    
    ret = gtk_ui_manager_get_accel_group(GTK_UI_MANAGER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_ui_manager_get_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    char *path;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.UIManager.get_widget", kwlist, &path))
        return NULL;
    
    ret = gtk_ui_manager_get_widget(GTK_UI_MANAGER(self->obj), path);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 4010 "./gtk.override"
static PyObject *
_wrap_gtk_ui_manager_get_toplevels(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "types", NULL };
    GtkUIManagerItemType types;
    PyObject *py_types = NULL;
    GSList *list, *tmp;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkUIManager.get_toplevels", kwlist,
				     &py_types))
        return NULL;
    
    if (pyg_flags_get_value(GTK_TYPE_UI_MANAGER_ITEM_TYPE, py_types, (gint *)&types))
        return NULL;

    list = gtk_ui_manager_get_toplevels(GTK_UI_MANAGER(self->obj), types);
    
    ret = PyList_New(0);
    for (tmp = list; tmp; tmp = tmp->next) {
        PyObject *item = pygobject_new(G_OBJECT(tmp->data));

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    
    return ret;
}
#line 98327 "gtk.c"


static PyObject *
_wrap_gtk_ui_manager_get_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    char *path;
    GtkAction *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.UIManager.get_action", kwlist, &path))
        return NULL;
    
    ret = gtk_ui_manager_get_action(GTK_UI_MANAGER(self->obj), path);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 4272 "./gtk.override"
static PyObject *
_wrap_gtk_ui_manager_add_ui_from_string(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    char *buffer;
    Py_ssize_t length;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s#:GtkUIManager.add_ui_from_string",
				     kwlist, &buffer, &length))
        return NULL;
    
    ret = gtk_ui_manager_add_ui_from_string(GTK_UI_MANAGER(self->obj),
					    buffer, length, &error);
    if (pyg_error_check(&error))
        return NULL;
    return PyInt_FromLong(ret);
}
#line 98366 "gtk.c"


static PyObject *
_wrap_gtk_ui_manager_add_ui_from_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;
    GError *error = NULL;
    guint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.UIManager.add_ui_from_file", kwlist, &filename))
        return NULL;
    
    ret = gtk_ui_manager_add_ui_from_file(GTK_UI_MANAGER(self->obj), filename, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_ui_manager_add_ui(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "merge_id", "path", "name", "action", "type", "top", NULL };
    PyObject *py_merge_id = NULL, *py_type = NULL;
    char *path, *name, *action;
    GtkUIManagerItemType type;
    guint merge_id = 0;
    int top;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OsszOi:Gtk.UIManager.add_ui", kwlist, &py_merge_id, &path, &name, &action, &py_type, &top))
        return NULL;
    if (py_merge_id) {
        if (PyLong_Check(py_merge_id))
            merge_id = PyLong_AsUnsignedLong(py_merge_id);
        else if (PyInt_Check(py_merge_id))
            merge_id = PyInt_AsLong(py_merge_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'merge_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GTK_TYPE_UI_MANAGER_ITEM_TYPE, py_type, (gpointer)&type))
        return NULL;
    
    gtk_ui_manager_add_ui(GTK_UI_MANAGER(self->obj), merge_id, path, name, action, type, top);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ui_manager_remove_ui(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "merge_id", NULL };
    PyObject *py_merge_id = NULL;
    guint merge_id = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.UIManager.remove_ui", kwlist, &py_merge_id))
        return NULL;
    if (py_merge_id) {
        if (PyLong_Check(py_merge_id))
            merge_id = PyLong_AsUnsignedLong(py_merge_id);
        else if (PyInt_Check(py_merge_id))
            merge_id = PyInt_AsLong(py_merge_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'merge_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_ui_manager_remove_ui(GTK_UI_MANAGER(self->obj), merge_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ui_manager_get_ui(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_ui_manager_get_ui(GTK_UI_MANAGER(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ui_manager_ensure_update(PyGObject *self)
{
    
    gtk_ui_manager_ensure_update(GTK_UI_MANAGER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_ui_manager_new_merge_id(PyGObject *self)
{
    guint ret;

    
    ret = gtk_ui_manager_new_merge_id(GTK_UI_MANAGER(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_GtkUIManager__do_add_widget(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "widget", NULL };
    PyGObject *self, *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.UIManager.add_widget", kwlist, &PyGtkUIManager_Type, &self, &PyGtkWidget_Type, &widget))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_UI_MANAGER_CLASS(klass)->add_widget)
        GTK_UI_MANAGER_CLASS(klass)->add_widget(GTK_UI_MANAGER(self->obj), GTK_WIDGET(widget->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.UIManager.add_widget not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkUIManager__do_actions_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.UIManager.actions_changed", kwlist, &PyGtkUIManager_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_UI_MANAGER_CLASS(klass)->actions_changed)
        GTK_UI_MANAGER_CLASS(klass)->actions_changed(GTK_UI_MANAGER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.UIManager.actions_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkUIManager__do_connect_proxy(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "action", "proxy", NULL };
    PyGObject *self, *action, *proxy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!:Gtk.UIManager.connect_proxy", kwlist, &PyGtkUIManager_Type, &self, &PyGtkAction_Type, &action, &PyGtkWidget_Type, &proxy))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_UI_MANAGER_CLASS(klass)->connect_proxy)
        GTK_UI_MANAGER_CLASS(klass)->connect_proxy(GTK_UI_MANAGER(self->obj), GTK_ACTION(action->obj), GTK_WIDGET(proxy->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.UIManager.connect_proxy not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkUIManager__do_disconnect_proxy(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "action", "proxy", NULL };
    PyGObject *self, *action, *proxy;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!:Gtk.UIManager.disconnect_proxy", kwlist, &PyGtkUIManager_Type, &self, &PyGtkAction_Type, &action, &PyGtkWidget_Type, &proxy))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_UI_MANAGER_CLASS(klass)->disconnect_proxy)
        GTK_UI_MANAGER_CLASS(klass)->disconnect_proxy(GTK_UI_MANAGER(self->obj), GTK_ACTION(action->obj), GTK_WIDGET(proxy->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.UIManager.disconnect_proxy not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkUIManager__do_pre_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "action", NULL };
    PyGObject *self, *action;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.UIManager.pre_activate", kwlist, &PyGtkUIManager_Type, &self, &PyGtkAction_Type, &action))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_UI_MANAGER_CLASS(klass)->pre_activate)
        GTK_UI_MANAGER_CLASS(klass)->pre_activate(GTK_UI_MANAGER(self->obj), GTK_ACTION(action->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.UIManager.pre_activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkUIManager__do_post_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "action", NULL };
    PyGObject *self, *action;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.UIManager.post_activate", kwlist, &PyGtkUIManager_Type, &self, &PyGtkAction_Type, &action))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_UI_MANAGER_CLASS(klass)->post_activate)
        GTK_UI_MANAGER_CLASS(klass)->post_activate(GTK_UI_MANAGER(self->obj), GTK_ACTION(action->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.UIManager.post_activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkUIManager__do_get_widget(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "path", NULL };
    PyGObject *self;
    char *path;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.UIManager.get_widget", kwlist, &PyGtkUIManager_Type, &self, &path))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_UI_MANAGER_CLASS(klass)->get_widget)
        ret = GTK_UI_MANAGER_CLASS(klass)->get_widget(GTK_UI_MANAGER(self->obj), path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.UIManager.get_widget not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkUIManager__do_get_action(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "path", NULL };
    PyGObject *self;
    char *path;
    GtkAction *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.UIManager.get_action", kwlist, &PyGtkUIManager_Type, &self, &path))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_UI_MANAGER_CLASS(klass)->get_action)
        ret = GTK_UI_MANAGER_CLASS(klass)->get_action(GTK_UI_MANAGER(self->obj), path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.UIManager.get_action not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkUIManager_methods[] = {
    { "set_add_tearoffs", (PyCFunction)_wrap_gtk_ui_manager_set_add_tearoffs, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_add_tearoffs", (PyCFunction)_wrap_gtk_ui_manager_get_add_tearoffs, METH_NOARGS,
      NULL },
    { "insert_action_group", (PyCFunction)_wrap_gtk_ui_manager_insert_action_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_action_group", (PyCFunction)_wrap_gtk_ui_manager_remove_action_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_action_groups", (PyCFunction)_wrap_gtk_ui_manager_get_action_groups, METH_NOARGS,
      NULL },
    { "get_accel_group", (PyCFunction)_wrap_gtk_ui_manager_get_accel_group, METH_NOARGS,
      NULL },
    { "get_widget", (PyCFunction)_wrap_gtk_ui_manager_get_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_toplevels", (PyCFunction)_wrap_gtk_ui_manager_get_toplevels, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_action", (PyCFunction)_wrap_gtk_ui_manager_get_action, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_ui_from_string", (PyCFunction)_wrap_gtk_ui_manager_add_ui_from_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_ui_from_file", (PyCFunction)_wrap_gtk_ui_manager_add_ui_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_ui", (PyCFunction)_wrap_gtk_ui_manager_add_ui, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_ui", (PyCFunction)_wrap_gtk_ui_manager_remove_ui, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_ui", (PyCFunction)_wrap_gtk_ui_manager_get_ui, METH_NOARGS,
      NULL },
    { "ensure_update", (PyCFunction)_wrap_gtk_ui_manager_ensure_update, METH_NOARGS,
      NULL },
    { "new_merge_id", (PyCFunction)_wrap_gtk_ui_manager_new_merge_id, METH_NOARGS,
      NULL },
    { "do_add_widget", (PyCFunction)_wrap_GtkUIManager__do_add_widget, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_actions_changed", (PyCFunction)_wrap_GtkUIManager__do_actions_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_connect_proxy", (PyCFunction)_wrap_GtkUIManager__do_connect_proxy, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_disconnect_proxy", (PyCFunction)_wrap_GtkUIManager__do_disconnect_proxy, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_pre_activate", (PyCFunction)_wrap_GtkUIManager__do_pre_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_post_activate", (PyCFunction)_wrap_GtkUIManager__do_post_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_widget", (PyCFunction)_wrap_GtkUIManager__do_get_widget, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_action", (PyCFunction)_wrap_GtkUIManager__do_get_action, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkUIManager_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.UIManager",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkUIManager_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_ui_manager_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkUIManager__proxy_do_add_widget(GtkUIManager *self, GtkWidget*widget)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_widget = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_widget);
    
    py_method = PyObject_GetAttrString(py_self, "do_add_widget");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkUIManager__proxy_do_actions_changed(GtkUIManager *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_actions_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkUIManager__proxy_do_connect_proxy(GtkUIManager *self, GtkAction*action, GtkWidget*proxy)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_action = NULL;
    PyObject *py_proxy = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (action)
        py_action = pygobject_new((GObject *) action);
    else {
        Py_INCREF(Py_None);
        py_action = Py_None;
    }
    if (proxy)
        py_proxy = pygobject_new((GObject *) proxy);
    else {
        Py_INCREF(Py_None);
        py_proxy = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_action);
    PyTuple_SET_ITEM(py_args, 1, py_proxy);
    
    py_method = PyObject_GetAttrString(py_self, "do_connect_proxy");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkUIManager__proxy_do_disconnect_proxy(GtkUIManager *self, GtkAction*action, GtkWidget*proxy)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_action = NULL;
    PyObject *py_proxy = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (action)
        py_action = pygobject_new((GObject *) action);
    else {
        Py_INCREF(Py_None);
        py_action = Py_None;
    }
    if (proxy)
        py_proxy = pygobject_new((GObject *) proxy);
    else {
        Py_INCREF(Py_None);
        py_proxy = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_action);
    PyTuple_SET_ITEM(py_args, 1, py_proxy);
    
    py_method = PyObject_GetAttrString(py_self, "do_disconnect_proxy");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkUIManager__proxy_do_pre_activate(GtkUIManager *self, GtkAction*action)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_action = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (action)
        py_action = pygobject_new((GObject *) action);
    else {
        Py_INCREF(Py_None);
        py_action = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_action);
    
    py_method = PyObject_GetAttrString(py_self, "do_pre_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkUIManager__proxy_do_post_activate(GtkUIManager *self, GtkAction*action)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_action = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (action)
        py_action = pygobject_new((GObject *) action);
    else {
        Py_INCREF(Py_None);
        py_action = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_action);
    
    py_method = PyObject_GetAttrString(py_self, "do_post_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GtkWidget*
_wrap_GtkUIManager__proxy_do_get_widget(GtkUIManager *self, const gchar*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path = NULL;
    GtkWidget* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (path)
        py_path = PyString_FromString(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_get_widget");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkWidget*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static GtkAction*
_wrap_GtkUIManager__proxy_do_get_action(GtkUIManager *self, const gchar*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path = NULL;
    GtkAction* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (path)
        py_path = PyString_FromString(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_get_action");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkAction*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkUIManager_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkUIManagerClass *klass = GTK_UI_MANAGER_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_add_widget");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "add_widget")))
            klass->add_widget = _wrap_GtkUIManager__proxy_do_add_widget;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_actions_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "actions_changed")))
            klass->actions_changed = _wrap_GtkUIManager__proxy_do_actions_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_connect_proxy");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "connect_proxy")))
            klass->connect_proxy = _wrap_GtkUIManager__proxy_do_connect_proxy;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_disconnect_proxy");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "disconnect_proxy")))
            klass->disconnect_proxy = _wrap_GtkUIManager__proxy_do_disconnect_proxy;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_pre_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "pre_activate")))
            klass->pre_activate = _wrap_GtkUIManager__proxy_do_pre_activate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_post_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "post_activate")))
            klass->post_activate = _wrap_GtkUIManager__proxy_do_post_activate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_get_widget");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "get_widget")))
            klass->get_widget = _wrap_GtkUIManager__proxy_do_get_widget;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_get_action");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "get_action")))
            klass->get_action = _wrap_GtkUIManager__proxy_do_get_action;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkVButtonBox ----------- */

static int
_wrap_gtk_vbutton_box_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.VButtonBox.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.VButtonBox object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkVButtonBox_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.VButtonBox",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_vbutton_box_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkViewport ----------- */

static int
_wrap_gtk_viewport_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[2];
    PyObject *parsed_args[2] = {NULL, };
    char *arg_names[] = {"hadjustment", "vadjustment", NULL };
    char *prop_names[] = {"hadjustment", "vadjustment", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO:gtk.Viewport.__init__" , arg_names , &parsed_args[0] , &parsed_args[1]))
        return -1;

    memset(params, 0, sizeof(GParameter)*2);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Viewport object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_viewport_get_hadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_viewport_get_hadjustment(GTK_VIEWPORT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_viewport_get_vadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_viewport_get_vadjustment(GTK_VIEWPORT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_viewport_set_hadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment;
    GtkAdjustment *adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Viewport.set_hadjustment", kwlist, &py_adjustment))
        return NULL;
    if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if ((PyObject *)py_adjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }
    
    gtk_viewport_set_hadjustment(GTK_VIEWPORT(self->obj), (GtkAdjustment *) adjustment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_viewport_set_vadjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment;
    GtkAdjustment *adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Viewport.set_vadjustment", kwlist, &py_adjustment))
        return NULL;
    if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if ((PyObject *)py_adjustment != Py_None) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }
    
    gtk_viewport_set_vadjustment(GTK_VIEWPORT(self->obj), (GtkAdjustment *) adjustment);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_viewport_set_shadow_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", NULL };
    PyObject *py_type = NULL;
    GtkShadowType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Viewport.set_shadow_type", kwlist, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_type, (gpointer)&type))
        return NULL;
    
    gtk_viewport_set_shadow_type(GTK_VIEWPORT(self->obj), type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_viewport_get_shadow_type(PyGObject *self)
{
    gint ret;

    
    ret = gtk_viewport_get_shadow_type(GTK_VIEWPORT(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_SHADOW_TYPE, ret);
}

static PyObject *
_wrap_gtk_viewport_get_bin_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_viewport_get_bin_window(GTK_VIEWPORT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_viewport_get_view_window(PyGObject *self)
{
    GdkWindow *ret;

    
    ret = gtk_viewport_get_view_window(GTK_VIEWPORT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkViewport__do_set_scroll_adjustments(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "hadjustment", "vadjustment", NULL };
    PyGObject *self, *hadjustment, *vadjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!:Gtk.Viewport.set_scroll_adjustments", kwlist, &PyGtkViewport_Type, &self, &PyGtkAdjustment_Type, &hadjustment, &PyGtkAdjustment_Type, &vadjustment))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_VIEWPORT_CLASS(klass)->set_scroll_adjustments)
        GTK_VIEWPORT_CLASS(klass)->set_scroll_adjustments(GTK_VIEWPORT(self->obj), GTK_ADJUSTMENT(hadjustment->obj), GTK_ADJUSTMENT(vadjustment->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Viewport.set_scroll_adjustments not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkViewport_methods[] = {
    { "get_hadjustment", (PyCFunction)_wrap_gtk_viewport_get_hadjustment, METH_NOARGS,
      NULL },
    { "get_vadjustment", (PyCFunction)_wrap_gtk_viewport_get_vadjustment, METH_NOARGS,
      NULL },
    { "set_hadjustment", (PyCFunction)_wrap_gtk_viewport_set_hadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_vadjustment", (PyCFunction)_wrap_gtk_viewport_set_vadjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_shadow_type", (PyCFunction)_wrap_gtk_viewport_set_shadow_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_shadow_type", (PyCFunction)_wrap_gtk_viewport_get_shadow_type, METH_NOARGS,
      NULL },
    { "get_bin_window", (PyCFunction)_wrap_gtk_viewport_get_bin_window, METH_NOARGS,
      NULL },
    { "get_view_window", (PyCFunction)_wrap_gtk_viewport_get_view_window, METH_NOARGS,
      NULL },
    { "do_set_scroll_adjustments", (PyCFunction)_wrap_GtkViewport__do_set_scroll_adjustments, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkViewport_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Viewport",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkViewport_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_viewport_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkViewport__proxy_do_set_scroll_adjustments(GtkViewport *self, GtkAdjustment*hadjustment, GtkAdjustment*vadjustment)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_hadjustment = NULL;
    PyObject *py_vadjustment = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (hadjustment)
        py_hadjustment = pygobject_new((GObject *) hadjustment);
    else {
        Py_INCREF(Py_None);
        py_hadjustment = Py_None;
    }
    if (vadjustment)
        py_vadjustment = pygobject_new((GObject *) vadjustment);
    else {
        Py_INCREF(Py_None);
        py_vadjustment = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_hadjustment);
    PyTuple_SET_ITEM(py_args, 1, py_vadjustment);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_scroll_adjustments");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkViewport_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkViewportClass *klass = GTK_VIEWPORT_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_set_scroll_adjustments");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "set_scroll_adjustments")))
            klass->set_scroll_adjustments = _wrap_GtkViewport__proxy_do_set_scroll_adjustments;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkVPaned ----------- */

 static int
_wrap_gtk_vpaned_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.VPaned.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.VPaned object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkVPaned_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.VPaned",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_vpaned_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkVRuler ----------- */

static int
_wrap_gtk_vruler_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.VRuler.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.VRuler object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkVRuler_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.VRuler",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_vruler_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkVScale ----------- */

static int
_wrap_gtk_vscale_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"adjustment", NULL };
    char *prop_names[] = {"adjustment", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.VScale.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.VScale object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkVScale_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.VScale",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_vscale_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkVScrollbar ----------- */

 static int
_wrap_gtk_vscrollbar_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"adjustment", NULL };
    char *prop_names[] = {"adjustment", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.VScrollbar.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.VScrollbar object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkVScrollbar_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.VScrollbar",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_vscrollbar_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkVSeparator ----------- */

 static int
_wrap_gtk_vseparator_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.VSeparator.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.VSeparator object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkVSeparator_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.VSeparator",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_vseparator_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkWindowGroup ----------- */

static int
_wrap_gtk_window_group_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.WindowGroup.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.WindowGroup object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_window_group_add_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", NULL };
    PyGObject *window;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.WindowGroup.add_window", kwlist, &PyGtkWindow_Type, &window))
        return NULL;
    
    gtk_window_group_add_window(GTK_WINDOW_GROUP(self->obj), GTK_WINDOW(window->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_group_remove_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", NULL };
    PyGObject *window;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.WindowGroup.remove_window", kwlist, &PyGtkWindow_Type, &window))
        return NULL;
    
    gtk_window_group_remove_window(GTK_WINDOW_GROUP(self->obj), GTK_WINDOW(window->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_group_get_current_grab(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_window_group_get_current_grab(GTK_WINDOW_GROUP(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkWindowGroup_methods[] = {
    { "add_window", (PyCFunction)_wrap_gtk_window_group_add_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_window", (PyCFunction)_wrap_gtk_window_group_remove_window, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_grab", (PyCFunction)_wrap_gtk_window_group_get_current_grab, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkWindowGroup_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.WindowGroup",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkWindowGroup_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_window_group_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};









/* ----------- GtkAssistant ----------- */

static int
_wrap_gtk_assistant_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Assistant.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Assistant object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_assistant_get_current_page(PyGObject *self)
{
    int ret;

    
    ret = gtk_assistant_get_current_page(GTK_ASSISTANT(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_assistant_set_current_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_num", NULL };
    int page_num;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Assistant.set_current_page", kwlist, &page_num))
        return NULL;
    
    gtk_assistant_set_current_page(GTK_ASSISTANT(self->obj), page_num);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_assistant_get_n_pages(PyGObject *self)
{
    int ret;

    
    ret = gtk_assistant_get_n_pages(GTK_ASSISTANT(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_assistant_get_nth_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_num", NULL };
    int page_num;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Assistant.get_nth_page", kwlist, &page_num))
        return NULL;
    
    ret = gtk_assistant_get_nth_page(GTK_ASSISTANT(self->obj), page_num);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_assistant_prepend_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", NULL };
    PyGObject *page;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.prepend_page", kwlist, &PyGtkWidget_Type, &page))
        return NULL;
    
    ret = gtk_assistant_prepend_page(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_assistant_append_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", NULL };
    PyGObject *page;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.append_page", kwlist, &PyGtkWidget_Type, &page))
        return NULL;
    
    ret = gtk_assistant_append_page(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_assistant_insert_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", "position", NULL };
    PyGObject *page;
    int position, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Assistant.insert_page", kwlist, &PyGtkWidget_Type, &page, &position))
        return NULL;
    
    ret = gtk_assistant_insert_page(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj), position);
    
    return PyInt_FromLong(ret);
}

#line 6911 "./gtk.override"
static gint
pygtk_assistant_set_forward_page_func_cb(gint current_page,
                                         gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    gint ret = current_page;
    PyObject *retobj;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(iO)",
                                     current_page, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(i)", current_page);
    }

    if (retobj != NULL) {
        ret = PyInt_AsLong(retobj);
        Py_DECREF(retobj);
    } else {
        PyErr_Print();
    }
  
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_assistant_set_forward_page_func(PyGObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    static char *kwlist[] = { "page_func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                          "O|O:GtkAssistant.set_forward_page_func",
                          kwlist, &pyfunc, &pyarg))
        return NULL;

    if (pyfunc != Py_None  && !PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "page_func must be a callable object");
        return NULL;
    }

    if (pyfunc == Py_None) {
        gtk_assistant_set_forward_page_func(GTK_ASSISTANT(self->obj),
                                            NULL, NULL, NULL);
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);
 
        gtk_assistant_set_forward_page_func(GTK_ASSISTANT(self->obj),
                                            pygtk_assistant_set_forward_page_func_cb,
                                            cunote, pygtk_custom_destroy_notify);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 100482 "gtk.c"


static PyObject *
_wrap_gtk_assistant_set_page_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", "type", NULL };
    PyGObject *page;
    PyObject *py_type = NULL;
    GtkAssistantPageType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Assistant.set_page_type", kwlist, &PyGtkWidget_Type, &page, &py_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ASSISTANT_PAGE_TYPE, py_type, (gpointer)&type))
        return NULL;
    
    gtk_assistant_set_page_type(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj), type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_assistant_get_page_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", NULL };
    PyGObject *page;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.get_page_type", kwlist, &PyGtkWidget_Type, &page))
        return NULL;
    
    ret = gtk_assistant_get_page_type(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ASSISTANT_PAGE_TYPE, ret);
}

static PyObject *
_wrap_gtk_assistant_set_page_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", "title", NULL };
    PyGObject *page;
    char *title;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.Assistant.set_page_title", kwlist, &PyGtkWidget_Type, &page, &title))
        return NULL;
    
    gtk_assistant_set_page_title(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj), title);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_assistant_get_page_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", NULL };
    PyGObject *page;
    const gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.get_page_title", kwlist, &PyGtkWidget_Type, &page))
        return NULL;
    
    ret = gtk_assistant_get_page_title(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_assistant_set_page_header_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", "pixbuf", NULL };
    PyGObject *page, *py_pixbuf = NULL;
    GdkPixbuf *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|O:Gtk.Assistant.set_page_header_image", kwlist, &PyGtkWidget_Type, &page, &py_pixbuf))
        return NULL;
    if ((PyObject *)py_pixbuf == Py_None)
        pixbuf = NULL;
    else if (py_pixbuf && pygobject_check(py_pixbuf, &PyGdkPixbuf_Type))
        pixbuf = GDK_PIXBUF(py_pixbuf->obj);
    else if (py_pixbuf) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf or None");
        return NULL;
    }
    
    gtk_assistant_set_page_header_image(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj), (GdkPixbuf *) pixbuf);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_assistant_get_page_header_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", NULL };
    PyGObject *page;
    GdkPixbuf *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.get_page_header_image", kwlist, &PyGtkWidget_Type, &page))
        return NULL;
    
    ret = gtk_assistant_get_page_header_image(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_assistant_set_page_side_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", "pixbuf", NULL };
    PyGObject *page, *py_pixbuf = NULL;
    GdkPixbuf *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|O:Gtk.Assistant.set_page_side_image", kwlist, &PyGtkWidget_Type, &page, &py_pixbuf))
        return NULL;
    if ((PyObject *)py_pixbuf == Py_None)
        pixbuf = NULL;
    else if (py_pixbuf && pygobject_check(py_pixbuf, &PyGdkPixbuf_Type))
        pixbuf = GDK_PIXBUF(py_pixbuf->obj);
    else if (py_pixbuf) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf or None");
        return NULL;
    }
    
    gtk_assistant_set_page_side_image(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj), (GdkPixbuf *) pixbuf);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_assistant_get_page_side_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", NULL };
    PyGObject *page;
    GdkPixbuf *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.get_page_side_image", kwlist, &PyGtkWidget_Type, &page))
        return NULL;
    
    ret = gtk_assistant_get_page_side_image(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_assistant_set_page_complete(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", "complete", NULL };
    PyGObject *page;
    int complete;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Assistant.set_page_complete", kwlist, &PyGtkWidget_Type, &page, &complete))
        return NULL;
    
    gtk_assistant_set_page_complete(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj), complete);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_assistant_get_page_complete(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page", NULL };
    PyGObject *page;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.get_page_complete", kwlist, &PyGtkWidget_Type, &page))
        return NULL;
    
    ret = gtk_assistant_get_page_complete(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_assistant_add_action_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.add_action_widget", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    gtk_assistant_add_action_widget(GTK_ASSISTANT(self->obj), GTK_WIDGET(child->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_assistant_remove_action_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.remove_action_widget", kwlist, &PyGtkWidget_Type, &child))
        return NULL;
    
    gtk_assistant_remove_action_widget(GTK_ASSISTANT(self->obj), GTK_WIDGET(child->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_assistant_update_buttons_state(PyGObject *self)
{
    
    gtk_assistant_update_buttons_state(GTK_ASSISTANT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_assistant_commit(PyGObject *self)
{
    
    gtk_assistant_commit(GTK_ASSISTANT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkAssistant__do_prepare(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "page", NULL };
    PyGObject *self, *page;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Assistant.prepare", kwlist, &PyGtkAssistant_Type, &self, &PyGtkWidget_Type, &page))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ASSISTANT_CLASS(klass)->prepare)
        GTK_ASSISTANT_CLASS(klass)->prepare(GTK_ASSISTANT(self->obj), GTK_WIDGET(page->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Assistant.prepare not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkAssistant__do_apply(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.apply", kwlist, &PyGtkAssistant_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ASSISTANT_CLASS(klass)->apply)
        GTK_ASSISTANT_CLASS(klass)->apply(GTK_ASSISTANT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Assistant.apply not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkAssistant__do_close(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.close", kwlist, &PyGtkAssistant_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ASSISTANT_CLASS(klass)->close)
        GTK_ASSISTANT_CLASS(klass)->close(GTK_ASSISTANT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Assistant.close not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkAssistant__do_cancel(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Assistant.cancel", kwlist, &PyGtkAssistant_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_ASSISTANT_CLASS(klass)->cancel)
        GTK_ASSISTANT_CLASS(klass)->cancel(GTK_ASSISTANT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Assistant.cancel not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkAssistant_methods[] = {
    { "get_current_page", (PyCFunction)_wrap_gtk_assistant_get_current_page, METH_NOARGS,
      NULL },
    { "set_current_page", (PyCFunction)_wrap_gtk_assistant_set_current_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_n_pages", (PyCFunction)_wrap_gtk_assistant_get_n_pages, METH_NOARGS,
      NULL },
    { "get_nth_page", (PyCFunction)_wrap_gtk_assistant_get_nth_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "prepend_page", (PyCFunction)_wrap_gtk_assistant_prepend_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "append_page", (PyCFunction)_wrap_gtk_assistant_append_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "insert_page", (PyCFunction)_wrap_gtk_assistant_insert_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_forward_page_func", (PyCFunction)_wrap_gtk_assistant_set_forward_page_func, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_page_type", (PyCFunction)_wrap_gtk_assistant_set_page_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_type", (PyCFunction)_wrap_gtk_assistant_get_page_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_page_title", (PyCFunction)_wrap_gtk_assistant_set_page_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_title", (PyCFunction)_wrap_gtk_assistant_get_page_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_page_header_image", (PyCFunction)_wrap_gtk_assistant_set_page_header_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_header_image", (PyCFunction)_wrap_gtk_assistant_get_page_header_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_page_side_image", (PyCFunction)_wrap_gtk_assistant_set_page_side_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_side_image", (PyCFunction)_wrap_gtk_assistant_get_page_side_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_page_complete", (PyCFunction)_wrap_gtk_assistant_set_page_complete, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_complete", (PyCFunction)_wrap_gtk_assistant_get_page_complete, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_action_widget", (PyCFunction)_wrap_gtk_assistant_add_action_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_action_widget", (PyCFunction)_wrap_gtk_assistant_remove_action_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "update_buttons_state", (PyCFunction)_wrap_gtk_assistant_update_buttons_state, METH_NOARGS,
      NULL },
    { "commit", (PyCFunction)_wrap_gtk_assistant_commit, METH_NOARGS,
      NULL },
    { "do_prepare", (PyCFunction)_wrap_GtkAssistant__do_prepare, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_apply", (PyCFunction)_wrap_GtkAssistant__do_apply, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_close", (PyCFunction)_wrap_GtkAssistant__do_close, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_cancel", (PyCFunction)_wrap_GtkAssistant__do_cancel, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkAssistant_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Assistant",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkAssistant_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_assistant_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkAssistant__proxy_do_prepare(GtkAssistant *self, GtkWidget*page)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_page = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (page)
        py_page = pygobject_new((GObject *) page);
    else {
        Py_INCREF(Py_None);
        py_page = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_page);
    
    py_method = PyObject_GetAttrString(py_self, "do_prepare");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkAssistant__proxy_do_apply(GtkAssistant *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_apply");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkAssistant__proxy_do_close(GtkAssistant *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_close");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkAssistant__proxy_do_cancel(GtkAssistant *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_cancel");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkAssistant_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkAssistantClass *klass = GTK_ASSISTANT_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_prepare");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "prepare")))
            klass->prepare = _wrap_GtkAssistant__proxy_do_prepare;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_apply");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "apply")))
            klass->apply = _wrap_GtkAssistant__proxy_do_apply;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_close");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "close")))
            klass->close = _wrap_GtkAssistant__proxy_do_close;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_cancel");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "cancel")))
            klass->cancel = _wrap_GtkAssistant__proxy_do_cancel;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkCellRendererAccel ----------- */

static int
_wrap_gtk_cell_renderer_accel_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.CellRendererAccel.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.CellRendererAccel object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_GtkCellRendererAccel__do_accel_edited(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "path_string", "accel_key", "accel_mods", "hardware_keycode", NULL };
    PyGObject *self;
    char *path_string;
    PyObject *py_accel_key = NULL, *py_accel_mods = NULL, *py_hardware_keycode = NULL;
    GdkModifierType accel_mods;
    guint accel_key = 0, hardware_keycode = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!sOOO:Gtk.CellRendererAccel.accel_edited", kwlist, &PyGtkCellRendererAccel_Type, &self, &path_string, &py_accel_key, &py_accel_mods, &py_hardware_keycode))
        return NULL;
    if (py_accel_key) {
        if (PyLong_Check(py_accel_key))
            accel_key = PyLong_AsUnsignedLong(py_accel_key);
        else if (PyInt_Check(py_accel_key))
            accel_key = PyInt_AsLong(py_accel_key);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'accel_key' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gpointer)&accel_mods))
        return NULL;
    if (py_hardware_keycode) {
        if (PyLong_Check(py_hardware_keycode))
            hardware_keycode = PyLong_AsUnsignedLong(py_hardware_keycode);
        else if (PyInt_Check(py_hardware_keycode))
            hardware_keycode = PyInt_AsLong(py_hardware_keycode);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'hardware_keycode' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_ACCEL_CLASS(klass)->accel_edited)
        GTK_CELL_RENDERER_ACCEL_CLASS(klass)->accel_edited(GTK_CELL_RENDERER_ACCEL(self->obj), path_string, accel_key, accel_mods, hardware_keycode);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CellRendererAccel.accel_edited not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellRendererAccel__do_accel_cleared(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "path_string", NULL };
    PyGObject *self;
    char *path_string;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.CellRendererAccel.accel_cleared", kwlist, &PyGtkCellRendererAccel_Type, &self, &path_string))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_CELL_RENDERER_ACCEL_CLASS(klass)->accel_cleared)
        GTK_CELL_RENDERER_ACCEL_CLASS(klass)->accel_cleared(GTK_CELL_RENDERER_ACCEL(self->obj), path_string);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.CellRendererAccel.accel_cleared not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCellRendererAccel_methods[] = {
    { "do_accel_edited", (PyCFunction)_wrap_GtkCellRendererAccel__do_accel_edited, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_accel_cleared", (PyCFunction)_wrap_GtkCellRendererAccel__do_accel_cleared, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererAccel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellRendererAccel",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCellRendererAccel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_cell_renderer_accel_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCellRendererAccel__proxy_do_accel_edited(GtkCellRendererAccel *self, const gchar*path_string, guint accel_key, GdkModifierType accel_mods, guint hardware_keycode)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path_string = NULL;
    PyObject *py_accel_key;
    PyObject *py_accel_mods;
    PyObject *py_hardware_keycode;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (path_string)
        py_path_string = PyString_FromString(path_string);
    if (!py_path_string) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_accel_key = PyInt_FromLong(accel_key);
    py_accel_mods = pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, accel_mods);
    if (!py_accel_mods) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_accel_key);
        Py_DECREF(py_path_string);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_hardware_keycode = PyInt_FromLong(hardware_keycode);
    
    py_args = PyTuple_New(4);
    PyTuple_SET_ITEM(py_args, 0, py_path_string);
    PyTuple_SET_ITEM(py_args, 1, py_accel_key);
    PyTuple_SET_ITEM(py_args, 2, py_accel_mods);
    PyTuple_SET_ITEM(py_args, 3, py_hardware_keycode);
    
    py_method = PyObject_GetAttrString(py_self, "do_accel_edited");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCellRendererAccel__proxy_do_accel_cleared(GtkCellRendererAccel *self, const gchar*path_string)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path_string = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (path_string)
        py_path_string = PyString_FromString(path_string);
    if (!py_path_string) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_path_string);
    
    py_method = PyObject_GetAttrString(py_self, "do_accel_cleared");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkCellRendererAccel_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkCellRendererAccelClass *klass = GTK_CELL_RENDERER_ACCEL_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_accel_edited");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "accel_edited")))
            klass->accel_edited = _wrap_GtkCellRendererAccel__proxy_do_accel_edited;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_accel_cleared");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "accel_cleared")))
            klass->accel_cleared = _wrap_GtkCellRendererAccel__proxy_do_accel_cleared;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkCellRendererSpin ----------- */

static int
_wrap_gtk_cell_renderer_spin_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.CellRendererSpin.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.CellRendererSpin object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererSpin_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellRendererSpin",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_cell_renderer_spin_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkLinkButton ----------- */

static int
_wrap_gtk_link_button_new_with_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[2];
    PyObject *parsed_args[2] = {NULL, };
    char *arg_names[] = {"uri", "label", NULL };
    char *prop_names[] = {"uri", "label", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:gtk.LinkButton.__init__" , arg_names , &parsed_args[0] , &parsed_args[1]))
        return -1;

    memset(params, 0, sizeof(GParameter)*2);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.LinkButton object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_link_button_get_uri(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_link_button_get_uri(GTK_LINK_BUTTON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_link_button_set_uri(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.LinkButton.set_uri", kwlist, &uri))
        return NULL;
    
    gtk_link_button_set_uri(GTK_LINK_BUTTON(self->obj), uri);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_link_button_get_visited(PyGObject *self)
{
    int ret;

    
    ret = gtk_link_button_get_visited(GTK_LINK_BUTTON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_link_button_set_visited(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visited", NULL };
    int visited;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.LinkButton.set_visited", kwlist, &visited))
        return NULL;
    
    gtk_link_button_set_visited(GTK_LINK_BUTTON(self->obj), visited);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkLinkButton_methods[] = {
    { "get_uri", (PyCFunction)_wrap_gtk_link_button_get_uri, METH_NOARGS,
      NULL },
    { "set_uri", (PyCFunction)_wrap_gtk_link_button_set_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visited", (PyCFunction)_wrap_gtk_link_button_get_visited, METH_NOARGS,
      NULL },
    { "set_visited", (PyCFunction)_wrap_gtk_link_button_set_visited, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkLinkButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.LinkButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkLinkButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_link_button_new_with_label,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkPageSetup ----------- */

 static int
_wrap_gtk_page_setup_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.PageSetup.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.PageSetup object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_page_setup_copy(PyGObject *self)
{
    GtkPageSetup *ret;

    
    ret = gtk_page_setup_copy(GTK_PAGE_SETUP(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_page_setup_get_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_page_setup_get_orientation(GTK_PAGE_SETUP(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_PAGE_ORIENTATION, ret);
}

static PyObject *
_wrap_gtk_page_setup_set_orientation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "orientation", NULL };
    PyObject *py_orientation = NULL;
    GtkPageOrientation orientation;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.set_orientation", kwlist, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PAGE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    
    gtk_page_setup_set_orientation(GTK_PAGE_SETUP(self->obj), orientation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_page_setup_get_paper_size(PyGObject *self)
{
    GtkPaperSize *ret;

    
    ret = gtk_page_setup_get_paper_size(GTK_PAGE_SETUP(self->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_PAPER_SIZE, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_page_setup_set_paper_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    PyObject *py_size;
    GtkPaperSize *size = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.set_paper_size", kwlist, &py_size))
        return NULL;
    if (pyg_boxed_check(py_size, GTK_TYPE_PAPER_SIZE))
        size = pyg_boxed_get(py_size, GtkPaperSize);
    else {
        PyErr_SetString(PyExc_TypeError, "size should be a GtkPaperSize");
        return NULL;
    }
    
    gtk_page_setup_set_paper_size(GTK_PAGE_SETUP(self->obj), size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_page_setup_get_top_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.get_top_margin", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_page_setup_get_top_margin(GTK_PAGE_SETUP(self->obj), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_page_setup_set_top_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "margin", "unit", NULL };
    PyObject *py_unit = NULL;
    double margin;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dO:Gtk.PageSetup.set_top_margin", kwlist, &margin, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    gtk_page_setup_set_top_margin(GTK_PAGE_SETUP(self->obj), margin, unit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_page_setup_get_bottom_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.get_bottom_margin", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_page_setup_get_bottom_margin(GTK_PAGE_SETUP(self->obj), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_page_setup_set_bottom_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "margin", "unit", NULL };
    PyObject *py_unit = NULL;
    double margin;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dO:Gtk.PageSetup.set_bottom_margin", kwlist, &margin, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    gtk_page_setup_set_bottom_margin(GTK_PAGE_SETUP(self->obj), margin, unit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_page_setup_get_left_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.get_left_margin", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_page_setup_get_left_margin(GTK_PAGE_SETUP(self->obj), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_page_setup_set_left_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "margin", "unit", NULL };
    PyObject *py_unit = NULL;
    double margin;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dO:Gtk.PageSetup.set_left_margin", kwlist, &margin, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    gtk_page_setup_set_left_margin(GTK_PAGE_SETUP(self->obj), margin, unit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_page_setup_get_right_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.get_right_margin", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_page_setup_get_right_margin(GTK_PAGE_SETUP(self->obj), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_page_setup_set_right_margin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "margin", "unit", NULL };
    PyObject *py_unit = NULL;
    double margin;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dO:Gtk.PageSetup.set_right_margin", kwlist, &margin, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    gtk_page_setup_set_right_margin(GTK_PAGE_SETUP(self->obj), margin, unit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_page_setup_set_paper_size_and_default_margins(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    PyObject *py_size;
    GtkPaperSize *size = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.set_paper_size_and_default_margins", kwlist, &py_size))
        return NULL;
    if (pyg_boxed_check(py_size, GTK_TYPE_PAPER_SIZE))
        size = pyg_boxed_get(py_size, GtkPaperSize);
    else {
        PyErr_SetString(PyExc_TypeError, "size should be a GtkPaperSize");
        return NULL;
    }
    
    gtk_page_setup_set_paper_size_and_default_margins(GTK_PAGE_SETUP(self->obj), size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_page_setup_get_paper_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.get_paper_width", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_page_setup_get_paper_width(GTK_PAGE_SETUP(self->obj), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_page_setup_get_paper_height(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.get_paper_height", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_page_setup_get_paper_height(GTK_PAGE_SETUP(self->obj), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_page_setup_get_page_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.get_page_width", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_page_setup_get_page_width(GTK_PAGE_SETUP(self->obj), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_page_setup_get_page_height(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PageSetup.get_page_height", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_page_setup_get_page_height(GTK_PAGE_SETUP(self->obj), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_page_setup_to_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file_name", NULL };
    char *file_name;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PageSetup.to_file", kwlist, &file_name))
        return NULL;
    
    ret = gtk_page_setup_to_file(GTK_PAGE_SETUP(self->obj), file_name, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_page_setup_load_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file_name", NULL };
    char *file_name;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PageSetup.load_file", kwlist, &file_name))
        return NULL;
    
    ret = gtk_page_setup_load_file(GTK_PAGE_SETUP(self->obj), file_name, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkPageSetup_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_page_setup_copy, METH_NOARGS,
      NULL },
    { "get_orientation", (PyCFunction)_wrap_gtk_page_setup_get_orientation, METH_NOARGS,
      NULL },
    { "set_orientation", (PyCFunction)_wrap_gtk_page_setup_set_orientation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_paper_size", (PyCFunction)_wrap_gtk_page_setup_get_paper_size, METH_NOARGS,
      NULL },
    { "set_paper_size", (PyCFunction)_wrap_gtk_page_setup_set_paper_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_top_margin", (PyCFunction)_wrap_gtk_page_setup_get_top_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_top_margin", (PyCFunction)_wrap_gtk_page_setup_set_top_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_bottom_margin", (PyCFunction)_wrap_gtk_page_setup_get_bottom_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_bottom_margin", (PyCFunction)_wrap_gtk_page_setup_set_bottom_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_left_margin", (PyCFunction)_wrap_gtk_page_setup_get_left_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_left_margin", (PyCFunction)_wrap_gtk_page_setup_set_left_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_right_margin", (PyCFunction)_wrap_gtk_page_setup_get_right_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_right_margin", (PyCFunction)_wrap_gtk_page_setup_set_right_margin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_paper_size_and_default_margins", (PyCFunction)_wrap_gtk_page_setup_set_paper_size_and_default_margins, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_paper_width", (PyCFunction)_wrap_gtk_page_setup_get_paper_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_paper_height", (PyCFunction)_wrap_gtk_page_setup_get_paper_height, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_width", (PyCFunction)_wrap_gtk_page_setup_get_page_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_height", (PyCFunction)_wrap_gtk_page_setup_get_page_height, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "to_file", (PyCFunction)_wrap_gtk_page_setup_to_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "load_file", (PyCFunction)_wrap_gtk_page_setup_load_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkPageSetup_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.PageSetup",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkPageSetup_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_page_setup_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkPrintContext ----------- */

#line 6899 "./gtk.override"
static PyObject *
_wrap_gtk_print_context_get_cairo_context(PyGObject *self)
{
    cairo_t *ret;

    ret = gtk_print_context_get_cairo_context(GTK_PRINT_CONTEXT(self->obj));

    cairo_reference(ret);
    return PycairoContext_FromContext(ret, &PyGdkCairoContext_Type, NULL);
}
#line 102207 "gtk.c"


static PyObject *
_wrap_gtk_print_context_get_page_setup(PyGObject *self)
{
    GtkPageSetup *ret;

    
    ret = gtk_print_context_get_page_setup(GTK_PRINT_CONTEXT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_print_context_get_width(PyGObject *self)
{
    double ret;

    
    ret = gtk_print_context_get_width(GTK_PRINT_CONTEXT(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_context_get_height(PyGObject *self)
{
    double ret;

    
    ret = gtk_print_context_get_height(GTK_PRINT_CONTEXT(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_context_get_dpi_x(PyGObject *self)
{
    double ret;

    
    ret = gtk_print_context_get_dpi_x(GTK_PRINT_CONTEXT(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_context_get_dpi_y(PyGObject *self)
{
    double ret;

    
    ret = gtk_print_context_get_dpi_y(GTK_PRINT_CONTEXT(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_context_get_pango_fontmap(PyGObject *self)
{
    PangoFontMap *ret;

    
    ret = gtk_print_context_get_pango_fontmap(GTK_PRINT_CONTEXT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_print_context_create_pango_context(PyGObject *self)
{
    PangoContext *ret;

    
    ret = gtk_print_context_create_pango_context(GTK_PRINT_CONTEXT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_print_context_create_pango_layout(PyGObject *self)
{
    PangoLayout *ret;

    
    ret = gtk_print_context_create_pango_layout(GTK_PRINT_CONTEXT(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_print_context_set_cairo_context(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cr", "dpi_x", "dpi_y", NULL };
    double dpi_x, dpi_y;
    PycairoContext *cr;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!dd:Gtk.PrintContext.set_cairo_context", kwlist, &PycairoContext_Type, &cr, &dpi_x, &dpi_y))
        return NULL;
    
    gtk_print_context_set_cairo_context(GTK_PRINT_CONTEXT(self->obj), cr->ctx, dpi_x, dpi_y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkPrintContext_methods[] = {
    { "get_cairo_context", (PyCFunction)_wrap_gtk_print_context_get_cairo_context, METH_NOARGS,
      NULL },
    { "get_page_setup", (PyCFunction)_wrap_gtk_print_context_get_page_setup, METH_NOARGS,
      NULL },
    { "get_width", (PyCFunction)_wrap_gtk_print_context_get_width, METH_NOARGS,
      NULL },
    { "get_height", (PyCFunction)_wrap_gtk_print_context_get_height, METH_NOARGS,
      NULL },
    { "get_dpi_x", (PyCFunction)_wrap_gtk_print_context_get_dpi_x, METH_NOARGS,
      NULL },
    { "get_dpi_y", (PyCFunction)_wrap_gtk_print_context_get_dpi_y, METH_NOARGS,
      NULL },
    { "get_pango_fontmap", (PyCFunction)_wrap_gtk_print_context_get_pango_fontmap, METH_NOARGS,
      NULL },
    { "create_pango_context", (PyCFunction)_wrap_gtk_print_context_create_pango_context, METH_NOARGS,
      NULL },
    { "create_pango_layout", (PyCFunction)_wrap_gtk_print_context_create_pango_layout, METH_NOARGS,
      NULL },
    { "set_cairo_context", (PyCFunction)_wrap_gtk_print_context_set_cairo_context, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkPrintContext_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.PrintContext",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkPrintContext_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkPrintOperation ----------- */

static int
_wrap_gtk_print_operation_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.PrintOperation.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.PrintOperation object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_print_operation_set_default_page_setup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "default_page_setup", NULL };
    GtkPageSetup *default_page_setup = NULL;
    PyGObject *py_default_page_setup = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.PrintOperation.set_default_page_setup", kwlist, &py_default_page_setup))
        return NULL;
    if ((PyObject *)py_default_page_setup == Py_None)
        default_page_setup = NULL;
    else if (py_default_page_setup && pygobject_check(py_default_page_setup, &PyGtkPageSetup_Type))
        default_page_setup = GTK_PAGE_SETUP(py_default_page_setup->obj);
    else if (py_default_page_setup) {
        PyErr_SetString(PyExc_TypeError, "default_page_setup should be a GtkPageSetup or None");
        return NULL;
    }
    
    gtk_print_operation_set_default_page_setup(GTK_PRINT_OPERATION(self->obj), (GtkPageSetup *) default_page_setup);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_get_default_page_setup(PyGObject *self)
{
    GtkPageSetup *ret;

    
    ret = gtk_print_operation_get_default_page_setup(GTK_PRINT_OPERATION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_print_operation_set_print_settings(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "print_settings", NULL };
    PyGObject *py_print_settings = NULL;
    GtkPrintSettings *print_settings = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.PrintOperation.set_print_settings", kwlist, &py_print_settings))
        return NULL;
    if ((PyObject *)py_print_settings == Py_None)
        print_settings = NULL;
    else if (py_print_settings && pygobject_check(py_print_settings, &PyGtkPrintSettings_Type))
        print_settings = GTK_PRINT_SETTINGS(py_print_settings->obj);
    else if (py_print_settings) {
        PyErr_SetString(PyExc_TypeError, "print_settings should be a GtkPrintSettings or None");
        return NULL;
    }
    
    gtk_print_operation_set_print_settings(GTK_PRINT_OPERATION(self->obj), (GtkPrintSettings *) print_settings);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_get_print_settings(PyGObject *self)
{
    GtkPrintSettings *ret;

    
    ret = gtk_print_operation_get_print_settings(GTK_PRINT_OPERATION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_print_operation_set_job_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "job_name", NULL };
    char *job_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintOperation.set_job_name", kwlist, &job_name))
        return NULL;
    
    gtk_print_operation_set_job_name(GTK_PRINT_OPERATION(self->obj), job_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_n_pages(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "n_pages", NULL };
    int n_pages;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperation.set_n_pages", kwlist, &n_pages))
        return NULL;
    
    gtk_print_operation_set_n_pages(GTK_PRINT_OPERATION(self->obj), n_pages);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_current_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "current_page", NULL };
    int current_page;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperation.set_current_page", kwlist, &current_page))
        return NULL;
    
    gtk_print_operation_set_current_page(GTK_PRINT_OPERATION(self->obj), current_page);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_use_full_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "full_page", NULL };
    int full_page;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperation.set_use_full_page", kwlist, &full_page))
        return NULL;
    
    gtk_print_operation_set_use_full_page(GTK_PRINT_OPERATION(self->obj), full_page);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_unit(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PrintOperation.set_unit", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    gtk_print_operation_set_unit(GTK_PRINT_OPERATION(self->obj), unit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_export_filename(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintOperation.set_export_filename", kwlist, &filename))
        return NULL;
    
    gtk_print_operation_set_export_filename(GTK_PRINT_OPERATION(self->obj), filename);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_track_print_status(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "track_status", NULL };
    int track_status;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperation.set_track_print_status", kwlist, &track_status))
        return NULL;
    
    gtk_print_operation_set_track_print_status(GTK_PRINT_OPERATION(self->obj), track_status);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_show_progress(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_progress", NULL };
    int show_progress;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperation.set_show_progress", kwlist, &show_progress))
        return NULL;
    
    gtk_print_operation_set_show_progress(GTK_PRINT_OPERATION(self->obj), show_progress);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_allow_async(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "allow_async", NULL };
    int allow_async;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperation.set_allow_async", kwlist, &allow_async))
        return NULL;
    
    gtk_print_operation_set_allow_async(GTK_PRINT_OPERATION(self->obj), allow_async);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_custom_tab_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintOperation.set_custom_tab_label", kwlist, &label))
        return NULL;
    
    gtk_print_operation_set_custom_tab_label(GTK_PRINT_OPERATION(self->obj), label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_run(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", "parent", NULL };
    GtkWindow *parent = NULL;
    PyObject *py_action = NULL;
    GError *error = NULL;
    PyGObject *py_parent = NULL;
    GtkPrintOperationAction action;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O|O:Gtk.PrintOperation.run", kwlist, &py_action, &py_parent))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PRINT_OPERATION_ACTION, py_action, (gpointer)&action))
        return NULL;
    if ((PyObject *)py_parent == Py_None)
        parent = NULL;
    else if (py_parent && pygobject_check(py_parent, &PyGtkWindow_Type))
        parent = GTK_WINDOW(py_parent->obj);
    else if (py_parent) {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkWindow or None");
        return NULL;
    }
    
    ret = gtk_print_operation_run(GTK_PRINT_OPERATION(self->obj), action, (GtkWindow *) parent, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return pyg_enum_from_gtype(GTK_TYPE_PRINT_OPERATION_RESULT, ret);
}

#line 8214 "./gtk.override"
static PyObject *
_wrap_gtk_print_operation_get_error(PyGObject *self)
{
    GError *error = NULL;

    gtk_print_operation_get_error(GTK_PRINT_OPERATION(self->obj), &error);

    if (pyg_error_check(&error)) {
        PyObject *type, *value, *traceback;
        PyErr_Fetch(&type, &value, &traceback);
        Py_DECREF(type);
        Py_DECREF(traceback);
        return value;
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#line 102687 "gtk.c"


static PyObject *
_wrap_gtk_print_operation_get_status(PyGObject *self)
{
    gint ret;

    
    ret = gtk_print_operation_get_status(GTK_PRINT_OPERATION(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_PRINT_STATUS, ret);
}

static PyObject *
_wrap_gtk_print_operation_get_status_string(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_print_operation_get_status_string(GTK_PRINT_OPERATION(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_is_finished(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_operation_is_finished(GTK_PRINT_OPERATION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_operation_cancel(PyGObject *self)
{
    
    gtk_print_operation_cancel(GTK_PRINT_OPERATION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_draw_page_finish(PyGObject *self)
{
    
    gtk_print_operation_draw_page_finish(GTK_PRINT_OPERATION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_defer_drawing(PyGObject *self)
{
    
    gtk_print_operation_set_defer_drawing(GTK_PRINT_OPERATION(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_set_support_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "support_selection", NULL };
    int support_selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperation.set_support_selection", kwlist, &support_selection))
        return NULL;
    
    gtk_print_operation_set_support_selection(GTK_PRINT_OPERATION(self->obj), support_selection);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_get_support_selection(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_operation_get_support_selection(GTK_PRINT_OPERATION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_operation_set_has_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "has_selection", NULL };
    int has_selection;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperation.set_has_selection", kwlist, &has_selection))
        return NULL;
    
    gtk_print_operation_set_has_selection(GTK_PRINT_OPERATION(self->obj), has_selection);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_get_has_selection(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_operation_get_has_selection(GTK_PRINT_OPERATION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_operation_set_embed_page_setup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "embed", NULL };
    int embed;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperation.set_embed_page_setup", kwlist, &embed))
        return NULL;
    
    gtk_print_operation_set_embed_page_setup(GTK_PRINT_OPERATION(self->obj), embed);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_get_embed_page_setup(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_operation_get_embed_page_setup(GTK_PRINT_OPERATION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_operation_get_n_pages_to_print(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_operation_get_n_pages_to_print(GTK_PRINT_OPERATION(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_GtkPrintOperation__do_done(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "result", NULL };
    PyGObject *self;
    GtkPrintOperationResult result;
    PyObject *py_result = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.PrintOperation.done", kwlist, &PyGtkPrintOperation_Type, &self, &py_result))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PRINT_OPERATION_RESULT, py_result, (gpointer)&result))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PRINT_OPERATION_CLASS(klass)->done)
        GTK_PRINT_OPERATION_CLASS(klass)->done(GTK_PRINT_OPERATION(self->obj), result);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.PrintOperation.done not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkPrintOperation__do_begin_print(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", NULL };
    PyGObject *self, *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.PrintOperation.begin_print", kwlist, &PyGtkPrintOperation_Type, &self, &PyGtkPrintContext_Type, &context))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PRINT_OPERATION_CLASS(klass)->begin_print)
        GTK_PRINT_OPERATION_CLASS(klass)->begin_print(GTK_PRINT_OPERATION(self->obj), GTK_PRINT_CONTEXT(context->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.PrintOperation.begin_print not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkPrintOperation__do_paginate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", NULL };
    PyGObject *self, *context;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.PrintOperation.paginate", kwlist, &PyGtkPrintOperation_Type, &self, &PyGtkPrintContext_Type, &context))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PRINT_OPERATION_CLASS(klass)->paginate)
        ret = GTK_PRINT_OPERATION_CLASS(klass)->paginate(GTK_PRINT_OPERATION(self->obj), GTK_PRINT_CONTEXT(context->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.PrintOperation.paginate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkPrintOperation__do_request_page_setup(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", "page_nr", "setup", NULL };
    PyGObject *self, *context, *setup;
    int page_nr;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!iO!:Gtk.PrintOperation.request_page_setup", kwlist, &PyGtkPrintOperation_Type, &self, &PyGtkPrintContext_Type, &context, &page_nr, &PyGtkPageSetup_Type, &setup))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PRINT_OPERATION_CLASS(klass)->request_page_setup)
        GTK_PRINT_OPERATION_CLASS(klass)->request_page_setup(GTK_PRINT_OPERATION(self->obj), GTK_PRINT_CONTEXT(context->obj), page_nr, GTK_PAGE_SETUP(setup->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.PrintOperation.request_page_setup not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkPrintOperation__do_draw_page(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", "page_nr", NULL };
    PyGObject *self, *context;
    int page_nr;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!i:Gtk.PrintOperation.draw_page", kwlist, &PyGtkPrintOperation_Type, &self, &PyGtkPrintContext_Type, &context, &page_nr))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PRINT_OPERATION_CLASS(klass)->draw_page)
        GTK_PRINT_OPERATION_CLASS(klass)->draw_page(GTK_PRINT_OPERATION(self->obj), GTK_PRINT_CONTEXT(context->obj), page_nr);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.PrintOperation.draw_page not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkPrintOperation__do_end_print(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "context", NULL };
    PyGObject *self, *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.PrintOperation.end_print", kwlist, &PyGtkPrintOperation_Type, &self, &PyGtkPrintContext_Type, &context))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PRINT_OPERATION_CLASS(klass)->end_print)
        GTK_PRINT_OPERATION_CLASS(klass)->end_print(GTK_PRINT_OPERATION(self->obj), GTK_PRINT_CONTEXT(context->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.PrintOperation.end_print not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkPrintOperation__do_status_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.PrintOperation.status_changed", kwlist, &PyGtkPrintOperation_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PRINT_OPERATION_CLASS(klass)->status_changed)
        GTK_PRINT_OPERATION_CLASS(klass)->status_changed(GTK_PRINT_OPERATION(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.PrintOperation.status_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkPrintOperation__do_create_custom_widget(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.PrintOperation.create_custom_widget", kwlist, &PyGtkPrintOperation_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PRINT_OPERATION_CLASS(klass)->create_custom_widget)
        ret = GTK_PRINT_OPERATION_CLASS(klass)->create_custom_widget(GTK_PRINT_OPERATION(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.PrintOperation.create_custom_widget not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkPrintOperation__do_custom_widget_apply(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "widget", NULL };
    PyGObject *self, *widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.PrintOperation.custom_widget_apply", kwlist, &PyGtkPrintOperation_Type, &self, &PyGtkWidget_Type, &widget))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PRINT_OPERATION_CLASS(klass)->custom_widget_apply)
        GTK_PRINT_OPERATION_CLASS(klass)->custom_widget_apply(GTK_PRINT_OPERATION(self->obj), GTK_WIDGET(widget->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.PrintOperation.custom_widget_apply not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkPrintOperation__do_preview(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "preview", "context", "parent", NULL };
    PyGObject *self, *preview, *context, *parent;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!O!:Gtk.PrintOperation.preview", kwlist, &PyGtkPrintOperation_Type, &self, &PyGtkPrintOperationPreview_Type, &preview, &PyGtkPrintContext_Type, &context, &PyGtkWindow_Type, &parent))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_PRINT_OPERATION_CLASS(klass)->preview)
        ret = GTK_PRINT_OPERATION_CLASS(klass)->preview(GTK_PRINT_OPERATION(self->obj), GTK_PRINT_OPERATION_PREVIEW(preview->obj), GTK_PRINT_CONTEXT(context->obj), GTK_WINDOW(parent->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.PrintOperation.preview not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkPrintOperation_methods[] = {
    { "set_default_page_setup", (PyCFunction)_wrap_gtk_print_operation_set_default_page_setup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_default_page_setup", (PyCFunction)_wrap_gtk_print_operation_get_default_page_setup, METH_NOARGS,
      NULL },
    { "set_print_settings", (PyCFunction)_wrap_gtk_print_operation_set_print_settings, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_print_settings", (PyCFunction)_wrap_gtk_print_operation_get_print_settings, METH_NOARGS,
      NULL },
    { "set_job_name", (PyCFunction)_wrap_gtk_print_operation_set_job_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_n_pages", (PyCFunction)_wrap_gtk_print_operation_set_n_pages, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_current_page", (PyCFunction)_wrap_gtk_print_operation_set_current_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_use_full_page", (PyCFunction)_wrap_gtk_print_operation_set_use_full_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_unit", (PyCFunction)_wrap_gtk_print_operation_set_unit, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_export_filename", (PyCFunction)_wrap_gtk_print_operation_set_export_filename, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_track_print_status", (PyCFunction)_wrap_gtk_print_operation_set_track_print_status, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_show_progress", (PyCFunction)_wrap_gtk_print_operation_set_show_progress, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_allow_async", (PyCFunction)_wrap_gtk_print_operation_set_allow_async, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_custom_tab_label", (PyCFunction)_wrap_gtk_print_operation_set_custom_tab_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "run", (PyCFunction)_wrap_gtk_print_operation_run, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_error", (PyCFunction)_wrap_gtk_print_operation_get_error, METH_NOARGS,
      NULL },
    { "get_status", (PyCFunction)_wrap_gtk_print_operation_get_status, METH_NOARGS,
      NULL },
    { "get_status_string", (PyCFunction)_wrap_gtk_print_operation_get_status_string, METH_NOARGS,
      NULL },
    { "is_finished", (PyCFunction)_wrap_gtk_print_operation_is_finished, METH_NOARGS,
      NULL },
    { "cancel", (PyCFunction)_wrap_gtk_print_operation_cancel, METH_NOARGS,
      NULL },
    { "draw_page_finish", (PyCFunction)_wrap_gtk_print_operation_draw_page_finish, METH_NOARGS,
      NULL },
    { "set_defer_drawing", (PyCFunction)_wrap_gtk_print_operation_set_defer_drawing, METH_NOARGS,
      NULL },
    { "set_support_selection", (PyCFunction)_wrap_gtk_print_operation_set_support_selection, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_support_selection", (PyCFunction)_wrap_gtk_print_operation_get_support_selection, METH_NOARGS,
      NULL },
    { "set_has_selection", (PyCFunction)_wrap_gtk_print_operation_set_has_selection, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_selection", (PyCFunction)_wrap_gtk_print_operation_get_has_selection, METH_NOARGS,
      NULL },
    { "set_embed_page_setup", (PyCFunction)_wrap_gtk_print_operation_set_embed_page_setup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_embed_page_setup", (PyCFunction)_wrap_gtk_print_operation_get_embed_page_setup, METH_NOARGS,
      NULL },
    { "get_n_pages_to_print", (PyCFunction)_wrap_gtk_print_operation_get_n_pages_to_print, METH_NOARGS,
      NULL },
    { "do_done", (PyCFunction)_wrap_GtkPrintOperation__do_done, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_begin_print", (PyCFunction)_wrap_GtkPrintOperation__do_begin_print, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_paginate", (PyCFunction)_wrap_GtkPrintOperation__do_paginate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_request_page_setup", (PyCFunction)_wrap_GtkPrintOperation__do_request_page_setup, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_draw_page", (PyCFunction)_wrap_GtkPrintOperation__do_draw_page, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_end_print", (PyCFunction)_wrap_GtkPrintOperation__do_end_print, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_status_changed", (PyCFunction)_wrap_GtkPrintOperation__do_status_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_create_custom_widget", (PyCFunction)_wrap_GtkPrintOperation__do_create_custom_widget, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_custom_widget_apply", (PyCFunction)_wrap_GtkPrintOperation__do_custom_widget_apply, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_preview", (PyCFunction)_wrap_GtkPrintOperation__do_preview, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkPrintOperation_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.PrintOperation",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkPrintOperation_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_print_operation_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkPrintOperation__proxy_do_done(GtkPrintOperation *self, GtkPrintOperationResult result)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_result;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_result = pyg_enum_from_gtype(GTK_TYPE_PRINT_OPERATION_RESULT, result);
    if (!py_result) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_result);
    
    py_method = PyObject_GetAttrString(py_self, "do_done");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkPrintOperation__proxy_do_begin_print(GtkPrintOperation *self, GtkPrintContext*context)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    
    py_method = PyObject_GetAttrString(py_self, "do_begin_print");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkPrintOperation__proxy_do_paginate(GtkPrintOperation *self, GtkPrintContext*context)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    
    py_method = PyObject_GetAttrString(py_self, "do_paginate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkPrintOperation__proxy_do_request_page_setup(GtkPrintOperation *self, GtkPrintContext*context, gint page_nr, GtkPageSetup*setup)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_page_nr;
    PyObject *py_setup = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    py_page_nr = PyInt_FromLong(page_nr);
    if (setup)
        py_setup = pygobject_new((GObject *) setup);
    else {
        Py_INCREF(Py_None);
        py_setup = Py_None;
    }
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    PyTuple_SET_ITEM(py_args, 1, py_page_nr);
    PyTuple_SET_ITEM(py_args, 2, py_setup);
    
    py_method = PyObject_GetAttrString(py_self, "do_request_page_setup");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkPrintOperation__proxy_do_draw_page(GtkPrintOperation *self, GtkPrintContext*context, gint page_nr)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_page_nr;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    py_page_nr = PyInt_FromLong(page_nr);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    PyTuple_SET_ITEM(py_args, 1, py_page_nr);
    
    py_method = PyObject_GetAttrString(py_self, "do_draw_page");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkPrintOperation__proxy_do_end_print(GtkPrintOperation *self, GtkPrintContext*context)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    
    py_method = PyObject_GetAttrString(py_self, "do_end_print");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkPrintOperation__proxy_do_status_changed(GtkPrintOperation *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_status_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GtkWidget*
_wrap_GtkPrintOperation__proxy_do_create_custom_widget(GtkPrintOperation *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkWidget* retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_create_custom_widget");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkWidget*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkPrintOperation__proxy_do_custom_widget_apply(GtkPrintOperation *self, GtkWidget*widget)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_widget = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (widget)
        py_widget = pygobject_new((GObject *) widget);
    else {
        Py_INCREF(Py_None);
        py_widget = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_widget);
    
    py_method = PyObject_GetAttrString(py_self, "do_custom_widget_apply");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkPrintOperation__proxy_do_preview(GtkPrintOperation *self, GtkPrintOperationPreview*preview, GtkPrintContext*context, GtkWindow*parent)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_preview = NULL;
    PyObject *py_context = NULL;
    PyObject *py_parent = NULL;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (preview)
        py_preview = pygobject_new((GObject *) preview);
    else {
        Py_INCREF(Py_None);
        py_preview = Py_None;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    if (parent)
        py_parent = pygobject_new((GObject *) parent);
    else {
        Py_INCREF(Py_None);
        py_parent = Py_None;
    }
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_preview);
    PyTuple_SET_ITEM(py_args, 1, py_context);
    PyTuple_SET_ITEM(py_args, 2, py_parent);
    
    py_method = PyObject_GetAttrString(py_self, "do_preview");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkPrintOperation_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkPrintOperationClass *klass = GTK_PRINT_OPERATION_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_done");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "done")))
            klass->done = _wrap_GtkPrintOperation__proxy_do_done;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_begin_print");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "begin_print")))
            klass->begin_print = _wrap_GtkPrintOperation__proxy_do_begin_print;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_paginate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "paginate")))
            klass->paginate = _wrap_GtkPrintOperation__proxy_do_paginate;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_request_page_setup");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "request_page_setup")))
            klass->request_page_setup = _wrap_GtkPrintOperation__proxy_do_request_page_setup;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_draw_page");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "draw_page")))
            klass->draw_page = _wrap_GtkPrintOperation__proxy_do_draw_page;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_end_print");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "end_print")))
            klass->end_print = _wrap_GtkPrintOperation__proxy_do_end_print;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_status_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "status_changed")))
            klass->status_changed = _wrap_GtkPrintOperation__proxy_do_status_changed;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_create_custom_widget");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "create_custom_widget")))
            klass->create_custom_widget = _wrap_GtkPrintOperation__proxy_do_create_custom_widget;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_custom_widget_apply");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "custom_widget_apply")))
            klass->custom_widget_apply = _wrap_GtkPrintOperation__proxy_do_custom_widget_apply;
        Py_DECREF(o);
    }

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_preview");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "preview")))
            klass->preview = _wrap_GtkPrintOperation__proxy_do_preview;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkPrintSettings ----------- */

static int
_wrap_gtk_print_settings_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.PrintSettings.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.PrintSettings object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_print_settings_copy(PyGObject *self)
{
    GtkPrintSettings *ret;

    
    ret = gtk_print_settings_copy(GTK_PRINT_SETTINGS(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_print_settings_has_key(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    char *key;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.has_key", kwlist, &key))
        return NULL;
    
    ret = gtk_print_settings_has_key(GTK_PRINT_SETTINGS(self->obj), key);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_settings_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    char *key;
    const gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.get", kwlist, &key))
        return NULL;
    
    ret = gtk_print_settings_get(GTK_PRINT_SETTINGS(self->obj), key);
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", "value", NULL };
    char *key, *value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sz:Gtk.PrintSettings.set", kwlist, &key, &value))
        return NULL;
    
    gtk_print_settings_set(GTK_PRINT_SETTINGS(self->obj), key, value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_unset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    char *key;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.unset", kwlist, &key))
        return NULL;
    
    gtk_print_settings_unset(GTK_PRINT_SETTINGS(self->obj), key);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 7141 "./gtk.override"
static void
pygtk_print_settings_foreach_cb(const gchar *key,
                                const gchar *value,
                                gpointer data)
{
    PyGILState_STATE state;
    PyObject *retobj;
    PyGtkCustomNotify *cunote = data;
  
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
  
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(ssO)", key, value,
                                     cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(ss)", key, value);
 
    if (retobj == NULL)
        PyErr_Print();

    Py_XDECREF(retobj);
  
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_print_settings_foreach(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "func", "user_data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:gtk.PrintSettings.foreach",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;
  
    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }

    cunote.func = pyfunc;
    cunote.data = pyarg;
 
    gtk_print_settings_foreach(GTK_PRINT_SETTINGS(self->obj),
                               pygtk_print_settings_foreach_cb, &cunote);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 104149 "gtk.c"


static PyObject *
_wrap_gtk_print_settings_get_bool(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    char *key;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.get_bool", kwlist, &key))
        return NULL;
    
    ret = gtk_print_settings_get_bool(GTK_PRINT_SETTINGS(self->obj), key);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_settings_set_bool(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", "value", NULL };
    char *key;
    int value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"si:Gtk.PrintSettings.set_bool", kwlist, &key, &value))
        return NULL;
    
    gtk_print_settings_set_bool(GTK_PRINT_SETTINGS(self->obj), key, value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_double(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    char *key;
    double ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.get_double", kwlist, &key))
        return NULL;
    
    ret = gtk_print_settings_get_double(GTK_PRINT_SETTINGS(self->obj), key);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_settings_get_double_with_default(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", "def_", NULL };
    char *key;
    double def, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sd:Gtk.PrintSettings.get_double_with_default", kwlist, &key, &def))
        return NULL;
    
    ret = gtk_print_settings_get_double_with_default(GTK_PRINT_SETTINGS(self->obj), key, def);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_double(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", "value", NULL };
    char *key;
    double value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sd:Gtk.PrintSettings.set_double", kwlist, &key, &value))
        return NULL;
    
    gtk_print_settings_set_double(GTK_PRINT_SETTINGS(self->obj), key, value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_length(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", "unit", NULL };
    char *key;
    PyObject *py_unit = NULL;
    GtkUnit unit;
    double ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO:Gtk.PrintSettings.get_length", kwlist, &key, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_print_settings_get_length(GTK_PRINT_SETTINGS(self->obj), key, unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_length(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", "value", "unit", NULL };
    char *key;
    double value;
    GtkUnit unit;
    PyObject *py_unit = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sdO:Gtk.PrintSettings.set_length", kwlist, &key, &value, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    gtk_print_settings_set_length(GTK_PRINT_SETTINGS(self->obj), key, value, unit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_int(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    char *key;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.get_int", kwlist, &key))
        return NULL;
    
    ret = gtk_print_settings_get_int(GTK_PRINT_SETTINGS(self->obj), key);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_print_settings_get_int_with_default(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", "def_", NULL };
    char *key;
    int def, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"si:Gtk.PrintSettings.get_int_with_default", kwlist, &key, &def))
        return NULL;
    
    ret = gtk_print_settings_get_int_with_default(GTK_PRINT_SETTINGS(self->obj), key, def);
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_int(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key", "value", NULL };
    char *key;
    int value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"si:Gtk.PrintSettings.set_int", kwlist, &key, &value))
        return NULL;
    
    gtk_print_settings_set_int(GTK_PRINT_SETTINGS(self->obj), key, value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_printer(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_print_settings_get_printer(GTK_PRINT_SETTINGS(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_set_printer(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "printer", NULL };
    char *printer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.set_printer", kwlist, &printer))
        return NULL;
    
    gtk_print_settings_set_printer(GTK_PRINT_SETTINGS(self->obj), printer);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_print_settings_get_orientation(GTK_PRINT_SETTINGS(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_PAGE_ORIENTATION, ret);
}

static PyObject *
_wrap_gtk_print_settings_set_orientation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "orientation", NULL };
    PyObject *py_orientation = NULL;
    GtkPageOrientation orientation;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PrintSettings.set_orientation", kwlist, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PAGE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    
    gtk_print_settings_set_orientation(GTK_PRINT_SETTINGS(self->obj), orientation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_paper_size(PyGObject *self)
{
    GtkPaperSize *ret;

    
    ret = gtk_print_settings_get_paper_size(GTK_PRINT_SETTINGS(self->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_PAPER_SIZE, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_print_settings_set_paper_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "paper_size", NULL };
    PyObject *py_paper_size;
    GtkPaperSize *paper_size = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PrintSettings.set_paper_size", kwlist, &py_paper_size))
        return NULL;
    if (pyg_boxed_check(py_paper_size, GTK_TYPE_PAPER_SIZE))
        paper_size = pyg_boxed_get(py_paper_size, GtkPaperSize);
    else {
        PyErr_SetString(PyExc_TypeError, "paper_size should be a GtkPaperSize");
        return NULL;
    }
    
    gtk_print_settings_set_paper_size(GTK_PRINT_SETTINGS(self->obj), paper_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_paper_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PrintSettings.get_paper_width", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_print_settings_get_paper_width(GTK_PRINT_SETTINGS(self->obj), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_paper_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "width", "unit", NULL };
    PyObject *py_unit = NULL;
    double width;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dO:Gtk.PrintSettings.set_paper_width", kwlist, &width, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    gtk_print_settings_set_paper_width(GTK_PRINT_SETTINGS(self->obj), width, unit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_paper_height(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "unit", NULL };
    PyObject *py_unit = NULL;
    double ret;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PrintSettings.get_paper_height", kwlist, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_print_settings_get_paper_height(GTK_PRINT_SETTINGS(self->obj), unit);
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_paper_height(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "height", "unit", NULL };
    PyObject *py_unit = NULL;
    double height;
    GtkUnit unit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"dO:Gtk.PrintSettings.set_paper_height", kwlist, &height, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    gtk_print_settings_set_paper_height(GTK_PRINT_SETTINGS(self->obj), height, unit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_use_color(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_settings_get_use_color(GTK_PRINT_SETTINGS(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_settings_set_use_color(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_color", NULL };
    int use_color;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintSettings.set_use_color", kwlist, &use_color))
        return NULL;
    
    gtk_print_settings_set_use_color(GTK_PRINT_SETTINGS(self->obj), use_color);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_collate(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_settings_get_collate(GTK_PRINT_SETTINGS(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_settings_set_collate(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "collate", NULL };
    int collate;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintSettings.set_collate", kwlist, &collate))
        return NULL;
    
    gtk_print_settings_set_collate(GTK_PRINT_SETTINGS(self->obj), collate);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_reverse(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_settings_get_reverse(GTK_PRINT_SETTINGS(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_settings_set_reverse(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "reverse", NULL };
    int reverse;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintSettings.set_reverse", kwlist, &reverse))
        return NULL;
    
    gtk_print_settings_set_reverse(GTK_PRINT_SETTINGS(self->obj), reverse);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_duplex(PyGObject *self)
{
    gint ret;

    
    ret = gtk_print_settings_get_duplex(GTK_PRINT_SETTINGS(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_PRINT_DUPLEX, ret);
}

static PyObject *
_wrap_gtk_print_settings_set_duplex(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "duplex", NULL };
    PyObject *py_duplex = NULL;
    GtkPrintDuplex duplex;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PrintSettings.set_duplex", kwlist, &py_duplex))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PRINT_DUPLEX, py_duplex, (gpointer)&duplex))
        return NULL;
    
    gtk_print_settings_set_duplex(GTK_PRINT_SETTINGS(self->obj), duplex);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_quality(PyGObject *self)
{
    gint ret;

    
    ret = gtk_print_settings_get_quality(GTK_PRINT_SETTINGS(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_PRINT_QUALITY, ret);
}

static PyObject *
_wrap_gtk_print_settings_set_quality(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "quality", NULL };
    PyObject *py_quality = NULL;
    GtkPrintQuality quality;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PrintSettings.set_quality", kwlist, &py_quality))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PRINT_QUALITY, py_quality, (gpointer)&quality))
        return NULL;
    
    gtk_print_settings_set_quality(GTK_PRINT_SETTINGS(self->obj), quality);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_n_copies(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_settings_get_n_copies(GTK_PRINT_SETTINGS(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_n_copies(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "num_copies", NULL };
    int num_copies;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintSettings.set_n_copies", kwlist, &num_copies))
        return NULL;
    
    gtk_print_settings_set_n_copies(GTK_PRINT_SETTINGS(self->obj), num_copies);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_number_up(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_settings_get_number_up(GTK_PRINT_SETTINGS(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_number_up(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "number_up", NULL };
    int number_up;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintSettings.set_number_up", kwlist, &number_up))
        return NULL;
    
    gtk_print_settings_set_number_up(GTK_PRINT_SETTINGS(self->obj), number_up);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_resolution(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_settings_get_resolution(GTK_PRINT_SETTINGS(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_resolution(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "resolution", NULL };
    int resolution;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintSettings.set_resolution", kwlist, &resolution))
        return NULL;
    
    gtk_print_settings_set_resolution(GTK_PRINT_SETTINGS(self->obj), resolution);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_scale(PyGObject *self)
{
    double ret;

    
    ret = gtk_print_settings_get_scale(GTK_PRINT_SETTINGS(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_scale(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "scale", NULL };
    double scale;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.PrintSettings.set_scale", kwlist, &scale))
        return NULL;
    
    gtk_print_settings_set_scale(GTK_PRINT_SETTINGS(self->obj), scale);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_print_pages(PyGObject *self)
{
    gint ret;

    
    ret = gtk_print_settings_get_print_pages(GTK_PRINT_SETTINGS(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_PRINT_PAGES, ret);
}

static PyObject *
_wrap_gtk_print_settings_set_print_pages(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pages", NULL };
    PyObject *py_pages = NULL;
    GtkPrintPages pages;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PrintSettings.set_print_pages", kwlist, &py_pages))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PRINT_PAGES, py_pages, (gpointer)&pages))
        return NULL;
    
    gtk_print_settings_set_print_pages(GTK_PRINT_SETTINGS(self->obj), pages);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 7196 "./gtk.override"
static PyObject *
_wrap_gtk_print_settings_get_page_ranges(PyGObject *self)
{
    GtkPageRange *ranges;
    PyObject *py_ranges;
    gint n_ranges, i;

    ranges = gtk_print_settings_get_page_ranges(GTK_PRINT_SETTINGS(self->obj),
                                                &n_ranges);

    py_ranges = PyList_New(n_ranges);

    for (i = 0; i < n_ranges; i++)
        PyList_SetItem(py_ranges, i,
                       Py_BuildValue("(ii)", ranges[i].start, ranges[i].end));
    g_free(ranges);
    return py_ranges;
}
#line 104772 "gtk.c"


#line 7216 "./gtk.override"
static PyObject *
_wrap_gtk_print_settings_set_page_ranges(PyGObject *self, PyObject *args,
                                         PyObject *kwargs)
{
    static char *kwlist[] = { "page_ranges", NULL };
    PyObject *py_ranges;
    gint n_ranges = 0, i;
    GtkPageRange *ranges = NULL;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:gtk.PrintSettings.set_page_ranges",
                                     kwlist, &py_ranges))
        return NULL;

    if (!PySequence_Check(py_ranges)) {
        PyErr_SetString(PyExc_TypeError,
                        "page_ranges must be a sequence of 2-tuples");
        return NULL;
    }

    n_ranges = PySequence_Size(py_ranges);
    ranges = g_new0(GtkPageRange, n_ranges);
    for (i = 0; i < n_ranges; i++) {
        PyObject *range = PySequence_GetItem(py_ranges, i);

        if (!PyTuple_Check(range)) {
            PyErr_SetString(PyExc_TypeError,
                            "Each page range must be a 2-tuple of start and end page numbers");
            g_free(ranges);
            return NULL;
        }
        if (!PyArg_ParseTuple(range,
                              "ii;Each page range must be a 2-tuple of start and end page numbers",
                              &ranges[i].start, &ranges[i].end)) {
            Py_DECREF(range);
            g_free(ranges);
            return NULL;
        }
        Py_DECREF(range);
    }
    gtk_print_settings_set_page_ranges(GTK_PRINT_SETTINGS(self->obj),
                                       ranges, n_ranges);
    g_free(ranges);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 104823 "gtk.c"


static PyObject *
_wrap_gtk_print_settings_get_page_set(PyGObject *self)
{
    gint ret;

    
    ret = gtk_print_settings_get_page_set(GTK_PRINT_SETTINGS(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_PAGE_SET, ret);
}

static PyObject *
_wrap_gtk_print_settings_set_page_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_set", NULL };
    PyObject *py_page_set = NULL;
    GtkPageSet page_set;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PrintSettings.set_page_set", kwlist, &py_page_set))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_PAGE_SET, py_page_set, (gpointer)&page_set))
        return NULL;
    
    gtk_print_settings_set_page_set(GTK_PRINT_SETTINGS(self->obj), page_set);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_default_source(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_print_settings_get_default_source(GTK_PRINT_SETTINGS(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_set_default_source(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "default_source", NULL };
    char *default_source;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.set_default_source", kwlist, &default_source))
        return NULL;
    
    gtk_print_settings_set_default_source(GTK_PRINT_SETTINGS(self->obj), default_source);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_media_type(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_print_settings_get_media_type(GTK_PRINT_SETTINGS(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_set_media_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "media_type", NULL };
    char *media_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.set_media_type", kwlist, &media_type))
        return NULL;
    
    gtk_print_settings_set_media_type(GTK_PRINT_SETTINGS(self->obj), media_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_dither(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_print_settings_get_dither(GTK_PRINT_SETTINGS(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_set_dither(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dither", NULL };
    char *dither;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.set_dither", kwlist, &dither))
        return NULL;
    
    gtk_print_settings_set_dither(GTK_PRINT_SETTINGS(self->obj), dither);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_finishings(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_print_settings_get_finishings(GTK_PRINT_SETTINGS(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_set_finishings(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "finishings", NULL };
    char *finishings;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.set_finishings", kwlist, &finishings))
        return NULL;
    
    gtk_print_settings_set_finishings(GTK_PRINT_SETTINGS(self->obj), finishings);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_output_bin(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_print_settings_get_output_bin(GTK_PRINT_SETTINGS(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_set_output_bin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "output_bin", NULL };
    char *output_bin;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.set_output_bin", kwlist, &output_bin))
        return NULL;
    
    gtk_print_settings_set_output_bin(GTK_PRINT_SETTINGS(self->obj), output_bin);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_to_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file_name", NULL };
    char *file_name;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.to_file", kwlist, &file_name))
        return NULL;
    
    ret = gtk_print_settings_to_file(GTK_PRINT_SETTINGS(self->obj), file_name, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_settings_load_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file_name", NULL };
    char *file_name;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.PrintSettings.load_file", kwlist, &file_name))
        return NULL;
    
    ret = gtk_print_settings_load_file(GTK_PRINT_SETTINGS(self->obj), file_name, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_print_settings_get_number_up_layout(PyGObject *self)
{
    gint ret;

    
    ret = gtk_print_settings_get_number_up_layout(GTK_PRINT_SETTINGS(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_NUMBER_UP_LAYOUT, ret);
}

static PyObject *
_wrap_gtk_print_settings_set_number_up_layout(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "number_up_layout", NULL };
    PyObject *py_number_up_layout = NULL;
    GtkNumberUpLayout number_up_layout;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.PrintSettings.set_number_up_layout", kwlist, &py_number_up_layout))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_NUMBER_UP_LAYOUT, py_number_up_layout, (gpointer)&number_up_layout))
        return NULL;
    
    gtk_print_settings_set_number_up_layout(GTK_PRINT_SETTINGS(self->obj), number_up_layout);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_resolution_x(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_settings_get_resolution_x(GTK_PRINT_SETTINGS(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_print_settings_get_resolution_y(PyGObject *self)
{
    int ret;

    
    ret = gtk_print_settings_get_resolution_y(GTK_PRINT_SETTINGS(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_resolution_xy(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "resolution_x", "resolution_y", NULL };
    int resolution_x, resolution_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.PrintSettings.set_resolution_xy", kwlist, &resolution_x, &resolution_y))
        return NULL;
    
    gtk_print_settings_set_resolution_xy(GTK_PRINT_SETTINGS(self->obj), resolution_x, resolution_y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_settings_get_printer_lpi(PyGObject *self)
{
    double ret;

    
    ret = gtk_print_settings_get_printer_lpi(GTK_PRINT_SETTINGS(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_print_settings_set_printer_lpi(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "lpi", NULL };
    double lpi;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.PrintSettings.set_printer_lpi", kwlist, &lpi))
        return NULL;
    
    gtk_print_settings_set_printer_lpi(GTK_PRINT_SETTINGS(self->obj), lpi);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkPrintSettings_methods[] = {
    { "copy", (PyCFunction)_wrap_gtk_print_settings_copy, METH_NOARGS,
      NULL },
    { "has_key", (PyCFunction)_wrap_gtk_print_settings_has_key, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get", (PyCFunction)_wrap_gtk_print_settings_get, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set", (PyCFunction)_wrap_gtk_print_settings_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unset", (PyCFunction)_wrap_gtk_print_settings_unset, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "foreach", (PyCFunction)_wrap_gtk_print_settings_foreach, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_bool", (PyCFunction)_wrap_gtk_print_settings_get_bool, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_bool", (PyCFunction)_wrap_gtk_print_settings_set_bool, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_double", (PyCFunction)_wrap_gtk_print_settings_get_double, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_double_with_default", (PyCFunction)_wrap_gtk_print_settings_get_double_with_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_double", (PyCFunction)_wrap_gtk_print_settings_set_double, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_length", (PyCFunction)_wrap_gtk_print_settings_get_length, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_length", (PyCFunction)_wrap_gtk_print_settings_set_length, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_int", (PyCFunction)_wrap_gtk_print_settings_get_int, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_int_with_default", (PyCFunction)_wrap_gtk_print_settings_get_int_with_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_int", (PyCFunction)_wrap_gtk_print_settings_set_int, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_printer", (PyCFunction)_wrap_gtk_print_settings_get_printer, METH_NOARGS,
      NULL },
    { "set_printer", (PyCFunction)_wrap_gtk_print_settings_set_printer, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_orientation", (PyCFunction)_wrap_gtk_print_settings_get_orientation, METH_NOARGS,
      NULL },
    { "set_orientation", (PyCFunction)_wrap_gtk_print_settings_set_orientation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_paper_size", (PyCFunction)_wrap_gtk_print_settings_get_paper_size, METH_NOARGS,
      NULL },
    { "set_paper_size", (PyCFunction)_wrap_gtk_print_settings_set_paper_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_paper_width", (PyCFunction)_wrap_gtk_print_settings_get_paper_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_paper_width", (PyCFunction)_wrap_gtk_print_settings_set_paper_width, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_paper_height", (PyCFunction)_wrap_gtk_print_settings_get_paper_height, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_paper_height", (PyCFunction)_wrap_gtk_print_settings_set_paper_height, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_color", (PyCFunction)_wrap_gtk_print_settings_get_use_color, METH_NOARGS,
      NULL },
    { "set_use_color", (PyCFunction)_wrap_gtk_print_settings_set_use_color, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_collate", (PyCFunction)_wrap_gtk_print_settings_get_collate, METH_NOARGS,
      NULL },
    { "set_collate", (PyCFunction)_wrap_gtk_print_settings_set_collate, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_reverse", (PyCFunction)_wrap_gtk_print_settings_get_reverse, METH_NOARGS,
      NULL },
    { "set_reverse", (PyCFunction)_wrap_gtk_print_settings_set_reverse, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_duplex", (PyCFunction)_wrap_gtk_print_settings_get_duplex, METH_NOARGS,
      NULL },
    { "set_duplex", (PyCFunction)_wrap_gtk_print_settings_set_duplex, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_quality", (PyCFunction)_wrap_gtk_print_settings_get_quality, METH_NOARGS,
      NULL },
    { "set_quality", (PyCFunction)_wrap_gtk_print_settings_set_quality, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_n_copies", (PyCFunction)_wrap_gtk_print_settings_get_n_copies, METH_NOARGS,
      NULL },
    { "set_n_copies", (PyCFunction)_wrap_gtk_print_settings_set_n_copies, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_number_up", (PyCFunction)_wrap_gtk_print_settings_get_number_up, METH_NOARGS,
      NULL },
    { "set_number_up", (PyCFunction)_wrap_gtk_print_settings_set_number_up, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_resolution", (PyCFunction)_wrap_gtk_print_settings_get_resolution, METH_NOARGS,
      NULL },
    { "set_resolution", (PyCFunction)_wrap_gtk_print_settings_set_resolution, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_scale", (PyCFunction)_wrap_gtk_print_settings_get_scale, METH_NOARGS,
      NULL },
    { "set_scale", (PyCFunction)_wrap_gtk_print_settings_set_scale, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_print_pages", (PyCFunction)_wrap_gtk_print_settings_get_print_pages, METH_NOARGS,
      NULL },
    { "set_print_pages", (PyCFunction)_wrap_gtk_print_settings_set_print_pages, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_ranges", (PyCFunction)_wrap_gtk_print_settings_get_page_ranges, METH_NOARGS,
      NULL },
    { "set_page_ranges", (PyCFunction)_wrap_gtk_print_settings_set_page_ranges, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_page_set", (PyCFunction)_wrap_gtk_print_settings_get_page_set, METH_NOARGS,
      NULL },
    { "set_page_set", (PyCFunction)_wrap_gtk_print_settings_set_page_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_default_source", (PyCFunction)_wrap_gtk_print_settings_get_default_source, METH_NOARGS,
      NULL },
    { "set_default_source", (PyCFunction)_wrap_gtk_print_settings_set_default_source, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_media_type", (PyCFunction)_wrap_gtk_print_settings_get_media_type, METH_NOARGS,
      NULL },
    { "set_media_type", (PyCFunction)_wrap_gtk_print_settings_set_media_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_dither", (PyCFunction)_wrap_gtk_print_settings_get_dither, METH_NOARGS,
      NULL },
    { "set_dither", (PyCFunction)_wrap_gtk_print_settings_set_dither, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_finishings", (PyCFunction)_wrap_gtk_print_settings_get_finishings, METH_NOARGS,
      NULL },
    { "set_finishings", (PyCFunction)_wrap_gtk_print_settings_set_finishings, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_output_bin", (PyCFunction)_wrap_gtk_print_settings_get_output_bin, METH_NOARGS,
      NULL },
    { "set_output_bin", (PyCFunction)_wrap_gtk_print_settings_set_output_bin, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "to_file", (PyCFunction)_wrap_gtk_print_settings_to_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "load_file", (PyCFunction)_wrap_gtk_print_settings_load_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_number_up_layout", (PyCFunction)_wrap_gtk_print_settings_get_number_up_layout, METH_NOARGS,
      NULL },
    { "set_number_up_layout", (PyCFunction)_wrap_gtk_print_settings_set_number_up_layout, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_resolution_x", (PyCFunction)_wrap_gtk_print_settings_get_resolution_x, METH_NOARGS,
      NULL },
    { "get_resolution_y", (PyCFunction)_wrap_gtk_print_settings_get_resolution_y, METH_NOARGS,
      NULL },
    { "set_resolution_xy", (PyCFunction)_wrap_gtk_print_settings_set_resolution_xy, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_printer_lpi", (PyCFunction)_wrap_gtk_print_settings_get_printer_lpi, METH_NOARGS,
      NULL },
    { "set_printer_lpi", (PyCFunction)_wrap_gtk_print_settings_set_printer_lpi, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkPrintSettings_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.PrintSettings",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkPrintSettings_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_print_settings_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkRecentChooserDialog ----------- */

#line 7308 "./gtk.override"
static int
_wrap_gtk_recent_chooser_dialog_new(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    gchar *title = NULL;
    PyGObject *py_window = NULL, *py_manager = NULL;
    PyObject *py_buttons = Py_None;
    int len, i;
    GtkWindow *parent;
    GtkRecentManager *manager;
    
    static char *kwlist[] = { "title", "parent", "manager", "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zOOO:gtk.RecentChooserDialog", kwlist,
                                     &title, &py_window, &py_manager,
                                     &py_buttons))
        return -1;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
	parent = NULL;
    else if (pygobject_check(py_window, &PyGtkWindow_Type))
	parent = GTK_WINDOW(py_window->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "parent must be a GtkWindow or None");
        return -1;
    }

    if (py_manager == NULL || (PyObject*)py_manager == Py_None)
	manager = NULL;
    else if (pygobject_check(py_manager, &PyGtkRecentManager_Type))
	manager = GTK_RECENT_MANAGER(py_manager->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "manager must be a GtkRecentManager or None");
        return -1;
    }

    if (py_buttons == Py_None)
        len = 0;
    else if (PySequence_Check(py_buttons))
        len = PySequence_Size(py_buttons);
    else {
        PyErr_SetString(PyExc_TypeError, "buttons must be a sequence containing text/response pairs or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    if (pygobject_construct(self, "recent-manager", manager, NULL)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkDialog object");
        return -1;
    }

  if (title)
    gtk_window_set_title (GTK_WINDOW (self->obj), title);

  if (parent)
    gtk_window_set_transient_for (GTK_WINDOW (self->obj), parent);

  for (i = 0; i < len; i += 2) {
      PyObject *text = PySequence_GetItem(py_buttons, i);
      PyObject *id = PySequence_GetItem(py_buttons, i + 1);
      if (!PyString_Check(text)) {
          gtk_object_destroy(GTK_OBJECT(self->obj));
          self->obj = NULL;
          PyErr_SetString(PyExc_RuntimeError,
                          "first member of each text/response id pair "
                          "must be a string");
          Py_DECREF(text);
          Py_DECREF(id);
          return -1;
      }
      if (!PyInt_Check(id)) {
          gtk_object_destroy(GTK_OBJECT(self->obj));
          self->obj = NULL;
          PyErr_SetString(PyExc_RuntimeError,
                          "second member of each text/response id pair "
                          "must be a number");
          Py_DECREF(text);
          Py_DECREF(id);
          return -1;
      }
      gtk_dialog_add_button(GTK_DIALOG(self->obj), PyString_AsString(text),
                            PyInt_AsLong(id));
      Py_DECREF(text);
      Py_DECREF(id);
  }
    
  return 0;
}
#line 105417 "gtk.c"


PyTypeObject G_GNUC_INTERNAL PyGtkRecentChooserDialog_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RecentChooserDialog",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_recent_chooser_dialog_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkRecentChooserMenu ----------- */

static int
_wrap_gtk_recent_chooser_menu_new_for_manager(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"manager", NULL };
    char *prop_names[] = {"recent-manager", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.RecentChooserMenu.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.RecentChooserMenu object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_recent_chooser_menu_get_show_numbers(PyGObject *self)
{
    int ret;

    
    ret = gtk_recent_chooser_menu_get_show_numbers(GTK_RECENT_CHOOSER_MENU(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_chooser_menu_set_show_numbers(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_numbers", NULL };
    int show_numbers;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentChooserMenu.set_show_numbers", kwlist, &show_numbers))
        return NULL;
    
    gtk_recent_chooser_menu_set_show_numbers(GTK_RECENT_CHOOSER_MENU(self->obj), show_numbers);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkRecentChooserMenu_methods[] = {
    { "get_show_numbers", (PyCFunction)_wrap_gtk_recent_chooser_menu_get_show_numbers, METH_NOARGS,
      NULL },
    { "set_show_numbers", (PyCFunction)_wrap_gtk_recent_chooser_menu_set_show_numbers, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRecentChooserMenu_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RecentChooserMenu",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRecentChooserMenu_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_recent_chooser_menu_new_for_manager,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkRecentChooserWidget ----------- */

 static int
_wrap_gtk_recent_chooser_widget_new_for_manager(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"manager", NULL };
    char *prop_names[] = {"recent-manager", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.RecentChooserWidget.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.RecentChooserWidget object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkRecentChooserWidget_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RecentChooserWidget",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_recent_chooser_widget_new_for_manager,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkRecentFilter ----------- */

 static int
_wrap_gtk_recent_filter_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.RecentFilter.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.RecentFilter object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_recent_filter_set_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentFilter.set_name", kwlist, &name))
        return NULL;
    
    gtk_recent_filter_set_name(GTK_RECENT_FILTER(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_filter_get_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_recent_filter_get_name(GTK_RECENT_FILTER(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_filter_add_mime_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "mime_type", NULL };
    char *mime_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentFilter.add_mime_type", kwlist, &mime_type))
        return NULL;
    
    gtk_recent_filter_add_mime_type(GTK_RECENT_FILTER(self->obj), mime_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_filter_add_pattern(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pattern", NULL };
    char *pattern;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentFilter.add_pattern", kwlist, &pattern))
        return NULL;
    
    gtk_recent_filter_add_pattern(GTK_RECENT_FILTER(self->obj), pattern);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_filter_add_pixbuf_formats(PyGObject *self)
{
    
    gtk_recent_filter_add_pixbuf_formats(GTK_RECENT_FILTER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_filter_add_application(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "application", NULL };
    char *application;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentFilter.add_application", kwlist, &application))
        return NULL;
    
    gtk_recent_filter_add_application(GTK_RECENT_FILTER(self->obj), application);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_filter_add_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group", NULL };
    char *group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentFilter.add_group", kwlist, &group))
        return NULL;
    
    gtk_recent_filter_add_group(GTK_RECENT_FILTER(self->obj), group);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_filter_add_age(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "days", NULL };
    int days;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentFilter.add_age", kwlist, &days))
        return NULL;
    
    gtk_recent_filter_add_age(GTK_RECENT_FILTER(self->obj), days);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 7586 "./gtk.override"
static gboolean
pygtk_recent_filter_add_custom_cb(const GtkRecentFilterInfo *info,
                                  gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_info, *retobj;
    gboolean ret = TRUE;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_info = PyDict_New();

    if (info->contains & GTK_RECENT_FILTER_URI)
        PyDict_SetItemString(py_info, "uri", PyString_FromString(info->uri));

    if (info->contains & GTK_RECENT_FILTER_DISPLAY_NAME)
        PyDict_SetItemString(py_info, "display_name",
                             PyString_FromString(info->display_name));

    if (info->contains & GTK_RECENT_FILTER_MIME_TYPE)
        PyDict_SetItemString(py_info, "mime_type",
                             PyString_FromString(info->mime_type));

    if (info->contains & GTK_RECENT_FILTER_APPLICATION) {
        gchar **apps = (gchar **)info->applications;
        PyObject *applications = PyList_New(0);
        if (apps) {
            while (*apps) {
                PyList_Append(applications, PyString_FromString(*apps));
                apps++;
            }
        }
        PyDict_SetItemString(py_info, "applications", applications);
    }

    if (info->contains & GTK_RECENT_FILTER_GROUP) {
        gchar **grps = (gchar **)info->groups;
        PyObject *groups = PyList_New(0);
        if (grps) {
            while (*grps) {
                PyList_Append(groups, PyString_FromString(*grps));
                grps++;
            }
        }
        PyDict_SetItemString(py_info, "groups", groups);
    }

    if (info->contains & GTK_RECENT_FILTER_AGE)
        PyDict_SetItemString(py_info, "age", PyInt_FromLong(info->age));
    
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NO)", py_info,
                                      cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(N)", py_info);
    }

    if (retobj != NULL) {
        ret = PyInt_AsLong(retobj);
        Py_DECREF(retobj);
    } else {
        PyErr_Print();
    }

    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_recent_filter_add_custom(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "needed", "func", "data", NULL };
    PyObject *pyneeded, *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
    GtkRecentFilterFlags needed;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|O:GtkRecentFilter.add_custom",
                                     kwlist, &pyneeded, &pyfunc, &pyarg))
        return NULL;

    if (pyg_flags_get_value(GTK_TYPE_RECENT_FILTER_FLAGS, pyneeded,
                            (gint *)&needed))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
 
    gtk_recent_filter_add_custom(GTK_RECENT_FILTER(self->obj), needed,
                                 pygtk_recent_filter_add_custom_cb,
                                 cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 105903 "gtk.c"


static PyObject *
_wrap_gtk_recent_filter_get_needed(PyGObject *self)
{
    guint ret;

    
    ret = gtk_recent_filter_get_needed(GTK_RECENT_FILTER(self->obj));
    
    return pyg_flags_from_gtype(GTK_TYPE_RECENT_FILTER_FLAGS, ret);
}

#line 7694 "./gtk.override"
static PyObject*
_wrap_gtk_recent_filter_filter(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "filter_info", NULL };
    GtkRecentFilterInfo info;
    PyObject *py_info, *py_ret = Py_False, *item;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkRecentFilter.filter", kwlist,
                                     &py_info))
        return NULL;

    if (!PyDict_Check(py_info)) {
        PyErr_SetString(PyExc_TypeError, "filter_info must be a mapping");
        return NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "uri"))) {
        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info uri must be a string");
            return NULL;
        }
        info.uri = PyString_AsString(item);
        info.contains |= GTK_RECENT_FILTER_URI;
    } else {
        info.uri = NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "mime_type"))) {
        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info mime_type must be a string");
            return NULL;
        }
        info.mime_type = PyString_AsString(item);
        info.contains |= GTK_RECENT_FILTER_MIME_TYPE;
    } else {
        info.mime_type = NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "display_name"))) {
        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info display_name must be a string");
            return NULL;
        }
        info.display_name = PyString_AsString(item);
        info.contains |= GTK_RECENT_FILTER_DISPLAY_NAME;
    } else {
        info.display_name = NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "applications"))) {
        gint size, i;
        if (!PySequence_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info applications must be a sequence of strings");
            return NULL;
        }
        size = PySequence_Size(item);
        info.applications = (const gchar**)g_new0(gchar*, size + 1);
        for (i = 0; i < size; i++) {
            PyObject *app = PySequence_GetItem(item, i);
            if (!PyString_Check(app)) {
                PyErr_SetString(PyExc_TypeError,
                                "filter_info applications must be a sequence of strings");
                return NULL;
            }
            info.applications[i] = PyString_AsString(app);
            Py_DECREF(app);
        }
        info.contains |= GTK_RECENT_FILTER_APPLICATION;
    } else {
        info.applications = NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "groups"))) {
        gint size, i;
        if (!PySequence_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info groups must be a sequence of strings");
            return NULL;
        }
        size = PySequence_Size(item);
        info.groups = (const gchar**)g_new0(gchar*, size + 1);
        for (i = 0; i < size; i++) {
            PyObject *grp = PySequence_GetItem(item, i);
            if (!PyString_Check(grp)) {
                PyErr_SetString(PyExc_TypeError,
                                "filter_info groups must be a sequence of strings");
                return NULL;
            }
            info.groups[i] = PyString_AsString(grp);
            Py_DECREF(grp);
        }
        info.contains |= GTK_RECENT_FILTER_GROUP;
    } else {
        info.groups = NULL;
    }

    if ((item = PyDict_GetItemString(py_info, "age"))) {
        if (!PyInt_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "filter_info age must be an int");
            return NULL;
        }
        info.age = PyInt_AsLong(item);
        info.contains |= GTK_RECENT_FILTER_AGE;
    } else {
        info.age = -1;
    }

    if (gtk_recent_filter_filter(GTK_RECENT_FILTER(self->obj), &info))
        py_ret = Py_True;

    if (info.applications)
        g_free(info.applications);
    if (info.groups)
        g_free(info.groups);

    Py_INCREF(py_ret);
    return py_ret;
}
#line 106043 "gtk.c"


static const PyMethodDef _PyGtkRecentFilter_methods[] = {
    { "set_name", (PyCFunction)_wrap_gtk_recent_filter_set_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_name", (PyCFunction)_wrap_gtk_recent_filter_get_name, METH_NOARGS,
      NULL },
    { "add_mime_type", (PyCFunction)_wrap_gtk_recent_filter_add_mime_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_pattern", (PyCFunction)_wrap_gtk_recent_filter_add_pattern, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_pixbuf_formats", (PyCFunction)_wrap_gtk_recent_filter_add_pixbuf_formats, METH_NOARGS,
      NULL },
    { "add_application", (PyCFunction)_wrap_gtk_recent_filter_add_application, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_group", (PyCFunction)_wrap_gtk_recent_filter_add_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_age", (PyCFunction)_wrap_gtk_recent_filter_add_age, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_custom", (PyCFunction)_wrap_gtk_recent_filter_add_custom, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_needed", (PyCFunction)_wrap_gtk_recent_filter_get_needed, METH_NOARGS,
      NULL },
    { "filter", (PyCFunction)_wrap_gtk_recent_filter_filter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRecentFilter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RecentFilter",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRecentFilter_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_recent_filter_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkRecentManager ----------- */

static int
_wrap_gtk_recent_manager_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.RecentManager.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.RecentManager object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_recent_manager_set_screen(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *screen;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentManager.set_screen", kwlist, &PyGdkScreen_Type, &screen))
        return NULL;
    
    gtk_recent_manager_set_screen(GTK_RECENT_MANAGER(self->obj), GDK_SCREEN(screen->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_manager_add_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentManager.add_item", kwlist, &uri))
        return NULL;
    
    ret = gtk_recent_manager_add_item(GTK_RECENT_MANAGER(self->obj), uri);
    
    return PyBool_FromLong(ret);

}

#line 7821 "./gtk.override"
static PyObject*
_wrap_gtk_recent_manager_add_full(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "uri", "recent_data", NULL };
    PyObject *py_data, *item, *py_ret = Py_False;
    gchar *uri;
    GtkRecentData recent_data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "sO:GtkRecentManager.add_full", kwlist,
                                     &uri, &py_data))
        return NULL;

    if (!PyDict_Check(py_data)) {
        PyErr_SetString(PyExc_TypeError, "recent_data must be a mapping");
        return NULL;
    }

    if (!(item = PyDict_GetItemString(py_data, "mime_type"))
        || !PyString_Check(item)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "recent_data must reference a 'mime_type' string value");
        return NULL;
    }
    recent_data.mime_type = PyString_AsString(item);

    if (!(item = PyDict_GetItemString(py_data, "app_name"))
        || !PyString_Check(item)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "recent_data must reference a 'app_name' string value");
        return NULL;
    }
    recent_data.app_name = PyString_AsString(item);

    if (!(item = PyDict_GetItemString(py_data, "app_exec"))
        || !PyString_Check(item)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "recent_data must reference a 'app_exec' string value");
        return NULL;
    }
    recent_data.app_exec = PyString_AsString(item);

    if ((item = PyDict_GetItemString(py_data, "display_name"))) {
        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "recent_data 'display_name' must reference a string");
            return NULL;
        }
        recent_data.display_name = PyString_AsString(item);
    } else {
        recent_data.display_name = NULL;
    }

    if ((item = PyDict_GetItemString(py_data, "description"))) {
        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "recent_data 'description' must reference a string");
            return NULL;
        }
        recent_data.description = PyString_AsString(item);
    } else {
        recent_data.description = NULL;
    }

    if ((item = PyDict_GetItemString(py_data, "is_private"))) {
        if (!PyBool_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "recent_data 'is_private' must reference a boolean");
            return NULL;
        }
        if (item == Py_True)
            recent_data.is_private = TRUE;
        else
            recent_data.is_private = FALSE;
    } else {
        recent_data.is_private = FALSE;
    }

    if ((item = PyDict_GetItemString(py_data, "groups"))) {
        gint size, i;
        if (!PySequence_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "recent_data 'groups' must reference a sequence of strings");
            return NULL;
        }
        size = PySequence_Size(item);
        recent_data.groups = (gchar**)g_new0(gchar*, size+1);
        for (i = 0; i < size; i++) {
            PyObject *group = PySequence_GetItem(item, i);
            if (!PyString_Check(group)) {
                PyErr_SetString(PyExc_TypeError,
                                "recent_data 'groups' must reference a sequence of strings");
                g_free(recent_data.groups);
                Py_XDECREF(group);
                return NULL;
            }
            recent_data.groups[i] = PyString_AsString(group);
            Py_DECREF(group);
        }
    } else {
        recent_data.groups = NULL;
    }

    if (gtk_recent_manager_add_full(GTK_RECENT_MANAGER(self->obj), uri,
                                    &recent_data))
        py_ret = Py_True;

    if (recent_data.groups)
        g_free(recent_data.groups);

    Py_INCREF(py_ret);
    return py_ret;
}
#line 106287 "gtk.c"


static PyObject *
_wrap_gtk_recent_manager_remove_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentManager.remove_item", kwlist, &uri))
        return NULL;
    
    ret = gtk_recent_manager_remove_item(GTK_RECENT_MANAGER(self->obj), uri, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_manager_lookup_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    GtkRecentInfo *ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentManager.lookup_item", kwlist, &uri))
        return NULL;
    
    ret = gtk_recent_manager_lookup_item(GTK_RECENT_MANAGER(self->obj), uri, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_RECENT_INFO, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_recent_manager_has_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentManager.has_item", kwlist, &uri))
        return NULL;
    
    ret = gtk_recent_manager_has_item(GTK_RECENT_MANAGER(self->obj), uri);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_manager_move_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", "new_uri", NULL };
    char *uri, *new_uri;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ss:Gtk.RecentManager.move_item", kwlist, &uri, &new_uri))
        return NULL;
    
    ret = gtk_recent_manager_move_item(GTK_RECENT_MANAGER(self->obj), uri, new_uri, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_manager_set_limit(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "limit", NULL };
    int limit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentManager.set_limit", kwlist, &limit))
        return NULL;
    
    gtk_recent_manager_set_limit(GTK_RECENT_MANAGER(self->obj), limit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_manager_get_limit(PyGObject *self)
{
    int ret;

    
    ret = gtk_recent_manager_get_limit(GTK_RECENT_MANAGER(self->obj));
    
    return PyInt_FromLong(ret);
}

#line 7937 "./gtk.override"
static PyObject *
_wrap_gtk_recent_manager_get_items(PyGObject *self)
{
    GtkRecentInfo *info;
    GList *items;
    PyObject *py_items;
    guint count, i;

    items = gtk_recent_manager_get_items(GTK_RECENT_MANAGER(self->obj));
    count = g_list_length(items);
    py_items = PyList_New(count);
    for (i = 0; i < count; i++) {
        info = g_list_nth_data(items, i);
        PyList_SetItem(py_items, i,
                       pyg_boxed_new(GTK_TYPE_RECENT_INFO, info, TRUE, TRUE));
    }
    g_list_foreach(items, (GFunc) gtk_recent_info_unref, NULL);
    g_list_free(items);

    return py_items;
}
#line 106411 "gtk.c"


static PyObject *
_wrap_gtk_recent_manager_purge_items(PyGObject *self)
{
    int ret;
    GError *error = NULL;

    
    ret = gtk_recent_manager_purge_items(GTK_RECENT_MANAGER(self->obj), &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_GtkRecentManager__do_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentManager.changed", kwlist, &PyGtkRecentManager_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_RECENT_MANAGER_CLASS(klass)->changed)
        GTK_RECENT_MANAGER_CLASS(klass)->changed(GTK_RECENT_MANAGER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.RecentManager.changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkRecentManager_methods[] = {
    { "set_screen", (PyCFunction)_wrap_gtk_recent_manager_set_screen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_item", (PyCFunction)_wrap_gtk_recent_manager_add_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_full", (PyCFunction)_wrap_gtk_recent_manager_add_full, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_item", (PyCFunction)_wrap_gtk_recent_manager_remove_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "lookup_item", (PyCFunction)_wrap_gtk_recent_manager_lookup_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "has_item", (PyCFunction)_wrap_gtk_recent_manager_has_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "move_item", (PyCFunction)_wrap_gtk_recent_manager_move_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_limit", (PyCFunction)_wrap_gtk_recent_manager_set_limit, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_limit", (PyCFunction)_wrap_gtk_recent_manager_get_limit, METH_NOARGS,
      NULL },
    { "get_items", (PyCFunction)_wrap_gtk_recent_manager_get_items, METH_NOARGS,
      NULL },
    { "purge_items", (PyCFunction)_wrap_gtk_recent_manager_purge_items, METH_NOARGS,
      NULL },
    { "do_changed", (PyCFunction)_wrap_GtkRecentManager__do_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRecentManager_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RecentManager",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRecentManager_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_recent_manager_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkRecentManager__proxy_do_changed(GtkRecentManager *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static int
__GtkRecentManager_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkRecentManagerClass *klass = GTK_RECENT_MANAGER_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "changed")))
            klass->changed = _wrap_GtkRecentManager__proxy_do_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkStatusIcon ----------- */

static int
_wrap_gtk_status_icon_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.StatusIcon.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.StatusIcon object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_status_icon_set_from_pixbuf(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *py_pixbuf;
    GdkPixbuf *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.StatusIcon.set_from_pixbuf", kwlist, &py_pixbuf))
        return NULL;
    if (py_pixbuf && pygobject_check(py_pixbuf, &PyGdkPixbuf_Type))
        pixbuf = GDK_PIXBUF(py_pixbuf->obj);
    else if ((PyObject *)py_pixbuf != Py_None) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf or None");
        return NULL;
    }
    
    gtk_status_icon_set_from_pixbuf(GTK_STATUS_ICON(self->obj), (GdkPixbuf *) pixbuf);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_set_from_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.StatusIcon.set_from_file", kwlist, &filename))
        return NULL;
    
    gtk_status_icon_set_from_file(GTK_STATUS_ICON(self->obj), filename);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_set_from_stock(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", NULL };
    char *stock_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.StatusIcon.set_from_stock", kwlist, &stock_id))
        return NULL;
    
    gtk_status_icon_set_from_stock(GTK_STATUS_ICON(self->obj), stock_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_set_from_icon_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    char *icon_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.StatusIcon.set_from_icon_name", kwlist, &icon_name))
        return NULL;
    
    gtk_status_icon_set_from_icon_name(GTK_STATUS_ICON(self->obj), icon_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_get_storage_type(PyGObject *self)
{
    gint ret;

    
    ret = gtk_status_icon_get_storage_type(GTK_STATUS_ICON(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_IMAGE_TYPE, ret);
}

static PyObject *
_wrap_gtk_status_icon_get_pixbuf(PyGObject *self)
{
    GdkPixbuf *ret;

    
    ret = gtk_status_icon_get_pixbuf(GTK_STATUS_ICON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_status_icon_get_stock(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_status_icon_get_stock(GTK_STATUS_ICON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_get_icon_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_status_icon_get_icon_name(GTK_STATUS_ICON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_get_size(PyGObject *self)
{
    int ret;

    
    ret = gtk_status_icon_get_size(GTK_STATUS_ICON(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_status_icon_set_tooltip(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tooltip_text", NULL };
    char *tooltip_text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.StatusIcon.set_tooltip", kwlist, &tooltip_text))
        return NULL;
    
    gtk_status_icon_set_tooltip(GTK_STATUS_ICON(self->obj), tooltip_text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_set_visible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "visible", NULL };
    int visible;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.StatusIcon.set_visible", kwlist, &visible))
        return NULL;
    
    gtk_status_icon_set_visible(GTK_STATUS_ICON(self->obj), visible);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_get_visible(PyGObject *self)
{
    int ret;

    
    ret = gtk_status_icon_get_visible(GTK_STATUS_ICON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_status_icon_set_blinking(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "blinking", NULL };
    int blinking;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.StatusIcon.set_blinking", kwlist, &blinking))
        return NULL;
    
    gtk_status_icon_set_blinking(GTK_STATUS_ICON(self->obj), blinking);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_get_blinking(PyGObject *self)
{
    int ret;

    
    ret = gtk_status_icon_get_blinking(GTK_STATUS_ICON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_status_icon_is_embedded(PyGObject *self)
{
    int ret;

    
    ret = gtk_status_icon_is_embedded(GTK_STATUS_ICON(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 7960 "./gtk.override"
static PyObject *
_wrap_gtk_status_icon_get_geometry(PyGObject *self)
{
    GdkScreen *screen;
    GdkRectangle rect;
    GtkOrientation orientation;
    gboolean ret;

    ret = gtk_status_icon_get_geometry(GTK_STATUS_ICON(self->obj),
                                       &screen, &rect, &orientation);
    if (ret) 
        return Py_BuildValue("(NNN)", pygobject_new((GObject*)screen),
                             pyg_boxed_new(GDK_TYPE_RECTANGLE, &rect,
                                           TRUE, TRUE),
                             pyg_enum_from_gtype(GTK_TYPE_ORIENTATION,
                                                 orientation));
    Py_INCREF(Py_None);
    return Py_None;
}
#line 106848 "gtk.c"


static PyObject *
_wrap_gtk_status_icon_set_screen(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *screen;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.StatusIcon.set_screen", kwlist, &PyGdkScreen_Type, &screen))
        return NULL;
    
    gtk_status_icon_set_screen(GTK_STATUS_ICON(self->obj), GDK_SCREEN(screen->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_get_screen(PyGObject *self)
{
    GdkScreen *ret;

    
    ret = gtk_status_icon_get_screen(GTK_STATUS_ICON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_status_icon_get_x11_window_id(PyGObject *self)
{
    guint32 ret;

    
    ret = gtk_status_icon_get_x11_window_id(GTK_STATUS_ICON(self->obj));
    
    return PyLong_FromUnsignedLong(ret);

}

static PyObject *
_wrap_gtk_status_icon_get_gicon(PyGObject *self)
{
    GIcon *ret;

    
    ret = gtk_status_icon_get_gicon(GTK_STATUS_ICON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_status_icon_set_from_gicon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon", NULL };
    PyGObject *icon;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.StatusIcon.set_from_gicon", kwlist, &PyGIcon_Type, &icon))
        return NULL;
    
    gtk_status_icon_set_from_gicon(GTK_STATUS_ICON(self->obj), G_ICON(icon->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_get_has_tooltip(PyGObject *self)
{
    int ret;

    
    ret = gtk_status_icon_get_has_tooltip(GTK_STATUS_ICON(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_status_icon_get_tooltip_text(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_status_icon_get_tooltip_text(GTK_STATUS_ICON(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_get_tooltip_markup(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_status_icon_get_tooltip_markup(GTK_STATUS_ICON(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_set_has_tooltip(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "has_tooltip", NULL };
    int has_tooltip;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.StatusIcon.set_has_tooltip", kwlist, &has_tooltip))
        return NULL;
    
    gtk_status_icon_set_has_tooltip(GTK_STATUS_ICON(self->obj), has_tooltip);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_set_tooltip_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.StatusIcon.set_tooltip_text", kwlist, &text))
        return NULL;
    
    gtk_status_icon_set_tooltip_text(GTK_STATUS_ICON(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_set_tooltip_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "markup", NULL };
    char *markup;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.StatusIcon.set_tooltip_markup", kwlist, &markup))
        return NULL;
    
    gtk_status_icon_set_tooltip_markup(GTK_STATUS_ICON(self->obj), markup);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_set_title(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "title", NULL };
    char *title;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.StatusIcon.set_title", kwlist, &title))
        return NULL;
    
    gtk_status_icon_set_title(GTK_STATUS_ICON(self->obj), title);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_get_title(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_status_icon_get_title(GTK_STATUS_ICON(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_status_icon_set_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.StatusIcon.set_name", kwlist, &name))
        return NULL;
    
    gtk_status_icon_set_name(GTK_STATUS_ICON(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStatusIcon__do_activate(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.StatusIcon.activate", kwlist, &PyGtkStatusIcon_Type, &self))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STATUS_ICON_CLASS(klass)->activate)
        GTK_STATUS_ICON_CLASS(klass)->activate(GTK_STATUS_ICON(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.StatusIcon.activate not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStatusIcon__do_popup_menu(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "button", "activate_time", NULL };
    PyGObject *self;
    PyObject *py_button = NULL;
    unsigned long activate_time;
    guint button = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!Ok:Gtk.StatusIcon.popup_menu", kwlist, &PyGtkStatusIcon_Type, &self, &py_button, &activate_time))
        return NULL;
    if (py_button) {
        if (PyLong_Check(py_button))
            button = PyLong_AsUnsignedLong(py_button);
        else if (PyInt_Check(py_button))
            button = PyInt_AsLong(py_button);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'button' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STATUS_ICON_CLASS(klass)->popup_menu)
        GTK_STATUS_ICON_CLASS(klass)->popup_menu(GTK_STATUS_ICON(self->obj), button, activate_time);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.StatusIcon.popup_menu not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkStatusIcon__do_size_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "size", NULL };
    PyGObject *self;
    int size, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.StatusIcon.size_changed", kwlist, &PyGtkStatusIcon_Type, &self, &size))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_STATUS_ICON_CLASS(klass)->size_changed)
        ret = GTK_STATUS_ICON_CLASS(klass)->size_changed(GTK_STATUS_ICON(self->obj), size);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.StatusIcon.size_changed not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkStatusIcon_methods[] = {
    { "set_from_pixbuf", (PyCFunction)_wrap_gtk_status_icon_set_from_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_from_file", (PyCFunction)_wrap_gtk_status_icon_set_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_from_stock", (PyCFunction)_wrap_gtk_status_icon_set_from_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_from_icon_name", (PyCFunction)_wrap_gtk_status_icon_set_from_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_storage_type", (PyCFunction)_wrap_gtk_status_icon_get_storage_type, METH_NOARGS,
      NULL },
    { "get_pixbuf", (PyCFunction)_wrap_gtk_status_icon_get_pixbuf, METH_NOARGS,
      NULL },
    { "get_stock", (PyCFunction)_wrap_gtk_status_icon_get_stock, METH_NOARGS,
      NULL },
    { "get_icon_name", (PyCFunction)_wrap_gtk_status_icon_get_icon_name, METH_NOARGS,
      NULL },
    { "get_size", (PyCFunction)_wrap_gtk_status_icon_get_size, METH_NOARGS,
      NULL },
    { "set_tooltip", (PyCFunction)_wrap_gtk_status_icon_set_tooltip, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_visible", (PyCFunction)_wrap_gtk_status_icon_set_visible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_visible", (PyCFunction)_wrap_gtk_status_icon_get_visible, METH_NOARGS,
      NULL },
    { "set_blinking", (PyCFunction)_wrap_gtk_status_icon_set_blinking, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_blinking", (PyCFunction)_wrap_gtk_status_icon_get_blinking, METH_NOARGS,
      NULL },
    { "is_embedded", (PyCFunction)_wrap_gtk_status_icon_is_embedded, METH_NOARGS,
      NULL },
    { "get_geometry", (PyCFunction)_wrap_gtk_status_icon_get_geometry, METH_NOARGS,
      NULL },
    { "set_screen", (PyCFunction)_wrap_gtk_status_icon_set_screen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_screen", (PyCFunction)_wrap_gtk_status_icon_get_screen, METH_NOARGS,
      NULL },
    { "get_x11_window_id", (PyCFunction)_wrap_gtk_status_icon_get_x11_window_id, METH_NOARGS,
      NULL },
    { "get_gicon", (PyCFunction)_wrap_gtk_status_icon_get_gicon, METH_NOARGS,
      NULL },
    { "set_from_gicon", (PyCFunction)_wrap_gtk_status_icon_set_from_gicon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_has_tooltip", (PyCFunction)_wrap_gtk_status_icon_get_has_tooltip, METH_NOARGS,
      NULL },
    { "get_tooltip_text", (PyCFunction)_wrap_gtk_status_icon_get_tooltip_text, METH_NOARGS,
      NULL },
    { "get_tooltip_markup", (PyCFunction)_wrap_gtk_status_icon_get_tooltip_markup, METH_NOARGS,
      NULL },
    { "set_has_tooltip", (PyCFunction)_wrap_gtk_status_icon_set_has_tooltip, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tooltip_text", (PyCFunction)_wrap_gtk_status_icon_set_tooltip_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tooltip_markup", (PyCFunction)_wrap_gtk_status_icon_set_tooltip_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_title", (PyCFunction)_wrap_gtk_status_icon_set_title, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_title", (PyCFunction)_wrap_gtk_status_icon_get_title, METH_NOARGS,
      NULL },
    { "set_name", (PyCFunction)_wrap_gtk_status_icon_set_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_activate", (PyCFunction)_wrap_GtkStatusIcon__do_activate, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_popup_menu", (PyCFunction)_wrap_GtkStatusIcon__do_popup_menu, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_size_changed", (PyCFunction)_wrap_GtkStatusIcon__do_size_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkStatusIcon_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.StatusIcon",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkStatusIcon_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_status_icon_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkStatusIcon__proxy_do_activate(GtkStatusIcon *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_activate");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkStatusIcon__proxy_do_size_changed(GtkStatusIcon *self, gint size)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_size;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_size = PyInt_FromLong(size);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_size);
    
    py_method = PyObject_GetAttrString(py_self, "do_size_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static int
__GtkStatusIcon_class_init(gpointer gclass, PyTypeObject *pyclass)
{
    PyObject *o;
    GtkStatusIconClass *klass = GTK_STATUS_ICON_CLASS(gclass);
    PyObject *gsignals = PyDict_GetItemString(pyclass->tp_dict, "__gsignals__");

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_activate");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "activate")))
            klass->activate = _wrap_GtkStatusIcon__proxy_do_activate;
        Py_DECREF(o);
    }

    /* overriding do_popup_menu is currently not supported */

    o = PyObject_GetAttrString((PyObject *) pyclass, "do_size_changed");
    if (o == NULL)
        PyErr_Clear();
    else {
        if (!PyObject_TypeCheck(o, &PyCFunction_Type)
            && !(gsignals && PyDict_GetItemString(gsignals, "size_changed")))
            klass->size_changed = _wrap_GtkStatusIcon__proxy_do_size_changed;
        Py_DECREF(o);
    }
    return 0;
}


/* ----------- GtkBuilder ----------- */

static int
_wrap_gtk_builder_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Builder.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Builder object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_builder_add_from_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;
    GError *error = NULL;
    guint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Builder.add_from_file", kwlist, &filename))
        return NULL;
    
    ret = gtk_builder_add_from_file(GTK_BUILDER(self->obj), filename, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_builder_add_from_string(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", "length", NULL };
    char *buffer;
    gsize length = -1;
    GError *error = NULL;
    guint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s|k:Gtk.Builder.add_from_string", kwlist, &buffer, &length))
        return NULL;
    
    ret = gtk_builder_add_from_string(GTK_BUILDER(self->obj), buffer, length, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_builder_get_object(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    GObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Builder.get_object", kwlist, &name))
        return NULL;
    
    ret = gtk_builder_get_object(GTK_BUILDER(self->obj), name);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 198 "gtkbuilder.override"
static PyObject *
_wrap_gtk_builder_get_objects(PyGObject *self)
{
    GSList *l, *objects;
    PyObject *pyobjects;

    pyobjects = PyList_New(0);
    objects = gtk_builder_get_objects(GTK_BUILDER(self->obj));
    for (l = objects; l; l = l->next)
    {
        PyObject *item = pygobject_new((GObject *)l->data);
        PyList_Append(pyobjects, item);
        Py_DECREF(item);
    }
    g_slist_free(objects);

    return pyobjects;
}

#line 107494 "gtk.c"


#line 88 "gtkbuilder.override"
static void
connect_many(GtkBuilder *builder, GObject *obj,
	     const gchar *signal_name, const gchar *handler_name,
	     GObject *connect_object, GConnectFlags flags, gpointer user_data)
{
    PyGCustomSignalNotify   *notify = user_data;
    PyObject                *handler_dict = notify->obj;
    PyObject                *tuple, *self;
    GClosure                *closure = NULL;

    if (notify->exception_pending)
        return;

    tuple = PyMapping_GetItemString(handler_dict, (gchar *)handler_name);
    if (!tuple) {
	PyErr_Clear();	
        tuple = PyObject_GetAttrString(handler_dict, (gchar *)handler_name);
        if (!tuple) {
            gchar *error_message;
            PyObject *name_obj;

            PyErr_Clear();

            name_obj = PyString_FromString(handler_name);
            PyList_Append(notify->missing_handlers, name_obj);
            Py_DECREF(name_obj);

            error_message = g_strdup_printf("missing handler '%s'", handler_name);
            if (PyErr_Warn(NULL, error_message)) {
                /* PyErr_Warn requests us to raise the warning as exception.  That can
                 * happen when user explicitly used warnings.filterwarnings('error'...).
                 * So, we will not call any Python code anymore and raise the exception
                 * from connect_signals(). */
                notify->exception_pending = TRUE;
            }

            g_free(error_message);
            return;
        }
    }
    
    if (PyTuple_Check(tuple)) {
	PyObject *callback = PyTuple_GetItem(tuple, 0);
	PyObject *extra = PySequence_GetSlice(tuple, 1, PyTuple_Size(tuple));
	PyObject *other = NULL;

	if (connect_object)
	    other = pygobject_new((GObject *)connect_object);

	closure = pyg_closure_new(callback, extra, other);
	Py_DECREF(extra);
    } else if (PyCallable_Check(tuple)) {
	PyObject *other = NULL;

	if (connect_object)
	    other = pygobject_new((GObject *)connect_object);

	closure = pyg_closure_new(tuple, notify->data, other);
    } else {
	g_warning("handler for `%s' not callable or a tuple", handler_name);
	Py_DECREF(tuple);
	return;
    }
    Py_DECREF(tuple);
    self = pygobject_new(obj);
    g_signal_connect_closure(obj, signal_name, closure, flags);
    pygobject_watch_closure(self, closure);
    Py_DECREF(self);
}

static PyObject *
_wrap_gtk_builder_connect_signals(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "object", "user_data", NULL };
    PyGCustomSignalNotify   notify;
    PyObject                *object, *user_data = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|O:GtkBuilder.connect_signals", kwlist,
				     &object, &user_data))
	return NULL;

    notify.obj = object;
    notify.data = user_data;
    notify.missing_handlers = PyList_New(0);
    notify.exception_pending = FALSE;

    if (!notify.missing_handlers)
        return NULL;

    gtk_builder_connect_signals_full(GTK_BUILDER(self->obj),
                                     connect_many,
                                     &notify);

    if (notify.exception_pending) {
        Py_DECREF(notify.missing_handlers);
        return NULL;
    }
    else if (PyObject_IsTrue(notify.missing_handlers))
        return notify.missing_handlers;
    else {
        Py_DECREF(notify.missing_handlers);
        Py_INCREF(Py_None);
        return Py_None;
    }
}

#line 107606 "gtk.c"


static PyObject *
_wrap_gtk_builder_set_translation_domain(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "domain", NULL };
    char *domain;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.Builder.set_translation_domain", kwlist, &domain))
        return NULL;
    
    gtk_builder_set_translation_domain(GTK_BUILDER(self->obj), domain);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_builder_get_translation_domain(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_builder_get_translation_domain(GTK_BUILDER(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_builder_get_type_from_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type_name", NULL };
    char *type_name;
    GType ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Builder.get_type_from_name", kwlist, &type_name))
        return NULL;
    
    ret = gtk_builder_get_type_from_name(GTK_BUILDER(self->obj), type_name);
    
    return pyg_type_wrapper_new(ret);
}

#line 219 "gtkbuilder.override"
static PyObject *
_wrap_gtk_builder_add_objects_from_file(PyGObject *self,
					PyObject *args,
					PyObject *kwargs)
{
    static char *kwlist[] = { "filename", "object_ids", NULL };
    const gchar *filename;
    PyObject *py_obj_ids;
    char **object_ids;
    guint ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "sO:GtkBuilder.add_objects_from_file",
				     kwlist, &filename, &py_obj_ids))
        return NULL;

    if (!pylist_to_strv (py_obj_ids, &object_ids))
        return NULL;

    ret = gtk_builder_add_objects_from_file (GTK_BUILDER (self->obj),
					     filename, object_ids, &error);
    g_strfreev (object_ids);
    
    if (pyg_error_check(&error))
        return NULL;
    
    return PyInt_FromLong(ret);
}

#line 107684 "gtk.c"


#line 251 "gtkbuilder.override"
static PyObject *
_wrap_gtk_builder_add_objects_from_string(PyGObject *self,
					  PyObject *args,
					  PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", "object_ids", NULL };
    const gchar *buffer;
    gsize lenght = -1;
    PyObject *py_obj_ids;
    char **object_ids;
    guint ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "sO:GtkBuilder.add_objects_from_string",
				     kwlist, &buffer, &py_obj_ids))
        return NULL;

    if (!pylist_to_strv (py_obj_ids, &object_ids))
        return NULL;

    ret = gtk_builder_add_objects_from_string (GTK_BUILDER (self->obj),
					       buffer, lenght,
					       object_ids, &error);
    g_strfreev (object_ids);
    
    if (pyg_error_check(&error))
        return NULL;
    
    return PyInt_FromLong(ret);
}
#line 107719 "gtk.c"


static PyObject *
_wrap_GtkBuilder__do_get_type_from_name(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "type_name", NULL };
    PyGObject *self;
    char *type_name;
    GType ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.Builder.get_type_from_name", kwlist, &PyGtkBuilder_Type, &self, &type_name))
        return NULL;
    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_BUILDER_CLASS(klass)->get_type_from_name)
        ret = GTK_BUILDER_CLASS(klass)->get_type_from_name(GTK_BUILDER(self->obj), type_name);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method Gtk.Builder.get_type_from_name not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    return pyg_type_wrapper_new(ret);
}

static const PyMethodDef _PyGtkBuilder_methods[] = {
    { "add_from_file", (PyCFunction)_wrap_gtk_builder_add_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_from_string", (PyCFunction)_wrap_gtk_builder_add_from_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_object", (PyCFunction)_wrap_gtk_builder_get_object, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_objects", (PyCFunction)_wrap_gtk_builder_get_objects, METH_NOARGS,
      NULL },
    { "connect_signals", (PyCFunction)_wrap_gtk_builder_connect_signals, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_translation_domain", (PyCFunction)_wrap_gtk_builder_set_translation_domain, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_translation_domain", (PyCFunction)_wrap_gtk_builder_get_translation_domain, METH_NOARGS,
      NULL },
    { "get_type_from_name", (PyCFunction)_wrap_gtk_builder_get_type_from_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_objects_from_file", (PyCFunction)_wrap_gtk_builder_add_objects_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_objects_from_string", (PyCFunction)_wrap_gtk_builder_add_objects_from_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_get_type_from_name", (PyCFunction)_wrap_GtkBuilder__do_get_type_from_name, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkBuilder_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Builder",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkBuilder_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_builder_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};


static int
__GtkBuilder_class_init(gpointer gclass, PyTypeObject *pyclass)
{

    /* overriding do_get_type_from_name is currently not supported */
    return 0;
}


/* ----------- GtkRecentAction ----------- */

static int
_wrap_gtk_recent_action_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "label", "tooltip", "stock_id", NULL };
    char *name, *label, *tooltip, *stock_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"szzz:Gtk.RecentAction.__init__", kwlist, &name, &label, &tooltip, &stock_id))
        return -1;
    self->obj = (GObject *)gtk_recent_action_new(name, label, tooltip, stock_id);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkRecentAction object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}

static PyObject *
_wrap_gtk_recent_action_get_show_numbers(PyGObject *self)
{
    int ret;

    
    ret = gtk_recent_action_get_show_numbers(GTK_RECENT_ACTION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_action_set_show_numbers(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_numbers", NULL };
    int show_numbers;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentAction.set_show_numbers", kwlist, &show_numbers))
        return NULL;
    
    gtk_recent_action_set_show_numbers(GTK_RECENT_ACTION(self->obj), show_numbers);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkRecentAction_methods[] = {
    { "get_show_numbers", (PyCFunction)_wrap_gtk_recent_action_get_show_numbers, METH_NOARGS,
      NULL },
    { "set_show_numbers", (PyCFunction)_wrap_gtk_recent_action_set_show_numbers, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRecentAction_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RecentAction",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRecentAction_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_recent_action_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkScaleButton ----------- */

#line 8483 "./gtk.override"
static int
_wrap_gtk_scale_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "size", "min", "max", "step", "icons", NULL };
    PyObject *py_size = NULL, *py_icons = NULL;
    double min, max, step;
    gchar **icons = NULL;
    GtkIconSize size;
    GtkAdjustment *adj;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oddd|O:GtkScaleButton.__init__", kwlist,
                                     &py_size, &min, &max, &step, &py_icons))
        return -1;
    
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return -1;
    
    if (py_icons) {
        if (!PySequence_Check(py_icons)) {
            PyErr_SetString(PyExc_TypeError, "icons must be a sequence");
            return -1;
        }    
        len = PySequence_Length(py_icons);
        icons = g_new(gchar *, len + 1);
        for (i = 0; i < len; i++) {
            PyObject *item = PySequence_GetItem(py_icons, i);
            if (!PyString_Check(item)) {
                PyErr_SetString(PyExc_TypeError, "icon must be a string");
                g_free(icons);
                return -1;
            }
            icons[i] = PyString_AsString(item);
            Py_DECREF(item);
        }
        icons[len] = NULL;
    }
    pygobject_construct(self, "size", size, "icons", icons, NULL);
    
    g_free(icons);
    
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create gtk.ScaleButton object");
        return -1;
    }

    adj = gtk_scale_button_get_adjustment(GTK_SCALE_BUTTON(self->obj));
    g_object_set(adj, "lower", min, "upper", max, "step-increment", step, NULL);

    return 0;
}
#line 107984 "gtk.c"


#line 8540 "./gtk.override"
static PyObject *
_wrap_gtk_scale_button_set_icons(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icons", NULL };
    PyObject *py_icons;
    gchar **icons = NULL;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkScaleButton.set_icons", kwlist,
                                     &py_icons))
        return NULL;

    if (!PySequence_Check(py_icons)) {
        PyErr_SetString(PyExc_TypeError, "icons must be a sequence");
        return NULL;
    }    
    len = PySequence_Length(py_icons);
    icons = g_new(gchar *, len + 1);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(py_icons, i);
        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError, "icon must be a string");
            g_free(icons);
            return NULL;
        }
        icons[i] = PyString_AsString(item);
        Py_DECREF(item);
    }
    icons[len] = NULL;

    gtk_scale_button_set_icons(GTK_SCALE_BUTTON(self->obj),
                               (const gchar **) icons);

    g_free(icons);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 108027 "gtk.c"


static PyObject *
_wrap_gtk_scale_button_get_value(PyGObject *self)
{
    double ret;

    
    ret = gtk_scale_button_get_value(GTK_SCALE_BUTTON(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_scale_button_set_value(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    double value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:Gtk.ScaleButton.set_value", kwlist, &value))
        return NULL;
    
    gtk_scale_button_set_value(GTK_SCALE_BUTTON(self->obj), value);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scale_button_get_adjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_scale_button_get_adjustment(GTK_SCALE_BUTTON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_scale_button_set_adjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *adjustment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ScaleButton.set_adjustment", kwlist, &PyGtkAdjustment_Type, &adjustment))
        return NULL;
    
    gtk_scale_button_set_adjustment(GTK_SCALE_BUTTON(self->obj), GTK_ADJUSTMENT(adjustment->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scale_button_get_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_scale_button_get_orientation(GTK_SCALE_BUTTON(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, ret);
}

static PyObject *
_wrap_gtk_scale_button_set_orientation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "orientation", NULL };
    GtkOrientation orientation;
    PyObject *py_orientation = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ScaleButton.set_orientation", kwlist, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    
    gtk_scale_button_set_orientation(GTK_SCALE_BUTTON(self->obj), orientation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_scale_button_get_plus_button(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_scale_button_get_plus_button(GTK_SCALE_BUTTON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_scale_button_get_minus_button(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_scale_button_get_minus_button(GTK_SCALE_BUTTON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_scale_button_get_popup(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_scale_button_get_popup(GTK_SCALE_BUTTON(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkScaleButton_methods[] = {
    { "set_icons", (PyCFunction)_wrap_gtk_scale_button_set_icons, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_value", (PyCFunction)_wrap_gtk_scale_button_get_value, METH_NOARGS,
      NULL },
    { "set_value", (PyCFunction)_wrap_gtk_scale_button_set_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_adjustment", (PyCFunction)_wrap_gtk_scale_button_get_adjustment, METH_NOARGS,
      NULL },
    { "set_adjustment", (PyCFunction)_wrap_gtk_scale_button_set_adjustment, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_orientation", (PyCFunction)_wrap_gtk_scale_button_get_orientation, METH_NOARGS,
      NULL },
    { "set_orientation", (PyCFunction)_wrap_gtk_scale_button_set_orientation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_plus_button", (PyCFunction)_wrap_gtk_scale_button_get_plus_button, METH_NOARGS,
      NULL },
    { "get_minus_button", (PyCFunction)_wrap_gtk_scale_button_get_minus_button, METH_NOARGS,
      NULL },
    { "get_popup", (PyCFunction)_wrap_gtk_scale_button_get_popup, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkScaleButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ScaleButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkScaleButton_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_scale_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTooltip ----------- */

static PyObject *
_wrap_gtk_tooltip_set_markup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "markup", NULL };
    char *markup;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.Tooltip.set_markup", kwlist, &markup))
        return NULL;
    
    gtk_tooltip_set_markup(GTK_TOOLTIP(self->obj), markup);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltip_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"z:Gtk.Tooltip.set_text", kwlist, &text))
        return NULL;
    
    gtk_tooltip_set_text(GTK_TOOLTIP(self->obj), text);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltip_set_icon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *py_pixbuf;
    GdkPixbuf *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Tooltip.set_icon", kwlist, &py_pixbuf))
        return NULL;
    if (py_pixbuf && pygobject_check(py_pixbuf, &PyGdkPixbuf_Type))
        pixbuf = GDK_PIXBUF(py_pixbuf->obj);
    else if ((PyObject *)py_pixbuf != Py_None) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf or None");
        return NULL;
    }
    
    gtk_tooltip_set_icon(GTK_TOOLTIP(self->obj), (GdkPixbuf *) pixbuf);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltip_set_icon_from_stock(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "size", NULL };
    char *stock_id;
    PyObject *py_size = NULL;
    GtkIconSize size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"zO:Gtk.Tooltip.set_icon_from_stock", kwlist, &stock_id, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    gtk_tooltip_set_icon_from_stock(GTK_TOOLTIP(self->obj), stock_id, size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltip_set_custom(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "custom_widget", NULL };
    PyGObject *custom_widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Tooltip.set_custom", kwlist, &PyGtkWidget_Type, &custom_widget))
        return NULL;
    
    gtk_tooltip_set_custom(GTK_TOOLTIP(self->obj), GTK_WIDGET(custom_widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltip_set_tip_area(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "rect", NULL };
    PyObject *py_rect;
    GdkRectangle rect = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Tooltip.set_tip_area", kwlist, &py_rect))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_rect, &rect))
        return NULL;
    
    gtk_tooltip_set_tip_area(GTK_TOOLTIP(self->obj), &rect);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltip_set_icon_from_icon_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", "size", NULL };
    char *icon_name;
    PyObject *py_size = NULL;
    GtkIconSize size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"zO:Gtk.Tooltip.set_icon_from_icon_name", kwlist, &icon_name, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    gtk_tooltip_set_icon_from_icon_name(GTK_TOOLTIP(self->obj), icon_name, size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tooltip_set_icon_from_gicon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gicon", "size", NULL };
    PyGObject *gicon;
    PyObject *py_size = NULL;
    GtkIconSize size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.Tooltip.set_icon_from_gicon", kwlist, &PyGIcon_Type, &gicon, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    gtk_tooltip_set_icon_from_gicon(GTK_TOOLTIP(self->obj), G_ICON(gicon->obj), size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTooltip_methods[] = {
    { "set_markup", (PyCFunction)_wrap_gtk_tooltip_set_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_text", (PyCFunction)_wrap_gtk_tooltip_set_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon", (PyCFunction)_wrap_gtk_tooltip_set_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_from_stock", (PyCFunction)_wrap_gtk_tooltip_set_icon_from_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_custom", (PyCFunction)_wrap_gtk_tooltip_set_custom, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_tip_area", (PyCFunction)_wrap_gtk_tooltip_set_tip_area, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_from_icon_name", (PyCFunction)_wrap_gtk_tooltip_set_icon_from_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_from_gicon", (PyCFunction)_wrap_gtk_tooltip_set_icon_from_gicon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTooltip_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Tooltip",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTooltip_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkVolumeButton ----------- */

static int
_wrap_gtk_volume_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.VolumeButton.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.VolumeButton object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkVolumeButton_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.VolumeButton",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_volume_button_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkMountOperation ----------- */

static int
_wrap_gtk_mount_operation_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GType obj_type = pyg_type_from_object((PyObject *) self);
    GParameter params[1];
    PyObject *parsed_args[1] = {NULL, };
    char *arg_names[] = {"parent", NULL };
    char *prop_names[] = {"parent", NULL };
    guint nparams, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:gtk.MountOperation.__init__" , arg_names , &parsed_args[0]))
        return -1;

    memset(params, 0, sizeof(GParameter)*1);
    if (!pyg_parse_constructor_args(obj_type, arg_names,
                                    prop_names, params, 
                                    &nparams, parsed_args))
        return -1;
    pygobject_constructv(self, nparams, params);
    for (i = 0; i < nparams; ++i)
        g_value_unset(&params[i].value);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.MountOperation object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_mount_operation_is_showing(PyGObject *self)
{
    int ret;

    
    ret = gtk_mount_operation_is_showing(GTK_MOUNT_OPERATION(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_mount_operation_set_parent(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyGObject *parent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MountOperation.set_parent", kwlist, &PyGtkWindow_Type, &parent))
        return NULL;
    
    gtk_mount_operation_set_parent(GTK_MOUNT_OPERATION(self->obj), GTK_WINDOW(parent->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_mount_operation_get_parent(PyGObject *self)
{
    GtkWindow *ret;

    
    ret = gtk_mount_operation_get_parent(GTK_MOUNT_OPERATION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_mount_operation_set_screen(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *screen;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.MountOperation.set_screen", kwlist, &PyGdkScreen_Type, &screen))
        return NULL;
    
    gtk_mount_operation_set_screen(GTK_MOUNT_OPERATION(self->obj), GDK_SCREEN(screen->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_mount_operation_get_screen(PyGObject *self)
{
    GdkScreen *ret;

    
    ret = gtk_mount_operation_get_screen(GTK_MOUNT_OPERATION(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkMountOperation_methods[] = {
    { "is_showing", (PyCFunction)_wrap_gtk_mount_operation_is_showing, METH_NOARGS,
      NULL },
    { "set_parent", (PyCFunction)_wrap_gtk_mount_operation_set_parent, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_parent", (PyCFunction)_wrap_gtk_mount_operation_get_parent, METH_NOARGS,
      NULL },
    { "set_screen", (PyCFunction)_wrap_gtk_mount_operation_set_screen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_screen", (PyCFunction)_wrap_gtk_mount_operation_get_screen, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkMountOperation_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.MountOperation",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkMountOperation_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_mount_operation_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkEntryBuffer ----------- */

static int
_wrap_gtk_entry_buffer_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "initial_chars", "n_initial_chars", NULL };
    char *initial_chars;
    int n_initial_chars;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"si:Gtk.EntryBuffer.__init__", kwlist, &initial_chars, &n_initial_chars))
        return -1;
    self->obj = (GObject *)gtk_entry_buffer_new(initial_chars, n_initial_chars);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkEntryBuffer object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}

static PyObject *
_wrap_gtk_entry_buffer_get_bytes(PyGObject *self)
{
    gsize ret;

    
    ret = gtk_entry_buffer_get_bytes(GTK_ENTRY_BUFFER(self->obj));
    
    return PyLong_FromUnsignedLongLong(ret);

}

static PyObject *
_wrap_gtk_entry_buffer_get_length(PyGObject *self)
{
    guint ret;

    
    ret = gtk_entry_buffer_get_length(GTK_ENTRY_BUFFER(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_entry_buffer_get_text(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_entry_buffer_get_text(GTK_ENTRY_BUFFER(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_buffer_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "chars", "n_chars", NULL };
    char *chars;
    int n_chars;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"si:Gtk.EntryBuffer.set_text", kwlist, &chars, &n_chars))
        return NULL;
    
    gtk_entry_buffer_set_text(GTK_ENTRY_BUFFER(self->obj), chars, n_chars);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_buffer_set_max_length(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "max_length", NULL };
    int max_length;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.EntryBuffer.set_max_length", kwlist, &max_length))
        return NULL;
    
    gtk_entry_buffer_set_max_length(GTK_ENTRY_BUFFER(self->obj), max_length);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_buffer_get_max_length(PyGObject *self)
{
    int ret;

    
    ret = gtk_entry_buffer_get_max_length(GTK_ENTRY_BUFFER(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_entry_buffer_insert_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", "chars", "n_chars", NULL };
    PyObject *py_position = NULL;
    char *chars;
    int n_chars;
    guint position = 0, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Osi:Gtk.EntryBuffer.insert_text", kwlist, &py_position, &chars, &n_chars))
        return NULL;
    if (py_position) {
        if (PyLong_Check(py_position))
            position = PyLong_AsUnsignedLong(py_position);
        else if (PyInt_Check(py_position))
            position = PyInt_AsLong(py_position);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'position' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_entry_buffer_insert_text(GTK_ENTRY_BUFFER(self->obj), position, chars, n_chars);
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_entry_buffer_delete_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", "n_chars", NULL };
    PyObject *py_position = NULL;
    int n_chars;
    guint position = 0, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:Gtk.EntryBuffer.delete_text", kwlist, &py_position, &n_chars))
        return NULL;
    if (py_position) {
        if (PyLong_Check(py_position))
            position = PyLong_AsUnsignedLong(py_position);
        else if (PyInt_Check(py_position))
            position = PyInt_AsLong(py_position);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'position' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_entry_buffer_delete_text(GTK_ENTRY_BUFFER(self->obj), position, n_chars);
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_entry_buffer_emit_inserted_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", "chars", "n_chars", NULL };
    PyObject *py_position = NULL, *py_n_chars = NULL;
    char *chars;
    guint position = 0, n_chars = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OsO:Gtk.EntryBuffer.emit_inserted_text", kwlist, &py_position, &chars, &py_n_chars))
        return NULL;
    if (py_position) {
        if (PyLong_Check(py_position))
            position = PyLong_AsUnsignedLong(py_position);
        else if (PyInt_Check(py_position))
            position = PyInt_AsLong(py_position);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'position' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_n_chars) {
        if (PyLong_Check(py_n_chars))
            n_chars = PyLong_AsUnsignedLong(py_n_chars);
        else if (PyInt_Check(py_n_chars))
            n_chars = PyInt_AsLong(py_n_chars);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'n_chars' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_entry_buffer_emit_inserted_text(GTK_ENTRY_BUFFER(self->obj), position, chars, n_chars);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_buffer_emit_deleted_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", "n_chars", NULL };
    PyObject *py_position = NULL, *py_n_chars = NULL;
    guint position = 0, n_chars = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.EntryBuffer.emit_deleted_text", kwlist, &py_position, &py_n_chars))
        return NULL;
    if (py_position) {
        if (PyLong_Check(py_position))
            position = PyLong_AsUnsignedLong(py_position);
        else if (PyInt_Check(py_position))
            position = PyInt_AsLong(py_position);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'position' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_n_chars) {
        if (PyLong_Check(py_n_chars))
            n_chars = PyLong_AsUnsignedLong(py_n_chars);
        else if (PyInt_Check(py_n_chars))
            n_chars = PyInt_AsLong(py_n_chars);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'n_chars' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_entry_buffer_emit_deleted_text(GTK_ENTRY_BUFFER(self->obj), position, n_chars);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkEntryBuffer_methods[] = {
    { "get_bytes", (PyCFunction)_wrap_gtk_entry_buffer_get_bytes, METH_NOARGS,
      NULL },
    { "get_length", (PyCFunction)_wrap_gtk_entry_buffer_get_length, METH_NOARGS,
      NULL },
    { "get_text", (PyCFunction)_wrap_gtk_entry_buffer_get_text, METH_NOARGS,
      NULL },
    { "set_text", (PyCFunction)_wrap_gtk_entry_buffer_set_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_max_length", (PyCFunction)_wrap_gtk_entry_buffer_set_max_length, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_max_length", (PyCFunction)_wrap_gtk_entry_buffer_get_max_length, METH_NOARGS,
      NULL },
    { "insert_text", (PyCFunction)_wrap_gtk_entry_buffer_insert_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "delete_text", (PyCFunction)_wrap_gtk_entry_buffer_delete_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "emit_inserted_text", (PyCFunction)_wrap_gtk_entry_buffer_emit_inserted_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "emit_deleted_text", (PyCFunction)_wrap_gtk_entry_buffer_emit_deleted_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkEntryBuffer_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.EntryBuffer",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkEntryBuffer_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_entry_buffer_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkInfoBar ----------- */

 static int
_wrap_gtk_info_bar_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.InfoBar.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.InfoBar object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_info_bar_get_action_area(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_info_bar_get_action_area(GTK_INFO_BAR(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_info_bar_get_content_area(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_info_bar_get_content_area(GTK_INFO_BAR(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_info_bar_add_action_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "child", "response_id", NULL };
    PyGObject *child;
    int response_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.InfoBar.add_action_widget", kwlist, &PyGtkWidget_Type, &child, &response_id))
        return NULL;
    
    gtk_info_bar_add_action_widget(GTK_INFO_BAR(self->obj), GTK_WIDGET(child->obj), response_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_info_bar_add_button(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "button_text", "response_id", NULL };
    char *button_text;
    int response_id;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"si:Gtk.InfoBar.add_button", kwlist, &button_text, &response_id))
        return NULL;
    
    ret = gtk_info_bar_add_button(GTK_INFO_BAR(self->obj), button_text, response_id);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_info_bar_set_response_sensitive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "response_id", "setting", NULL };
    int response_id, setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.InfoBar.set_response_sensitive", kwlist, &response_id, &setting))
        return NULL;
    
    gtk_info_bar_set_response_sensitive(GTK_INFO_BAR(self->obj), response_id, setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_info_bar_set_default_response(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "response_id", NULL };
    int response_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.InfoBar.set_default_response", kwlist, &response_id))
        return NULL;
    
    gtk_info_bar_set_default_response(GTK_INFO_BAR(self->obj), response_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_info_bar_response(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "response_id", NULL };
    int response_id;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.InfoBar.response", kwlist, &response_id))
        return NULL;
    
    gtk_info_bar_response(GTK_INFO_BAR(self->obj), response_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_info_bar_set_message_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "message_type", NULL };
    PyObject *py_message_type = NULL;
    GtkMessageType message_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.InfoBar.set_message_type", kwlist, &py_message_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, py_message_type, (gpointer)&message_type))
        return NULL;
    
    gtk_info_bar_set_message_type(GTK_INFO_BAR(self->obj), message_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_info_bar_get_message_type(PyGObject *self)
{
    gint ret;

    
    ret = gtk_info_bar_get_message_type(GTK_INFO_BAR(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_MESSAGE_TYPE, ret);
}

static const PyMethodDef _PyGtkInfoBar_methods[] = {
    { "get_action_area", (PyCFunction)_wrap_gtk_info_bar_get_action_area, METH_NOARGS,
      NULL },
    { "get_content_area", (PyCFunction)_wrap_gtk_info_bar_get_content_area, METH_NOARGS,
      NULL },
    { "add_action_widget", (PyCFunction)_wrap_gtk_info_bar_add_action_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_button", (PyCFunction)_wrap_gtk_info_bar_add_button, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_response_sensitive", (PyCFunction)_wrap_gtk_info_bar_set_response_sensitive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_default_response", (PyCFunction)_wrap_gtk_info_bar_set_default_response, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "response", (PyCFunction)_wrap_gtk_info_bar_response, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_message_type", (PyCFunction)_wrap_gtk_info_bar_set_message_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_message_type", (PyCFunction)_wrap_gtk_info_bar_get_message_type, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkInfoBar_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.InfoBar",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkInfoBar_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_info_bar_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkHSV ----------- */

static PyObject *
_wrap_gtk_hsv_set_color(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "h", "s", "v", NULL };
    double h, s, v;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ddd:Gtk.HSV.set_color", kwlist, &h, &s, &v))
        return NULL;
    
    gtk_hsv_set_color(GTK_HSV(self->obj), h, s, v);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 8745 "./gtk.override"
static PyObject *
_wrap_gtk_hsv_get_color(PyGObject *self)
{
    gdouble h, s, v;

    gtk_hsv_get_color(GTK_HSV(self->obj), &h, &s, &v);

    return Py_BuildValue("(ddd)", h, s, v);
}
#line 109204 "gtk.c"


static PyObject *
_wrap_gtk_hsv_set_metrics(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "size", "ring_width", NULL };
    int size, ring_width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.HSV.set_metrics", kwlist, &size, &ring_width))
        return NULL;
    
    gtk_hsv_set_metrics(GTK_HSV(self->obj), size, ring_width);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 8756 "./gtk.override"
static PyObject *
_wrap_gtk_hsv_get_metrics(PyGObject *self)
{
    gint size, ring_width;

    gtk_hsv_get_metrics(GTK_HSV(self->obj), &size, &ring_width);

    return Py_BuildValue("(ii)", size, ring_width);
}
#line 109232 "gtk.c"


static PyObject *
_wrap_gtk_hsv_is_adjusting(PyGObject *self)
{
    int ret;

    
    ret = gtk_hsv_is_adjusting(GTK_HSV(self->obj));
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkHSV_methods[] = {
    { "set_color", (PyCFunction)_wrap_gtk_hsv_set_color, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_color", (PyCFunction)_wrap_gtk_hsv_get_color, METH_NOARGS,
      NULL },
    { "set_metrics", (PyCFunction)_wrap_gtk_hsv_set_metrics, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_metrics", (PyCFunction)_wrap_gtk_hsv_get_metrics, METH_NOARGS,
      NULL },
    { "is_adjusting", (PyCFunction)_wrap_gtk_hsv_is_adjusting, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkHSV_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.HSV",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkHSV_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkToolItemGroup ----------- */

static int
_wrap_gtk_tool_item_group_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ToolItemGroup.__init__", kwlist, &label))
        return -1;
    self->obj = (GObject *)gtk_tool_item_group_new(label);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkToolItemGroup object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}

static PyObject *
_wrap_gtk_tool_item_group_set_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.ToolItemGroup.set_label", kwlist, &label))
        return NULL;
    
    gtk_tool_item_group_set_label(GTK_TOOL_ITEM_GROUP(self->obj), label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_group_set_label_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label_widget", NULL };
    PyGObject *label_widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolItemGroup.set_label_widget", kwlist, &PyGtkWidget_Type, &label_widget))
        return NULL;
    
    gtk_tool_item_group_set_label_widget(GTK_TOOL_ITEM_GROUP(self->obj), GTK_WIDGET(label_widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_group_set_collapsed(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "collapsed", NULL };
    int collapsed;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.ToolItemGroup.set_collapsed", kwlist, &collapsed))
        return NULL;
    
    gtk_tool_item_group_set_collapsed(GTK_TOOL_ITEM_GROUP(self->obj), collapsed);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_group_set_ellipsize(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "ellipsize", NULL };
    PyObject *py_ellipsize = NULL;
    PangoEllipsizeMode ellipsize;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ToolItemGroup.set_ellipsize", kwlist, &py_ellipsize))
        return NULL;
    if (pyg_enum_get_value(PANGO_TYPE_ELLIPSIZE_MODE, py_ellipsize, (gpointer)&ellipsize))
        return NULL;
    
    gtk_tool_item_group_set_ellipsize(GTK_TOOL_ITEM_GROUP(self->obj), ellipsize);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_group_set_header_relief(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "style", NULL };
    GtkReliefStyle style;
    PyObject *py_style = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ToolItemGroup.set_header_relief", kwlist, &py_style))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_RELIEF_STYLE, py_style, (gpointer)&style))
        return NULL;
    
    gtk_tool_item_group_set_header_relief(GTK_TOOL_ITEM_GROUP(self->obj), style);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_group_get_label(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_tool_item_group_get_label(GTK_TOOL_ITEM_GROUP(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_group_get_label_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_tool_item_group_get_label_widget(GTK_TOOL_ITEM_GROUP(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tool_item_group_get_collapsed(PyGObject *self)
{
    int ret;

    
    ret = gtk_tool_item_group_get_collapsed(GTK_TOOL_ITEM_GROUP(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tool_item_group_get_ellipsize(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_item_group_get_ellipsize(GTK_TOOL_ITEM_GROUP(self->obj));
    
    return pyg_enum_from_gtype(PANGO_TYPE_ELLIPSIZE_MODE, ret);
}

static PyObject *
_wrap_gtk_tool_item_group_get_header_relief(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_item_group_get_header_relief(GTK_TOOL_ITEM_GROUP(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_RELIEF_STYLE, ret);
}

static PyObject *
_wrap_gtk_tool_item_group_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item", "position", NULL };
    PyGObject *item;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.ToolItemGroup.insert", kwlist, &PyGtkToolItem_Type, &item, &position))
        return NULL;
    
    gtk_tool_item_group_insert(GTK_TOOL_ITEM_GROUP(self->obj), GTK_TOOL_ITEM(item->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_group_set_item_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item", "position", NULL };
    PyGObject *item;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.ToolItemGroup.set_item_position", kwlist, &PyGtkToolItem_Type, &item, &position))
        return NULL;
    
    gtk_tool_item_group_set_item_position(GTK_TOOL_ITEM_GROUP(self->obj), GTK_TOOL_ITEM(item->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_item_group_get_item_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "item", NULL };
    PyGObject *item;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolItemGroup.get_item_position", kwlist, &PyGtkToolItem_Type, &item))
        return NULL;
    
    ret = gtk_tool_item_group_get_item_position(GTK_TOOL_ITEM_GROUP(self->obj), GTK_TOOL_ITEM(item->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tool_item_group_get_n_items(PyGObject *self)
{
    guint ret;

    
    ret = gtk_tool_item_group_get_n_items(GTK_TOOL_ITEM_GROUP(self->obj));
    
    return PyLong_FromUnsignedLong(ret);
}

static PyObject *
_wrap_gtk_tool_item_group_get_nth_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "index", NULL };
    PyObject *py_index = NULL;
    GtkToolItem *ret;
    guint index = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ToolItemGroup.get_nth_item", kwlist, &py_index))
        return NULL;
    if (py_index) {
        if (PyLong_Check(py_index))
            index = PyLong_AsUnsignedLong(py_index);
        else if (PyInt_Check(py_index))
            index = PyInt_AsLong(py_index);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'index' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_tool_item_group_get_nth_item(GTK_TOOL_ITEM_GROUP(self->obj), index);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tool_item_group_get_drop_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    int x, y;
    GtkToolItem *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.ToolItemGroup.get_drop_item", kwlist, &x, &y))
        return NULL;
    
    ret = gtk_tool_item_group_get_drop_item(GTK_TOOL_ITEM_GROUP(self->obj), x, y);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkToolItemGroup_methods[] = {
    { "set_label", (PyCFunction)_wrap_gtk_tool_item_group_set_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_label_widget", (PyCFunction)_wrap_gtk_tool_item_group_set_label_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_collapsed", (PyCFunction)_wrap_gtk_tool_item_group_set_collapsed, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_ellipsize", (PyCFunction)_wrap_gtk_tool_item_group_set_ellipsize, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_header_relief", (PyCFunction)_wrap_gtk_tool_item_group_set_header_relief, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_label", (PyCFunction)_wrap_gtk_tool_item_group_get_label, METH_NOARGS,
      NULL },
    { "get_label_widget", (PyCFunction)_wrap_gtk_tool_item_group_get_label_widget, METH_NOARGS,
      NULL },
    { "get_collapsed", (PyCFunction)_wrap_gtk_tool_item_group_get_collapsed, METH_NOARGS,
      NULL },
    { "get_ellipsize", (PyCFunction)_wrap_gtk_tool_item_group_get_ellipsize, METH_NOARGS,
      NULL },
    { "get_header_relief", (PyCFunction)_wrap_gtk_tool_item_group_get_header_relief, METH_NOARGS,
      NULL },
    { "insert", (PyCFunction)_wrap_gtk_tool_item_group_insert, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_item_position", (PyCFunction)_wrap_gtk_tool_item_group_set_item_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_item_position", (PyCFunction)_wrap_gtk_tool_item_group_get_item_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_n_items", (PyCFunction)_wrap_gtk_tool_item_group_get_n_items, METH_NOARGS,
      NULL },
    { "get_nth_item", (PyCFunction)_wrap_gtk_tool_item_group_get_nth_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_drop_item", (PyCFunction)_wrap_gtk_tool_item_group_get_drop_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkToolItemGroup_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ToolItemGroup",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkToolItemGroup_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tool_item_group_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkToolPalette ----------- */

static int
_wrap_gtk_tool_palette_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.ToolPalette.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.ToolPalette object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_tool_palette_set_group_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group", "position", NULL };
    PyGObject *group;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.ToolPalette.set_group_position", kwlist, &PyGtkToolItemGroup_Type, &group, &position))
        return NULL;
    
    gtk_tool_palette_set_group_position(GTK_TOOL_PALETTE(self->obj), GTK_TOOL_ITEM_GROUP(group->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_palette_set_exclusive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group", "exclusive", NULL };
    PyGObject *group;
    int exclusive;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.ToolPalette.set_exclusive", kwlist, &PyGtkToolItemGroup_Type, &group, &exclusive))
        return NULL;
    
    gtk_tool_palette_set_exclusive(GTK_TOOL_PALETTE(self->obj), GTK_TOOL_ITEM_GROUP(group->obj), exclusive);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_palette_set_expand(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group", "expand", NULL };
    PyGObject *group;
    int expand;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.ToolPalette.set_expand", kwlist, &PyGtkToolItemGroup_Type, &group, &expand))
        return NULL;
    
    gtk_tool_palette_set_expand(GTK_TOOL_PALETTE(self->obj), GTK_TOOL_ITEM_GROUP(group->obj), expand);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_palette_get_group_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group", NULL };
    PyGObject *group;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolPalette.get_group_position", kwlist, &PyGtkToolItemGroup_Type, &group))
        return NULL;
    
    ret = gtk_tool_palette_get_group_position(GTK_TOOL_PALETTE(self->obj), GTK_TOOL_ITEM_GROUP(group->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tool_palette_get_exclusive(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group", NULL };
    PyGObject *group;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolPalette.get_exclusive", kwlist, &PyGtkToolItemGroup_Type, &group))
        return NULL;
    
    ret = gtk_tool_palette_get_exclusive(GTK_TOOL_PALETTE(self->obj), GTK_TOOL_ITEM_GROUP(group->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tool_palette_get_expand(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "group", NULL };
    PyGObject *group;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolPalette.get_expand", kwlist, &PyGtkToolItemGroup_Type, &group))
        return NULL;
    
    ret = gtk_tool_palette_get_expand(GTK_TOOL_PALETTE(self->obj), GTK_TOOL_ITEM_GROUP(group->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tool_palette_set_icon_size(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_size", NULL };
    PyObject *py_icon_size = NULL;
    GtkIconSize icon_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ToolPalette.set_icon_size", kwlist, &py_icon_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_icon_size, (gpointer)&icon_size))
        return NULL;
    
    gtk_tool_palette_set_icon_size(GTK_TOOL_PALETTE(self->obj), icon_size);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_palette_unset_icon_size(PyGObject *self)
{
    
    gtk_tool_palette_unset_icon_size(GTK_TOOL_PALETTE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_palette_set_style(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "style", NULL };
    PyObject *py_style = NULL;
    GtkToolbarStyle style;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ToolPalette.set_style", kwlist, &py_style))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_STYLE, py_style, (gpointer)&style))
        return NULL;
    
    gtk_tool_palette_set_style(GTK_TOOL_PALETTE(self->obj), style);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_palette_unset_style(PyGObject *self)
{
    
    gtk_tool_palette_unset_style(GTK_TOOL_PALETTE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_palette_get_icon_size(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_palette_get_icon_size(GTK_TOOL_PALETTE(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, ret);
}

static PyObject *
_wrap_gtk_tool_palette_get_style(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_palette_get_style(GTK_TOOL_PALETTE(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_TOOLBAR_STYLE, ret);
}

static PyObject *
_wrap_gtk_tool_palette_get_drop_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    int x, y;
    GtkToolItem *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.ToolPalette.get_drop_item", kwlist, &x, &y))
        return NULL;
    
    ret = gtk_tool_palette_get_drop_item(GTK_TOOL_PALETTE(self->obj), x, y);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tool_palette_get_drop_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    int x, y;
    GtkToolItemGroup *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.ToolPalette.get_drop_group", kwlist, &x, &y))
        return NULL;
    
    ret = gtk_tool_palette_get_drop_group(GTK_TOOL_PALETTE(self->obj), x, y);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tool_palette_get_drag_item(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "selection", NULL };
    PyObject *py_selection;
    GtkSelectionData *selection = NULL;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ToolPalette.get_drag_item", kwlist, &py_selection))
        return NULL;
    if (pyg_boxed_check(py_selection, GTK_TYPE_SELECTION_DATA))
        selection = pyg_boxed_get(py_selection, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection should be a GtkSelectionData");
        return NULL;
    }
    
    ret = gtk_tool_palette_get_drag_item(GTK_TOOL_PALETTE(self->obj), selection);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tool_palette_set_drag_source(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    PyObject *py_targets = NULL;
    GtkToolPaletteDragTargets targets;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.ToolPalette.set_drag_source", kwlist, &py_targets))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_TOOL_PALETTE_DRAG_TARGETS, py_targets, (gpointer)&targets))
        return NULL;
    
    gtk_tool_palette_set_drag_source(GTK_TOOL_PALETTE(self->obj), targets);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_palette_add_drag_dest(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "flags", "targets", "actions", NULL };
    PyGObject *widget;
    PyObject *py_flags = NULL, *py_targets = NULL, *py_actions = NULL;
    GtkToolPaletteDragTargets targets;
    GtkDestDefaults flags;
    GdkDragAction actions;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOO:Gtk.ToolPalette.add_drag_dest", kwlist, &PyGtkWidget_Type, &widget, &py_flags, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, py_flags, (gpointer)&flags))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_TOOL_PALETTE_DRAG_TARGETS, py_targets, (gpointer)&targets))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION, py_actions, (gpointer)&actions))
        return NULL;
    
    gtk_tool_palette_add_drag_dest(GTK_TOOL_PALETTE(self->obj), GTK_WIDGET(widget->obj), flags, targets, actions);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_palette_get_hadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_tool_palette_get_hadjustment(GTK_TOOL_PALETTE(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tool_palette_get_vadjustment(PyGObject *self)
{
    GtkAdjustment *ret;

    
    ret = gtk_tool_palette_get_vadjustment(GTK_TOOL_PALETTE(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkToolPalette_methods[] = {
    { "set_group_position", (PyCFunction)_wrap_gtk_tool_palette_set_group_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_exclusive", (PyCFunction)_wrap_gtk_tool_palette_set_exclusive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_expand", (PyCFunction)_wrap_gtk_tool_palette_set_expand, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_group_position", (PyCFunction)_wrap_gtk_tool_palette_get_group_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_exclusive", (PyCFunction)_wrap_gtk_tool_palette_get_exclusive, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_expand", (PyCFunction)_wrap_gtk_tool_palette_get_expand, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_icon_size", (PyCFunction)_wrap_gtk_tool_palette_set_icon_size, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unset_icon_size", (PyCFunction)_wrap_gtk_tool_palette_unset_icon_size, METH_NOARGS,
      NULL },
    { "set_style", (PyCFunction)_wrap_gtk_tool_palette_set_style, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unset_style", (PyCFunction)_wrap_gtk_tool_palette_unset_style, METH_NOARGS,
      NULL },
    { "get_icon_size", (PyCFunction)_wrap_gtk_tool_palette_get_icon_size, METH_NOARGS,
      NULL },
    { "get_style", (PyCFunction)_wrap_gtk_tool_palette_get_style, METH_NOARGS,
      NULL },
    { "get_drop_item", (PyCFunction)_wrap_gtk_tool_palette_get_drop_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_drop_group", (PyCFunction)_wrap_gtk_tool_palette_get_drop_group, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_drag_item", (PyCFunction)_wrap_gtk_tool_palette_get_drag_item, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_drag_source", (PyCFunction)_wrap_gtk_tool_palette_set_drag_source, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_drag_dest", (PyCFunction)_wrap_gtk_tool_palette_add_drag_dest, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_hadjustment", (PyCFunction)_wrap_gtk_tool_palette_get_hadjustment, METH_NOARGS,
      NULL },
    { "get_vadjustment", (PyCFunction)_wrap_gtk_tool_palette_get_vadjustment, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkToolPalette_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ToolPalette",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkToolPalette_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_tool_palette_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkCellRendererSpinner ----------- */

static int
_wrap_gtk_cell_renderer_spinner_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.CellRendererSpinner.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.CellRendererSpinner object");
        return -1;
    }
    return 0;
}

PyTypeObject G_GNUC_INTERNAL PyGtkCellRendererSpinner_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellRendererSpinner",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_cell_renderer_spinner_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkOffscreenWindow ----------- */

static int
_wrap_gtk_offscreen_window_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.OffscreenWindow.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.OffscreenWindow object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_offscreen_window_get_pixmap(PyGObject *self)
{
    GdkPixmap *ret;

    
    ret = gtk_offscreen_window_get_pixmap(GTK_OFFSCREEN_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_offscreen_window_get_pixbuf(PyGObject *self)
{
    GdkPixbuf *ret;

    
    ret = gtk_offscreen_window_get_pixbuf(GTK_OFFSCREEN_WINDOW(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkOffscreenWindow_methods[] = {
    { "get_pixmap", (PyCFunction)_wrap_gtk_offscreen_window_get_pixmap, METH_NOARGS,
      NULL },
    { "get_pixbuf", (PyCFunction)_wrap_gtk_offscreen_window_get_pixbuf, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkOffscreenWindow_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.OffscreenWindow",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkOffscreenWindow_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_offscreen_window_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkSpinner ----------- */

static int
_wrap_gtk_spinner_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char* kwlist[] = { NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     ":gtk.Spinner.__init__",
                                     kwlist))
        return -1;

    pygobject_constructv(self, 0, NULL);
    if (!self->obj) {
        PyErr_SetString(
            PyExc_RuntimeError, 
            "could not create gtk.Spinner object");
        return -1;
    }
    return 0;
}

static PyObject *
_wrap_gtk_spinner_start(PyGObject *self)
{
    
    gtk_spinner_start(GTK_SPINNER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_spinner_stop(PyGObject *self)
{
    
    gtk_spinner_stop(GTK_SPINNER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkSpinner_methods[] = {
    { "start", (PyCFunction)_wrap_gtk_spinner_start, METH_NOARGS,
      NULL },
    { "stop", (PyCFunction)_wrap_gtk_spinner_stop, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkSpinner_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Spinner",                   /* tp_name */
    sizeof(PyGObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    offsetof(PyGObject, weakreflist),             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkSpinner_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    offsetof(PyGObject, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_gtk_spinner_new,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkCellEditable ----------- */

static PyObject *
_wrap_gtk_cell_editable_start_editing(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", NULL };
    GdkEvent *event = NULL;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.CellEditable.start_editing", kwlist, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    gtk_cell_editable_start_editing(GTK_CELL_EDITABLE(self->obj), event);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_editable_editing_done(PyGObject *self)
{
    
    gtk_cell_editable_editing_done(GTK_CELL_EDITABLE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_editable_remove_widget(PyGObject *self)
{
    
    gtk_cell_editable_remove_widget(GTK_CELL_EDITABLE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellEditable__do_editing_done(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkCellEditableIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CellEditable.editing_done", kwlist, &PyGtkCellEditable_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_CELL_EDITABLE);
    if (iface->editing_done)
        iface->editing_done(GTK_CELL_EDITABLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.CellEditable.editing_done not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellEditable__do_remove_widget(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkCellEditableIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CellEditable.remove_widget", kwlist, &PyGtkCellEditable_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_CELL_EDITABLE);
    if (iface->remove_widget)
        iface->remove_widget(GTK_CELL_EDITABLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.CellEditable.remove_widget not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellEditable__do_start_editing(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkCellEditableIface *iface;
    static char *kwlist[] = { "self", "event", NULL };
    PyGObject *self;
    GdkEvent *event = NULL;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.CellEditable.start_editing", kwlist, &PyGtkCellEditable_Type, &self, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_CELL_EDITABLE);
    if (iface->start_editing)
        iface->start_editing(GTK_CELL_EDITABLE(self->obj), event);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.CellEditable.start_editing not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCellEditable_methods[] = {
    { "start_editing", (PyCFunction)_wrap_gtk_cell_editable_start_editing, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "editing_done", (PyCFunction)_wrap_gtk_cell_editable_editing_done, METH_NOARGS,
      NULL },
    { "remove_widget", (PyCFunction)_wrap_gtk_cell_editable_remove_widget, METH_NOARGS,
      NULL },
    { "do_editing_done", (PyCFunction)_wrap_GtkCellEditable__do_editing_done, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_remove_widget", (PyCFunction)_wrap_GtkCellEditable__do_remove_widget, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_start_editing", (PyCFunction)_wrap_GtkCellEditable__do_start_editing, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkCellEditable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellEditable",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCellEditable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCellEditable__proxy_do_editing_done(GtkCellEditable *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_editing_done");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCellEditable__proxy_do_remove_widget(GtkCellEditable *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_remove_widget");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCellEditable__proxy_do_start_editing(GtkCellEditable *self, GdkEvent*event)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_event;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_event = pyg_boxed_new(GDK_TYPE_EVENT, event, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_event);
    
    py_method = PyObject_GetAttrString(py_self, "do_start_editing");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static void
__GtkCellEditable__interface_init(GtkCellEditableIface *iface, PyTypeObject *pytype)
{
    GtkCellEditableIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_editing_done") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->editing_done = _wrap_GtkCellEditable__proxy_do_editing_done;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->editing_done = parent_iface->editing_done;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_remove_widget") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->remove_widget = _wrap_GtkCellEditable__proxy_do_remove_widget;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->remove_widget = parent_iface->remove_widget;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_start_editing") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->start_editing = _wrap_GtkCellEditable__proxy_do_start_editing;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->start_editing = parent_iface->start_editing;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkCellEditable__iinfo = {
    (GInterfaceInitFunc) __GtkCellEditable__interface_init,
    NULL,
    NULL
};


/* ----------- GtkCellLayout ----------- */

static PyObject *
_wrap_gtk_cell_layout_pack_start(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cell", "expand", NULL };
    PyGObject *cell;
    int expand = TRUE;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|i:Gtk.CellLayout.pack_start", kwlist, &PyGtkCellRenderer_Type, &cell, &expand))
        return NULL;
    
    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(self->obj), GTK_CELL_RENDERER(cell->obj), expand);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_layout_pack_end(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cell", "expand", NULL };
    PyGObject *cell;
    int expand = TRUE;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|i:Gtk.CellLayout.pack_end", kwlist, &PyGtkCellRenderer_Type, &cell, &expand))
        return NULL;
    
    gtk_cell_layout_pack_end(GTK_CELL_LAYOUT(self->obj), GTK_CELL_RENDERER(cell->obj), expand);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_layout_clear(PyGObject *self)
{
    
    gtk_cell_layout_clear(GTK_CELL_LAYOUT(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4446 "./gtk.override"
static PyObject *
_wrap_gtk_cell_layout_set_attributes(PyGObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    PyObject *py_cell, *key, *item;
    GtkCellRenderer *cell;
    Py_ssize_t i = 0;

    if (!PyArg_ParseTuple(args, "O!:GtkCellLayout.set_attributes",
                          &PyGtkCellRenderer_Type, &py_cell))
        return NULL;
    cell = GTK_CELL_RENDERER(pygobject_get(py_cell));
    gtk_cell_layout_clear_attributes(GTK_CELL_LAYOUT(self->obj), cell);
    if (kwargs) {
        while (PyDict_Next(kwargs, &i, &key, &item)) {
            gchar *attr = PyString_AsString(key);

            if (!PyInt_Check(item)) {
                gchar err[128];
                g_snprintf(err, sizeof(err),
                           "%s must be an integer column number", attr);
                PyErr_SetString(PyExc_TypeError, err);
                return NULL;
            }
            gtk_cell_layout_add_attribute(GTK_CELL_LAYOUT(self->obj),
					  cell, attr, PyInt_AsLong(item));
        }
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 110787 "gtk.c"


static PyObject *
_wrap_gtk_cell_layout_add_attribute(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cell", "attribute", "column", NULL };
    PyGObject *cell;
    char *attribute;
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!si:Gtk.CellLayout.add_attribute", kwlist, &PyGtkCellRenderer_Type, &cell, &attribute, &column))
        return NULL;
    
    gtk_cell_layout_add_attribute(GTK_CELL_LAYOUT(self->obj), GTK_CELL_RENDERER(cell->obj), attribute, column);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 184 "gtktreeview.override"
static void
pygtk_cell_data_func_marshal (GtkCellLayout *cell_layout,
                              GtkCellRenderer *cell,
                              GtkTreeModel *tree_model,
                              GtkTreeIter *iter, gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *retobj;
    PyObject *pycelllayout, *pycell, *pytreemodel, *pyiter;

    g_assert (cunote->func);

    state = pyg_gil_state_ensure();

    pycelllayout = pygobject_new((GObject *)cell_layout);
    pycell = pygobject_new((GObject *)cell);
    pytreemodel = pygobject_new((GObject *)tree_model);
    pyiter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter,
                           FALSE, FALSE);
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NNNNO)",
                                     pycelllayout, pycell,
                                     pytreemodel, pyiter, cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(NNNN)",
                                     pycelllayout, pycell,
                                     pytreemodel, pyiter);

    if (retobj == NULL) {
        PyErr_Print();
    } else
        Py_DECREF(retobj);

    pyg_gil_state_release(state);
}

static PyObject *
_wrap_gtk_cell_layout_set_cell_data_func (PyGObject *self, PyObject *args,
                                               PyObject *kwargs)
{
    PyObject *pycell, *pyfunc, *pyarg = NULL;
    GtkCellRenderer *cell;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTuple(args, "OO|O:GtkCellLayout.set_cell_data_func",
                          &pycell, &pyfunc, &pyarg))
        return NULL;

    if (pygobject_check(pycell, &PyGtkCellRenderer_Type))
        cell = GTK_CELL_RENDERER(pygobject_get(pycell));
    else {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkCellRenderer");
        return NULL;
    }

    if (pyfunc == Py_None) {
	gtk_cell_layout_set_cell_data_func(GTK_CELL_LAYOUT(self->obj), cell,
                                           NULL, NULL, NULL);
    } else {
	cunote = g_new0(PyGtkCustomNotify, 1);
	cunote->func = pyfunc;
	cunote->data = pyarg;
	Py_INCREF(cunote->func);
	Py_XINCREF(cunote->data);

	gtk_cell_layout_set_cell_data_func(GTK_CELL_LAYOUT(self->obj), cell,
                                           pygtk_cell_data_func_marshal,
                                           cunote,
                                           pygtk_custom_destroy_notify);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 110884 "gtk.c"


static PyObject *
_wrap_gtk_cell_layout_clear_attributes(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cell", NULL };
    PyGObject *cell;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CellLayout.clear_attributes", kwlist, &PyGtkCellRenderer_Type, &cell))
        return NULL;
    
    gtk_cell_layout_clear_attributes(GTK_CELL_LAYOUT(self->obj), GTK_CELL_RENDERER(cell->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_cell_layout_reorder(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cell", "position", NULL };
    PyGObject *cell;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.CellLayout.reorder", kwlist, &PyGtkCellRenderer_Type, &cell, &position))
        return NULL;
    
    gtk_cell_layout_reorder(GTK_CELL_LAYOUT(self->obj), GTK_CELL_RENDERER(cell->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 8581 "./gtk.override"
static PyObject *
_wrap_gtk_cell_layout_get_cells(PyGObject *self)
{
    PyObject    *py_cells;
    GList       *cells, *l;
    
    py_cells = PyList_New(0);
    
    cells = gtk_cell_layout_get_cells(GTK_CELL_LAYOUT(self->obj));

    for (l = cells; l; l = l->next)
    {
        PyObject *item = pygobject_new((GObject *)l->data);
        PyList_Append(py_cells, item);
        Py_DECREF(item);
    }
    g_list_free(cells);

    return py_cells;
}
#line 110939 "gtk.c"


static PyObject *
_wrap_GtkCellLayout__do_pack_start(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkCellLayoutIface *iface;
    static char *kwlist[] = { "self", "cell", "expand", NULL };
    PyGObject *self, *cell;
    int expand;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!i:Gtk.CellLayout.pack_start", kwlist, &PyGtkCellLayout_Type, &self, &PyGtkCellRenderer_Type, &cell, &expand))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_CELL_LAYOUT);
    if (iface->pack_start)
        iface->pack_start(GTK_CELL_LAYOUT(self->obj), GTK_CELL_RENDERER(cell->obj), expand);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.CellLayout.pack_start not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellLayout__do_pack_end(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkCellLayoutIface *iface;
    static char *kwlist[] = { "self", "cell", "expand", NULL };
    PyGObject *self, *cell;
    int expand;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!i:Gtk.CellLayout.pack_end", kwlist, &PyGtkCellLayout_Type, &self, &PyGtkCellRenderer_Type, &cell, &expand))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_CELL_LAYOUT);
    if (iface->pack_end)
        iface->pack_end(GTK_CELL_LAYOUT(self->obj), GTK_CELL_RENDERER(cell->obj), expand);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.CellLayout.pack_end not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellLayout__do_clear(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkCellLayoutIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.CellLayout.clear", kwlist, &PyGtkCellLayout_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_CELL_LAYOUT);
    if (iface->clear)
        iface->clear(GTK_CELL_LAYOUT(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.CellLayout.clear not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellLayout__do_add_attribute(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkCellLayoutIface *iface;
    static char *kwlist[] = { "self", "cell", "attribute", "column", NULL };
    PyGObject *self, *cell;
    char *attribute;
    int column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!si:Gtk.CellLayout.add_attribute", kwlist, &PyGtkCellLayout_Type, &self, &PyGtkCellRenderer_Type, &cell, &attribute, &column))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_CELL_LAYOUT);
    if (iface->add_attribute)
        iface->add_attribute(GTK_CELL_LAYOUT(self->obj), GTK_CELL_RENDERER(cell->obj), attribute, column);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.CellLayout.add_attribute not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellLayout__do_clear_attributes(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkCellLayoutIface *iface;
    static char *kwlist[] = { "self", "cell", NULL };
    PyGObject *self, *cell;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.CellLayout.clear_attributes", kwlist, &PyGtkCellLayout_Type, &self, &PyGtkCellRenderer_Type, &cell))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_CELL_LAYOUT);
    if (iface->clear_attributes)
        iface->clear_attributes(GTK_CELL_LAYOUT(self->obj), GTK_CELL_RENDERER(cell->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.CellLayout.clear_attributes not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkCellLayout__do_reorder(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkCellLayoutIface *iface;
    static char *kwlist[] = { "self", "cell", "position", NULL };
    PyGObject *self, *cell;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!i:Gtk.CellLayout.reorder", kwlist, &PyGtkCellLayout_Type, &self, &PyGtkCellRenderer_Type, &cell, &position))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_CELL_LAYOUT);
    if (iface->reorder)
        iface->reorder(GTK_CELL_LAYOUT(self->obj), GTK_CELL_RENDERER(cell->obj), position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.CellLayout.reorder not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkCellLayout_methods[] = {
    { "pack_start", (PyCFunction)_wrap_gtk_cell_layout_pack_start, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "pack_end", (PyCFunction)_wrap_gtk_cell_layout_pack_end, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "clear", (PyCFunction)_wrap_gtk_cell_layout_clear, METH_NOARGS,
      NULL },
    { "set_attributes", (PyCFunction)_wrap_gtk_cell_layout_set_attributes, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "add_attribute", (PyCFunction)_wrap_gtk_cell_layout_add_attribute, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_cell_data_func", (PyCFunction)_wrap_gtk_cell_layout_set_cell_data_func, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "clear_attributes", (PyCFunction)_wrap_gtk_cell_layout_clear_attributes, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "reorder", (PyCFunction)_wrap_gtk_cell_layout_reorder, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_cells", (PyCFunction)_wrap_gtk_cell_layout_get_cells, METH_NOARGS,
      NULL },
    { "do_pack_start", (PyCFunction)_wrap_GtkCellLayout__do_pack_start, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_pack_end", (PyCFunction)_wrap_GtkCellLayout__do_pack_end, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_clear", (PyCFunction)_wrap_GtkCellLayout__do_clear, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_add_attribute", (PyCFunction)_wrap_GtkCellLayout__do_add_attribute, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_clear_attributes", (PyCFunction)_wrap_GtkCellLayout__do_clear_attributes, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_reorder", (PyCFunction)_wrap_GtkCellLayout__do_reorder, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkCellLayout_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.CellLayout",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkCellLayout_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkCellLayout__proxy_do_pack_start(GtkCellLayout *self, GtkCellRenderer*cell, gboolean expand)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_cell = NULL;
    PyObject *py_expand;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (cell)
        py_cell = pygobject_new((GObject *) cell);
    else {
        Py_INCREF(Py_None);
        py_cell = Py_None;
    }
    py_expand = expand? Py_True : Py_False;
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_cell);
    Py_INCREF(py_expand);
    PyTuple_SET_ITEM(py_args, 1, py_expand);
    
    py_method = PyObject_GetAttrString(py_self, "do_pack_start");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCellLayout__proxy_do_pack_end(GtkCellLayout *self, GtkCellRenderer*cell, gboolean expand)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_cell = NULL;
    PyObject *py_expand;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (cell)
        py_cell = pygobject_new((GObject *) cell);
    else {
        Py_INCREF(Py_None);
        py_cell = Py_None;
    }
    py_expand = expand? Py_True : Py_False;
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_cell);
    Py_INCREF(py_expand);
    PyTuple_SET_ITEM(py_args, 1, py_expand);
    
    py_method = PyObject_GetAttrString(py_self, "do_pack_end");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCellLayout__proxy_do_clear(GtkCellLayout *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_clear");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCellLayout__proxy_do_add_attribute(GtkCellLayout *self, GtkCellRenderer*cell, const gchar*attribute, gint column)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_cell = NULL;
    PyObject *py_attribute = NULL;
    PyObject *py_column;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (cell)
        py_cell = pygobject_new((GObject *) cell);
    else {
        Py_INCREF(Py_None);
        py_cell = Py_None;
    }
    if (attribute)
        py_attribute = PyString_FromString(attribute);
    if (!py_attribute) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_cell);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_column = PyInt_FromLong(column);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_cell);
    PyTuple_SET_ITEM(py_args, 1, py_attribute);
    PyTuple_SET_ITEM(py_args, 2, py_column);
    
    py_method = PyObject_GetAttrString(py_self, "do_add_attribute");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
#line 6660 "./gtk.override"

typedef struct {
    GtkCellLayoutDataFunc  func;
    gpointer               func_data;
    GDestroyNotify         destroy;
} PyGtkCellLayoutDataFuncData;

static void
_wrap_GtkCellLayoutDataFunc_destroy(void *arg)
{
    PyGtkCellLayoutDataFuncData *data = arg;
    data->destroy(data->func_data);
    g_free(data);
}

static PyObject *
_wrap_GtkCellLayoutDataFunc(PyObject *self, PyObject *args)
{
    PyObject *py_cell_layout;
    PyObject *py_cell;
    PyObject *py_tree_model;
    PyObject *py_iter;
    PyObject *py_data;
    PyGtkCellLayoutDataFuncData *data;

    if (!PyArg_ParseTuple(args, "O!O!O!OO!",
                          &PyGtkCellLayout_Type, &py_cell_layout,
                          &PyGtkCellRenderer_Type, &py_cell,
                          &PyGtkTreeModel_Type, &py_tree_model,
                          &py_iter,
                          &PyCObject_Type, &py_data))
        return NULL;
    if (!pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER)) {
        PyErr_SetString(PyExc_TypeError, "4th argument must be a gtk.TreeIter");
        return NULL;
    }

    data = PyCObject_AsVoidPtr(py_data);
    data->func(GTK_CELL_LAYOUT(pygobject_get(py_cell_layout)),
               GTK_CELL_RENDERER(pygobject_get(py_cell)),
               GTK_TREE_MODEL(pygobject_get(py_tree_model)),
               pyg_boxed_get(py_iter, GtkTreeIter),
               data->func_data);
    Py_INCREF(Py_None);
    return Py_None;
}

static void
_wrap_GtkCellLayout__proxy_do_set_cell_data_func (
    GtkCellLayout         *cell_layout,
    GtkCellRenderer       *cell,
    GtkCellLayoutDataFunc  func,
    gpointer               func_data,
    GDestroyNotify         destroy)
{
    PyGILState_STATE state;
    PyObject *self, *py_ret, *py_cell, *py_func, *py_func_data;
    PyMethodDef pyfunc_def = { NULL, (PyCFunction)_wrap_GtkCellLayoutDataFunc,
                               METH_VARARGS|METH_KEYWORDS };
    PyGtkCellLayoutDataFuncData *data;

    state = pyg_gil_state_ensure();
    self = pygobject_new((GObject *)cell);
    py_cell = pygobject_new((GObject *)cell);
    py_func = PyCFunction_NewEx(&pyfunc_def, NULL, NULL);
    data = g_new(PyGtkCellLayoutDataFuncData, 1);
    data->func = func;
    data->func_data = func_data;
    data->destroy = destroy;
    py_func_data = PyCObject_FromVoidPtr(data, _wrap_GtkCellLayoutDataFunc_destroy);

    py_ret = PyObject_CallMethod(self, "do_set_cell_data_func", "NNNN",
                                 self, py_cell, py_func, py_func_data);
    if (!py_ret)
	PyErr_Print();
    Py_DECREF(self);
    Py_XDECREF(py_ret);
    pyg_gil_state_release(state);
}
#line 111499 "gtk.c"


static void
_wrap_GtkCellLayout__proxy_do_clear_attributes(GtkCellLayout *self, GtkCellRenderer*cell)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_cell = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (cell)
        py_cell = pygobject_new((GObject *) cell);
    else {
        Py_INCREF(Py_None);
        py_cell = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_cell);
    
    py_method = PyObject_GetAttrString(py_self, "do_clear_attributes");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkCellLayout__proxy_do_reorder(GtkCellLayout *self, GtkCellRenderer*cell, gint position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_cell = NULL;
    PyObject *py_position;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (cell)
        py_cell = pygobject_new((GObject *) cell);
    else {
        Py_INCREF(Py_None);
        py_cell = Py_None;
    }
    py_position = PyInt_FromLong(position);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_cell);
    PyTuple_SET_ITEM(py_args, 1, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_reorder");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static void
__GtkCellLayout__interface_init(GtkCellLayoutIface *iface, PyTypeObject *pytype)
{
    GtkCellLayoutIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_pack_start") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->pack_start = _wrap_GtkCellLayout__proxy_do_pack_start;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->pack_start = parent_iface->pack_start;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_pack_end") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->pack_end = _wrap_GtkCellLayout__proxy_do_pack_end;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->pack_end = parent_iface->pack_end;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_clear") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->clear = _wrap_GtkCellLayout__proxy_do_clear;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->clear = parent_iface->clear;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_add_attribute") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->add_attribute = _wrap_GtkCellLayout__proxy_do_add_attribute;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->add_attribute = parent_iface->add_attribute;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_set_cell_data_func") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->set_cell_data_func = _wrap_GtkCellLayout__proxy_do_set_cell_data_func;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->set_cell_data_func = parent_iface->set_cell_data_func;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_clear_attributes") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->clear_attributes = _wrap_GtkCellLayout__proxy_do_clear_attributes;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->clear_attributes = parent_iface->clear_attributes;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_reorder") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->reorder = _wrap_GtkCellLayout__proxy_do_reorder;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->reorder = parent_iface->reorder;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkCellLayout__iinfo = {
    (GInterfaceInitFunc) __GtkCellLayout__interface_init,
    NULL,
    NULL
};


/* ----------- GtkEditable ----------- */

static PyObject *
_wrap_gtk_editable_select_region(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start", "end", NULL };
    int start, end;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Editable.select_region", kwlist, &start, &end))
        return NULL;
    
    gtk_editable_select_region(GTK_EDITABLE(self->obj), start, end);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1397 "./gtk.override"
static PyObject *
_wrap_gtk_editable_get_selection_bounds(PyGObject *self, PyObject *args)
{
    int start, end;

    if (!gtk_editable_get_selection_bounds(GTK_EDITABLE(self->obj), &start, &end)) {
            return Py_BuildValue ("()");
    }

    return Py_BuildValue ("(ii)", start, end);
}
#line 111753 "gtk.c"


#line 1379 "./gtk.override"
static PyObject *
_wrap_gtk_editable_insert_text(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "text", "position", NULL };
    char *text;
    Py_ssize_t len;
    int position=0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s#|i:GtkEditable.insert_text",
                                     kwlist, &text, &len, &position))
        return NULL;
    gtk_editable_insert_text(GTK_EDITABLE(self->obj), text, len, &position);
    return PyInt_FromLong(position);
}
#line 111773 "gtk.c"


static PyObject *
_wrap_gtk_editable_delete_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_pos", "end_pos", NULL };
    int start_pos, end_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Editable.delete_text", kwlist, &start_pos, &end_pos))
        return NULL;
    
    gtk_editable_delete_text(GTK_EDITABLE(self->obj), start_pos, end_pos);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_editable_get_chars(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_pos", "end_pos", NULL };
    int start_pos, end_pos;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ii:Gtk.Editable.get_chars", kwlist, &start_pos, &end_pos))
        return NULL;
    
    ret = gtk_editable_get_chars(GTK_EDITABLE(self->obj), start_pos, end_pos);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_editable_cut_clipboard(PyGObject *self)
{
    
    gtk_editable_cut_clipboard(GTK_EDITABLE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_editable_copy_clipboard(PyGObject *self)
{
    
    gtk_editable_copy_clipboard(GTK_EDITABLE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_editable_paste_clipboard(PyGObject *self)
{
    
    gtk_editable_paste_clipboard(GTK_EDITABLE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_editable_delete_selection(PyGObject *self)
{
    
    gtk_editable_delete_selection(GTK_EDITABLE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_editable_set_position(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Editable.set_position", kwlist, &position))
        return NULL;
    
    gtk_editable_set_position(GTK_EDITABLE(self->obj), position);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_editable_get_position(PyGObject *self)
{
    int ret;

    
    ret = gtk_editable_get_position(GTK_EDITABLE(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_editable_set_editable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "is_editable", NULL };
    int is_editable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Editable.set_editable", kwlist, &is_editable))
        return NULL;
    
    gtk_editable_set_editable(GTK_EDITABLE(self->obj), is_editable);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_editable_get_editable(PyGObject *self)
{
    int ret;

    
    ret = gtk_editable_get_editable(GTK_EDITABLE(self->obj));
    
    return PyBool_FromLong(ret);

}

#line 8235 "./gtk.override"
static PyObject *
_wrap_GtkEditable__do_insert_text(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "text", "position", NULL };
    PyGObject *self;
    Py_ssize_t text_len;
    int position;
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s#i:GtkEditable.do_insert_text", kwlist,
                                     &PyGtkEditable_Type, &self,
                                     &text, &text_len, &position))
        return NULL;


    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_EDITABLE_CLASS(klass)->insert_text)
        GTK_EDITABLE_CLASS(klass)->insert_text(GTK_EDITABLE(self->obj),
                                               text, text_len, &position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkEditable.do_insert_text not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    
    return PyInt_FromLong(position);
}

#line 111936 "gtk.c"


static PyObject *
_wrap_GtkEditable__do_delete_text(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkEditableClass *iface;
    static char *kwlist[] = { "self", "start_pos", "end_pos", NULL };
    PyGObject *self;
    int start_pos, end_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.Editable.delete_text", kwlist, &PyGtkEditable_Type, &self, &start_pos, &end_pos))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_EDITABLE);
    if (iface->delete_text)
        iface->delete_text(GTK_EDITABLE(self->obj), start_pos, end_pos);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Editable.delete_text not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEditable__do_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkEditableClass *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Editable.changed", kwlist, &PyGtkEditable_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_EDITABLE);
    if (iface->changed)
        iface->changed(GTK_EDITABLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Editable.changed not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 8267 "./gtk.override"
static PyObject *
_wrap_GtkEditable__do_do_insert_text(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", "text", "position", NULL };
    PyGObject *self;
    Py_ssize_t text_len;
    int position;
    char *text;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s#i:GtkEditable.do_do_insert_text", kwlist,
                                     &PyGtkEditable_Type, &self,
                                     &text, &text_len, &position))
        return NULL;


    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_EDITABLE_CLASS(klass)->do_insert_text)
        GTK_EDITABLE_CLASS(klass)->do_insert_text(GTK_EDITABLE(self->obj),
                                                  text, text_len, &position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkEditable.do_do_insert_text not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    
    return PyInt_FromLong(position);
}

#line 112011 "gtk.c"


static PyObject *
_wrap_GtkEditable__do_do_delete_text(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkEditableClass *iface;
    static char *kwlist[] = { "self", "start_pos", "end_pos", NULL };
    PyGObject *self;
    int start_pos, end_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.Editable.do_delete_text", kwlist, &PyGtkEditable_Type, &self, &start_pos, &end_pos))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_EDITABLE);
    if (iface->do_delete_text)
        iface->do_delete_text(GTK_EDITABLE(self->obj), start_pos, end_pos);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Editable.do_delete_text not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEditable__do_get_chars(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkEditableClass *iface;
    static char *kwlist[] = { "self", "start_pos", "end_pos", NULL };
    PyGObject *self;
    int start_pos, end_pos;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.Editable.get_chars", kwlist, &PyGtkEditable_Type, &self, &start_pos, &end_pos))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_EDITABLE);
    if (iface->get_chars)
        ret = iface->get_chars(GTK_EDITABLE(self->obj), start_pos, end_pos);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Editable.get_chars not implemented");
        return NULL;
    }
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEditable__do_set_selection_bounds(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkEditableClass *iface;
    static char *kwlist[] = { "self", "start_pos", "end_pos", NULL };
    PyGObject *self;
    int start_pos, end_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!ii:Gtk.Editable.set_selection_bounds", kwlist, &PyGtkEditable_Type, &self, &start_pos, &end_pos))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_EDITABLE);
    if (iface->set_selection_bounds)
        iface->set_selection_bounds(GTK_EDITABLE(self->obj), start_pos, end_pos);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Editable.set_selection_bounds not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 8299 "./gtk.override"
static PyObject *
_wrap_GtkEditable__do_get_selection_bounds(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int start_pos, end_pos;;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:GtkEditable.do_get_selection_bounds", kwlist,
                                     &PyGtkEditable_Type, &self))
        return NULL;

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (GTK_EDITABLE_CLASS(klass)->get_selection_bounds)
        GTK_EDITABLE_CLASS(klass)->get_selection_bounds(GTK_EDITABLE(self->obj),
                                                        &start_pos, &end_pos);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "virtual method GtkEditable.do_get_selection_bounds not implemented");
        g_type_class_unref(klass);
        return NULL;
    }
    g_type_class_unref(klass);
    
    return Py_BuildValue("ii", start_pos, end_pos);
}

#line 112110 "gtk.c"


static PyObject *
_wrap_GtkEditable__do_set_position(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkEditableClass *iface;
    static char *kwlist[] = { "self", "position", NULL };
    PyGObject *self;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.Editable.set_position", kwlist, &PyGtkEditable_Type, &self, &position))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_EDITABLE);
    if (iface->set_position)
        iface->set_position(GTK_EDITABLE(self->obj), position);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Editable.set_position not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkEditable__do_get_position(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkEditableClass *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Editable.get_position", kwlist, &PyGtkEditable_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_EDITABLE);
    if (iface->get_position)
        ret = iface->get_position(GTK_EDITABLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Editable.get_position not implemented");
        return NULL;
    }
    return PyInt_FromLong(ret);
}

static const PyMethodDef _PyGtkEditable_methods[] = {
    { "select_region", (PyCFunction)_wrap_gtk_editable_select_region, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_selection_bounds", (PyCFunction)_wrap_gtk_editable_get_selection_bounds, METH_NOARGS,
      NULL },
    { "insert_text", (PyCFunction)_wrap_gtk_editable_insert_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "delete_text", (PyCFunction)_wrap_gtk_editable_delete_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_chars", (PyCFunction)_wrap_gtk_editable_get_chars, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "cut_clipboard", (PyCFunction)_wrap_gtk_editable_cut_clipboard, METH_NOARGS,
      NULL },
    { "copy_clipboard", (PyCFunction)_wrap_gtk_editable_copy_clipboard, METH_NOARGS,
      NULL },
    { "paste_clipboard", (PyCFunction)_wrap_gtk_editable_paste_clipboard, METH_NOARGS,
      NULL },
    { "delete_selection", (PyCFunction)_wrap_gtk_editable_delete_selection, METH_NOARGS,
      NULL },
    { "set_position", (PyCFunction)_wrap_gtk_editable_set_position, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_position", (PyCFunction)_wrap_gtk_editable_get_position, METH_NOARGS,
      NULL },
    { "set_editable", (PyCFunction)_wrap_gtk_editable_set_editable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_editable", (PyCFunction)_wrap_gtk_editable_get_editable, METH_NOARGS,
      NULL },
    { "do_insert_text", (PyCFunction)_wrap_GtkEditable__do_insert_text, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_delete_text", (PyCFunction)_wrap_GtkEditable__do_delete_text, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_changed", (PyCFunction)_wrap_GtkEditable__do_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_do_insert_text", (PyCFunction)_wrap_GtkEditable__do_do_insert_text, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_do_delete_text", (PyCFunction)_wrap_GtkEditable__do_do_delete_text, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_chars", (PyCFunction)_wrap_GtkEditable__do_get_chars, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_selection_bounds", (PyCFunction)_wrap_GtkEditable__do_set_selection_bounds, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_selection_bounds", (PyCFunction)_wrap_GtkEditable__do_get_selection_bounds, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_position", (PyCFunction)_wrap_GtkEditable__do_set_position, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_position", (PyCFunction)_wrap_GtkEditable__do_get_position, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkEditable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Editable",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkEditable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkEditable__proxy_do_insert_text(GtkEditable *self, const gchar*text, gint length, gint*position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_text = NULL;
    PyObject *py_length;
    PyObject *py_position;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (text)
        py_text = PyString_FromString(text);
    if (!py_text) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_length = PyInt_FromLong(length);
    py_position = PyInt_FromLong(*position);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_text);
    PyTuple_SET_ITEM(py_args, 1, py_length);
    PyTuple_SET_ITEM(py_args, 2, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_insert_text");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (!PyArg_ParseTuple(py_retval, "i", position)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEditable__proxy_do_delete_text(GtkEditable *self, gint start_pos, gint end_pos)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_start_pos;
    PyObject *py_end_pos;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_start_pos = PyInt_FromLong(start_pos);
    py_end_pos = PyInt_FromLong(end_pos);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_start_pos);
    PyTuple_SET_ITEM(py_args, 1, py_end_pos);
    
    py_method = PyObject_GetAttrString(py_self, "do_delete_text");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEditable__proxy_do_changed(GtkEditable *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEditable__proxy_do_do_insert_text(GtkEditable *self, const gchar*text, gint length, gint*position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_text = NULL;
    PyObject *py_length;
    PyObject *py_position;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (text)
        py_text = PyString_FromString(text);
    if (!py_text) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_length = PyInt_FromLong(length);
    py_position = PyInt_FromLong(*position);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_text);
    PyTuple_SET_ITEM(py_args, 1, py_length);
    PyTuple_SET_ITEM(py_args, 2, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_do_insert_text");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (!PyArg_ParseTuple(py_retval, "i", position)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkEditable__proxy_do_do_delete_text(GtkEditable *self, gint start_pos, gint end_pos)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_start_pos;
    PyObject *py_end_pos;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_start_pos = PyInt_FromLong(start_pos);
    py_end_pos = PyInt_FromLong(end_pos);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_start_pos);
    PyTuple_SET_ITEM(py_args, 1, py_end_pos);
    
    py_method = PyObject_GetAttrString(py_self, "do_do_delete_text");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gchar*
_wrap_GtkEditable__proxy_do_get_chars(GtkEditable *self, gint start_pos, gint end_pos)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_start_pos;
    PyObject *py_end_pos;
    gchar* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_start_pos = PyInt_FromLong(start_pos);
    py_end_pos = PyInt_FromLong(end_pos);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_start_pos);
    PyTuple_SET_ITEM(py_args, 1, py_end_pos);
    
    py_method = PyObject_GetAttrString(py_self, "do_get_chars");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "s", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    retval = g_strdup(retval);
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkEditable__proxy_do_set_selection_bounds(GtkEditable *self, gint start_pos, gint end_pos)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_start_pos;
    PyObject *py_end_pos;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_start_pos = PyInt_FromLong(start_pos);
    py_end_pos = PyInt_FromLong(end_pos);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_start_pos);
    PyTuple_SET_ITEM(py_args, 1, py_end_pos);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_selection_bounds");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkEditable__proxy_do_get_selection_bounds(GtkEditable *self, gint*start_pos, gint*end_pos)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_selection_bounds");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (!PyArg_ParseTuple(py_retval, "Oii", &py_main_retval, start_pos, end_pos)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkEditable__proxy_do_set_position(GtkEditable *self, gint position)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_position;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_position = PyInt_FromLong(position);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_position);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_position");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gint
_wrap_GtkEditable__proxy_do_get_position(GtkEditable *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gint retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_position");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "i", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static void
__GtkEditable__interface_init(GtkEditableClass *iface, PyTypeObject *pytype)
{
    GtkEditableClass *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_insert_text") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->insert_text = _wrap_GtkEditable__proxy_do_insert_text;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->insert_text = parent_iface->insert_text;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_delete_text") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->delete_text = _wrap_GtkEditable__proxy_do_delete_text;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->delete_text = parent_iface->delete_text;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_changed") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->changed = _wrap_GtkEditable__proxy_do_changed;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->changed = parent_iface->changed;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_do_insert_text") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->do_insert_text = _wrap_GtkEditable__proxy_do_do_insert_text;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->do_insert_text = parent_iface->do_insert_text;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_do_delete_text") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->do_delete_text = _wrap_GtkEditable__proxy_do_do_delete_text;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->do_delete_text = parent_iface->do_delete_text;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_chars") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_chars = _wrap_GtkEditable__proxy_do_get_chars;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_chars = parent_iface->get_chars;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_set_selection_bounds") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->set_selection_bounds = _wrap_GtkEditable__proxy_do_set_selection_bounds;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->set_selection_bounds = parent_iface->set_selection_bounds;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_selection_bounds") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_selection_bounds = _wrap_GtkEditable__proxy_do_get_selection_bounds;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_selection_bounds = parent_iface->get_selection_bounds;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_set_position") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->set_position = _wrap_GtkEditable__proxy_do_set_position;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->set_position = parent_iface->set_position;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_position") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_position = _wrap_GtkEditable__proxy_do_get_position;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_position = parent_iface->get_position;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkEditable__iinfo = {
    (GInterfaceInitFunc) __GtkEditable__interface_init,
    NULL,
    NULL
};


/* ----------- GtkFileChooser ----------- */

static PyObject *
_wrap_gtk_file_chooser_set_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", NULL };
    PyObject *py_action = NULL;
    GtkFileChooserAction action;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.FileChooser.set_action", kwlist, &py_action))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_FILE_CHOOSER_ACTION, py_action, (gpointer)&action))
        return NULL;
    
    gtk_file_chooser_set_action(GTK_FILE_CHOOSER(self->obj), action);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_action(PyGObject *self)
{
    gint ret;

    
    ret = gtk_file_chooser_get_action(GTK_FILE_CHOOSER(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_FILE_CHOOSER_ACTION, ret);
}

static PyObject *
_wrap_gtk_file_chooser_set_local_only(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "local_only", NULL };
    int local_only;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FileChooser.set_local_only", kwlist, &local_only))
        return NULL;
    
    gtk_file_chooser_set_local_only(GTK_FILE_CHOOSER(self->obj), local_only);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_local_only(PyGObject *self)
{
    int ret;

    
    ret = gtk_file_chooser_get_local_only(GTK_FILE_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_set_select_multiple(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "select_multiple", NULL };
    int select_multiple;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FileChooser.set_select_multiple", kwlist, &select_multiple))
        return NULL;
    
    gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(self->obj), select_multiple);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_select_multiple(PyGObject *self)
{
    int ret;

    
    ret = gtk_file_chooser_get_select_multiple(GTK_FILE_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_set_show_hidden(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_hidden", NULL };
    int show_hidden;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FileChooser.set_show_hidden", kwlist, &show_hidden))
        return NULL;
    
    gtk_file_chooser_set_show_hidden(GTK_FILE_CHOOSER(self->obj), show_hidden);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_show_hidden(PyGObject *self)
{
    int ret;

    
    ret = gtk_file_chooser_get_show_hidden(GTK_FILE_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_set_do_overwrite_confirmation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "do_overwrite_confirmation", NULL };
    int do_overwrite_confirmation;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FileChooser.set_do_overwrite_confirmation", kwlist, &do_overwrite_confirmation))
        return NULL;
    
    gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(self->obj), do_overwrite_confirmation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_do_overwrite_confirmation(PyGObject *self)
{
    int ret;

    
    ret = gtk_file_chooser_get_do_overwrite_confirmation(GTK_FILE_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_set_current_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.set_current_name", kwlist, &name))
        return NULL;
    
    gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_filename(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_set_filename(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.set_filename", kwlist, &filename))
        return NULL;
    
    ret = gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(self->obj), filename);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_select_filename(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.select_filename", kwlist, &filename))
        return NULL;
    
    ret = gtk_file_chooser_select_filename(GTK_FILE_CHOOSER(self->obj), filename);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_unselect_filename(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.unselect_filename", kwlist, &filename))
        return NULL;
    
    gtk_file_chooser_unselect_filename(GTK_FILE_CHOOSER(self->obj), filename);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_select_all(PyGObject *self)
{
    
    gtk_file_chooser_select_all(GTK_FILE_CHOOSER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_unselect_all(PyGObject *self)
{
    
    gtk_file_chooser_unselect_all(GTK_FILE_CHOOSER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4585 "./gtk.override"
static PyObject *
_wrap_gtk_file_chooser_get_filenames(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyString_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
#line 113268 "gtk.c"


static PyObject *
_wrap_gtk_file_chooser_set_current_folder(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.set_current_folder", kwlist, &filename))
        return NULL;
    
    ret = gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(self->obj), filename);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_get_current_folder(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_uri(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_set_uri(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.set_uri", kwlist, &uri))
        return NULL;
    
    ret = gtk_file_chooser_set_uri(GTK_FILE_CHOOSER(self->obj), uri);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_select_uri(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.select_uri", kwlist, &uri))
        return NULL;
    
    ret = gtk_file_chooser_select_uri(GTK_FILE_CHOOSER(self->obj), uri);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_unselect_uri(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.unselect_uri", kwlist, &uri))
        return NULL;
    
    gtk_file_chooser_unselect_uri(GTK_FILE_CHOOSER(self->obj), uri);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4613 "./gtk.override"
static PyObject *
_wrap_gtk_file_chooser_get_uris(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_get_uris(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyString_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
#line 113395 "gtk.c"


static PyObject *
_wrap_gtk_file_chooser_set_current_folder_uri(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.set_current_folder_uri", kwlist, &uri))
        return NULL;
    
    ret = gtk_file_chooser_set_current_folder_uri(GTK_FILE_CHOOSER(self->obj), uri);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_get_current_folder_uri(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_file_chooser_get_current_folder_uri(GTK_FILE_CHOOSER(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_set_preview_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "preview_widget", NULL };
    PyGObject *preview_widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.FileChooser.set_preview_widget", kwlist, &PyGtkWidget_Type, &preview_widget))
        return NULL;
    
    gtk_file_chooser_set_preview_widget(GTK_FILE_CHOOSER(self->obj), GTK_WIDGET(preview_widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_preview_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_file_chooser_get_preview_widget(GTK_FILE_CHOOSER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_chooser_set_preview_widget_active(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "active", NULL };
    int active;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FileChooser.set_preview_widget_active", kwlist, &active))
        return NULL;
    
    gtk_file_chooser_set_preview_widget_active(GTK_FILE_CHOOSER(self->obj), active);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_preview_widget_active(PyGObject *self)
{
    int ret;

    
    ret = gtk_file_chooser_get_preview_widget_active(GTK_FILE_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_set_use_preview_label(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_label", NULL };
    int use_label;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FileChooser.set_use_preview_label", kwlist, &use_label))
        return NULL;
    
    gtk_file_chooser_set_use_preview_label(GTK_FILE_CHOOSER(self->obj), use_label);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_use_preview_label(PyGObject *self)
{
    int ret;

    
    ret = gtk_file_chooser_get_use_preview_label(GTK_FILE_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_get_preview_filename(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_file_chooser_get_preview_filename(GTK_FILE_CHOOSER(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_preview_uri(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_file_chooser_get_preview_uri(GTK_FILE_CHOOSER(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_set_extra_widget(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "extra_widget", NULL };
    PyGObject *extra_widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.FileChooser.set_extra_widget", kwlist, &PyGtkWidget_Type, &extra_widget))
        return NULL;
    
    gtk_file_chooser_set_extra_widget(GTK_FILE_CHOOSER(self->obj), GTK_WIDGET(extra_widget->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_extra_widget(PyGObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_file_chooser_get_extra_widget(GTK_FILE_CHOOSER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_chooser_add_filter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filter", NULL };
    PyGObject *filter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.FileChooser.add_filter", kwlist, &PyGtkFileFilter_Type, &filter))
        return NULL;
    
    gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(self->obj), GTK_FILE_FILTER(filter->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_remove_filter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filter", NULL };
    PyGObject *filter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.FileChooser.remove_filter", kwlist, &PyGtkFileFilter_Type, &filter))
        return NULL;
    
    gtk_file_chooser_remove_filter(GTK_FILE_CHOOSER(self->obj), GTK_FILE_FILTER(filter->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 4641 "./gtk.override"
static PyObject *
_wrap_gtk_file_chooser_list_filters(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_list_filters(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = pygobject_new(G_OBJECT(tmp->data));
        if (obj == NULL) {
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_free(slist);
    return py_list;
}
#line 113628 "gtk.c"


static PyObject *
_wrap_gtk_file_chooser_set_filter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filter", NULL };
    PyGObject *filter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.FileChooser.set_filter", kwlist, &PyGtkFileFilter_Type, &filter))
        return NULL;
    
    gtk_file_chooser_set_filter(GTK_FILE_CHOOSER(self->obj), GTK_FILE_FILTER(filter->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_filter(PyGObject *self)
{
    GtkFileFilter *ret;

    
    ret = gtk_file_chooser_get_filter(GTK_FILE_CHOOSER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_chooser_add_shortcut_folder(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "folder", NULL };
    char *folder;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.add_shortcut_folder", kwlist, &folder))
        return NULL;
    
    ret = gtk_file_chooser_add_shortcut_folder(GTK_FILE_CHOOSER(self->obj), folder, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_remove_shortcut_folder(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "folder", NULL };
    char *folder;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.remove_shortcut_folder", kwlist, &folder))
        return NULL;
    
    ret = gtk_file_chooser_remove_shortcut_folder(GTK_FILE_CHOOSER(self->obj), folder, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

#line 4696 "./gtk.override"
static PyObject *
_wrap_gtk_file_chooser_list_shortcut_folders(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_list_shortcut_folders(GTK_FILE_CHOOSER(self->obj));
    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyString_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
#line 113723 "gtk.c"


static PyObject *
_wrap_gtk_file_chooser_add_shortcut_folder_uri(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.add_shortcut_folder_uri", kwlist, &uri))
        return NULL;
    
    ret = gtk_file_chooser_add_shortcut_folder_uri(GTK_FILE_CHOOSER(self->obj), uri, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_remove_shortcut_folder_uri(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.FileChooser.remove_shortcut_folder_uri", kwlist, &uri))
        return NULL;
    
    ret = gtk_file_chooser_remove_shortcut_folder_uri(GTK_FILE_CHOOSER(self->obj), uri, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

#line 4667 "./gtk.override"
static PyObject *
_wrap_gtk_file_chooser_list_shortcut_folder_uris(PyGObject *self)
{
    PyObject *py_list;
    GSList *slist, *tmp;
    int i, slen;

    slist = gtk_file_chooser_list_shortcut_folder_uris(GTK_FILE_CHOOSER(self->obj));

    slen = g_slist_length(slist);
    if ((py_list = PyList_New(slen)) == NULL)
        return NULL;

    for (i = 0, tmp = slist; i < slen && tmp != NULL; tmp = tmp->next, i++) {
        PyObject *obj = PyString_FromString((char *)tmp->data);
        if (obj == NULL) {
	    g_slist_foreach(slist, (GFunc)g_free, NULL);
	    g_slist_free(slist);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_SetItem(py_list, i, obj);
    }
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
    return py_list;
}
#line 113792 "gtk.c"


static PyObject *
_wrap_gtk_file_chooser_get_file(PyGObject *self)
{
    GFile *ret;

    
    ret = gtk_file_chooser_get_file(GTK_FILE_CHOOSER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_chooser_set_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file", NULL };
    PyGObject *file;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.FileChooser.set_file", kwlist, &PyGFile_Type, &file))
        return NULL;
    
    ret = gtk_file_chooser_set_file(GTK_FILE_CHOOSER(self->obj), G_FILE(file->obj), &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_select_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file", NULL };
    PyGObject *file;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.FileChooser.select_file", kwlist, &PyGFile_Type, &file))
        return NULL;
    
    ret = gtk_file_chooser_select_file(GTK_FILE_CHOOSER(self->obj), G_FILE(file->obj), &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_unselect_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file", NULL };
    PyGObject *file;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.FileChooser.unselect_file", kwlist, &PyGFile_Type, &file))
        return NULL;
    
    gtk_file_chooser_unselect_file(GTK_FILE_CHOOSER(self->obj), G_FILE(file->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_set_current_folder_file(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file", NULL };
    PyGObject *file;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.FileChooser.set_current_folder_file", kwlist, &PyGFile_Type, &file))
        return NULL;
    
    ret = gtk_file_chooser_set_current_folder_file(GTK_FILE_CHOOSER(self->obj), G_FILE(file->obj), &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_file_chooser_get_current_folder_file(PyGObject *self)
{
    GFile *ret;

    
    ret = gtk_file_chooser_get_current_folder_file(GTK_FILE_CHOOSER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_chooser_get_preview_file(PyGObject *self)
{
    GFile *ret;

    
    ret = gtk_file_chooser_get_preview_file(GTK_FILE_CHOOSER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_file_chooser_set_create_folders(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "create_folders", NULL };
    int create_folders;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.FileChooser.set_create_folders", kwlist, &create_folders))
        return NULL;
    
    gtk_file_chooser_set_create_folders(GTK_FILE_CHOOSER(self->obj), create_folders);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_file_chooser_get_create_folders(PyGObject *self)
{
    int ret;

    
    ret = gtk_file_chooser_get_create_folders(GTK_FILE_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkFileChooser_methods[] = {
    { "set_action", (PyCFunction)_wrap_gtk_file_chooser_set_action, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_action", (PyCFunction)_wrap_gtk_file_chooser_get_action, METH_NOARGS,
      NULL },
    { "set_local_only", (PyCFunction)_wrap_gtk_file_chooser_set_local_only, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_local_only", (PyCFunction)_wrap_gtk_file_chooser_get_local_only, METH_NOARGS,
      NULL },
    { "set_select_multiple", (PyCFunction)_wrap_gtk_file_chooser_set_select_multiple, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_select_multiple", (PyCFunction)_wrap_gtk_file_chooser_get_select_multiple, METH_NOARGS,
      NULL },
    { "set_show_hidden", (PyCFunction)_wrap_gtk_file_chooser_set_show_hidden, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_hidden", (PyCFunction)_wrap_gtk_file_chooser_get_show_hidden, METH_NOARGS,
      NULL },
    { "set_do_overwrite_confirmation", (PyCFunction)_wrap_gtk_file_chooser_set_do_overwrite_confirmation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_do_overwrite_confirmation", (PyCFunction)_wrap_gtk_file_chooser_get_do_overwrite_confirmation, METH_NOARGS,
      NULL },
    { "set_current_name", (PyCFunction)_wrap_gtk_file_chooser_set_current_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_filename", (PyCFunction)_wrap_gtk_file_chooser_get_filename, METH_NOARGS,
      NULL },
    { "set_filename", (PyCFunction)_wrap_gtk_file_chooser_set_filename, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_filename", (PyCFunction)_wrap_gtk_file_chooser_select_filename, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_filename", (PyCFunction)_wrap_gtk_file_chooser_unselect_filename, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_all", (PyCFunction)_wrap_gtk_file_chooser_select_all, METH_NOARGS,
      NULL },
    { "unselect_all", (PyCFunction)_wrap_gtk_file_chooser_unselect_all, METH_NOARGS,
      NULL },
    { "get_filenames", (PyCFunction)_wrap_gtk_file_chooser_get_filenames, METH_NOARGS,
      NULL },
    { "set_current_folder", (PyCFunction)_wrap_gtk_file_chooser_set_current_folder, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_folder", (PyCFunction)_wrap_gtk_file_chooser_get_current_folder, METH_NOARGS,
      NULL },
    { "get_uri", (PyCFunction)_wrap_gtk_file_chooser_get_uri, METH_NOARGS,
      NULL },
    { "set_uri", (PyCFunction)_wrap_gtk_file_chooser_set_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_uri", (PyCFunction)_wrap_gtk_file_chooser_select_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_uri", (PyCFunction)_wrap_gtk_file_chooser_unselect_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_uris", (PyCFunction)_wrap_gtk_file_chooser_get_uris, METH_NOARGS,
      NULL },
    { "set_current_folder_uri", (PyCFunction)_wrap_gtk_file_chooser_set_current_folder_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_folder_uri", (PyCFunction)_wrap_gtk_file_chooser_get_current_folder_uri, METH_NOARGS,
      NULL },
    { "set_preview_widget", (PyCFunction)_wrap_gtk_file_chooser_set_preview_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_preview_widget", (PyCFunction)_wrap_gtk_file_chooser_get_preview_widget, METH_NOARGS,
      NULL },
    { "set_preview_widget_active", (PyCFunction)_wrap_gtk_file_chooser_set_preview_widget_active, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_preview_widget_active", (PyCFunction)_wrap_gtk_file_chooser_get_preview_widget_active, METH_NOARGS,
      NULL },
    { "set_use_preview_label", (PyCFunction)_wrap_gtk_file_chooser_set_use_preview_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_preview_label", (PyCFunction)_wrap_gtk_file_chooser_get_use_preview_label, METH_NOARGS,
      NULL },
    { "get_preview_filename", (PyCFunction)_wrap_gtk_file_chooser_get_preview_filename, METH_NOARGS,
      NULL },
    { "get_preview_uri", (PyCFunction)_wrap_gtk_file_chooser_get_preview_uri, METH_NOARGS,
      NULL },
    { "set_extra_widget", (PyCFunction)_wrap_gtk_file_chooser_set_extra_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_extra_widget", (PyCFunction)_wrap_gtk_file_chooser_get_extra_widget, METH_NOARGS,
      NULL },
    { "add_filter", (PyCFunction)_wrap_gtk_file_chooser_add_filter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_filter", (PyCFunction)_wrap_gtk_file_chooser_remove_filter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "list_filters", (PyCFunction)_wrap_gtk_file_chooser_list_filters, METH_NOARGS,
      NULL },
    { "set_filter", (PyCFunction)_wrap_gtk_file_chooser_set_filter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_filter", (PyCFunction)_wrap_gtk_file_chooser_get_filter, METH_NOARGS,
      NULL },
    { "add_shortcut_folder", (PyCFunction)_wrap_gtk_file_chooser_add_shortcut_folder, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_shortcut_folder", (PyCFunction)_wrap_gtk_file_chooser_remove_shortcut_folder, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "list_shortcut_folders", (PyCFunction)_wrap_gtk_file_chooser_list_shortcut_folders, METH_NOARGS,
      NULL },
    { "add_shortcut_folder_uri", (PyCFunction)_wrap_gtk_file_chooser_add_shortcut_folder_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_shortcut_folder_uri", (PyCFunction)_wrap_gtk_file_chooser_remove_shortcut_folder_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "list_shortcut_folder_uris", (PyCFunction)_wrap_gtk_file_chooser_list_shortcut_folder_uris, METH_NOARGS,
      NULL },
    { "get_file", (PyCFunction)_wrap_gtk_file_chooser_get_file, METH_NOARGS,
      NULL },
    { "set_file", (PyCFunction)_wrap_gtk_file_chooser_set_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_file", (PyCFunction)_wrap_gtk_file_chooser_select_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_file", (PyCFunction)_wrap_gtk_file_chooser_unselect_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_current_folder_file", (PyCFunction)_wrap_gtk_file_chooser_set_current_folder_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_folder_file", (PyCFunction)_wrap_gtk_file_chooser_get_current_folder_file, METH_NOARGS,
      NULL },
    { "get_preview_file", (PyCFunction)_wrap_gtk_file_chooser_get_preview_file, METH_NOARGS,
      NULL },
    { "set_create_folders", (PyCFunction)_wrap_gtk_file_chooser_set_create_folders, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_create_folders", (PyCFunction)_wrap_gtk_file_chooser_get_create_folders, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkFileChooser_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.FileChooser",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkFileChooser_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- GtkTreeDragDest ----------- */

static PyObject *
_wrap_gtk_tree_drag_dest_drag_data_received(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dest", "selection_data", NULL };
    PyObject *py_dest, *py_selection_data;
    int ret;
    GtkSelectionData *selection_data = NULL;
    GtkTreePath *dest;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeDragDest.drag_data_received", kwlist, &py_dest, &py_selection_data))
        return NULL;
    dest = pygtk_tree_path_from_pyobject(py_dest);
    if (!dest) {
        PyErr_SetString(PyExc_TypeError, "could not convert dest to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_selection_data, GTK_TYPE_SELECTION_DATA))
        selection_data = pyg_boxed_get(py_selection_data, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection_data should be a GtkSelectionData");
        return NULL;
    }
    
    ret = gtk_tree_drag_dest_drag_data_received(GTK_TREE_DRAG_DEST(self->obj), dest, selection_data);
    
    if (dest)
        gtk_tree_path_free(dest);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_drag_dest_row_drop_possible(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dest_path", "selection_data", NULL };
    PyObject *py_dest_path, *py_selection_data;
    int ret;
    GtkSelectionData *selection_data = NULL;
    GtkTreePath *dest_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeDragDest.row_drop_possible", kwlist, &py_dest_path, &py_selection_data))
        return NULL;
    dest_path = pygtk_tree_path_from_pyobject(py_dest_path);
    if (!dest_path) {
        PyErr_SetString(PyExc_TypeError, "could not convert dest_path to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_selection_data, GTK_TYPE_SELECTION_DATA))
        selection_data = pyg_boxed_get(py_selection_data, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection_data should be a GtkSelectionData");
        return NULL;
    }
    
    ret = gtk_tree_drag_dest_row_drop_possible(GTK_TREE_DRAG_DEST(self->obj), dest_path, selection_data);
    
    if (dest_path)
        gtk_tree_path_free(dest_path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeDragDest__do_drag_data_received(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeDragDestIface *iface;
    static char *kwlist[] = { "self", "dest", "selection_data", NULL };
    PyGObject *self;
    PyObject *py_dest, *py_selection_data;
    GtkSelectionData *selection_data = NULL;
    GtkTreePath *dest;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeDragDest.drag_data_received", kwlist, &PyGtkTreeDragDest_Type, &self, &py_dest, &py_selection_data))
        return NULL;
    dest = pygtk_tree_path_from_pyobject(py_dest);
    if (!dest) {
        PyErr_SetString(PyExc_TypeError, "could not convert dest to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_selection_data, GTK_TYPE_SELECTION_DATA))
        selection_data = pyg_boxed_get(py_selection_data, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection_data should be a GtkSelectionData");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_DRAG_DEST);
    if (iface->drag_data_received)
        ret = iface->drag_data_received(GTK_TREE_DRAG_DEST(self->obj), dest, selection_data);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeDragDest.drag_data_received not implemented");
        return NULL;
    }
    if (dest)
        gtk_tree_path_free(dest);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeDragDest__do_row_drop_possible(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeDragDestIface *iface;
    static char *kwlist[] = { "self", "dest_path", "selection_data", NULL };
    PyGObject *self;
    PyObject *py_dest_path, *py_selection_data;
    GtkSelectionData *selection_data = NULL;
    GtkTreePath *dest_path;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeDragDest.row_drop_possible", kwlist, &PyGtkTreeDragDest_Type, &self, &py_dest_path, &py_selection_data))
        return NULL;
    dest_path = pygtk_tree_path_from_pyobject(py_dest_path);
    if (!dest_path) {
        PyErr_SetString(PyExc_TypeError, "could not convert dest_path to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_selection_data, GTK_TYPE_SELECTION_DATA))
        selection_data = pyg_boxed_get(py_selection_data, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection_data should be a GtkSelectionData");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_DRAG_DEST);
    if (iface->row_drop_possible)
        ret = iface->row_drop_possible(GTK_TREE_DRAG_DEST(self->obj), dest_path, selection_data);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeDragDest.row_drop_possible not implemented");
        return NULL;
    }
    if (dest_path)
        gtk_tree_path_free(dest_path);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkTreeDragDest_methods[] = {
    { "drag_data_received", (PyCFunction)_wrap_gtk_tree_drag_dest_drag_data_received, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "row_drop_possible", (PyCFunction)_wrap_gtk_tree_drag_dest_row_drop_possible, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_drag_data_received", (PyCFunction)_wrap_GtkTreeDragDest__do_drag_data_received, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_row_drop_possible", (PyCFunction)_wrap_GtkTreeDragDest__do_row_drop_possible, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeDragDest_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeDragDest",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeDragDest_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gboolean
_wrap_GtkTreeDragDest__proxy_do_drag_data_received(GtkTreeDragDest *self, GtkTreePath*dest, GtkSelectionData*selection_data)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_dest;
    PyObject *py_selection_data;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_dest = pygtk_tree_path_to_pyobject(dest);
    if (!py_dest) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_selection_data = pyg_boxed_new(GTK_TYPE_SELECTION_DATA, selection_data, FALSE, FALSE);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_dest);
    PyTuple_SET_ITEM(py_args, 1, py_selection_data);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_data_received");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeDragDest__proxy_do_row_drop_possible(GtkTreeDragDest *self, GtkTreePath*dest_path, GtkSelectionData*selection_data)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_dest_path;
    PyObject *py_selection_data;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_dest_path = pygtk_tree_path_to_pyobject(dest_path);
    if (!py_dest_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_selection_data = pyg_boxed_new(GTK_TYPE_SELECTION_DATA, selection_data, FALSE, FALSE);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_dest_path);
    PyTuple_SET_ITEM(py_args, 1, py_selection_data);
    
    py_method = PyObject_GetAttrString(py_self, "do_row_drop_possible");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static void
__GtkTreeDragDest__interface_init(GtkTreeDragDestIface *iface, PyTypeObject *pytype)
{
    GtkTreeDragDestIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_drag_data_received") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->drag_data_received = _wrap_GtkTreeDragDest__proxy_do_drag_data_received;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->drag_data_received = parent_iface->drag_data_received;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_row_drop_possible") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->row_drop_possible = _wrap_GtkTreeDragDest__proxy_do_row_drop_possible;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->row_drop_possible = parent_iface->row_drop_possible;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkTreeDragDest__iinfo = {
    (GInterfaceInitFunc) __GtkTreeDragDest__interface_init,
    NULL,
    NULL
};


/* ----------- GtkTreeDragSource ----------- */

static PyObject *
_wrap_gtk_tree_drag_source_row_draggable(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    int ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeDragSource.row_draggable", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_drag_source_row_draggable(GTK_TREE_DRAG_SOURCE(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_drag_source_drag_data_delete(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    int ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeDragSource.drag_data_delete", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    ret = gtk_tree_drag_source_drag_data_delete(GTK_TREE_DRAG_SOURCE(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_drag_source_drag_data_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "selection_data", NULL };
    PyObject *py_path, *py_selection_data;
    int ret;
    GtkSelectionData *selection_data = NULL;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeDragSource.drag_data_get", kwlist, &py_path, &py_selection_data))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_selection_data, GTK_TYPE_SELECTION_DATA))
        selection_data = pyg_boxed_get(py_selection_data, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection_data should be a GtkSelectionData");
        return NULL;
    }
    
    ret = gtk_tree_drag_source_drag_data_get(GTK_TREE_DRAG_SOURCE(self->obj), path, selection_data);
    
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeDragSource__do_row_draggable(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeDragSourceIface *iface;
    static char *kwlist[] = { "self", "path", NULL };
    PyGObject *self;
    PyObject *py_path;
    int ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeDragSource.row_draggable", kwlist, &PyGtkTreeDragSource_Type, &self, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_DRAG_SOURCE);
    if (iface->row_draggable)
        ret = iface->row_draggable(GTK_TREE_DRAG_SOURCE(self->obj), path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeDragSource.row_draggable not implemented");
        return NULL;
    }
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeDragSource__do_drag_data_get(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeDragSourceIface *iface;
    static char *kwlist[] = { "self", "path", "selection_data", NULL };
    PyGObject *self;
    PyObject *py_path, *py_selection_data;
    GtkSelectionData *selection_data = NULL;
    GtkTreePath *path;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeDragSource.drag_data_get", kwlist, &PyGtkTreeDragSource_Type, &self, &py_path, &py_selection_data))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_selection_data, GTK_TYPE_SELECTION_DATA))
        selection_data = pyg_boxed_get(py_selection_data, GtkSelectionData);
    else {
        PyErr_SetString(PyExc_TypeError, "selection_data should be a GtkSelectionData");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_DRAG_SOURCE);
    if (iface->drag_data_get)
        ret = iface->drag_data_get(GTK_TREE_DRAG_SOURCE(self->obj), path, selection_data);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeDragSource.drag_data_get not implemented");
        return NULL;
    }
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeDragSource__do_drag_data_delete(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeDragSourceIface *iface;
    static char *kwlist[] = { "self", "path", NULL };
    PyGObject *self;
    PyObject *py_path;
    int ret;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeDragSource.drag_data_delete", kwlist, &PyGtkTreeDragSource_Type, &self, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_DRAG_SOURCE);
    if (iface->drag_data_delete)
        ret = iface->drag_data_delete(GTK_TREE_DRAG_SOURCE(self->obj), path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeDragSource.drag_data_delete not implemented");
        return NULL;
    }
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkTreeDragSource_methods[] = {
    { "row_draggable", (PyCFunction)_wrap_gtk_tree_drag_source_row_draggable, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_data_delete", (PyCFunction)_wrap_gtk_tree_drag_source_drag_data_delete, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_data_get", (PyCFunction)_wrap_gtk_tree_drag_source_drag_data_get, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_row_draggable", (PyCFunction)_wrap_GtkTreeDragSource__do_row_draggable, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_drag_data_get", (PyCFunction)_wrap_GtkTreeDragSource__do_drag_data_get, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_drag_data_delete", (PyCFunction)_wrap_GtkTreeDragSource__do_drag_data_delete, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeDragSource_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeDragSource",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeDragSource_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gboolean
_wrap_GtkTreeDragSource__proxy_do_row_draggable(GtkTreeDragSource *self, GtkTreePath*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_row_draggable");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeDragSource__proxy_do_drag_data_get(GtkTreeDragSource *self, GtkTreePath*path, GtkSelectionData*selection_data)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path;
    PyObject *py_selection_data;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_selection_data = pyg_boxed_new(GTK_TYPE_SELECTION_DATA, selection_data, FALSE, FALSE);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    PyTuple_SET_ITEM(py_args, 1, py_selection_data);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_data_get");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeDragSource__proxy_do_drag_data_delete(GtkTreeDragSource *self, GtkTreePath*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_drag_data_delete");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static void
__GtkTreeDragSource__interface_init(GtkTreeDragSourceIface *iface, PyTypeObject *pytype)
{
    GtkTreeDragSourceIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_row_draggable") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->row_draggable = _wrap_GtkTreeDragSource__proxy_do_row_draggable;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->row_draggable = parent_iface->row_draggable;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_drag_data_get") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->drag_data_get = _wrap_GtkTreeDragSource__proxy_do_drag_data_get;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->drag_data_get = parent_iface->drag_data_get;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_drag_data_delete") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->drag_data_delete = _wrap_GtkTreeDragSource__proxy_do_drag_data_delete;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->drag_data_delete = parent_iface->drag_data_delete;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkTreeDragSource__iinfo = {
    (GInterfaceInitFunc) __GtkTreeDragSource__interface_init,
    NULL,
    NULL
};


/* ----------- GtkTreeModel ----------- */

static PyObject *
_wrap_gtk_tree_model_get_flags(PyGObject *self)
{
    guint ret;

    
    ret = gtk_tree_model_get_flags(GTK_TREE_MODEL(self->obj));
    
    return pyg_flags_from_gtype(GTK_TYPE_TREE_MODEL_FLAGS, ret);
}

static PyObject *
_wrap_gtk_tree_model_get_n_columns(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_tree_model_get_column_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "index", NULL };
    int index;
    GType ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.TreeModel.get_column_type", kwlist, &index))
        return NULL;
    
    ret = gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj), index);
    
    return pyg_type_wrapper_new(ret);
}

#line 796 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_get_iter(PyGObject *self, PyObject *args,PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreeIter iter;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTreeModel.get_iter",
                                     kwlist, &py_path))
        return NULL;

    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "GtkTreeModel.get_iter requires a tree path as its argument");
        return NULL;
    }
    if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
        gtk_tree_path_free(path);
        return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    } else {
        gtk_tree_path_free(path);
        PyErr_SetString(PyExc_ValueError, "invalid tree path");
        return NULL;
    }
}
#line 115058 "gtk.c"


#line 824 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_get_iter_from_string(PyGObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    static char *kwlist[] = { "path_string", NULL };
    const gchar *path_string;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s:GtkTreeModel.get_iter_from_string",
                                     kwlist, &path_string))
        return NULL;

    if (gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(self->obj), &iter,
                                            path_string)) {
        return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    } else {
        PyErr_SetString(PyExc_ValueError, "invalid tree path");
        return NULL;
    }
}
#line 115083 "gtk.c"


static PyObject *
_wrap_gtk_tree_model_get_string_from_iter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModel.get_string_from_iter", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_tree_model_get_string_from_iter(GTK_TREE_MODEL(self->obj), iter);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2341 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_get_iter_first(PyGObject *self)
{
    GtkTreeIter iter;

    if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->obj), &iter))
        return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
#line 115127 "gtk.c"


static PyObject *
_wrap_gtk_tree_model_get_path(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    GtkTreePath *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModel.get_path", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_tree_model_get_path(GTK_TREE_MODEL(self->obj), iter);
    
    if (ret) {
        PyObject *py_ret = pygtk_tree_path_to_pyobject(ret);
        gtk_tree_path_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 847 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_get_value(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "iter", "column", NULL };
    PyObject *iter, *ret;
    gint column;
    GValue value = { 0, };

    if (!PyArg_ParseTupleAndKeywords(args,kwargs, "Oi:GtkTreeModel.get_value",
                                     kwlist, &iter, &column))
        return NULL;
    if (column < 0 ||
        column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
        PyErr_SetString(PyExc_ValueError, "column number is out of range");
        return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
        PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
        return NULL;
    }
    gtk_tree_model_get_value(GTK_TREE_MODEL(self->obj),
                             pyg_boxed_get(iter, GtkTreeIter), column, &value);
    ret = pyg_value_as_pyobject(&value, TRUE);
    g_value_unset(&value);
    return ret;
}
#line 115185 "gtk.c"


#line 2355 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_iter_next(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkTreeModel.iter_next", kwlist,
                                     &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = *pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }

    if (gtk_tree_model_iter_next(GTK_TREE_MODEL(self->obj), &iter))
        return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
#line 115215 "gtk.c"


#line 2383 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_iter_children(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkTreeModel.iter_children", kwlist,
                                     &py_parent))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent == Py_None)
        parent = NULL;
    else {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkTreeIter or None");
        return NULL;
    }

    if (gtk_tree_model_iter_children(GTK_TREE_MODEL(self->obj),
                                     &iter, parent))
        return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
#line 115248 "gtk.c"


static PyObject *
_wrap_gtk_tree_model_iter_has_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModel.iter_has_child", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    ret = gtk_tree_model_iter_has_child(GTK_TREE_MODEL(self->obj), iter);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_tree_model_iter_n_children(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter = Py_None;
    GtkTreeIter *iter = NULL;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModel.iter_n_children", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else if (py_iter != Py_None) {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter or None");
        return NULL;
    }
    
    ret = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(self->obj), iter);
    
    return PyInt_FromLong(ret);
}

#line 2414 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_iter_nth_child(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "n", NULL };
    PyObject *py_parent;
    gint n;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oi:GtkTreeModel.iter_nth_child", kwlist,
                                     &py_parent, &n))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent == Py_None)
        parent = NULL;
    else {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkTreeIter or None");
        return NULL;
    }

    if (gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(self->obj),
                                     &iter, parent, n))
        return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
#line 115327 "gtk.c"


#line 2446 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_iter_parent(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyObject *py_child;
    GtkTreeIter iter, *child = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkTreeModel.iter_parent", kwlist,
                                     &py_child))
        return NULL;
    if (pyg_boxed_check(py_child, GTK_TYPE_TREE_ITER))
        child = pyg_boxed_get(py_child, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "child should be a GtkTreeIter");
        return NULL;
    }

    if (gtk_tree_model_iter_parent(GTK_TREE_MODEL(self->obj),
                                   &iter, child))
        return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
#line 115358 "gtk.c"


static PyObject *
_wrap_gtk_tree_model_ref_node(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModel.ref_node", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_tree_model_ref_node(GTK_TREE_MODEL(self->obj), iter);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_model_unref_node(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModel.unref_node", kwlist, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_tree_model_unref_node(GTK_TREE_MODEL(self->obj), iter);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3109 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_get(PyGObject *self, PyObject *args)
{
    PyObject *py_iter, *ret;
    gint len, i, n_columns;
    GtkTreeIter *iter;

    len = PyTuple_Size(args) - 1;

    if (len < 1) {
	PyErr_SetString(PyExc_TypeError,
			"gtk.TreeModel.get requires at least two arguments");
	return NULL;
    }

    py_iter = PyTuple_GetItem(args, 0);
 
    if (!pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER)) {
        PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
        return NULL;
    }
    iter = pyg_boxed_get(py_iter, GtkTreeIter);

    ret = PyTuple_New(len);

    n_columns = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
    for (i = 0; i < len; i++) {
	GValue value = { 0, };
	gint column;
	PyObject *py_column = PyTuple_GetItem(args, i+1);

	if (!PyInt_Check(py_column)) {
	    PyErr_SetString(PyExc_TypeError, "column numbers must be ints");
	    Py_DECREF(ret);
	    return NULL;
	}
	column = PyInt_AsLong(py_column);
	if (column < 0 || column >= n_columns) {
	    PyErr_SetString(PyExc_ValueError, "column number is out of range");
	    Py_DECREF(ret);
	    return NULL;
	}
	gtk_tree_model_get_value(GTK_TREE_MODEL(self->obj), iter,
				 column, &value);
	PyTuple_SetItem(ret, i, pyg_value_as_pyobject(&value, TRUE));
	g_value_unset(&value);
    }
    return ret;
}
#line 115455 "gtk.c"


#line 2475 "gtktreeview.override"
static gboolean
pygtk_tree_foreach_marshal(GtkTreeModel *model,
                           GtkTreePath *path,
                           GtkTreeIter *iter,
                           gpointer data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = data;
    PyObject *py_model, *py_path, *py_iter, *retobj;
    gboolean ret;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_model = pygobject_new((GObject *)model);
    py_path = pygtk_tree_path_to_pyobject(path);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter,  FALSE, FALSE);
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(NNOO)",
                                     py_model, py_path, py_iter,
                                     cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(NNO)",
                                     py_model, py_path, py_iter);

    if (retobj != NULL) {
        ret = PyObject_IsTrue(retobj);
        Py_DECREF(retobj);
    } else {
        ret = TRUE;
    }
    pygtk_boxed_unref_shared(py_iter);
    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_tree_model_foreach(PyGObject *self, PyObject *args)
{
    gboolean pygtk_tree_foreach_marshal(GtkTreeModel *model,
                                           GtkTreePath *path,
                                           GtkTreeIter *iter,
                                           gpointer data);
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;

    if(!PyArg_ParseTuple(args, "O|O:GtkTreeModel.foreach",
                         &pyfunc, &pyarg))
        return NULL;

    cunote.func = pyfunc;
    cunote.data = pyarg;
    gtk_tree_model_foreach(GTK_TREE_MODEL(self->obj),
                           pygtk_tree_foreach_marshal, &cunote);

    if (PyErr_Occurred())
        return NULL;

    Py_INCREF(Py_None);
    return Py_None;
}
#line 115520 "gtk.c"


static PyObject *
_wrap_gtk_tree_model_row_changed(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "iter", NULL };
    PyObject *py_path, *py_iter;
    GtkTreeIter *iter = NULL;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeModel.row_changed", kwlist, &py_path, &py_iter))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_tree_model_row_changed(GTK_TREE_MODEL(self->obj), path, iter);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_model_row_inserted(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "iter", NULL };
    PyObject *py_path, *py_iter;
    GtkTreeIter *iter = NULL;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeModel.row_inserted", kwlist, &py_path, &py_iter))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_tree_model_row_inserted(GTK_TREE_MODEL(self->obj), path, iter);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_model_row_has_child_toggled(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "iter", NULL };
    PyObject *py_path, *py_iter;
    GtkTreeIter *iter = NULL;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:Gtk.TreeModel.row_has_child_toggled", kwlist, &py_path, &py_iter))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    
    gtk_tree_model_row_has_child_toggled(GTK_TREE_MODEL(self->obj), path, iter);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tree_model_row_deleted(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.TreeModel.row_deleted", kwlist, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    
    gtk_tree_model_row_deleted(GTK_TREE_MODEL(self->obj), path);
    
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 875 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_rows_reordered(PyGObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    static char *kwlist[] = { "path", "iter", "new_order", NULL };
    PyObject *py_path, *py_iter, *py_new_order, *sitem;
    GtkTreeIter *iter = NULL;
    GtkTreePath *path;
    gint *new_order;
    gint len_model, len_seq;
    gint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO:GtkTreeModel.rows_reordered", kwlist,
				     &py_path, &py_iter, &py_new_order))
        return NULL;

    if (py_path == Py_None ||
        (PyTuple_Check(py_path) && PyTuple_Size(py_path) == 0) ||
        (PyString_Check(py_path) && PyString_Size(py_path) == 0))
        path = gtk_tree_path_new();
    else
        path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError,
	    "could not convert path to a GtkTreePath");
        return NULL;
    }

    if (py_iter == Py_None)
        iter = NULL;
    else if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        gtk_tree_path_free(path);
        return NULL;
    }

    if (!PySequence_Check(py_new_order)) {
        PyErr_SetString(PyExc_TypeError,
	    "new_order must be a sequence of ints");
        gtk_tree_path_free(path);
        return NULL;
    }

    len_model = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(self->obj), iter);
    len_seq = PySequence_Size(py_new_order);
    if (len_model != len_seq) {
        PyErr_Format(PyExc_ValueError,
	    "new_order should be a sequence with the same size as the "
	    "number of children of iter (%d, is %d)", len_model, len_seq);
        gtk_tree_path_free(path);
        return NULL;
    }

    // Create on stack: much faster, no free() needed.
    new_order = g_newa(gint, len_seq);
    for (i = 0; i < len_seq; i++) {
	sitem = PySequence_GetItem(py_new_order, i);
	Py_DECREF(sitem);
	sitem = PyNumber_Int(sitem);
	if (sitem)
	    new_order[i] = (gint) PyInt_AsLong(sitem);
	else {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "new_order sequence item not an int");
	    gtk_tree_path_free(path);
	    return NULL;
	}
	Py_DECREF(sitem);
    }

    gtk_tree_model_rows_reordered(GTK_TREE_MODEL(self->obj),
				  path, iter, new_order);
    gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 115717 "gtk.c"


static PyObject *
_wrap_gtk_tree_model_filter_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "root", NULL };
    PyObject *py_root = Py_None;
    GtkTreeModel *ret;
    GtkTreePath *root = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.TreeModel.filter_new", kwlist, &py_root))
        return NULL;
    if (py_root != Py_None) {
        root = pygtk_tree_path_from_pyobject(py_root);
        if (!root) {
            PyErr_SetString(PyExc_TypeError, "could not convert root to a GtkTreePath");
            return NULL;
        }
    }
    
    ret = gtk_tree_model_filter_new(GTK_TREE_MODEL(self->obj), root);
    
    if (root)
        gtk_tree_path_free(root);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkTreeModel__do_row_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "path", "iter", NULL };
    PyGObject *self;
    PyObject *py_path, *py_iter;
    GtkTreePath *path;
    GtkTreeIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeModel.row_changed", kwlist, &PyGtkTreeModel_Type, &self, &py_path, &py_iter))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->row_changed)
        iface->row_changed(GTK_TREE_MODEL(self->obj), path, iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.row_changed not implemented");
        return NULL;
    }
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeModel__do_row_inserted(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "path", "iter", NULL };
    PyGObject *self;
    PyObject *py_path, *py_iter;
    GtkTreePath *path;
    GtkTreeIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeModel.row_inserted", kwlist, &PyGtkTreeModel_Type, &self, &py_path, &py_iter))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->row_inserted)
        iface->row_inserted(GTK_TREE_MODEL(self->obj), path, iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.row_inserted not implemented");
        return NULL;
    }
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeModel__do_row_has_child_toggled(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "path", "iter", NULL };
    PyGObject *self;
    PyObject *py_path, *py_iter;
    GtkTreePath *path;
    GtkTreeIter *iter = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeModel.row_has_child_toggled", kwlist, &PyGtkTreeModel_Type, &self, &py_path, &py_iter))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->row_has_child_toggled)
        iface->row_has_child_toggled(GTK_TREE_MODEL(self->obj), path, iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.row_has_child_toggled not implemented");
        return NULL;
    }
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeModel__do_row_deleted(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "path", NULL };
    PyGObject *self;
    PyObject *py_path;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeModel.row_deleted", kwlist, &PyGtkTreeModel_Type, &self, &py_path))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->row_deleted)
        iface->row_deleted(GTK_TREE_MODEL(self->obj), path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.row_deleted not implemented");
        return NULL;
    }
    if (path)
        gtk_tree_path_free(path);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeModel__do_get_flags(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    guint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeModel.get_flags", kwlist, &PyGtkTreeModel_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->get_flags)
        ret = iface->get_flags(GTK_TREE_MODEL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.get_flags not implemented");
        return NULL;
    }
    return pyg_flags_from_gtype(GTK_TYPE_TREE_MODEL_FLAGS, ret);
}

static PyObject *
_wrap_GtkTreeModel__do_get_n_columns(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeModel.get_n_columns", kwlist, &PyGtkTreeModel_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->get_n_columns)
        ret = iface->get_n_columns(GTK_TREE_MODEL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.get_n_columns not implemented");
        return NULL;
    }
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_GtkTreeModel__do_get_column_type(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "index_", NULL };
    PyGObject *self;
    int index_;
    GType ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.TreeModel.get_column_type", kwlist, &PyGtkTreeModel_Type, &self, &index_))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->get_column_type)
        ret = iface->get_column_type(GTK_TREE_MODEL(self->obj), index_);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.get_column_type not implemented");
        return NULL;
    }
    return pyg_type_wrapper_new(ret);
}

static PyObject *
_wrap_GtkTreeModel__do_get_iter(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "iter", "path", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    int ret;
    GtkTreePath *path;
    PyObject *py_iter, *py_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeModel.get_iter", kwlist, &PyGtkTreeModel_Type, &self, &py_iter, &py_path))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->get_iter)
        ret = iface->get_iter(GTK_TREE_MODEL(self->obj), iter, path);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.get_iter not implemented");
        return NULL;
    }
    if (path)
        gtk_tree_path_free(path);
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeModel__do_get_path(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "iter", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    GtkTreePath *ret;
    PyObject *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeModel.get_path", kwlist, &PyGtkTreeModel_Type, &self, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->get_path)
        ret = iface->get_path(GTK_TREE_MODEL(self->obj), iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.get_path not implemented");
        return NULL;
    }
    if (ret) {
        PyObject *py_ret = pygtk_tree_path_to_pyobject(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeModel__do_iter_next(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "iter", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    int ret;
    PyObject *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeModel.iter_next", kwlist, &PyGtkTreeModel_Type, &self, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->iter_next)
        ret = iface->iter_next(GTK_TREE_MODEL(self->obj), iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.iter_next not implemented");
        return NULL;
    }
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeModel__do_iter_children(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "iter", "parent", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL, *parent = NULL;
    int ret;
    PyObject *py_iter, *py_parent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeModel.iter_children", kwlist, &PyGtkTreeModel_Type, &self, &py_iter, &py_parent))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->iter_children)
        ret = iface->iter_children(GTK_TREE_MODEL(self->obj), iter, parent);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.iter_children not implemented");
        return NULL;
    }
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeModel__do_iter_has_child(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "iter", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    int ret;
    PyObject *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeModel.iter_has_child", kwlist, &PyGtkTreeModel_Type, &self, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->iter_has_child)
        ret = iface->iter_has_child(GTK_TREE_MODEL(self->obj), iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.iter_has_child not implemented");
        return NULL;
    }
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeModel__do_iter_n_children(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "iter", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    int ret;
    PyObject *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeModel.iter_n_children", kwlist, &PyGtkTreeModel_Type, &self, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->iter_n_children)
        ret = iface->iter_n_children(GTK_TREE_MODEL(self->obj), iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.iter_n_children not implemented");
        return NULL;
    }
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_GtkTreeModel__do_iter_nth_child(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "iter", "parent", "n", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL, *parent = NULL;
    int n, ret;
    PyObject *py_iter, *py_parent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OOi:Gtk.TreeModel.iter_nth_child", kwlist, &PyGtkTreeModel_Type, &self, &py_iter, &py_parent, &n))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->iter_nth_child)
        ret = iface->iter_nth_child(GTK_TREE_MODEL(self->obj), iter, parent, n);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.iter_nth_child not implemented");
        return NULL;
    }
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeModel__do_iter_parent(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "iter", "child", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL, *child = NULL;
    int ret;
    PyObject *py_iter, *py_child;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:Gtk.TreeModel.iter_parent", kwlist, &PyGtkTreeModel_Type, &self, &py_iter, &py_child))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    if (pyg_boxed_check(py_child, GTK_TYPE_TREE_ITER))
        child = pyg_boxed_get(py_child, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "child should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->iter_parent)
        ret = iface->iter_parent(GTK_TREE_MODEL(self->obj), iter, child);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.iter_parent not implemented");
        return NULL;
    }
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeModel__do_ref_node(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "iter", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    PyObject *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeModel.ref_node", kwlist, &PyGtkTreeModel_Type, &self, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->ref_node)
        iface->ref_node(GTK_TREE_MODEL(self->obj), iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.ref_node not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkTreeModel__do_unref_node(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeModelIface *iface;
    static char *kwlist[] = { "self", "iter", NULL };
    PyGObject *self;
    GtkTreeIter *iter = NULL;
    PyObject *py_iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:Gtk.TreeModel.unref_node", kwlist, &PyGtkTreeModel_Type, &self, &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_MODEL);
    if (iface->unref_node)
        iface->unref_node(GTK_TREE_MODEL(self->obj), iter);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeModel.unref_node not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkTreeModel_methods[] = {
    { "get_flags", (PyCFunction)_wrap_gtk_tree_model_get_flags, METH_NOARGS,
      NULL },
    { "get_n_columns", (PyCFunction)_wrap_gtk_tree_model_get_n_columns, METH_NOARGS,
      NULL },
    { "get_column_type", (PyCFunction)_wrap_gtk_tree_model_get_column_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_iter", (PyCFunction)_wrap_gtk_tree_model_get_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_iter_from_string", (PyCFunction)_wrap_gtk_tree_model_get_iter_from_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_string_from_iter", (PyCFunction)_wrap_gtk_tree_model_get_string_from_iter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_iter_root", (PyCFunction)_wrap_gtk_tree_model_get_iter_first, METH_NOARGS,
      NULL },
    { "get_iter_first", (PyCFunction)_wrap_gtk_tree_model_get_iter_first, METH_NOARGS,
      NULL },
    { "get_path", (PyCFunction)_wrap_gtk_tree_model_get_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_value", (PyCFunction)_wrap_gtk_tree_model_get_value, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "iter_next", (PyCFunction)_wrap_gtk_tree_model_iter_next, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "iter_children", (PyCFunction)_wrap_gtk_tree_model_iter_children, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "iter_has_child", (PyCFunction)_wrap_gtk_tree_model_iter_has_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "iter_n_children", (PyCFunction)_wrap_gtk_tree_model_iter_n_children, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "iter_nth_child", (PyCFunction)_wrap_gtk_tree_model_iter_nth_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "iter_parent", (PyCFunction)_wrap_gtk_tree_model_iter_parent, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "ref_node", (PyCFunction)_wrap_gtk_tree_model_ref_node, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unref_node", (PyCFunction)_wrap_gtk_tree_model_unref_node, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get", (PyCFunction)_wrap_gtk_tree_model_get, METH_VARARGS,
      NULL },
    { "foreach", (PyCFunction)_wrap_gtk_tree_model_foreach, METH_VARARGS,
      NULL },
    { "row_changed", (PyCFunction)_wrap_gtk_tree_model_row_changed, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "row_inserted", (PyCFunction)_wrap_gtk_tree_model_row_inserted, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "row_has_child_toggled", (PyCFunction)_wrap_gtk_tree_model_row_has_child_toggled, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "row_deleted", (PyCFunction)_wrap_gtk_tree_model_row_deleted, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rows_reordered", (PyCFunction)_wrap_gtk_tree_model_rows_reordered, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "filter_new", (PyCFunction)_wrap_gtk_tree_model_filter_new, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_row_changed", (PyCFunction)_wrap_GtkTreeModel__do_row_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_row_inserted", (PyCFunction)_wrap_GtkTreeModel__do_row_inserted, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_row_has_child_toggled", (PyCFunction)_wrap_GtkTreeModel__do_row_has_child_toggled, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_row_deleted", (PyCFunction)_wrap_GtkTreeModel__do_row_deleted, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_flags", (PyCFunction)_wrap_GtkTreeModel__do_get_flags, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_n_columns", (PyCFunction)_wrap_GtkTreeModel__do_get_n_columns, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_column_type", (PyCFunction)_wrap_GtkTreeModel__do_get_column_type, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_iter", (PyCFunction)_wrap_GtkTreeModel__do_get_iter, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_path", (PyCFunction)_wrap_GtkTreeModel__do_get_path, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_iter_next", (PyCFunction)_wrap_GtkTreeModel__do_iter_next, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_iter_children", (PyCFunction)_wrap_GtkTreeModel__do_iter_children, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_iter_has_child", (PyCFunction)_wrap_GtkTreeModel__do_iter_has_child, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_iter_n_children", (PyCFunction)_wrap_GtkTreeModel__do_iter_n_children, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_iter_nth_child", (PyCFunction)_wrap_GtkTreeModel__do_iter_nth_child, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_iter_parent", (PyCFunction)_wrap_GtkTreeModel__do_iter_parent, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_ref_node", (PyCFunction)_wrap_GtkTreeModel__do_ref_node, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unref_node", (PyCFunction)_wrap_GtkTreeModel__do_unref_node, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

#line 957 "gtktreeview.override"
static int
_wrap_gtk_tree_model_tp_nonzero(PyGObject *self)
{
    return TRUE;
}
static PyNumberMethods _wrap_gtk_tree_model_tp_as_number = {
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (ternaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (inquiry)_wrap_gtk_tree_model_tp_nonzero,
    (unaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (coercion)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0
};
#line 116382 "gtk.c"


#line 989 "gtktreeview.override"
static Py_ssize_t
_wrap_gtk_tree_model_tp_length(PyGObject *self)
{
    return gtk_tree_model_iter_n_children(GTK_TREE_MODEL(self->obj), NULL);
}
static PyObject *
_wrap_gtk_tree_model_tp_getitem(PyGObject *self, PyObject *item)
{
    GtkTreePath *path = NULL;
    GtkTreeIter iter;
    PyObject *ret = NULL;

    if (pyg_boxed_check(item, GTK_TYPE_TREE_ITER)) {
        return _pygtk_tree_model_row_new(GTK_TREE_MODEL(self->obj),
                                         pyg_boxed_get(item, GtkTreeIter));
    }

    if (PyInt_Check(item)) {
	int value = PyInt_AsLong(item);

	if (value < 0) {
            PyObject *inverse;

            /* Since value is always negative at this point,
	     * we need to do an invertion.
	     */
            value = _wrap_gtk_tree_model_tp_length(self) - -value;
            inverse = PyInt_FromLong(value);
            if (!inverse)
                return NULL;

            path = pygtk_tree_path_from_pyobject(inverse);
            Py_DECREF(inverse);
	}
    }

    if (!path)
        path = pygtk_tree_path_from_pyobject(item);

    if (!path) {
        PyErr_SetString(PyExc_TypeError,
                        "could not parse subscript as a tree path");
        return  NULL;
    }
    if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
        ret = _pygtk_tree_model_row_new(GTK_TREE_MODEL(self->obj), &iter);
    } else {
        PyErr_SetString(PyExc_IndexError, "could not find tree path");
        ret = NULL;
    }
    gtk_tree_path_free(path);
    return ret;
}
static int
_wrap_gtk_tree_model_tp_setitem(PyGObject *self, PyObject *item,
                                PyObject *value)
{
    GtkTreeIter *iter, iter2;

    if (pyg_boxed_check(item, GTK_TYPE_TREE_ITER)) {
        iter = pyg_boxed_get(item, GtkTreeIter);
    } else {
        GtkTreePath *path = NULL;

	if (PyInt_Check(item)) {
	    int value = PyInt_AsLong(item);

	    if (value < 0) {
                PyObject *inverse;

                /* Since value is always negative at this point,
		 * we need to do an invertion.
		 */
                value = _wrap_gtk_tree_model_tp_length(self) - -value;
                inverse = PyInt_FromLong(value);
                if (!inverse)
                    return -1;

                path = pygtk_tree_path_from_pyobject(inverse);
                Py_DECREF(inverse);
	    }
	}

        if (!path)
            path = pygtk_tree_path_from_pyobject(item);

        if (!path) {
            PyErr_SetString(PyExc_TypeError,
                            "could not parse subscript as a tree path");
            return  -1;
        }
        if (!gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter2,path)) {
            PyErr_SetString(PyExc_TypeError, "could not find tree path");
            gtk_tree_path_free(path);
            return -1;
        }
        iter = &iter2;
        gtk_tree_path_free(path);
    }

    if (value == NULL) {
        return _pygtk_tree_model_remove_row(GTK_TREE_MODEL(self->obj), iter);
    } else {
        return _pygtk_tree_model_set_row(GTK_TREE_MODEL(self->obj),
                                         iter, value);
    }
}

static PyMappingMethods _wrap_gtk_tree_model_tp_as_mapping = {
    (lenfunc)_wrap_gtk_tree_model_tp_length,
    (binaryfunc)_wrap_gtk_tree_model_tp_getitem,
    (objobjargproc)_wrap_gtk_tree_model_tp_setitem
};
#line 116499 "gtk.c"


#line 1104 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_model_tp_iter(PyGObject *self)
{
    return _pygtk_tree_model_row_iter_new(GTK_TREE_MODEL(self->obj), NULL);
}
#line 116508 "gtk.c"


PyTypeObject G_GNUC_INTERNAL PyGtkTreeModel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeModel",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)&_wrap_gtk_tree_model_tp_as_number,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)&_wrap_gtk_tree_model_tp_as_mapping,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_gtk_tree_model_tp_iter,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeModel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkTreeModel__proxy_do_row_changed(GtkTreeModel *self, GtkTreePath*path, GtkTreeIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path;
    PyObject *py_iter;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    PyTuple_SET_ITEM(py_args, 1, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_row_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTreeModel__proxy_do_row_inserted(GtkTreeModel *self, GtkTreePath*path, GtkTreeIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path;
    PyObject *py_iter;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    PyTuple_SET_ITEM(py_args, 1, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_row_inserted");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTreeModel__proxy_do_row_has_child_toggled(GtkTreeModel *self, GtkTreePath*path, GtkTreeIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path;
    PyObject *py_iter;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    PyTuple_SET_ITEM(py_args, 1, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_row_has_child_toggled");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTreeModel__proxy_do_row_deleted(GtkTreeModel *self, GtkTreePath*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_path;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_row_deleted");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GtkTreeModelFlags
_wrap_GtkTreeModel__proxy_do_get_flags(GtkTreeModel *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkTreeModelFlags retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_flags");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    if (pyg_flags_get_value(GTK_TYPE_TREE_MODEL_FLAGS, py_retval, (gint *)&retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gint
_wrap_GtkTreeModel__proxy_do_get_n_columns(GtkTreeModel *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gint retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_n_columns");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "i", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeModel__proxy_do_get_iter(GtkTreeModel *self, GtkTreeIter*iter, GtkTreePath*path)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    PyObject *py_path;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    py_path = pygtk_tree_path_to_pyobject(path);
    if (!py_path) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_iter);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    PyTuple_SET_ITEM(py_args, 1, py_path);
    
    py_method = PyObject_GetAttrString(py_self, "do_get_iter");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static GtkTreePath*
_wrap_GtkTreeModel__proxy_do_get_path(GtkTreeModel *self, GtkTreeIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    GtkTreePath * retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_get_path");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = pygtk_tree_path_from_pyobject(py_retval);
    if (!retval) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GtkTreePath");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeModel__proxy_do_iter_next(GtkTreeModel *self, GtkTreeIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_iter_next");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeModel__proxy_do_iter_children(GtkTreeModel *self, GtkTreeIter*iter, GtkTreeIter*parent)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    PyObject *py_parent;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    py_parent = pyg_boxed_new(GTK_TYPE_TREE_ITER, parent, FALSE, FALSE);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    PyTuple_SET_ITEM(py_args, 1, py_parent);
    
    py_method = PyObject_GetAttrString(py_self, "do_iter_children");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeModel__proxy_do_iter_has_child(GtkTreeModel *self, GtkTreeIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_iter_has_child");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gint
_wrap_GtkTreeModel__proxy_do_iter_n_children(GtkTreeModel *self, GtkTreeIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    gint retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_iter_n_children");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "i", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeModel__proxy_do_iter_nth_child(GtkTreeModel *self, GtkTreeIter*iter, GtkTreeIter*parent, gint n)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    PyObject *py_parent;
    PyObject *py_n;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    py_parent = pyg_boxed_new(GTK_TYPE_TREE_ITER, parent, FALSE, FALSE);
    py_n = PyInt_FromLong(n);
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    PyTuple_SET_ITEM(py_args, 1, py_parent);
    PyTuple_SET_ITEM(py_args, 2, py_n);
    
    py_method = PyObject_GetAttrString(py_self, "do_iter_nth_child");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkTreeModel__proxy_do_iter_parent(GtkTreeModel *self, GtkTreeIter*iter, GtkTreeIter*child)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    PyObject *py_child;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    py_child = pyg_boxed_new(GTK_TYPE_TREE_ITER, child, FALSE, FALSE);
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    PyTuple_SET_ITEM(py_args, 1, py_child);
    
    py_method = PyObject_GetAttrString(py_self, "do_iter_parent");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkTreeModel__proxy_do_ref_node(GtkTreeModel *self, GtkTreeIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_ref_node");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkTreeModel__proxy_do_unref_node(GtkTreeModel *self, GtkTreeIter*iter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_iter;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, FALSE, FALSE);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_iter);
    
    py_method = PyObject_GetAttrString(py_self, "do_unref_node");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static void
__GtkTreeModel__interface_init(GtkTreeModelIface *iface, PyTypeObject *pytype)
{
    GtkTreeModelIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_row_changed") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->row_changed = _wrap_GtkTreeModel__proxy_do_row_changed;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->row_changed = parent_iface->row_changed;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_row_inserted") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->row_inserted = _wrap_GtkTreeModel__proxy_do_row_inserted;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->row_inserted = parent_iface->row_inserted;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_row_has_child_toggled") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->row_has_child_toggled = _wrap_GtkTreeModel__proxy_do_row_has_child_toggled;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->row_has_child_toggled = parent_iface->row_has_child_toggled;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_row_deleted") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->row_deleted = _wrap_GtkTreeModel__proxy_do_row_deleted;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->row_deleted = parent_iface->row_deleted;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_flags") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_flags = _wrap_GtkTreeModel__proxy_do_get_flags;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_flags = parent_iface->get_flags;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_n_columns") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_n_columns = _wrap_GtkTreeModel__proxy_do_get_n_columns;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_n_columns = parent_iface->get_n_columns;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_iter") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_iter = _wrap_GtkTreeModel__proxy_do_get_iter;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_iter = parent_iface->get_iter;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_path") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_path = _wrap_GtkTreeModel__proxy_do_get_path;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_path = parent_iface->get_path;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_iter_next") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->iter_next = _wrap_GtkTreeModel__proxy_do_iter_next;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->iter_next = parent_iface->iter_next;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_iter_children") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->iter_children = _wrap_GtkTreeModel__proxy_do_iter_children;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->iter_children = parent_iface->iter_children;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_iter_has_child") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->iter_has_child = _wrap_GtkTreeModel__proxy_do_iter_has_child;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->iter_has_child = parent_iface->iter_has_child;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_iter_n_children") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->iter_n_children = _wrap_GtkTreeModel__proxy_do_iter_n_children;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->iter_n_children = parent_iface->iter_n_children;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_iter_nth_child") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->iter_nth_child = _wrap_GtkTreeModel__proxy_do_iter_nth_child;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->iter_nth_child = parent_iface->iter_nth_child;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_iter_parent") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->iter_parent = _wrap_GtkTreeModel__proxy_do_iter_parent;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->iter_parent = parent_iface->iter_parent;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_ref_node") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->ref_node = _wrap_GtkTreeModel__proxy_do_ref_node;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->ref_node = parent_iface->ref_node;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_unref_node") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->unref_node = _wrap_GtkTreeModel__proxy_do_unref_node;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->unref_node = parent_iface->unref_node;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkTreeModel__iinfo = {
    (GInterfaceInitFunc) __GtkTreeModel__interface_init,
    NULL,
    NULL
};


/* ----------- GtkTreeSortable ----------- */

static PyObject *
_wrap_gtk_tree_sortable_sort_column_changed(PyGObject *self)
{
    
    gtk_tree_sortable_sort_column_changed(GTK_TREE_SORTABLE(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1111 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_sortable_get_sort_column_id(PyGObject *self)
{
    gboolean ret;
    gint sort_column_id;
    GtkSortType order;

    ret = gtk_tree_sortable_get_sort_column_id(GTK_TREE_SORTABLE(self->obj),
                                               &sort_column_id, &order);

    /* if we don't have a sort column set, return (None, None) */
    if (ret)
        return Py_BuildValue("(iN)", sort_column_id,
			     pyg_enum_from_gtype(GTK_TYPE_SORT_TYPE, order));
    else
        return Py_BuildValue("(OO)", Py_None, Py_None);
}
#line 117832 "gtk.c"


static PyObject *
_wrap_gtk_tree_sortable_set_sort_column_id(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sort_column_id", "order", NULL };
    int sort_column_id;
    PyObject *py_order = NULL;
    GtkSortType order;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"iO:Gtk.TreeSortable.set_sort_column_id", kwlist, &sort_column_id, &py_order))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SORT_TYPE, py_order, (gpointer)&order))
        return NULL;
    
    gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->obj), sort_column_id, order);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1130 "gtktreeview.override"
static gint
pygtk_tree_sortable_sort_cb(GtkTreeModel *model, GtkTreeIter *iter1,
                            GtkTreeIter *iter2, gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_model, *py_iter2, *py_iter1, *retobj;
    gint ret = 0;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_model = pygobject_new((GObject *)model);
    py_iter1 = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter1, FALSE, FALSE);
    py_iter2 = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter2,  FALSE, FALSE);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NOOO)", py_model,
                                     py_iter1, py_iter2, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NOO)", py_model,
                                     py_iter1, py_iter2);
    }
    pygtk_boxed_unref_shared(py_iter1);
    pygtk_boxed_unref_shared(py_iter2);
    if (retobj)
        ret = PyInt_AsLong(retobj);
    if (PyErr_Occurred()) {
        PyErr_Print();
        ret = 0;
    }
    Py_XDECREF(retobj);

    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_tree_sortable_set_sort_func(PyGObject *self, PyObject *args)
{
    gint column;
    PyObject *callback, *data = NULL;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTuple(args, "iO|O:GtkTreeSortable.set_sort_func",
                          &column, &callback, &data))
        return NULL;

    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "callback must be a callable object");
        return NULL;
    }
    cunote = g_new(PyGtkCustomNotify, 1);
    Py_INCREF(callback);
    cunote->func = callback;
    Py_XINCREF(data);
    cunote->data = data;

    gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(self->obj), column,
                                    pygtk_tree_sortable_sort_cb, cunote,
                                    pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 117920 "gtk.c"


#line 1197 "gtktreeview.override"
static PyObject *
_wrap_gtk_tree_sortable_set_default_sort_func(PyGObject *self, PyObject *args)
{
    PyObject *callback, *data = NULL;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTuple(args, "O|O:GtkTreeSortable.set_default_sort_func",
                          &callback, &data))
        return NULL;

    if (callback == Py_None) {
	gtk_tree_sortable_set_default_sort_func(GTK_TREE_SORTABLE(self->obj),
						NULL,
						NULL,
						NULL);
	goto beach;
    }
    
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "callback must be a callable object");
        return NULL;
    }
    cunote = g_new(PyGtkCustomNotify, 1);
    Py_INCREF(callback);
    cunote->func = callback;
    Py_XINCREF(data);
    cunote->data = data;

    gtk_tree_sortable_set_default_sort_func(GTK_TREE_SORTABLE(self->obj),
                                            pygtk_tree_sortable_sort_cb,
                                            cunote,
                                            pygtk_custom_destroy_notify);
 beach:
    Py_INCREF(Py_None);
    return Py_None;
}
#line 117960 "gtk.c"


static PyObject *
_wrap_gtk_tree_sortable_has_default_sort_func(PyGObject *self)
{
    int ret;

    
    ret = gtk_tree_sortable_has_default_sort_func(GTK_TREE_SORTABLE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkTreeSortable__do_sort_column_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeSortableIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeSortable.sort_column_changed", kwlist, &PyGtkTreeSortable_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_SORTABLE);
    if (iface->sort_column_changed)
        iface->sort_column_changed(GTK_TREE_SORTABLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeSortable.sort_column_changed not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1235 "gtktreeview.override"
static PyObject *
_wrap_GtkTreeSortable__do_get_sort_column_id(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "self", NULL };
    GtkTreeSortableIface *iface;
    PyGObject *self;
    gint sort_column_id;
    GtkSortType order;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:gtk.TreeSortable.do_get_sort_column_id", kwlist, &PyGtkTreeSortable_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_SORTABLE);
    if (iface->get_sort_column_id)
        iface->get_sort_column_id(GTK_TREE_SORTABLE(self->obj), &sort_column_id, &order);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method gtk.TreeSortable.get_sort_column_id not implemented");
        return NULL;
    }

    return Py_BuildValue("(iN)", sort_column_id, pyg_enum_from_gtype(GTK_TYPE_SORT_TYPE, order));
}
#line 118017 "gtk.c"


static PyObject *
_wrap_GtkTreeSortable__do_set_sort_column_id(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeSortableIface *iface;
    static char *kwlist[] = { "self", "sort_column_id", "order", NULL };
    PyGObject *self;
    int sort_column_id;
    PyObject *py_order = NULL;
    GtkSortType order;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iO:Gtk.TreeSortable.set_sort_column_id", kwlist, &PyGtkTreeSortable_Type, &self, &sort_column_id, &py_order))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SORT_TYPE, py_order, (gpointer)&order))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_SORTABLE);
    if (iface->set_sort_column_id)
        iface->set_sort_column_id(GTK_TREE_SORTABLE(self->obj), sort_column_id, order);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeSortable.set_sort_column_id not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1323 "gtktreeview.override"
static PyObject *
_wrap_GtkTreeSortable__do_set_sort_func(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "self", "sort_column_id", "func", "user_data", NULL };
    GtkTreeSortableIface *iface;
    PyGObject *self;
    gint sort_column_id;
    PyObject *func;
    PyObject *user_data;
    PyGtkCustomNotify *func_wrapper;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!iO|O:gtk.TreeSortable.do_set_sort_func", kwlist,
                                     &PyGtkTreeSortable_Type, &self,
                                     &sort_column_id, &func, &user_data))
        return NULL;

    if (!PyCallable_Check(func)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }

    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_SORTABLE);
    if (!iface->set_sort_func) {
        PyErr_SetString(PyExc_NotImplementedError,
                        "interface method gtk.TreeSortable.set_sort_func not implemented");
        return NULL;
    }

    func_wrapper = g_new(PyGtkCustomNotify, 1);
    func_wrapper->func = func;
    Py_INCREF(func_wrapper->func);
    func_wrapper->data = user_data;
    Py_XINCREF(func_wrapper->data);

    iface->set_sort_func(GTK_TREE_SORTABLE(self->obj), sort_column_id,
                         pygtk_tree_sortable_sort_cb, func_wrapper, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 118086 "gtk.c"


#line 1365 "gtktreeview.override"
static PyObject *
_wrap_GtkTreeSortable__do_set_default_sort_func(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "self", "func", "user_data", NULL };
    GtkTreeSortableIface *iface;
    PyGObject *self;
    PyObject *func;
    PyObject *user_data;
    PyGtkCustomNotify *func_wrapper;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!iO|O:gtk.TreeSortable.do_set_default_sort_func", kwlist,
                                     &PyGtkTreeSortable_Type, &self,
                                     &func, &user_data))
        return NULL;

    if (!PyCallable_Check(func)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    }

    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_SORTABLE);
    if (!iface->set_default_sort_func) {
        PyErr_SetString(PyExc_NotImplementedError,
                        "interface method gtk.TreeSortable.set_default_sort_func not implemented");
        return NULL;
    }

    func_wrapper = g_new(PyGtkCustomNotify, 1);
    func_wrapper->func = func;
    Py_INCREF(func_wrapper->func);
    func_wrapper->data = user_data;
    Py_XINCREF(func_wrapper->data);

    iface->set_default_sort_func(GTK_TREE_SORTABLE(self->obj),
                                 pygtk_tree_sortable_sort_cb, func_wrapper, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 118130 "gtk.c"


static PyObject *
_wrap_GtkTreeSortable__do_has_default_sort_func(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkTreeSortableIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    int ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.TreeSortable.has_default_sort_func", kwlist, &PyGtkTreeSortable_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TREE_SORTABLE);
    if (iface->has_default_sort_func)
        ret = iface->has_default_sort_func(GTK_TREE_SORTABLE(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.TreeSortable.has_default_sort_func not implemented");
        return NULL;
    }
    return PyBool_FromLong(ret);

}

static const PyMethodDef _PyGtkTreeSortable_methods[] = {
    { "sort_column_changed", (PyCFunction)_wrap_gtk_tree_sortable_sort_column_changed, METH_NOARGS,
      NULL },
    { "get_sort_column_id", (PyCFunction)_wrap_gtk_tree_sortable_get_sort_column_id, METH_NOARGS,
      NULL },
    { "set_sort_column_id", (PyCFunction)_wrap_gtk_tree_sortable_set_sort_column_id, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_sort_func", (PyCFunction)_wrap_gtk_tree_sortable_set_sort_func, METH_VARARGS,
      NULL },
    { "set_default_sort_func", (PyCFunction)_wrap_gtk_tree_sortable_set_default_sort_func, METH_VARARGS,
      NULL },
    { "has_default_sort_func", (PyCFunction)_wrap_gtk_tree_sortable_has_default_sort_func, METH_NOARGS,
      NULL },
    { "do_sort_column_changed", (PyCFunction)_wrap_GtkTreeSortable__do_sort_column_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_sort_column_id", (PyCFunction)_wrap_GtkTreeSortable__do_get_sort_column_id, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_sort_column_id", (PyCFunction)_wrap_GtkTreeSortable__do_set_sort_column_id, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_set_sort_func", (PyCFunction)_wrap_GtkTreeSortable__do_set_sort_func, METH_VARARGS|METH_CLASS,
      NULL },
    { "do_set_default_sort_func", (PyCFunction)_wrap_GtkTreeSortable__do_set_default_sort_func, METH_VARARGS|METH_CLASS,
      NULL },
    { "do_has_default_sort_func", (PyCFunction)_wrap_GtkTreeSortable__do_has_default_sort_func, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkTreeSortable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.TreeSortable",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkTreeSortable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkTreeSortable__proxy_do_sort_column_changed(GtkTreeSortable *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_sort_column_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
#line 1258 "gtktreeview.override"
static gboolean
_wrap_GtkTreeSortable__proxy_do_get_sort_column_id(GtkTreeSortable *self, gint *sort_column_id, GtkSortType *order)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    gint py_sort_column_id;
    PyObject *py_order;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_method = PyObject_GetAttrString(py_self, "do_get_sort_column_id");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (!PyArg_ParseTuple(py_retval, "iO", &py_sort_column_id, &py_order)) {
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (sort_column_id)
        *sort_column_id = py_sort_column_id;
    if (order && pyg_enum_get_value(GTK_TYPE_SORT_TYPE, py_order, (gint *) order)) {
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }

    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);

    return py_order >= 0;
}
#line 118343 "gtk.c"


static void
_wrap_GtkTreeSortable__proxy_do_set_sort_column_id(GtkTreeSortable *self, gint sort_column_id, GtkSortType order)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_sort_column_id;
    PyObject *py_order;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_sort_column_id = PyInt_FromLong(sort_column_id);
    py_order = pyg_enum_from_gtype(GTK_TYPE_SORT_TYPE, order);
    if (!py_order) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_sort_column_id);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_sort_column_id);
    PyTuple_SET_ITEM(py_args, 1, py_order);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_sort_column_id");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
#line 1407 "gtktreeview.override"

typedef struct {
  GtkTreeIterCompareFunc func;
  gpointer               data;
  GDestroyNotify         destroy;
} _PyGTKIterCompareFuncWrapper;

static PyObject *
_pygtk_tree_iter_compare_func_wrapper__call(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", "iter1", "iter2", NULL };

    PyObject *py_model;
    PyObject *py_iter1;
    PyObject *py_iter2;
    _PyGTKIterCompareFuncWrapper *wrapper;
    int result;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O!O!", kwlist,
                                     &PyGtkTreeModel_Type, &py_model,
                                     &PyGtkTreeIter_Type, &py_iter1,
                                     &PyGtkTreeIter_Type, &py_iter2))
        return NULL;

    wrapper = (_PyGTKIterCompareFuncWrapper *) PyCObject_AsVoidPtr(self);
    result = (*wrapper->func) (GTK_TREE_MODEL(((PyGObject *) py_model)->obj),
                               pyg_boxed_get(py_iter1, GtkTreeIter),
                               pyg_boxed_get(py_iter2, GtkTreeIter),
                               wrapper->data);

    return PyInt_FromLong(result);
}

static void
_pygtk_tree_iter_compare_func_wrapper__destroy(void *wrapper_)
{
    _PyGTKIterCompareFuncWrapper *wrapper = (_PyGTKIterCompareFuncWrapper *) wrapper_;

    if (wrapper->destroy)
        (*wrapper->destroy) (wrapper->data);

    g_slice_free(_PyGTKIterCompareFuncWrapper, wrapper);
}

static PyObject *
_wrap_tree_iter_compare_func(GtkTreeIterCompareFunc func, gpointer data, GDestroyNotify destroy)
{
    static PyMethodDef wrapper_method
        = { "_iter_compare", (PyCFunction) _pygtk_tree_iter_compare_func_wrapper__call,
            METH_VARARGS | METH_KEYWORDS, NULL };

    _PyGTKIterCompareFuncWrapper *wrapper;
    PyObject *py_wrapper;
    PyObject *result;

    if (!func) {
        if (destroy)
            (*destroy) (data);

        Py_INCREF(Py_None);
        return Py_None;
    }

    wrapper = g_slice_new(_PyGTKIterCompareFuncWrapper);
    wrapper->func = func;
    wrapper->data = data;
    wrapper->destroy = destroy;

    py_wrapper = PyCObject_FromVoidPtr(wrapper, _pygtk_tree_iter_compare_func_wrapper__destroy);
    if (!py_wrapper) {
        _pygtk_tree_iter_compare_func_wrapper__destroy(wrapper);
        return NULL;
    }

    result = PyCFunction_New(&wrapper_method, py_wrapper);
    Py_DECREF(py_wrapper);

    return result;
}

static void
_do_proxy_do_set_sort_func(GtkTreeSortable *self, gboolean default_,
                           gint sort_column_id,
                           GtkTreeIterCompareFunc func,
                           gpointer data,
                           GDestroyNotify destroy)
{
    PyGILState_STATE py_state = pyg_gil_state_ensure ();
    PyObject *py_self = NULL;
    PyObject *py_func = NULL;
    PyObject *result = NULL;

    py_self = pygobject_new(G_OBJECT(self));
    if (!py_self)
        goto error;

    py_func = _wrap_tree_iter_compare_func(func, data, destroy);
    if (!py_func)
        goto error;

    if (default_)
        result = PyObject_CallMethod(py_self, "do_set_default_sort_func", "O", py_func);
    else
        result = PyObject_CallMethod(py_self, "do_set_sort_func", "iO", sort_column_id, py_func);

    if (!result)
        goto error;

 done:
    Py_XDECREF(py_self);
    Py_XDECREF(py_func);
    Py_XDECREF(result);
  
    pyg_gil_state_release (py_state);

    return;

 error:
    if (PyErr_Occurred ())
        PyErr_Print ();

    goto done;
}

static void
_wrap_GtkTreeSortable__proxy_do_set_sort_func(GtkTreeSortable *self,
                                              gint sort_column_id,
                                              GtkTreeIterCompareFunc func,
                                              gpointer data,
                                              GDestroyNotify destroy)
{
    _do_proxy_do_set_sort_func(self, FALSE, sort_column_id, func, data, destroy);
}
#line 118552 "gtk.c"


#line 1542 "gtktreeview.override"
static void
_wrap_GtkTreeSortable__proxy_do_set_default_sort_func(GtkTreeSortable *self,
                                                      GtkTreeIterCompareFunc func,
                                                      gpointer data,
                                                      GDestroyNotify destroy)
{
    _do_proxy_do_set_sort_func(self, TRUE, 0, func, data, destroy);
}

#line 118565 "gtk.c"


static gboolean
_wrap_GtkTreeSortable__proxy_do_has_default_sort_func(GtkTreeSortable *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_has_default_sort_func");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static void
__GtkTreeSortable__interface_init(GtkTreeSortableIface *iface, PyTypeObject *pytype)
{
    GtkTreeSortableIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_sort_column_changed") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->sort_column_changed = _wrap_GtkTreeSortable__proxy_do_sort_column_changed;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->sort_column_changed = parent_iface->sort_column_changed;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_sort_column_id") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_sort_column_id = _wrap_GtkTreeSortable__proxy_do_get_sort_column_id;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_sort_column_id = parent_iface->get_sort_column_id;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_set_sort_column_id") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->set_sort_column_id = _wrap_GtkTreeSortable__proxy_do_set_sort_column_id;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->set_sort_column_id = parent_iface->set_sort_column_id;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_set_sort_func") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->set_sort_func = _wrap_GtkTreeSortable__proxy_do_set_sort_func;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->set_sort_func = parent_iface->set_sort_func;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_set_default_sort_func") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->set_default_sort_func = _wrap_GtkTreeSortable__proxy_do_set_default_sort_func;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->set_default_sort_func = parent_iface->set_default_sort_func;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_has_default_sort_func") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->has_default_sort_func = _wrap_GtkTreeSortable__proxy_do_has_default_sort_func;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->has_default_sort_func = parent_iface->has_default_sort_func;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkTreeSortable__iinfo = {
    (GInterfaceInitFunc) __GtkTreeSortable__interface_init,
    NULL,
    NULL
};




/* ----------- GtkPrintOperationPreview ----------- */

static PyObject *
_wrap_gtk_print_operation_preview_render_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_nr", NULL };
    int page_nr;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperationPreview.render_page", kwlist, &page_nr))
        return NULL;
    
    gtk_print_operation_preview_render_page(GTK_PRINT_OPERATION_PREVIEW(self->obj), page_nr);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_preview_end_preview(PyGObject *self)
{
    
    gtk_print_operation_preview_end_preview(GTK_PRINT_OPERATION_PREVIEW(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_operation_preview_is_selected(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_nr", NULL };
    int page_nr, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.PrintOperationPreview.is_selected", kwlist, &page_nr))
        return NULL;
    
    ret = gtk_print_operation_preview_is_selected(GTK_PRINT_OPERATION_PREVIEW(self->obj), page_nr);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkPrintOperationPreview__do_ready(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkPrintOperationPreviewIface *iface;
    static char *kwlist[] = { "self", "context", NULL };
    PyGObject *self, *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.PrintOperationPreview.ready", kwlist, &PyGtkPrintOperationPreview_Type, &self, &PyGtkPrintContext_Type, &context))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_PRINT_OPERATION_PREVIEW);
    if (iface->ready)
        iface->ready(GTK_PRINT_OPERATION_PREVIEW(self->obj), GTK_PRINT_CONTEXT(context->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.PrintOperationPreview.ready not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkPrintOperationPreview__do_got_page_size(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkPrintOperationPreviewIface *iface;
    static char *kwlist[] = { "self", "context", "page_setup", NULL };
    PyGObject *self, *context, *page_setup;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!:Gtk.PrintOperationPreview.got_page_size", kwlist, &PyGtkPrintOperationPreview_Type, &self, &PyGtkPrintContext_Type, &context, &PyGtkPageSetup_Type, &page_setup))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_PRINT_OPERATION_PREVIEW);
    if (iface->got_page_size)
        iface->got_page_size(GTK_PRINT_OPERATION_PREVIEW(self->obj), GTK_PRINT_CONTEXT(context->obj), GTK_PAGE_SETUP(page_setup->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.PrintOperationPreview.got_page_size not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkPrintOperationPreview__do_render_page(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkPrintOperationPreviewIface *iface;
    static char *kwlist[] = { "self", "page_nr", NULL };
    PyGObject *self;
    int page_nr;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.PrintOperationPreview.render_page", kwlist, &PyGtkPrintOperationPreview_Type, &self, &page_nr))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_PRINT_OPERATION_PREVIEW);
    if (iface->render_page)
        iface->render_page(GTK_PRINT_OPERATION_PREVIEW(self->obj), page_nr);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.PrintOperationPreview.render_page not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkPrintOperationPreview__do_is_selected(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkPrintOperationPreviewIface *iface;
    static char *kwlist[] = { "self", "page_nr", NULL };
    PyGObject *self;
    int page_nr, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:Gtk.PrintOperationPreview.is_selected", kwlist, &PyGtkPrintOperationPreview_Type, &self, &page_nr))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_PRINT_OPERATION_PREVIEW);
    if (iface->is_selected)
        ret = iface->is_selected(GTK_PRINT_OPERATION_PREVIEW(self->obj), page_nr);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.PrintOperationPreview.is_selected not implemented");
        return NULL;
    }
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkPrintOperationPreview__do_end_preview(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkPrintOperationPreviewIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.PrintOperationPreview.end_preview", kwlist, &PyGtkPrintOperationPreview_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_PRINT_OPERATION_PREVIEW);
    if (iface->end_preview)
        iface->end_preview(GTK_PRINT_OPERATION_PREVIEW(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.PrintOperationPreview.end_preview not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkPrintOperationPreview_methods[] = {
    { "render_page", (PyCFunction)_wrap_gtk_print_operation_preview_render_page, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "end_preview", (PyCFunction)_wrap_gtk_print_operation_preview_end_preview, METH_NOARGS,
      NULL },
    { "is_selected", (PyCFunction)_wrap_gtk_print_operation_preview_is_selected, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_ready", (PyCFunction)_wrap_GtkPrintOperationPreview__do_ready, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_got_page_size", (PyCFunction)_wrap_GtkPrintOperationPreview__do_got_page_size, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_render_page", (PyCFunction)_wrap_GtkPrintOperationPreview__do_render_page, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_is_selected", (PyCFunction)_wrap_GtkPrintOperationPreview__do_is_selected, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_end_preview", (PyCFunction)_wrap_GtkPrintOperationPreview__do_end_preview, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkPrintOperationPreview_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.PrintOperationPreview",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkPrintOperationPreview_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkPrintOperationPreview__proxy_do_ready(GtkPrintOperationPreview *self, GtkPrintContext*context)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    
    py_method = PyObject_GetAttrString(py_self, "do_ready");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkPrintOperationPreview__proxy_do_got_page_size(GtkPrintOperationPreview *self, GtkPrintContext*context, GtkPageSetup*page_setup)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_context = NULL;
    PyObject *py_page_setup = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (context)
        py_context = pygobject_new((GObject *) context);
    else {
        Py_INCREF(Py_None);
        py_context = Py_None;
    }
    if (page_setup)
        py_page_setup = pygobject_new((GObject *) page_setup);
    else {
        Py_INCREF(Py_None);
        py_page_setup = Py_None;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_context);
    PyTuple_SET_ITEM(py_args, 1, py_page_setup);
    
    py_method = PyObject_GetAttrString(py_self, "do_got_page_size");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkPrintOperationPreview__proxy_do_render_page(GtkPrintOperationPreview *self, gint page_nr)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_page_nr;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_page_nr = PyInt_FromLong(page_nr);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_page_nr);
    
    py_method = PyObject_GetAttrString(py_self, "do_render_page");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static gboolean
_wrap_GtkPrintOperationPreview__proxy_do_is_selected(GtkPrintOperationPreview *self, gint page_nr)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_page_nr;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_page_nr = PyInt_FromLong(page_nr);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_page_nr);
    
    py_method = PyObject_GetAttrString(py_self, "do_is_selected");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkPrintOperationPreview__proxy_do_end_preview(GtkPrintOperationPreview *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_end_preview");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static void
__GtkPrintOperationPreview__interface_init(GtkPrintOperationPreviewIface *iface, PyTypeObject *pytype)
{
    GtkPrintOperationPreviewIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_ready") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->ready = _wrap_GtkPrintOperationPreview__proxy_do_ready;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->ready = parent_iface->ready;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_got_page_size") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->got_page_size = _wrap_GtkPrintOperationPreview__proxy_do_got_page_size;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->got_page_size = parent_iface->got_page_size;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_render_page") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->render_page = _wrap_GtkPrintOperationPreview__proxy_do_render_page;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->render_page = parent_iface->render_page;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_is_selected") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->is_selected = _wrap_GtkPrintOperationPreview__proxy_do_is_selected;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->is_selected = parent_iface->is_selected;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_end_preview") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->end_preview = _wrap_GtkPrintOperationPreview__proxy_do_end_preview;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->end_preview = parent_iface->end_preview;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkPrintOperationPreview__iinfo = {
    (GInterfaceInitFunc) __GtkPrintOperationPreview__interface_init,
    NULL,
    NULL
};


/* ----------- GtkRecentChooser ----------- */

static PyObject *
_wrap_gtk_recent_chooser_set_show_private(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_private", NULL };
    int show_private;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentChooser.set_show_private", kwlist, &show_private))
        return NULL;
    
    gtk_recent_chooser_set_show_private(GTK_RECENT_CHOOSER(self->obj), show_private);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_get_show_private(PyGObject *self)
{
    int ret;

    
    ret = gtk_recent_chooser_get_show_private(GTK_RECENT_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_chooser_set_show_not_found(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_not_found", NULL };
    int show_not_found;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentChooser.set_show_not_found", kwlist, &show_not_found))
        return NULL;
    
    gtk_recent_chooser_set_show_not_found(GTK_RECENT_CHOOSER(self->obj), show_not_found);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_get_show_not_found(PyGObject *self)
{
    int ret;

    
    ret = gtk_recent_chooser_get_show_not_found(GTK_RECENT_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_chooser_set_select_multiple(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "select_multiple", NULL };
    int select_multiple;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentChooser.set_select_multiple", kwlist, &select_multiple))
        return NULL;
    
    gtk_recent_chooser_set_select_multiple(GTK_RECENT_CHOOSER(self->obj), select_multiple);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_get_select_multiple(PyGObject *self)
{
    int ret;

    
    ret = gtk_recent_chooser_get_select_multiple(GTK_RECENT_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_chooser_set_limit(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "limit", NULL };
    int limit;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentChooser.set_limit", kwlist, &limit))
        return NULL;
    
    gtk_recent_chooser_set_limit(GTK_RECENT_CHOOSER(self->obj), limit);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_get_limit(PyGObject *self)
{
    int ret;

    
    ret = gtk_recent_chooser_get_limit(GTK_RECENT_CHOOSER(self->obj));
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_recent_chooser_set_local_only(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "local_only", NULL };
    int local_only;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentChooser.set_local_only", kwlist, &local_only))
        return NULL;
    
    gtk_recent_chooser_set_local_only(GTK_RECENT_CHOOSER(self->obj), local_only);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_get_local_only(PyGObject *self)
{
    int ret;

    
    ret = gtk_recent_chooser_get_local_only(GTK_RECENT_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_chooser_set_show_tips(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_tips", NULL };
    int show_tips;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentChooser.set_show_tips", kwlist, &show_tips))
        return NULL;
    
    gtk_recent_chooser_set_show_tips(GTK_RECENT_CHOOSER(self->obj), show_tips);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_get_show_tips(PyGObject *self)
{
    int ret;

    
    ret = gtk_recent_chooser_get_show_tips(GTK_RECENT_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_chooser_set_show_icons(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "show_icons", NULL };
    int show_icons;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.RecentChooser.set_show_icons", kwlist, &show_icons))
        return NULL;
    
    gtk_recent_chooser_set_show_icons(GTK_RECENT_CHOOSER(self->obj), show_icons);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_get_show_icons(PyGObject *self)
{
    int ret;

    
    ret = gtk_recent_chooser_get_show_icons(GTK_RECENT_CHOOSER(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_chooser_set_sort_type(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "sort_type", NULL };
    GtkRecentSortType sort_type;
    PyObject *py_sort_type = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.RecentChooser.set_sort_type", kwlist, &py_sort_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_RECENT_SORT_TYPE, py_sort_type, (gpointer)&sort_type))
        return NULL;
    
    gtk_recent_chooser_set_sort_type(GTK_RECENT_CHOOSER(self->obj), sort_type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_get_sort_type(PyGObject *self)
{
    gint ret;

    
    ret = gtk_recent_chooser_get_sort_type(GTK_RECENT_CHOOSER(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_RECENT_SORT_TYPE, ret);
}

#line 7428 "./gtk.override"
static gint
pygtk_recent_chooser_set_sort_func_cb(GtkRecentInfo *a,
                                      GtkRecentInfo *b,
                                      gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_a, *py_b, *retobj;
    gint ret = -1;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_a = pyg_boxed_new(GTK_TYPE_RECENT_INFO, a, TRUE, TRUE);
    py_b = pyg_boxed_new(GTK_TYPE_RECENT_INFO, b, TRUE, TRUE);
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNO)",
                                     py_a, py_b, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NN)", py_a, py_b);
    }

    if (retobj != NULL) {
        ret = PyInt_AsLong(retobj);
        Py_DECREF(retobj);
    } else {
        PyErr_Print();
    }

    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_recent_chooser_set_sort_func(PyGObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    static char *kwlist[] = { "sort_func", "sort_data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkRecentChooser.set_sort_func",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "sort_func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
 
    gtk_recent_chooser_set_sort_func(GTK_RECENT_CHOOSER(self->obj),
                                        pygtk_recent_chooser_set_sort_func_cb,
                                        cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 119585 "gtk.c"


static PyObject *
_wrap_gtk_recent_chooser_set_current_uri(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentChooser.set_current_uri", kwlist, &uri))
        return NULL;
    
    ret = gtk_recent_chooser_set_current_uri(GTK_RECENT_CHOOSER(self->obj), uri, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_chooser_get_current_uri(PyGObject *self)
{
    gchar *ret;

    
    ret = gtk_recent_chooser_get_current_uri(GTK_RECENT_CHOOSER(self->obj));
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_get_current_item(PyGObject *self)
{
    GtkRecentInfo *ret;

    
    ret = gtk_recent_chooser_get_current_item(GTK_RECENT_CHOOSER(self->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_RECENT_INFO, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_recent_chooser_select_uri(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentChooser.select_uri", kwlist, &uri))
        return NULL;
    
    ret = gtk_recent_chooser_select_uri(GTK_RECENT_CHOOSER(self->obj), uri, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_recent_chooser_unselect_uri(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.RecentChooser.unselect_uri", kwlist, &uri))
        return NULL;
    
    gtk_recent_chooser_unselect_uri(GTK_RECENT_CHOOSER(self->obj), uri);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_select_all(PyGObject *self)
{
    
    gtk_recent_chooser_select_all(GTK_RECENT_CHOOSER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_unselect_all(PyGObject *self)
{
    
    gtk_recent_chooser_unselect_all(GTK_RECENT_CHOOSER(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 7265 "./gtk.override"
static PyObject *
_wrap_gtk_recent_chooser_get_items(PyGObject *self)
{
    GList *items;
    GtkRecentInfo *info;
    PyObject *py_items;
    guint count, i;

    items = gtk_recent_chooser_get_items(GTK_RECENT_CHOOSER(self->obj));
    count = g_list_length(items);
    py_items = PyList_New(count);
    for (i = 0;  i < count; i++) {
        info = g_list_nth_data(items, i);
        PyList_SetItem(py_items, i,
                       pyg_boxed_new(GTK_TYPE_RECENT_INFO, info, TRUE, TRUE));
    }
    g_list_foreach(items, (GFunc) gtk_recent_info_unref, NULL);
    g_list_free(items);

    return py_items;
}
#line 119712 "gtk.c"


#line 7288 "./gtk.override"
static PyObject *
_wrap_gtk_recent_chooser_get_uris(PyGObject *self)
{
    gchar **uris;
    PyObject *py_uris;
    gsize length, i;

    uris = gtk_recent_chooser_get_uris(GTK_RECENT_CHOOSER(self->obj),
                                        &length);
    if (!uris)
        length = 0;
    py_uris = PyList_New(length);
    for (i = 0; i < length; i++)
        PyList_SetItem(py_uris, i, PyString_FromString(uris[i]));
    g_strfreev(uris);

    return py_uris;
}
#line 119734 "gtk.c"


static PyObject *
_wrap_gtk_recent_chooser_add_filter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filter", NULL };
    PyGObject *filter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentChooser.add_filter", kwlist, &PyGtkRecentFilter_Type, &filter))
        return NULL;
    
    gtk_recent_chooser_add_filter(GTK_RECENT_CHOOSER(self->obj), GTK_RECENT_FILTER(filter->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_remove_filter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filter", NULL };
    PyGObject *filter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentChooser.remove_filter", kwlist, &PyGtkRecentFilter_Type, &filter))
        return NULL;
    
    gtk_recent_chooser_remove_filter(GTK_RECENT_CHOOSER(self->obj), GTK_RECENT_FILTER(filter->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 7407 "./gtk.override"
static PyObject *
_wrap_gtk_recent_chooser_list_filters(PyGObject *self)
{
    GSList *filters;
    GtkRecentFilter *filter;
    PyObject *py_filters;
    guint count, i;

    filters = gtk_recent_chooser_list_filters(GTK_RECENT_CHOOSER(self->obj));
    count = g_slist_length(filters);
    py_filters = PyList_New(count);
    for (i = 0; i < count; i++) {
        filter = g_slist_nth_data(filters, i);
        PyList_SetItem(py_filters, i, pygobject_new((GObject*)filter));
    }
    g_slist_free(filters);

    return py_filters;
}
#line 119787 "gtk.c"


static PyObject *
_wrap_gtk_recent_chooser_set_filter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filter", NULL };
    PyGObject *filter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentChooser.set_filter", kwlist, &PyGtkRecentFilter_Type, &filter))
        return NULL;
    
    gtk_recent_chooser_set_filter(GTK_RECENT_CHOOSER(self->obj), GTK_RECENT_FILTER(filter->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_recent_chooser_get_filter(PyGObject *self)
{
    GtkRecentFilter *ret;

    
    ret = gtk_recent_chooser_get_filter(GTK_RECENT_CHOOSER(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkRecentChooser__do_set_current_uri(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", "uri", NULL };
    PyGObject *self;
    char *uri;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.RecentChooser.set_current_uri", kwlist, &PyGtkRecentChooser_Type, &self, &uri))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->set_current_uri)
        ret = iface->set_current_uri(GTK_RECENT_CHOOSER(self->obj), uri, &error);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.set_current_uri not implemented");
        return NULL;
    }
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkRecentChooser__do_get_current_uri(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentChooser.get_current_uri", kwlist, &PyGtkRecentChooser_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->get_current_uri)
        ret = iface->get_current_uri(GTK_RECENT_CHOOSER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.get_current_uri not implemented");
        return NULL;
    }
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRecentChooser__do_select_uri(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", "uri", NULL };
    PyGObject *self;
    char *uri;
    int ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.RecentChooser.select_uri", kwlist, &PyGtkRecentChooser_Type, &self, &uri))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->select_uri)
        ret = iface->select_uri(GTK_RECENT_CHOOSER(self->obj), uri, &error);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.select_uri not implemented");
        return NULL;
    }
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_GtkRecentChooser__do_unselect_uri(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", "uri", NULL };
    PyGObject *self;
    char *uri;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.RecentChooser.unselect_uri", kwlist, &PyGtkRecentChooser_Type, &self, &uri))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->unselect_uri)
        iface->unselect_uri(GTK_RECENT_CHOOSER(self->obj), uri);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.unselect_uri not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRecentChooser__do_select_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentChooser.select_all", kwlist, &PyGtkRecentChooser_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->select_all)
        iface->select_all(GTK_RECENT_CHOOSER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.select_all not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRecentChooser__do_unselect_all(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentChooser.unselect_all", kwlist, &PyGtkRecentChooser_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->unselect_all)
        iface->unselect_all(GTK_RECENT_CHOOSER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.unselect_all not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRecentChooser__do_get_recent_manager(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    GtkRecentManager *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentChooser.get_recent_manager", kwlist, &PyGtkRecentChooser_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->get_recent_manager)
        ret = iface->get_recent_manager(GTK_RECENT_CHOOSER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.get_recent_manager not implemented");
        return NULL;
    }
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkRecentChooser__do_add_filter(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", "filter", NULL };
    PyGObject *self, *filter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.RecentChooser.add_filter", kwlist, &PyGtkRecentChooser_Type, &self, &PyGtkRecentFilter_Type, &filter))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->add_filter)
        iface->add_filter(GTK_RECENT_CHOOSER(self->obj), GTK_RECENT_FILTER(filter->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.add_filter not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRecentChooser__do_remove_filter(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", "filter", NULL };
    PyGObject *self, *filter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.RecentChooser.remove_filter", kwlist, &PyGtkRecentChooser_Type, &self, &PyGtkRecentFilter_Type, &filter))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->remove_filter)
        iface->remove_filter(GTK_RECENT_CHOOSER(self->obj), GTK_RECENT_FILTER(filter->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.remove_filter not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRecentChooser__do_item_activated(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentChooser.item_activated", kwlist, &PyGtkRecentChooser_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->item_activated)
        iface->item_activated(GTK_RECENT_CHOOSER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.item_activated not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkRecentChooser__do_selection_changed(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkRecentChooserIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.RecentChooser.selection_changed", kwlist, &PyGtkRecentChooser_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_RECENT_CHOOSER);
    if (iface->selection_changed)
        iface->selection_changed(GTK_RECENT_CHOOSER(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.RecentChooser.selection_changed not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkRecentChooser_methods[] = {
    { "set_show_private", (PyCFunction)_wrap_gtk_recent_chooser_set_show_private, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_private", (PyCFunction)_wrap_gtk_recent_chooser_get_show_private, METH_NOARGS,
      NULL },
    { "set_show_not_found", (PyCFunction)_wrap_gtk_recent_chooser_set_show_not_found, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_not_found", (PyCFunction)_wrap_gtk_recent_chooser_get_show_not_found, METH_NOARGS,
      NULL },
    { "set_select_multiple", (PyCFunction)_wrap_gtk_recent_chooser_set_select_multiple, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_select_multiple", (PyCFunction)_wrap_gtk_recent_chooser_get_select_multiple, METH_NOARGS,
      NULL },
    { "set_limit", (PyCFunction)_wrap_gtk_recent_chooser_set_limit, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_limit", (PyCFunction)_wrap_gtk_recent_chooser_get_limit, METH_NOARGS,
      NULL },
    { "set_local_only", (PyCFunction)_wrap_gtk_recent_chooser_set_local_only, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_local_only", (PyCFunction)_wrap_gtk_recent_chooser_get_local_only, METH_NOARGS,
      NULL },
    { "set_show_tips", (PyCFunction)_wrap_gtk_recent_chooser_set_show_tips, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_tips", (PyCFunction)_wrap_gtk_recent_chooser_get_show_tips, METH_NOARGS,
      NULL },
    { "set_show_icons", (PyCFunction)_wrap_gtk_recent_chooser_set_show_icons, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_show_icons", (PyCFunction)_wrap_gtk_recent_chooser_get_show_icons, METH_NOARGS,
      NULL },
    { "set_sort_type", (PyCFunction)_wrap_gtk_recent_chooser_set_sort_type, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_sort_type", (PyCFunction)_wrap_gtk_recent_chooser_get_sort_type, METH_NOARGS,
      NULL },
    { "set_sort_func", (PyCFunction)_wrap_gtk_recent_chooser_set_sort_func, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_current_uri", (PyCFunction)_wrap_gtk_recent_chooser_set_current_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_uri", (PyCFunction)_wrap_gtk_recent_chooser_get_current_uri, METH_NOARGS,
      NULL },
    { "get_current_item", (PyCFunction)_wrap_gtk_recent_chooser_get_current_item, METH_NOARGS,
      NULL },
    { "select_uri", (PyCFunction)_wrap_gtk_recent_chooser_select_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "unselect_uri", (PyCFunction)_wrap_gtk_recent_chooser_unselect_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "select_all", (PyCFunction)_wrap_gtk_recent_chooser_select_all, METH_NOARGS,
      NULL },
    { "unselect_all", (PyCFunction)_wrap_gtk_recent_chooser_unselect_all, METH_NOARGS,
      NULL },
    { "get_items", (PyCFunction)_wrap_gtk_recent_chooser_get_items, METH_NOARGS,
      NULL },
    { "get_uris", (PyCFunction)_wrap_gtk_recent_chooser_get_uris, METH_NOARGS,
      NULL },
    { "add_filter", (PyCFunction)_wrap_gtk_recent_chooser_add_filter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "remove_filter", (PyCFunction)_wrap_gtk_recent_chooser_remove_filter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "list_filters", (PyCFunction)_wrap_gtk_recent_chooser_list_filters, METH_NOARGS,
      NULL },
    { "set_filter", (PyCFunction)_wrap_gtk_recent_chooser_set_filter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_filter", (PyCFunction)_wrap_gtk_recent_chooser_get_filter, METH_NOARGS,
      NULL },
    { "do_set_current_uri", (PyCFunction)_wrap_GtkRecentChooser__do_set_current_uri, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_current_uri", (PyCFunction)_wrap_GtkRecentChooser__do_get_current_uri, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_uri", (PyCFunction)_wrap_GtkRecentChooser__do_select_uri, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unselect_uri", (PyCFunction)_wrap_GtkRecentChooser__do_unselect_uri, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_select_all", (PyCFunction)_wrap_GtkRecentChooser__do_select_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_unselect_all", (PyCFunction)_wrap_GtkRecentChooser__do_unselect_all, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_recent_manager", (PyCFunction)_wrap_GtkRecentChooser__do_get_recent_manager, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_add_filter", (PyCFunction)_wrap_GtkRecentChooser__do_add_filter, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_remove_filter", (PyCFunction)_wrap_GtkRecentChooser__do_remove_filter, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_item_activated", (PyCFunction)_wrap_GtkRecentChooser__do_item_activated, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_selection_changed", (PyCFunction)_wrap_GtkRecentChooser__do_selection_changed, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkRecentChooser_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.RecentChooser",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkRecentChooser_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static gboolean
_wrap_GtkRecentChooser__proxy_do_set_current_uri(GtkRecentChooser *self, const gchar*uri, GError **error)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_uri = NULL;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (uri)
        py_uri = PyString_FromString(uri);
    if (!py_uri) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_uri);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_current_uri");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (pyg_gerror_exception_check(error)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_uri);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gchar*
_wrap_GtkRecentChooser__proxy_do_get_current_uri(GtkRecentChooser *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    gchar* retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_current_uri");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "s", &retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    retval = g_strdup(retval);
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static gboolean
_wrap_GtkRecentChooser__proxy_do_select_uri(GtkRecentChooser *self, const gchar*uri, GError **error)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_uri = NULL;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (uri)
        py_uri = PyString_FromString(uri);
    if (!py_uri) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_uri);
    
    py_method = PyObject_GetAttrString(py_self, "do_select_uri");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (pyg_gerror_exception_check(error)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_uri);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    
    retval = PyObject_IsTrue(py_main_retval)? TRUE : FALSE;
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkRecentChooser__proxy_do_unselect_uri(GtkRecentChooser *self, const gchar*uri)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_uri = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (uri)
        py_uri = PyString_FromString(uri);
    if (!py_uri) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_uri);
    
    py_method = PyObject_GetAttrString(py_self, "do_unselect_uri");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkRecentChooser__proxy_do_select_all(GtkRecentChooser *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_select_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkRecentChooser__proxy_do_unselect_all(GtkRecentChooser *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_unselect_all");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GtkRecentManager*
_wrap_GtkRecentChooser__proxy_do_get_recent_manager(GtkRecentChooser *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkRecentManager* retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_recent_manager");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GtkRecentManager*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkRecentChooser__proxy_do_add_filter(GtkRecentChooser *self, GtkRecentFilter*filter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_filter = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (filter)
        py_filter = pygobject_new((GObject *) filter);
    else {
        Py_INCREF(Py_None);
        py_filter = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_filter);
    
    py_method = PyObject_GetAttrString(py_self, "do_add_filter");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkRecentChooser__proxy_do_remove_filter(GtkRecentChooser *self, GtkRecentFilter*filter)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_filter = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (filter)
        py_filter = pygobject_new((GObject *) filter);
    else {
        Py_INCREF(Py_None);
        py_filter = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_filter);
    
    py_method = PyObject_GetAttrString(py_self, "do_remove_filter");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkRecentChooser__proxy_do_item_activated(GtkRecentChooser *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_item_activated");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkRecentChooser__proxy_do_selection_changed(GtkRecentChooser *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_selection_changed");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static void
__GtkRecentChooser__interface_init(GtkRecentChooserIface *iface, PyTypeObject *pytype)
{
    GtkRecentChooserIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_set_current_uri") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->set_current_uri = _wrap_GtkRecentChooser__proxy_do_set_current_uri;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->set_current_uri = parent_iface->set_current_uri;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_current_uri") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_current_uri = _wrap_GtkRecentChooser__proxy_do_get_current_uri;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_current_uri = parent_iface->get_current_uri;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_select_uri") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->select_uri = _wrap_GtkRecentChooser__proxy_do_select_uri;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->select_uri = parent_iface->select_uri;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_unselect_uri") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->unselect_uri = _wrap_GtkRecentChooser__proxy_do_unselect_uri;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->unselect_uri = parent_iface->unselect_uri;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_select_all") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->select_all = _wrap_GtkRecentChooser__proxy_do_select_all;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->select_all = parent_iface->select_all;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_unselect_all") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->unselect_all = _wrap_GtkRecentChooser__proxy_do_unselect_all;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->unselect_all = parent_iface->unselect_all;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_recent_manager") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_recent_manager = _wrap_GtkRecentChooser__proxy_do_get_recent_manager;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_recent_manager = parent_iface->get_recent_manager;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_add_filter") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->add_filter = _wrap_GtkRecentChooser__proxy_do_add_filter;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->add_filter = parent_iface->add_filter;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_remove_filter") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->remove_filter = _wrap_GtkRecentChooser__proxy_do_remove_filter;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->remove_filter = parent_iface->remove_filter;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_item_activated") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->item_activated = _wrap_GtkRecentChooser__proxy_do_item_activated;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->item_activated = parent_iface->item_activated;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_selection_changed") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->selection_changed = _wrap_GtkRecentChooser__proxy_do_selection_changed;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->selection_changed = parent_iface->selection_changed;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkRecentChooser__iinfo = {
    (GInterfaceInitFunc) __GtkRecentChooser__interface_init,
    NULL,
    NULL
};


/* ----------- GtkBuildable ----------- */

static PyObject *
_wrap_gtk_buildable_set_name(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:Gtk.Buildable.set_name", kwlist, &name))
        return NULL;
    
    gtk_buildable_set_name(GTK_BUILDABLE(self->obj), name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_buildable_get_name(PyGObject *self)
{
    const gchar *ret;

    
    ret = gtk_buildable_get_name(GTK_BUILDABLE(self->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_buildable_add_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "builder", "child", "type", NULL };
    PyGObject *builder, *child;
    char *type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!z:Gtk.Buildable.add_child", kwlist, &PyGtkBuilder_Type, &builder, &PyGObject_Type, &child, &type))
        return NULL;
    
    gtk_buildable_add_child(GTK_BUILDABLE(self->obj), GTK_BUILDER(builder->obj), G_OBJECT(child->obj), type);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_buildable_construct_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "builder", "name", NULL };
    PyGObject *builder;
    char *name;
    GObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.Buildable.construct_child", kwlist, &PyGtkBuilder_Type, &builder, &name))
        return NULL;
    
    ret = gtk_buildable_construct_child(GTK_BUILDABLE(self->obj), GTK_BUILDER(builder->obj), name);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_buildable_parser_finished(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "builder", NULL };
    PyGObject *builder;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Buildable.parser_finished", kwlist, &PyGtkBuilder_Type, &builder))
        return NULL;
    
    gtk_buildable_parser_finished(GTK_BUILDABLE(self->obj), GTK_BUILDER(builder->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_buildable_get_internal_child(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "builder", "childname", NULL };
    PyGObject *builder;
    char *childname;
    GObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.Buildable.get_internal_child", kwlist, &PyGtkBuilder_Type, &builder, &childname))
        return NULL;
    
    ret = gtk_buildable_get_internal_child(GTK_BUILDABLE(self->obj), GTK_BUILDER(builder->obj), childname);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkBuildable__do_set_name(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkBuildableIface *iface;
    static char *kwlist[] = { "self", "name", NULL };
    PyGObject *self;
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!s:Gtk.Buildable.set_name", kwlist, &PyGtkBuildable_Type, &self, &name))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_BUILDABLE);
    if (iface->set_name)
        iface->set_name(GTK_BUILDABLE(self->obj), name);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Buildable.set_name not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkBuildable__do_add_child(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkBuildableIface *iface;
    static char *kwlist[] = { "self", "builder", "child", "type", NULL };
    PyGObject *self, *builder, *child;
    char *type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!s:Gtk.Buildable.add_child", kwlist, &PyGtkBuildable_Type, &self, &PyGtkBuilder_Type, &builder, &PyGObject_Type, &child, &type))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_BUILDABLE);
    if (iface->add_child)
        iface->add_child(GTK_BUILDABLE(self->obj), GTK_BUILDER(builder->obj), G_OBJECT(child->obj), type);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Buildable.add_child not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkBuildable__do_construct_child(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkBuildableIface *iface;
    static char *kwlist[] = { "self", "builder", "name", NULL };
    PyGObject *self, *builder;
    char *name;
    GObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!s:Gtk.Buildable.construct_child", kwlist, &PyGtkBuildable_Type, &self, &PyGtkBuilder_Type, &builder, &name))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_BUILDABLE);
    if (iface->construct_child)
        ret = iface->construct_child(GTK_BUILDABLE(self->obj), GTK_BUILDER(builder->obj), name);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Buildable.construct_child not implemented");
        return NULL;
    }
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkBuildable__do_parser_finished(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkBuildableIface *iface;
    static char *kwlist[] = { "self", "builder", NULL };
    PyGObject *self, *builder;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Buildable.parser_finished", kwlist, &PyGtkBuildable_Type, &self, &PyGtkBuilder_Type, &builder))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_BUILDABLE);
    if (iface->parser_finished)
        iface->parser_finished(GTK_BUILDABLE(self->obj), GTK_BUILDER(builder->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Buildable.parser_finished not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkBuildable__do_get_internal_child(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkBuildableIface *iface;
    static char *kwlist[] = { "self", "builder", "childname", NULL };
    PyGObject *self, *builder;
    char *childname;
    GObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!s:Gtk.Buildable.get_internal_child", kwlist, &PyGtkBuildable_Type, &self, &PyGtkBuilder_Type, &builder, &childname))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_BUILDABLE);
    if (iface->get_internal_child)
        ret = iface->get_internal_child(GTK_BUILDABLE(self->obj), GTK_BUILDER(builder->obj), childname);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Buildable.get_internal_child not implemented");
        return NULL;
    }
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static const PyMethodDef _PyGtkBuildable_methods[] = {
    { "set_name", (PyCFunction)_wrap_gtk_buildable_set_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_name", (PyCFunction)_wrap_gtk_buildable_get_name, METH_NOARGS,
      NULL },
    { "add_child", (PyCFunction)_wrap_gtk_buildable_add_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "construct_child", (PyCFunction)_wrap_gtk_buildable_construct_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "parser_finished", (PyCFunction)_wrap_gtk_buildable_parser_finished, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_internal_child", (PyCFunction)_wrap_gtk_buildable_get_internal_child, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_set_name", (PyCFunction)_wrap_GtkBuildable__do_set_name, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_add_child", (PyCFunction)_wrap_GtkBuildable__do_add_child, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_construct_child", (PyCFunction)_wrap_GtkBuildable__do_construct_child, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_parser_finished", (PyCFunction)_wrap_GtkBuildable__do_parser_finished, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_internal_child", (PyCFunction)_wrap_GtkBuildable__do_get_internal_child, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkBuildable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Buildable",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkBuildable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkBuildable__proxy_do_set_name(GtkBuildable *self, const gchar*name)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_name = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (name)
        py_name = PyString_FromString(name);
    if (!py_name) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_name);
    
    py_method = PyObject_GetAttrString(py_self, "do_set_name");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkBuildable__proxy_do_add_child(GtkBuildable *self, GtkBuilder*builder, GObject*child, const gchar*type)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_builder = NULL;
    PyObject *py_child = NULL;
    PyObject *py_type = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (builder)
        py_builder = pygobject_new((GObject *) builder);
    else {
        Py_INCREF(Py_None);
        py_builder = Py_None;
    }
    if (child)
        py_child = pygobject_new((GObject *) child);
    else {
        Py_INCREF(Py_None);
        py_child = Py_None;
    }
    if (type)
        py_type = PyString_FromString(type);
    if (!py_type) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_child);
        Py_DECREF(py_builder);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_builder);
    PyTuple_SET_ITEM(py_args, 1, py_child);
    PyTuple_SET_ITEM(py_args, 2, py_type);
    
    py_method = PyObject_GetAttrString(py_self, "do_add_child");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GObject*
_wrap_GtkBuildable__proxy_do_construct_child(GtkBuildable *self, GtkBuilder*builder, const gchar*name)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_builder = NULL;
    PyObject *py_name = NULL;
    GObject* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (builder)
        py_builder = pygobject_new((GObject *) builder);
    else {
        Py_INCREF(Py_None);
        py_builder = Py_None;
    }
    if (name)
        py_name = PyString_FromString(name);
    if (!py_name) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_builder);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_builder);
    PyTuple_SET_ITEM(py_args, 1, py_name);
    
    py_method = PyObject_GetAttrString(py_self, "do_construct_child");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GObject*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkBuildable__proxy_do_parser_finished(GtkBuildable *self, GtkBuilder*builder)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_builder = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (builder)
        py_builder = pygobject_new((GObject *) builder);
    else {
        Py_INCREF(Py_None);
        py_builder = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_builder);
    
    py_method = PyObject_GetAttrString(py_self, "do_parser_finished");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static GObject*
_wrap_GtkBuildable__proxy_do_get_internal_child(GtkBuildable *self, GtkBuilder*builder, const gchar*childname)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_builder = NULL;
    PyObject *py_childname = NULL;
    GObject* retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (builder)
        py_builder = pygobject_new((GObject *) builder);
    else {
        Py_INCREF(Py_None);
        py_builder = Py_None;
    }
    if (childname)
        py_childname = PyString_FromString(childname);
    if (!py_childname) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_builder);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_builder);
    PyTuple_SET_ITEM(py_args, 1, py_childname);
    
    py_method = PyObject_GetAttrString(py_self, "do_get_internal_child");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (!PyObject_TypeCheck(py_retval, &PyGObject_Type)) {
        PyErr_SetString(PyExc_TypeError, "retval should be a GObject");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    retval = (GObject*) pygobject_get(py_retval);
    g_object_ref((GObject *) retval);
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}

static void
__GtkBuildable__interface_init(GtkBuildableIface *iface, PyTypeObject *pytype)
{
    GtkBuildableIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_set_name") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->set_name = _wrap_GtkBuildable__proxy_do_set_name;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->set_name = parent_iface->set_name;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_add_child") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->add_child = _wrap_GtkBuildable__proxy_do_add_child;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->add_child = parent_iface->add_child;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_construct_child") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->construct_child = _wrap_GtkBuildable__proxy_do_construct_child;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->construct_child = parent_iface->construct_child;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_parser_finished") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->parser_finished = _wrap_GtkBuildable__proxy_do_parser_finished;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->parser_finished = parent_iface->parser_finished;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_internal_child") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_internal_child = _wrap_GtkBuildable__proxy_do_get_internal_child;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_internal_child = parent_iface->get_internal_child;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkBuildable__iinfo = {
    (GInterfaceInitFunc) __GtkBuildable__interface_init,
    NULL,
    NULL
};


/* ----------- GtkToolShell ----------- */

static PyObject *
_wrap_gtk_tool_shell_get_icon_size(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_shell_get_icon_size(GTK_TOOL_SHELL(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, ret);
}

static PyObject *
_wrap_gtk_tool_shell_get_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_shell_get_orientation(GTK_TOOL_SHELL(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, ret);
}

static PyObject *
_wrap_gtk_tool_shell_get_style(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_shell_get_style(GTK_TOOL_SHELL(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_TOOLBAR_STYLE, ret);
}

static PyObject *
_wrap_gtk_tool_shell_get_relief_style(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_shell_get_relief_style(GTK_TOOL_SHELL(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_RELIEF_STYLE, ret);
}

static PyObject *
_wrap_gtk_tool_shell_rebuild_menu(PyGObject *self)
{
    
    gtk_tool_shell_rebuild_menu(GTK_TOOL_SHELL(self->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_tool_shell_get_text_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_shell_get_text_orientation(GTK_TOOL_SHELL(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, ret);
}

static PyObject *
_wrap_gtk_tool_shell_get_text_alignment(PyGObject *self)
{
    double ret;

    
    ret = gtk_tool_shell_get_text_alignment(GTK_TOOL_SHELL(self->obj));
    
    return PyFloat_FromDouble(ret);
}

static PyObject *
_wrap_gtk_tool_shell_get_ellipsize_mode(PyGObject *self)
{
    gint ret;

    
    ret = gtk_tool_shell_get_ellipsize_mode(GTK_TOOL_SHELL(self->obj));
    
    return pyg_enum_from_gtype(PANGO_TYPE_ELLIPSIZE_MODE, ret);
}

static PyObject *
_wrap_gtk_tool_shell_get_text_size_group(PyGObject *self)
{
    GtkSizeGroup *ret;

    
    ret = gtk_tool_shell_get_text_size_group(GTK_TOOL_SHELL(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_GtkToolShell__do_get_icon_size(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkToolShellIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolShell.get_icon_size", kwlist, &PyGtkToolShell_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TOOL_SHELL);
    if (iface->get_icon_size)
        ret = iface->get_icon_size(GTK_TOOL_SHELL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.ToolShell.get_icon_size not implemented");
        return NULL;
    }
    return pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, ret);
}

static PyObject *
_wrap_GtkToolShell__do_get_orientation(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkToolShellIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolShell.get_orientation", kwlist, &PyGtkToolShell_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TOOL_SHELL);
    if (iface->get_orientation)
        ret = iface->get_orientation(GTK_TOOL_SHELL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.ToolShell.get_orientation not implemented");
        return NULL;
    }
    return pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, ret);
}

static PyObject *
_wrap_GtkToolShell__do_get_style(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkToolShellIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolShell.get_style", kwlist, &PyGtkToolShell_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TOOL_SHELL);
    if (iface->get_style)
        ret = iface->get_style(GTK_TOOL_SHELL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.ToolShell.get_style not implemented");
        return NULL;
    }
    return pyg_enum_from_gtype(GTK_TYPE_TOOLBAR_STYLE, ret);
}

static PyObject *
_wrap_GtkToolShell__do_get_relief_style(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkToolShellIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolShell.get_relief_style", kwlist, &PyGtkToolShell_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TOOL_SHELL);
    if (iface->get_relief_style)
        ret = iface->get_relief_style(GTK_TOOL_SHELL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.ToolShell.get_relief_style not implemented");
        return NULL;
    }
    return pyg_enum_from_gtype(GTK_TYPE_RELIEF_STYLE, ret);
}

static PyObject *
_wrap_GtkToolShell__do_rebuild_menu(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkToolShellIface *iface;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.ToolShell.rebuild_menu", kwlist, &PyGtkToolShell_Type, &self))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_TOOL_SHELL);
    if (iface->rebuild_menu)
        iface->rebuild_menu(GTK_TOOL_SHELL(self->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.ToolShell.rebuild_menu not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkToolShell_methods[] = {
    { "get_icon_size", (PyCFunction)_wrap_gtk_tool_shell_get_icon_size, METH_NOARGS,
      NULL },
    { "get_orientation", (PyCFunction)_wrap_gtk_tool_shell_get_orientation, METH_NOARGS,
      NULL },
    { "get_style", (PyCFunction)_wrap_gtk_tool_shell_get_style, METH_NOARGS,
      NULL },
    { "get_relief_style", (PyCFunction)_wrap_gtk_tool_shell_get_relief_style, METH_NOARGS,
      NULL },
    { "rebuild_menu", (PyCFunction)_wrap_gtk_tool_shell_rebuild_menu, METH_NOARGS,
      NULL },
    { "get_text_orientation", (PyCFunction)_wrap_gtk_tool_shell_get_text_orientation, METH_NOARGS,
      NULL },
    { "get_text_alignment", (PyCFunction)_wrap_gtk_tool_shell_get_text_alignment, METH_NOARGS,
      NULL },
    { "get_ellipsize_mode", (PyCFunction)_wrap_gtk_tool_shell_get_ellipsize_mode, METH_NOARGS,
      NULL },
    { "get_text_size_group", (PyCFunction)_wrap_gtk_tool_shell_get_text_size_group, METH_NOARGS,
      NULL },
    { "do_get_icon_size", (PyCFunction)_wrap_GtkToolShell__do_get_icon_size, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_orientation", (PyCFunction)_wrap_GtkToolShell__do_get_orientation, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_style", (PyCFunction)_wrap_GtkToolShell__do_get_style, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_get_relief_style", (PyCFunction)_wrap_GtkToolShell__do_get_relief_style, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_rebuild_menu", (PyCFunction)_wrap_GtkToolShell__do_rebuild_menu, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkToolShell_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.ToolShell",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkToolShell_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static GtkIconSize
_wrap_GtkToolShell__proxy_do_get_icon_size(GtkToolShell *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkIconSize retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_icon_size");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_retval, (gint *)&retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static GtkOrientation
_wrap_GtkToolShell__proxy_do_get_orientation(GtkToolShell *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkOrientation retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_orientation");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_retval, (gint *)&retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static GtkToolbarStyle
_wrap_GtkToolShell__proxy_do_get_style(GtkToolShell *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkToolbarStyle retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_style");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_STYLE, py_retval, (gint *)&retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static GtkReliefStyle
_wrap_GtkToolShell__proxy_do_get_relief_style(GtkToolShell *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    GtkReliefStyle retval;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_get_relief_style");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    if (pyg_enum_get_value(GTK_TYPE_RELIEF_STYLE, py_retval, (gint *)&retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return -G_MAXINT;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return retval;
}
static void
_wrap_GtkToolShell__proxy_do_rebuild_menu(GtkToolShell *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    py_method = PyObject_GetAttrString(py_self, "do_rebuild_menu");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static void
__GtkToolShell__interface_init(GtkToolShellIface *iface, PyTypeObject *pytype)
{
    GtkToolShellIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_icon_size") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_icon_size = _wrap_GtkToolShell__proxy_do_get_icon_size;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_icon_size = parent_iface->get_icon_size;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_orientation") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_orientation = _wrap_GtkToolShell__proxy_do_get_orientation;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_orientation = parent_iface->get_orientation;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_style") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_style = _wrap_GtkToolShell__proxy_do_get_style;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_style = parent_iface->get_style;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_get_relief_style") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->get_relief_style = _wrap_GtkToolShell__proxy_do_get_relief_style;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->get_relief_style = parent_iface->get_relief_style;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_rebuild_menu") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->rebuild_menu = _wrap_GtkToolShell__proxy_do_rebuild_menu;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->rebuild_menu = parent_iface->rebuild_menu;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkToolShell__iinfo = {
    (GInterfaceInitFunc) __GtkToolShell__interface_init,
    NULL,
    NULL
};


/* ----------- GtkActivatable ----------- */

static PyObject *
_wrap_gtk_activatable_sync_action_properties(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", NULL };
    PyGObject *py_action = NULL;
    GtkAction *action = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:Gtk.Activatable.sync_action_properties", kwlist, &py_action))
        return NULL;
    if ((PyObject *)py_action == Py_None)
        action = NULL;
    else if (py_action && pygobject_check(py_action, &PyGtkAction_Type))
        action = GTK_ACTION(py_action->obj);
    else if (py_action) {
        PyErr_SetString(PyExc_TypeError, "action should be a GtkAction or None");
        return NULL;
    }
    
    gtk_activatable_sync_action_properties(GTK_ACTIVATABLE(self->obj), (GtkAction *) action);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_activatable_set_related_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", NULL };
    PyGObject *action;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Activatable.set_related_action", kwlist, &PyGtkAction_Type, &action))
        return NULL;
    
    gtk_activatable_set_related_action(GTK_ACTIVATABLE(self->obj), GTK_ACTION(action->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_activatable_get_related_action(PyGObject *self)
{
    GtkAction *ret;

    
    ret = gtk_activatable_get_related_action(GTK_ACTIVATABLE(self->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_activatable_set_use_action_appearance(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "use_appearance", NULL };
    int use_appearance;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:Gtk.Activatable.set_use_action_appearance", kwlist, &use_appearance))
        return NULL;
    
    gtk_activatable_set_use_action_appearance(GTK_ACTIVATABLE(self->obj), use_appearance);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_activatable_get_use_action_appearance(PyGObject *self)
{
    int ret;

    
    ret = gtk_activatable_get_use_action_appearance(GTK_ACTIVATABLE(self->obj));
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_activatable_do_set_related_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", NULL };
    PyGObject *action;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:Gtk.Activatable.do_set_related_action", kwlist, &PyGtkAction_Type, &action))
        return NULL;
    
    gtk_activatable_do_set_related_action(GTK_ACTIVATABLE(self->obj), GTK_ACTION(action->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkActivatable__do_update(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkActivatableIface *iface;
    static char *kwlist[] = { "self", "action", "property_name", NULL };
    PyGObject *self, *action;
    char *property_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!s:Gtk.Activatable.update", kwlist, &PyGtkActivatable_Type, &self, &PyGtkAction_Type, &action, &property_name))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_ACTIVATABLE);
    if (iface->update)
        iface->update(GTK_ACTIVATABLE(self->obj), GTK_ACTION(action->obj), property_name);
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Activatable.update not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_GtkActivatable__do_sync_action_properties(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    GtkActivatableIface *iface;
    static char *kwlist[] = { "self", "action", NULL };
    PyGObject *self, *action;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:Gtk.Activatable.sync_action_properties", kwlist, &PyGtkActivatable_Type, &self, &PyGtkAction_Type, &action))
        return NULL;
    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)), GTK_TYPE_ACTIVATABLE);
    if (iface->sync_action_properties)
        iface->sync_action_properties(GTK_ACTIVATABLE(self->obj), GTK_ACTION(action->obj));
    else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method Gtk.Activatable.sync_action_properties not implemented");
        return NULL;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static const PyMethodDef _PyGtkActivatable_methods[] = {
    { "sync_action_properties", (PyCFunction)_wrap_gtk_activatable_sync_action_properties, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "set_related_action", (PyCFunction)_wrap_gtk_activatable_set_related_action, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_related_action", (PyCFunction)_wrap_gtk_activatable_get_related_action, METH_NOARGS,
      NULL },
    { "set_use_action_appearance", (PyCFunction)_wrap_gtk_activatable_set_use_action_appearance, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_use_action_appearance", (PyCFunction)_wrap_gtk_activatable_get_use_action_appearance, METH_NOARGS,
      NULL },
    { "do_set_related_action", (PyCFunction)_wrap_gtk_activatable_do_set_related_action, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "do_update", (PyCFunction)_wrap_GtkActivatable__do_update, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { "do_sync_action_properties", (PyCFunction)_wrap_GtkActivatable__do_sync_action_properties, METH_VARARGS|METH_KEYWORDS|METH_CLASS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkActivatable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Activatable",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkActivatable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};

static void
_wrap_GtkActivatable__proxy_do_update(GtkActivatable *self, GtkAction*action, const gchar*property_name)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_action = NULL;
    PyObject *py_property_name = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (action)
        py_action = pygobject_new((GObject *) action);
    else {
        Py_INCREF(Py_None);
        py_action = Py_None;
    }
    if (property_name)
        py_property_name = PyString_FromString(property_name);
    if (!py_property_name) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_action);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    py_args = PyTuple_New(2);
    PyTuple_SET_ITEM(py_args, 0, py_action);
    PyTuple_SET_ITEM(py_args, 1, py_property_name);
    
    py_method = PyObject_GetAttrString(py_self, "do_update");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
static void
_wrap_GtkActivatable__proxy_do_sync_action_properties(GtkActivatable *self, GtkAction*action)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_action = NULL;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (action)
        py_action = pygobject_new((GObject *) action);
    else {
        Py_INCREF(Py_None);
        py_action = Py_None;
    }
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_action);
    
    py_method = PyObject_GetAttrString(py_self, "do_sync_action_properties");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

static void
__GtkActivatable__interface_init(GtkActivatableIface *iface, PyTypeObject *pytype)
{
    GtkActivatableIface *parent_iface = g_type_interface_peek_parent(iface);
    PyObject *py_method;

    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_update") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->update = _wrap_GtkActivatable__proxy_do_update;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->update = parent_iface->update;
        }
    Py_XDECREF(py_method);
    }
    py_method = pytype? PyObject_GetAttrString((PyObject *) pytype, "do_sync_action_properties") : NULL;
    if (py_method && !PyObject_TypeCheck(py_method, &PyCFunction_Type)) {
        iface->sync_action_properties = _wrap_GtkActivatable__proxy_do_sync_action_properties;
    } else {
        PyErr_Clear();
        if (parent_iface) {
            iface->sync_action_properties = parent_iface->sync_action_properties;
        }
    Py_XDECREF(py_method);
    }
}


static const GInterfaceInfo __GtkActivatable__iinfo = {
    (GInterfaceInitFunc) __GtkActivatable__interface_init,
    NULL,
    NULL
};


/* ----------- GtkOrientable ----------- */

static PyObject *
_wrap_gtk_orientable_set_orientation(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "orientation", NULL };
    GtkOrientation orientation;
    PyObject *py_orientation = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:Gtk.Orientable.set_orientation", kwlist, &py_orientation))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation, (gpointer)&orientation))
        return NULL;
    
    gtk_orientable_set_orientation(GTK_ORIENTABLE(self->obj), orientation);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_orientable_get_orientation(PyGObject *self)
{
    gint ret;

    
    ret = gtk_orientable_get_orientation(GTK_ORIENTABLE(self->obj));
    
    return pyg_enum_from_gtype(GTK_TYPE_ORIENTATION, ret);
}

static const PyMethodDef _PyGtkOrientable_methods[] = {
    { "set_orientation", (PyCFunction)_wrap_gtk_orientable_set_orientation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_orientation", (PyCFunction)_wrap_gtk_orientable_get_orientation, METH_NOARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};

PyTypeObject G_GNUC_INTERNAL PyGtkOrientable_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    "gtk.Orientable",                   /* tp_name */
    sizeof(PyObject),          /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)0,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)0,       /* tp_getattr */
    (setattrfunc)0,       /* tp_setattr */
    (cmpfunc)0,           /* tp_compare */
    (reprfunc)0,             /* tp_repr */
    (PyNumberMethods*)0,     /* tp_as_number */
    (PySequenceMethods*)0, /* tp_as_sequence */
    (PyMappingMethods*)0,   /* tp_as_mapping */
    (hashfunc)0,             /* tp_hash */
    (ternaryfunc)0,          /* tp_call */
    (reprfunc)0,              /* tp_str */
    (getattrofunc)0,     /* tp_getattro */
    (setattrofunc)0,     /* tp_setattro */
    (PyBufferProcs*)0,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)0,     /* tp_traverse */
    (inquiry)0,             /* tp_clear */
    (richcmpfunc)0,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)0,          /* tp_iter */
    (iternextfunc)0,     /* tp_iternext */
    (struct PyMethodDef*)_PyGtkOrientable_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    (struct PyGetSetDef*)0,  /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)0,    /* tp_descr_get */
    (descrsetfunc)0,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)0,             /* tp_init */
    (allocfunc)0,           /* tp_alloc */
    (newfunc)0,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)0              /* tp_is_gc */
};



/* ----------- functions ----------- */

#line 6463 "./gtk.override"
static void
pygtk_about_dialog_link_hook_marshal(GtkAboutDialog *about,
                                         const gchar *link,
                                         gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_about, *retobj;
 
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
 
    py_about = pygobject_new((GObject *)about);

    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NsO)", py_about,
                                     link, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(Ns)", py_about, link);
    }

    if (!retobj)
	PyErr_Print();
 
    Py_XDECREF(retobj);
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_about_dialog_set_email_hook(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL };
    PyObject *pyfunc = NULL, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:GtkAboutDialog.set_email_hook",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (pyfunc == NULL || pyfunc == Py_None) {
        gtk_about_dialog_set_email_hook(NULL, NULL, NULL);
    } else if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);

        gtk_about_dialog_set_email_hook(
            pygtk_about_dialog_link_hook_marshal,
            cunote,
            pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 122881 "gtk.c"


#line 6526 "./gtk.override"
static PyObject *
_wrap_gtk_about_dialog_set_url_hook(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL};
    PyObject *pyfunc = NULL, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
 
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:GtkAboutDialog.set_url_hook",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (pyfunc == NULL || pyfunc == Py_None) {
        gtk_about_dialog_set_url_hook(NULL, NULL, NULL);
    } else if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object");
        return NULL;
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);

        gtk_about_dialog_set_url_hook(
            pygtk_about_dialog_link_hook_marshal,
            cunote,
            pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 122918 "gtk.c"


#line 5820 "./gtk.override"
static PyObject *
_wrap_gtk_show_about_dialog(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkWindow *parent;
    PyGObject *py_window = NULL;
    GtkWidget *dialog;
    GObjectClass *klass;

    if (!PyArg_ParseTuple (args, "O:Gtk.show_about_dialog", &py_window))
        return NULL;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
        parent = NULL;
    else
        parent = GTK_WINDOW (py_window->obj);

    dialog = gtk_about_dialog_new ();

    g_signal_connect (dialog, "response",
                      G_CALLBACK (gtk_widget_destroy), NULL);

    if (kwargs) {
        Py_ssize_t pos = 0;
        PyObject *py_prop_name;
        PyObject *py_prop_value;

        while (PyDict_Next (kwargs, &pos, &py_prop_name, &py_prop_value)) {
            GParamSpec *pspec;
            const gchar *property_name;
            GValue property_gvalue = { 0, };

            property_name = PyString_AsString (py_prop_name);

            klass = G_OBJECT_CLASS (GTK_ABOUT_DIALOG_GET_CLASS(dialog));

            pspec = g_object_class_find_property (klass, property_name);
            if (!pspec) {
                PyErr_Format(PyExc_TypeError,
                             "Gtk.AboutDialog doesn't support property `%s'",
                             property_name);
                goto arg_error;
            }

            g_value_init (&property_gvalue, G_PARAM_SPEC_VALUE_TYPE(pspec));
            if (pyg_param_gvalue_from_pyobject(&property_gvalue,
                                               py_prop_value, pspec) < 0) {
                PyErr_Format(PyExc_TypeError,
                             "could not convert value for property `%s'",
                             property_name);
                g_value_unset (&property_gvalue);
                goto arg_error;
            }

            g_object_set_property (G_OBJECT (dialog), property_name,
                                   &property_gvalue);
            g_value_unset (&property_gvalue);
        }
    }

    if (parent) {
        gtk_window_set_transient_for (GTK_WINDOW (dialog), parent);
        gtk_window_set_destroy_with_parent (GTK_WINDOW (dialog), TRUE);
    }

    gtk_window_present (GTK_WINDOW (dialog));

    Py_INCREF(Py_None);
    return Py_None;

arg_error:
    if (dialog)
        gtk_widget_destroy (dialog);

    return NULL;
}
#line 122997 "gtk.c"


static PyObject *
_wrap_gtk_accel_groups_activate(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "object", "accel_key", "accel_mods", NULL };
    PyGObject *object;
    PyObject *py_accel_key = NULL, *py_accel_mods = NULL;
    int ret;
    GdkModifierType accel_mods;
    guint accel_key = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:accel_groups_activate", kwlist, &PyGObject_Type, &object, &py_accel_key, &py_accel_mods))
        return NULL;
    if (py_accel_key) {
        if (PyLong_Check(py_accel_key))
            accel_key = PyLong_AsUnsignedLong(py_accel_key);
        else if (PyInt_Check(py_accel_key))
            accel_key = PyInt_AsLong(py_accel_key);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'accel_key' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gpointer)&accel_mods))
        return NULL;
    
    ret = gtk_accel_groups_activate(G_OBJECT(object->obj), accel_key, accel_mods);
    
    return PyBool_FromLong(ret);

}

#line 5461 "./gtk.override"
static PyObject *
_wrap_gtk_accel_groups_from_object(PyGObject *self, PyObject *args)
{
    PyGObject *obj;
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *item;

    if (!PyArg_ParseTuple(args, "O!:accel_group_from_object",
			  &PyGObject_Type, &obj))
	return NULL;
    
    list = gtk_accel_groups_from_object(G_OBJECT(obj->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    
    for (tmp = list; tmp; tmp = tmp->next) {
        item = pygobject_new(G_OBJECT(tmp->data));
        if (item == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, item);
        Py_DECREF(item);
    }
    
    return py_list;
}
#line 123062 "gtk.c"


static PyObject *
_wrap_gtk_accel_group_from_accel_closure(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "closure", NULL };
    PyObject *py_closure;
    GtkAccelGroup *ret;
    GClosure *closure = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:accel_group_from_accel_closure", kwlist, &py_closure))
        return NULL;
    if (pyg_boxed_check(py_closure, G_TYPE_CLOSURE))
        closure = pyg_boxed_get(py_closure, GClosure);
    else {
        PyErr_SetString(PyExc_TypeError, "closure should be a GClosure");
        return NULL;
    }
    
    ret = gtk_accel_group_from_accel_closure(closure);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_accelerator_valid(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "keyval", "modifiers", NULL };
    PyObject *py_keyval = NULL, *py_modifiers = NULL;
    int ret;
    GdkModifierType modifiers;
    guint keyval = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:accelerator_valid", kwlist, &py_keyval, &py_modifiers))
        return NULL;
    if (py_keyval) {
        if (PyLong_Check(py_keyval))
            keyval = PyLong_AsUnsignedLong(py_keyval);
        else if (PyInt_Check(py_keyval))
            keyval = PyInt_AsLong(py_keyval);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'keyval' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_modifiers, (gpointer)&modifiers))
        return NULL;
    
    ret = gtk_accelerator_valid(keyval, modifiers);
    
    return PyBool_FromLong(ret);

}

#line 3669 "./gtk.override"
static PyObject *
_wrap_gtk_accelerator_parse(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accelerator", NULL };
    gchar *accel;
    guint keyval;
    GdkModifierType modifier;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:Gtk.accelerator_parse",
				     kwlist, &accel))
        return NULL;

    gtk_accelerator_parse((const gchar *)accel, &keyval, &modifier);

    return Py_BuildValue("iN", keyval,
                         pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE,
                                              modifier));
}
#line 123137 "gtk.c"


static PyObject *
_wrap_gtk_accelerator_name(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accelerator_key", "accelerator_mods", NULL };
    PyObject *py_accelerator_key = NULL, *py_accelerator_mods = NULL;
    gchar *ret;
    GdkModifierType accelerator_mods;
    guint accelerator_key = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:accelerator_name", kwlist, &py_accelerator_key, &py_accelerator_mods))
        return NULL;
    if (py_accelerator_key) {
        if (PyLong_Check(py_accelerator_key))
            accelerator_key = PyLong_AsUnsignedLong(py_accelerator_key);
        else if (PyInt_Check(py_accelerator_key))
            accelerator_key = PyInt_AsLong(py_accelerator_key);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'accelerator_key' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accelerator_mods, (gpointer)&accelerator_mods))
        return NULL;
    
    ret = gtk_accelerator_name(accelerator_key, accelerator_mods);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accelerator_set_default_mod_mask(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "default_mod_mask", NULL };
    PyObject *py_default_mod_mask = NULL;
    GdkModifierType default_mod_mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:accelerator_set_default_mod_mask", kwlist, &py_default_mod_mask))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_default_mod_mask, (gpointer)&default_mod_mask))
        return NULL;
    
    gtk_accelerator_set_default_mod_mask(default_mod_mask);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accelerator_get_default_mod_mask(PyObject *self)
{
    guint ret;

    
    ret = gtk_accelerator_get_default_mod_mask();
    
    return pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, ret);
}

static PyObject *
_wrap_gtk_accelerator_get_label(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accelerator_key", "accelerator_mods", NULL };
    PyObject *py_accelerator_key = NULL, *py_accelerator_mods = NULL;
    gchar *ret;
    GdkModifierType accelerator_mods;
    guint accelerator_key = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:accelerator_get_label", kwlist, &py_accelerator_key, &py_accelerator_mods))
        return NULL;
    if (py_accelerator_key) {
        if (PyLong_Check(py_accelerator_key))
            accelerator_key = PyLong_AsUnsignedLong(py_accelerator_key);
        else if (PyInt_Check(py_accelerator_key))
            accelerator_key = PyInt_AsLong(py_accelerator_key);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'accelerator_key' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accelerator_mods, (gpointer)&accelerator_mods))
        return NULL;
    
    ret = gtk_accelerator_get_label(accelerator_key, accelerator_mods);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accel_map_add_entry(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", "accel_key", "accel_mods", NULL };
    char *accel_path;
    PyObject *py_accel_key = NULL, *py_accel_mods = NULL;
    GdkModifierType accel_mods;
    guint accel_key = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sOO:accel_map_add_entry", kwlist, &accel_path, &py_accel_key, &py_accel_mods))
        return NULL;
    if (py_accel_key) {
        if (PyLong_Check(py_accel_key))
            accel_key = PyLong_AsUnsignedLong(py_accel_key);
        else if (PyInt_Check(py_accel_key))
            accel_key = PyInt_AsLong(py_accel_key);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'accel_key' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gpointer)&accel_mods))
        return NULL;
    
    gtk_accel_map_add_entry(accel_path, accel_key, accel_mods);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3689 "./gtk.override"
static PyObject *
_wrap_gtk_accel_map_lookup_entry(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", NULL };
    gchar *accel_path;
    GtkAccelKey accel_key;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:gtk.accel_map_lookup_entry",
				     kwlist, &accel_path))
        return NULL;

    if (gtk_accel_map_lookup_entry((const gchar *)accel_path, &accel_key))
	return Py_BuildValue("iN", accel_key.accel_key,
			     pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, accel_key.accel_mods));

    Py_INCREF(Py_None);
    return Py_None;
}
#line 123290 "gtk.c"


static PyObject *
_wrap_gtk_accel_map_change_entry(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", "accel_key", "accel_mods", "replace", NULL };
    char *accel_path;
    PyObject *py_accel_key = NULL, *py_accel_mods = NULL;
    int replace, ret;
    GdkModifierType accel_mods;
    guint accel_key = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sOOi:accel_map_change_entry", kwlist, &accel_path, &py_accel_key, &py_accel_mods, &replace))
        return NULL;
    if (py_accel_key) {
        if (PyLong_Check(py_accel_key))
            accel_key = PyLong_AsUnsignedLong(py_accel_key);
        else if (PyInt_Check(py_accel_key))
            accel_key = PyInt_AsLong(py_accel_key);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'accel_key' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gpointer)&accel_mods))
        return NULL;
    
    ret = gtk_accel_map_change_entry(accel_path, accel_key, accel_mods, replace);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_accel_map_load(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file_name", NULL };
    char *file_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:accel_map_load", kwlist, &file_name))
        return NULL;
    
    gtk_accel_map_load(file_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accel_map_save(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file_name", NULL };
    char *file_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:accel_map_save", kwlist, &file_name))
        return NULL;
    
    gtk_accel_map_save(file_name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 8398 "./gtk.override"
static void
pygtk_accel_map_foreach_cb(gpointer data, const gchar *accel_path,
                                guint accel_key, GdkModifierType accel_mode,
                                gboolean changed)
{
    PyGILState_STATE state;
    PyObject *retobj, *py_accel_mode;
    PyGtkCustomNotify *cunote = data;
  
    g_assert(cunote->func);

    state = pyg_gil_state_ensure();
    py_accel_mode = pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE, accel_mode);
    if (cunote->data)
        retobj = PyEval_CallFunction(cunote->func, "(siNNO)",
                                     accel_path, accel_key, py_accel_mode,
                                     PyBool_FromLong(changed), cunote->data);
    else
        retobj = PyEval_CallFunction(cunote->func, "(siNN)", accel_path,
                                     accel_key, py_accel_mode,
                                     PyBool_FromLong(changed));
 
    if (retobj == NULL)
        PyErr_Print();

    Py_XDECREF(retobj);
  
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_accel_map_foreach(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "foreach_func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:gtk.accel_map_foreach",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;
  
    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "foreach_func must be a callable object");
        return NULL;
    }

    cunote.func = pyfunc;
    cunote.data = pyarg;
 
    gtk_accel_map_foreach(&cunote, pygtk_accel_map_foreach_cb);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 123410 "gtk.c"


#line 3711 "./gtk.override"
static PyObject *
_wrap_gtk_accel_map_load_fd(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "fd", NULL };
    gint fd;
    PyObject *py_fd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.accel_map_load_fd",
				     kwlist, &py_fd))
        return NULL;

    if ((fd = PyObject_AsFileDescriptor(py_fd)) != -1)
	gtk_accel_map_load_fd(fd);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 123433 "gtk.c"


#line 3732 "./gtk.override"
static PyObject *
_wrap_gtk_accel_map_save_fd(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "fd", NULL };
    gint fd;
    PyObject *py_fd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.accel_map_save_fd",
				     kwlist, &py_fd))
        return NULL;

    if ((fd = PyObject_AsFileDescriptor(py_fd)) != -1)
	gtk_accel_map_save_fd(fd);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 123456 "gtk.c"


static PyObject *
_wrap_gtk_accel_map_lock_path(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", NULL };
    char *accel_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:accel_map_lock_path", kwlist, &accel_path))
        return NULL;
    
    gtk_accel_map_lock_path(accel_path);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accel_map_unlock_path(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", NULL };
    char *accel_path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:accel_map_unlock_path", kwlist, &accel_path))
        return NULL;
    
    gtk_accel_map_unlock_path(accel_path);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_accel_map_add_filter(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filter_pattern", NULL };
    char *filter_pattern;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:accel_map_add_filter", kwlist, &filter_pattern))
        return NULL;
    
    gtk_accel_map_add_filter(filter_pattern);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 8455 "./gtk.override"
static PyObject *
_wrap_gtk_accel_map_foreach_unfiltered(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "foreach_func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:gtk.accel_map_foreach_unfiltered",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;
  
    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "foreach_func must be a callable object");
        return NULL;
    }

    cunote.func = pyfunc;
    cunote.data = pyarg;
 
    gtk_accel_map_foreach_unfiltered(&cunote, pygtk_accel_map_foreach_cb);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 123531 "gtk.c"


static PyObject *
_wrap_gtk_accel_map_get(PyObject *self)
{
    GtkAccelMap *ret;

    
    ret = gtk_accel_map_get();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_bindings_activate(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "object", "keyval", "modifiers", NULL };
    PyGObject *object;
    PyObject *py_keyval = NULL, *py_modifiers = NULL;
    int ret;
    GdkModifierType modifiers;
    guint keyval = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO:bindings_activate", kwlist, &PyGtkObject_Type, &object, &py_keyval, &py_modifiers))
        return NULL;
    if (py_keyval) {
        if (PyLong_Check(py_keyval))
            keyval = PyLong_AsUnsignedLong(py_keyval);
        else if (PyInt_Check(py_keyval))
            keyval = PyInt_AsLong(py_keyval);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'keyval' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_modifiers, (gpointer)&modifiers))
        return NULL;
    
    ret = gtk_bindings_activate(GTK_OBJECT(object->obj), keyval, modifiers);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_bindings_activate_event(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "object", "event", NULL };
    PyGObject *object;
    GdkEvent *event = NULL;
    int ret;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:bindings_activate_event", kwlist, &PyGtkObject_Type, &object, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    ret = gtk_bindings_activate_event(GTK_OBJECT(object->obj), (GdkEventKey *)event);
    
    return PyBool_FromLong(ret);

}

#line 962 "./gtk.override"
static PyObject *
_wrap_gtk_binding_entry_add_signal(PyGObject *self, PyObject *args)
{
    PyObject *first;
    gint len, i;
    PyObject *class;
    guint keyval, modifiers;
    gchar *signal_name;
    GType class_type;
    GtkBindingSet *bset = NULL;
    GSList *slist = NULL;
    gchar *errmsg;

    len = PyTuple_Size(args);
    if (len < 4) {
        PyErr_SetString(PyExc_TypeError, "binding_entry_add_signal requires at"
                        " least 4 arguments");
        return NULL;
    }
    first = PySequence_GetSlice(args, 0, 4);
    if (!PyArg_ParseTuple(first, "Oiis:binding_entry_add_signal", &class,
                          &keyval, &modifiers, &signal_name)) {
        Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
        return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));

    /* extra args */
    if ((len-4)%2) {
        PyErr_SetString(PyExc_ValueError,
                        "GtkBindingSet.add_signal requires an even number"
                        " of parameter pairs following the first four args");
        return NULL;
    }
    for (i=4; i < len; i+=2) {
        PyObject *item;
        GType arg_type;
        GtkBindingArg *arg = NULL;

        item = PyTuple_GET_ITEM(args, i);
        arg_type = pyg_type_from_object(item);
        if (!arg_type) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "GtkBindingSet.add_signal parameter types"
                            " must be int");
            goto arg_error;
        }
        arg = g_new0 (GtkBindingArg, 1);
        slist = g_slist_prepend(slist, arg);

        arg->arg_type = arg_type;
        switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
        case GTK_TYPE_CHAR:
        case GTK_TYPE_UCHAR:
        case GTK_TYPE_INT:
        case GTK_TYPE_UINT:
        case GTK_TYPE_BOOL:
        case GTK_TYPE_ENUM:
        case GTK_TYPE_FLAGS:
        case GTK_TYPE_LONG:
        case GTK_TYPE_ULONG:
            arg->arg_type = GTK_TYPE_LONG;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyInt_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal "
                                         "arg[%u] must be int", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.long_data = (glong)PyInt_AsLong(item);
            break;
        case GTK_TYPE_FLOAT:
        case GTK_TYPE_DOUBLE:
            arg->arg_type = GTK_TYPE_DOUBLE;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyFloat_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal "
                                         "arg[%u] must be float", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.double_data = (gdouble)PyFloat_AsDouble(item);
            break;
        case GTK_TYPE_STRING:
            arg->arg_type = GTK_TYPE_STRING;
            if (arg->arg_type != GTK_TYPE_IDENTIFIER)
                arg->arg_type = GTK_TYPE_STRING;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyString_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
                                         "must be non-empty string", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.string_data = (gchar*)PyString_AsString(item);
            if (!arg->d.string_data) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
                                         "must be non-empty string", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            break;
        default:
            errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
                                     "type %10s for arg[%u]",
                                     gtk_type_name(arg->arg_type), i+1);
            PyErr_SetString(PyExc_TypeError, errmsg);
            g_free(errmsg);
            goto arg_error;
        } /* switch */
    }

    slist = g_slist_reverse (slist);
    gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);

    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);

    Py_INCREF(Py_None);
    return Py_None;

arg_error:
    if (slist) {
        g_slist_foreach(slist, (GFunc)g_free, NULL);
        g_slist_free(slist);
    }
    return NULL;
}
#line 123741 "gtk.c"


#line 3836 "./gtk.override"
static PyObject *
_wrap_gtk_binding_entry_remove(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "class_type", "keyval", "modifiers", NULL };
    int keyval;
    PyObject *py_modifiers = NULL;
    GdkModifierType modifiers;
    PyObject *class;
    GType class_type;
    GtkBindingSet *bset = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:gtk_binding_entry_remove",
				     kwlist, &class, &keyval, &py_modifiers))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_modifiers, (gint *)&modifiers))
        return NULL;

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
        return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));
    gtk_binding_entry_remove(bset, keyval, modifiers);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 123772 "gtk.c"


static PyObject *
_wrap_gtk_cell_view_new_with_text(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;
    PyObject *py_ret;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:cell_view_new_with_text", kwlist, &text))
        return NULL;
    
    ret = gtk_cell_view_new_with_text(text);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_cell_view_new_with_markup(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "markup", NULL };
    char *markup;
    PyObject *py_ret;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:cell_view_new_with_markup", kwlist, &markup))
        return NULL;
    
    ret = gtk_cell_view_new_with_markup(markup);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_cell_view_new_with_pixbuf(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf;
    PyObject *py_ret;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:cell_view_new_with_pixbuf", kwlist, &PyGdkPixbuf_Type, &pixbuf))
        return NULL;
    
    ret = gtk_cell_view_new_with_pixbuf(GDK_PIXBUF(pixbuf->obj));
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_clipboard_get(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "selection", NULL };
    PyObject *py_selection = NULL;
    GdkAtom selection = GDK_SELECTION_CLIPBOARD;
    GtkClipboard *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:clipboard_get", kwlist, &py_selection))
        return NULL;
    if (py_selection) {
        selection = pygdk_atom_from_pyobject(py_selection);
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_clipboard_get(selection);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 3753 "./gtk.override"
static PyObject *
_wrap_gtk_color_selection_palette_from_string(PyGObject *self, PyObject *args,
					      PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    gchar *str;
    GdkColor *colors;
    gint i, n_colors;
    PyObject *py_list;

    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "s:gtk.color_selection_palette_from_string",
	kwlist, &str))
        return NULL;

    if (!gtk_color_selection_palette_from_string(str, &colors, &n_colors)) {
	Py_INCREF(Py_None);
	return Py_None;
    }

    if ((py_list = PyList_New(n_colors)) == NULL) {
	g_free(colors);
	return NULL;
    }

    for (i = 0; i < n_colors; i++) {
	PyObject *item = pyg_boxed_new(GDK_TYPE_COLOR, &colors[i], TRUE, TRUE);

	PyList_SetItem(py_list, i, item);
    }
    g_free(colors);

    return py_list;
}
#line 123889 "gtk.c"


#line 3789 "./gtk.override"
static PyObject *
_wrap_gtk_color_selection_palette_to_string(PyGObject *self, PyObject *args,
					      PyObject *kwargs)
{
    static char *kwlist[] = { "colors", NULL };
    gchar *str;
    GdkColor *colors;
    gint i, n_colors;
    PyObject *py_colors, *ret;

    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "O:gtk.color_selection_palette_to_string",
	kwlist, &py_colors))
        return NULL;

    if (!(py_colors = PySequence_Fast(
              py_colors, "colors must be a sequence of gtk.gdk.Colors")))
        return NULL;

    n_colors = PySequence_Fast_GET_SIZE(py_colors);
    if ((colors = g_new0(GdkColor, n_colors)) == NULL) {
        Py_DECREF(py_colors);
	return NULL;
    }
    for (i = 0; i < n_colors; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_colors, i);
	if (!pyg_boxed_check(item, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError,
			    "colors must contain gtk.gdk.Colors");
	    g_free(colors);
            Py_DECREF(py_colors);
	    return NULL;
	}
	colors[i] = *pyg_boxed_get(item, GdkColor);
    }

    str = gtk_color_selection_palette_to_string(colors, n_colors);
    ret = PyString_FromString(str);
    g_free(colors);
    g_free(str);
    Py_DECREF(py_colors);

    return ret;
}

#line 123938 "gtk.c"


static PyObject *
_wrap_gtk_combo_box_new_text(PyObject *self)
{
    PyObject *py_ret;
    GtkWidget *ret;

    
    ret = gtk_combo_box_new_text();
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_combo_box_entry_new_with_model(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", "text_column", NULL };
    PyGObject *model;
    int text_column;
    GtkWidget *ret;
    PyObject *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:combo_box_entry_new_with_model", kwlist, &PyGtkTreeModel_Type, &model, &text_column))
        return NULL;
    
    ret = gtk_combo_box_entry_new_with_model(GTK_TREE_MODEL(model->obj), text_column);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_combo_box_entry_new_text(PyObject *self)
{
    PyObject *py_ret;
    GtkWidget *ret;

    
    ret = gtk_combo_box_entry_new_text();
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

#line 649 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_class_install_child_property (PyObject *self,
					       PyObject *args,
					       PyObject* kwargs)
{
    static char *kwlist[] = { "klass", "property_id", "pspec", NULL };
    PyObject *py_itype, *property;
    GType itype;
    GtkContainerClass *class;
    guint property_id;
    GParamSpec *pspec;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use the gtk.Container.install_child_property classmethod"))
        return NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:container_class_install_child_property",
				     kwlist,
				     &py_itype, &property_id, &property))
	return NULL;


    if ((itype = pyg_type_from_object(py_itype)) == 0)
	return NULL;

    if (!g_type_is_a(itype, GTK_TYPE_CONTAINER)) {
	PyErr_SetString(PyExc_TypeError, "type must be derived from GtkContainer");
	return NULL;
    }

    class = g_type_class_ref(itype);
    if (!class) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not get a reference to type class");
	return NULL;
    }

    pspec = pyg_param_spec_from_object(property);
    if(!pspec) {
	g_type_class_unref(class);
	return NULL;
    }

    if (gtk_container_class_find_child_property(G_OBJECT_CLASS(class), pspec->name)) {
	PyErr_Format(PyExc_TypeError,
		     "there is already a '%s' property installed", pspec->name);
	g_type_class_unref(class);
	return NULL;
    }
    
    gtk_container_class_install_child_property(class, property_id, pspec);
	
    g_type_class_unref(class);

    Py_INCREF(Py_None);
    return Py_None;
}

#line 124050 "gtk.c"


#line 557 "gtkcontainer.override"
static PyObject *
_wrap_gtk_container_class_list_child_properties (PyObject *self, PyObject *args,
					      PyObject*kwargs)
{
    static char *kwlist[] = { "klass", NULL };
    GParamSpec **specs;
    PyObject *py_itype, *list;
    GType itype;
    GObjectClass *class;
    guint nprops;
    guint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.container_class_list_child_properties", kwlist,
				     &py_itype))
	return NULL;
    
    if ((itype = pyg_type_from_object(py_itype)) == 0)
	return NULL;

    if (!g_type_is_a(itype, G_TYPE_OBJECT)) {
	PyErr_SetString(PyExc_TypeError, "type must be derived from GObject");
	return NULL;
    }

    class = g_type_class_ref(itype);
    if (!class) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not get a reference to type class");
	return NULL;
    }

    specs = gtk_container_class_list_child_properties(class, &nprops);
    list = PyTuple_New(nprops);
    if (list == NULL) {
	g_free(specs);
	g_type_class_unref(class);
	return NULL;
    }
    
    for (i = 0; i < nprops; i++) {
	PyTuple_SetItem(list, i, pyg_param_spec_new(specs[i]));
    }
    
    g_free(specs);
    g_type_class_unref(class);

    return list;
}
#line 124103 "gtk.c"


static PyObject *
_wrap_gtk_alternative_dialog_button_order(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *py_screen = NULL;
    int ret;
    GdkScreen *screen = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|O:alternative_dialog_button_order", kwlist, &py_screen))
        return NULL;
    if ((PyObject *)py_screen == Py_None)
        screen = NULL;
    else if (py_screen && pygobject_check(py_screen, &PyGdkScreen_Type))
        screen = GDK_SCREEN(py_screen->obj);
    else if (py_screen) {
        PyErr_SetString(PyExc_TypeError, "screen should be a GdkScreen or None");
        return NULL;
    }
    
    ret = gtk_alternative_dialog_button_order((GdkScreen *) screen);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_drag_set_default_icon(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "colormap", "pixmap", "mask", "hot_x", "hot_y", NULL };
    PyGObject *colormap, *pixmap, *mask;
    int hot_x, hot_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!O!ii:drag_set_default_icon", kwlist, &PyGdkColormap_Type, &colormap, &PyGdkPixmap_Type, &pixmap, &PyGdkPixmap_Type, &mask, &hot_x, &hot_y))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "change the stock pixbuf for GTK_STOCK_DND") < 0)
        return NULL;
    
    gtk_drag_set_default_icon(GDK_COLORMAP(colormap->obj), GDK_PIXMAP(pixmap->obj), GDK_PIXMAP(mask->obj), hot_x, hot_y);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 6384 "./gtk.override"
static PyObject *
_wrap_gtk_target_list_add_text_targets(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", NULL };
    PyObject *list = NULL;
    guint info = 0;
    GtkTargetList *targets;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oi:gtk.target_list_add_text_targets",
                                     kwlist, &list, &info)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        targets = gtk_target_list_new(NULL, 0);
    } else if (!(targets = pygtk_target_list_from_sequence(list)))
        return NULL;

    gtk_target_list_add_text_targets(targets, info);
    list = pygtk_target_list_to_list(targets);
    gtk_target_list_unref(targets);
    return list;
}
#line 124174 "gtk.c"


#line 6410 "./gtk.override"
static PyObject *
_wrap_gtk_target_list_add_image_targets(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", "writable", NULL };
    PyObject *list = NULL;
    guint info = 0;
    gboolean writable = FALSE;
    GtkTargetList *targets;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oii:gtk.target_list_add_text_targets",
                                     kwlist, &list, &info, &writable)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        targets = gtk_target_list_new(NULL, 0);
    } else if (!(targets = pygtk_target_list_from_sequence(list)))
        return NULL;

    gtk_target_list_add_image_targets(targets, info, writable);
    list = pygtk_target_list_to_list(targets);
    gtk_target_list_unref(targets);
    return list;
}
#line 124203 "gtk.c"


#line 6437 "./gtk.override"
static PyObject *
_wrap_gtk_target_list_add_uri_targets(PyGObject *self, PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", NULL };
    PyObject *list = NULL;
    guint info = 0;
    GtkTargetList *targets;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oi:gtk.target_list_add_text_targets",
                                     kwlist, &list, &info)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        targets = gtk_target_list_new(NULL, 0);
    } else if (!(targets = pygtk_target_list_from_sequence(list)))
        return NULL;

    gtk_target_list_add_uri_targets(targets, info);
    list = pygtk_target_list_to_list(targets);
    gtk_target_list_unref(targets);
    return list;
}
#line 124231 "gtk.c"


static PyObject *
_wrap_gtk_drag_get_source_widget(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "context", NULL };
    PyGObject *context;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:drag_get_source_widget", kwlist, &PyGdkDragContext_Type, &context))
        return NULL;
    
    ret = gtk_drag_get_source_widget(GDK_DRAG_CONTEXT(context->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 451 "gtkwidget.override"
static PyObject *
_wrap_gtk_drag_source_set_icon_name1(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "icon_name", NULL };
    PyGObject *widget;
    PyObject *icon_name, *ret, *nargs;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.Widget.drag_source_set_icon_name") < 0)
        return NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!s:gtk.drag_source_set_icon_name",
                                     kwlist, &PyGtkWidget_Type, &widget,
                                     &icon_name))
	return NULL;
    nargs = Py_BuildValue("(s)", icon_name);
    ret = _wrap_gtk_drag_source_set_icon_name(widget, nargs, NULL);
    Py_DECREF(nargs);
    return ret;
}
#line 124271 "gtk.c"


static PyObject *
_wrap_gtk_expander_new_with_mnemonic(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    char *label = NULL;
    PyObject *py_ret;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|z:expander_new_with_mnemonic", kwlist, &label))
        return NULL;
    
    ret = gtk_expander_new_with_mnemonic(label);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_file_chooser_widget_new_with_backend(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action", "backend", NULL };
    PyObject *py_action = NULL, *py_ret;
    char *backend;
    GtkFileChooserAction action;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Os:file_chooser_widget_new_with_backend", kwlist, &py_action, &backend))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_FILE_CHOOSER_ACTION, py_action, (gpointer)&action))
        return NULL;
    
    ret = gtk_file_chooser_widget_new_with_backend(action, backend);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_hbutton_box_get_spacing_default(PyObject *self)
{
    int ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    ret = gtk_hbutton_box_get_spacing_default();
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_hbutton_box_get_layout_default(PyObject *self)
{
    gint ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    ret = gtk_hbutton_box_get_layout_default();
    
    return pyg_enum_from_gtype(GTK_TYPE_BUTTON_BOX_STYLE, ret);
}

static PyObject *
_wrap_gtk_hbutton_box_set_spacing_default(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "spacing", NULL };
    int spacing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:hbutton_box_set_spacing_default", kwlist, &spacing))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_hbutton_box_set_spacing_default(spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_hbutton_box_set_layout_default(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "layout", NULL };
    PyObject *py_layout = NULL;
    GtkButtonBoxStyle layout;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:hbutton_box_set_layout_default", kwlist, &py_layout))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_BUTTON_BOX_STYLE, py_layout, (gpointer)&layout))
        return NULL;
    
    gtk_hbutton_box_set_layout_default(layout);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_factory_lookup_default(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", NULL };
    char *stock_id;
    GtkIconSet *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:icon_factory_lookup_default", kwlist, &stock_id))
        return NULL;
    
    ret = gtk_icon_factory_lookup_default(stock_id);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_ICON_SET, ret, TRUE, TRUE);
}

#line 3383 "./gtk.override"
static PyObject *
_wrap_gtk_icon_size_lookup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_size", NULL };
    PyObject *py_icon_size;
    GtkIconSize icon_size;
    gint width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:icon_size_lookup",
                                     kwlist, &py_icon_size))
        return NULL;

    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_icon_size,
                           (gint *) &icon_size))
        return NULL;

    gtk_icon_size_lookup(icon_size, &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
#line 124415 "gtk.c"


#line 5171 "./gtk.override"
static PyObject *
_wrap_gtk_icon_size_lookup_for_settings(PyGObject *self, PyObject *args,
					PyObject *kwargs)
{
    static char *kwlist[] = { "settings", "icon_size", NULL };
    PyObject *py_settings, *py_icon_size;
    GtkSettings *settings;
    GtkIconSize icon_size;
    gint width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!O:icon_size_lookupfor settings",
                                     kwlist, &PyGtkSettings_Type,
				     &py_settings, &py_icon_size))
        return NULL;

    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_icon_size,
                           (gint *) &icon_size))
        return NULL;

    settings = GTK_SETTINGS(pygobject_get(py_settings));
    if (gtk_icon_size_lookup_for_settings(settings, icon_size,
					  &width, &height))
	return Py_BuildValue("(ii)", width, height);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 124447 "gtk.c"


static PyObject *
_wrap_gtk_icon_size_register(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "width", "height", NULL };
    char *name;
    int width, height;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sii:icon_size_register", kwlist, &name, &width, &height))
        return NULL;
    
    ret = gtk_icon_size_register(name, width, height);
    
    return pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, ret);
}

static PyObject *
_wrap_gtk_icon_size_register_alias(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "alias", "target", NULL };
    char *alias;
    PyObject *py_target = NULL;
    GtkIconSize target;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO:icon_size_register_alias", kwlist, &alias, &py_target))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_target, (gpointer)&target))
        return NULL;
    
    gtk_icon_size_register_alias(alias, target);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_size_from_name(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    gint ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:icon_size_from_name", kwlist, &name))
        return NULL;
    
    ret = gtk_icon_size_from_name(name);
    
    return pyg_enum_from_gtype(GTK_TYPE_ICON_SIZE, ret);
}

static PyObject *
_wrap_gtk_icon_size_get_name(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    PyObject *py_size = NULL;
    const gchar *ret;
    GtkIconSize size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:icon_size_get_name", kwlist, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    ret = gtk_icon_size_get_name(size);
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_set_new(PyObject *self)
{
    GtkIconSet *ret;

    
    ret = gtk_icon_set_new();
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_ICON_SET, ret, FALSE, TRUE);
}

static PyObject *
_wrap_gtk_icon_theme_get_default(PyObject *self)
{
    GtkIconTheme *ret;

    
    ret = gtk_icon_theme_get_default();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_icon_theme_get_for_screen(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *screen;
    GtkIconTheme *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:icon_theme_get_for_screen", kwlist, &PyGdkScreen_Type, &screen))
        return NULL;
    
    ret = gtk_icon_theme_get_for_screen(GDK_SCREEN(screen->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_icon_theme_add_builtin_icon(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", "size", "pixbuf", NULL };
    char *icon_name;
    int size;
    PyGObject *pixbuf;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"siO!:icon_theme_add_builtin_icon", kwlist, &icon_name, &size, &PyGdkPixbuf_Type, &pixbuf))
        return NULL;
    
    gtk_icon_theme_add_builtin_icon(icon_name, size, GDK_PIXBUF(pixbuf->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_image_new_from_pixmap(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixmap", "mask", NULL };
    PyGObject *py_pixmap, *py_mask;
    PyObject *py_ret;
    GtkWidget *ret;
    GdkPixmap *pixmap = NULL, *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:image_new_from_pixmap", kwlist, &py_pixmap, &py_mask))
        return NULL;
    if (py_pixmap && pygobject_check(py_pixmap, &PyGdkPixmap_Type))
        pixmap = GDK_PIXMAP(py_pixmap->obj);
    else if ((PyObject *)py_pixmap != Py_None) {
        PyErr_SetString(PyExc_TypeError, "pixmap should be a GdkPixmap or None");
        return NULL;
    }
    if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if ((PyObject *)py_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return NULL;
    }
    
    ret = gtk_image_new_from_pixmap((GdkPixmap *) pixmap, (GdkBitmap *) mask);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_image_new_from_image(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "image", "mask", NULL };
    PyGObject *py_image, *py_mask;
    PyObject *py_ret;
    GtkWidget *ret;
    GdkPixmap *mask = NULL;
    GdkImage *image = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:image_new_from_image", kwlist, &py_image, &py_mask))
        return NULL;
    if (py_image && pygobject_check(py_image, &PyGdkImage_Type))
        image = GDK_IMAGE(py_image->obj);
    else if ((PyObject *)py_image != Py_None) {
        PyErr_SetString(PyExc_TypeError, "image should be a GdkImage or None");
        return NULL;
    }
    if (py_mask && pygobject_check(py_mask, &PyGdkPixmap_Type))
        mask = GDK_PIXMAP(py_mask->obj);
    else if ((PyObject *)py_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap or None");
        return NULL;
    }
    
    ret = gtk_image_new_from_image((GdkImage *) image, (GdkBitmap *) mask);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_image_new_from_file(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:image_new_from_file", kwlist, &filename))
        return NULL;
    
    ret = gtk_image_new_from_file(filename);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_image_new_from_pixbuf(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *py_pixbuf;
    PyObject *py_ret;
    GdkPixbuf *pixbuf = NULL;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:image_new_from_pixbuf", kwlist, &py_pixbuf))
        return NULL;
    if (py_pixbuf && pygobject_check(py_pixbuf, &PyGdkPixbuf_Type))
        pixbuf = GDK_PIXBUF(py_pixbuf->obj);
    else if ((PyObject *)py_pixbuf != Py_None) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf or None");
        return NULL;
    }
    
    ret = gtk_image_new_from_pixbuf((GdkPixbuf *) pixbuf);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_image_new_from_stock(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "size", NULL };
    char *stock_id;
    PyObject *py_size = NULL, *py_ret;
    GtkIconSize size;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO:image_new_from_stock", kwlist, &stock_id, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    ret = gtk_image_new_from_stock(stock_id, size);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_image_new_from_icon_set(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_set", "size", NULL };
    PyObject *py_icon_set, *py_size = NULL, *py_ret;
    GtkIconSize size;
    GtkWidget *ret;
    GtkIconSet *icon_set = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OO:image_new_from_icon_set", kwlist, &py_icon_set, &py_size))
        return NULL;
    if (pyg_boxed_check(py_icon_set, GTK_TYPE_ICON_SET))
        icon_set = pyg_boxed_get(py_icon_set, GtkIconSet);
    else {
        PyErr_SetString(PyExc_TypeError, "icon_set should be a GtkIconSet");
        return NULL;
    }
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    ret = gtk_image_new_from_icon_set(icon_set, size);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_image_new_from_animation(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "animation", NULL };
    PyGObject *animation;
    PyObject *py_ret;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:image_new_from_animation", kwlist, &PyGdkPixbufAnimation_Type, &animation))
        return NULL;
    
    ret = gtk_image_new_from_animation(GDK_PIXBUF_ANIMATION(animation->obj));
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_image_new_from_icon_name(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", "size", NULL };
    char *icon_name;
    PyObject *py_size = NULL, *py_ret;
    GtkIconSize size;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"sO:image_new_from_icon_name", kwlist, &icon_name, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    ret = gtk_image_new_from_icon_name(icon_name, size);
    
    py_ret = pygobject_new((GObject *)ret);
    if (ret != NULL)
        g_object_unref(ret);
    return py_ret;
}

static PyObject *
_wrap_gtk_item_factory_add_foreign(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_widget", "full_path", "accel_group", "keyval", "modifiers", NULL };
    PyGObject *accel_widget, *accel_group;
    char *full_path;
    PyObject *py_keyval = NULL, *py_modifiers = NULL;
    GdkModifierType modifiers;
    guint keyval = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!sO!OO:item_factory_add_foreign", kwlist, &PyGtkWidget_Type, &accel_widget, &full_path, &PyGtkAccelGroup_Type, &accel_group, &py_keyval, &py_modifiers))
        return NULL;
    if (py_keyval) {
        if (PyLong_Check(py_keyval))
            keyval = PyLong_AsUnsignedLong(py_keyval);
        else if (PyInt_Check(py_keyval))
            keyval = PyInt_AsLong(py_keyval);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'keyval' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_modifiers, (gpointer)&modifiers))
        return NULL;
    
    gtk_item_factory_add_foreign(GTK_WIDGET(accel_widget->obj), full_path, GTK_ACCEL_GROUP(accel_group->obj), keyval, modifiers);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_item_factory_from_widget(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;
    GtkItemFactory *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:item_factory_from_widget", kwlist, &PyGtkWidget_Type, &widget))
        return NULL;
    
    ret = gtk_item_factory_from_widget(GTK_WIDGET(widget->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_item_factory_path_from_widget(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;
    const gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:item_factory_path_from_widget", kwlist, &PyGtkWidget_Type, &widget))
        return NULL;
    
    ret = gtk_item_factory_path_from_widget(GTK_WIDGET(widget->obj));
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_item_factory_from_path(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    char *path;
    GtkItemFactory *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:item_factory_from_path", kwlist, &path))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    ret = gtk_item_factory_from_path(path);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_item_factories_path_delete(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "ifactory_path", "path", NULL };
    char *ifactory_path, *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ss:item_factories_path_delete", kwlist, &ifactory_path, &path))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_item_factories_path_delete(ifactory_path, path);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_check_version(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "required_major", "required_minor", "required_micro", NULL };
    PyObject *py_required_major = NULL, *py_required_minor = NULL, *py_required_micro = NULL;
    const gchar *ret;
    guint required_major = 0, required_minor = 0, required_micro = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOO:check_version", kwlist, &py_required_major, &py_required_minor, &py_required_micro))
        return NULL;
    if (py_required_major) {
        if (PyLong_Check(py_required_major))
            required_major = PyLong_AsUnsignedLong(py_required_major);
        else if (PyInt_Check(py_required_major))
            required_major = PyInt_AsLong(py_required_major);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'required_major' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_required_minor) {
        if (PyLong_Check(py_required_minor))
            required_minor = PyLong_AsUnsignedLong(py_required_minor);
        else if (PyInt_Check(py_required_minor))
            required_minor = PyInt_AsLong(py_required_minor);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'required_minor' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_required_micro) {
        if (PyLong_Check(py_required_micro))
            required_micro = PyLong_AsUnsignedLong(py_required_micro);
        else if (PyInt_Check(py_required_micro))
            required_micro = PyInt_AsLong(py_required_micro);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'required_micro' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    ret = gtk_check_version(required_major, required_minor, required_micro);
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

#line 395 "./gtk.override"
static PyObject *
_wrap_gtk_init_check(PyGObject *self, PyObject *args)
{
    PyObject *av;
    int argc, i;
    char **argv;
    
    /* initialise GTK ... */
    av = PySys_GetObject("argv");
    if (av != NULL) {
	if (!PyList_Check(av)) {
	    PyErr_Warn(PyExc_Warning, "ignoring sys.argv: it must be a list of strings");
	    av = NULL;
	} else {
	    argc = PyList_Size(av);
	    for (i = 0; i < argc; i++)
		if (!PyString_Check(PyList_GetItem(av, i))) {
		    PyErr_Warn(PyExc_Warning, "ignoring sys.argv: it must be a list of strings");
		    av = NULL;
		    break;
		}
	}
    }
    if (av != NULL) {
	argv = g_new(char *, argc);
	for (i = 0; i < argc; i++)
	    argv[i] = g_strdup(PyString_AsString(PyList_GetItem(av, i)));
    } else {
	    argc = 0;
	    argv = NULL;
    }

    if (!gtk_init_check(&argc, &argv)) {
	if (argv != NULL) {
	    for (i = 0; i < argc; i++)
		g_free(argv[i]);
	    g_free(argv);
	}
	PyErr_SetString(PyExc_RuntimeError, "could not open display");
	/* set the LC_NUMERIC locale back to "C", as Python < 2.4 requires
	 * that it be set that way. */
#if PY_VERSION_HEX < 0x020400F0
	setlocale(LC_NUMERIC, "C");
#endif
	return NULL;
    }
    /* set the LC_NUMERIC locale back to "C", as Python < 2.4 requires that
     * it be set that way. */
#if PY_VERSION_HEX < 0x020400F0
    setlocale(LC_NUMERIC, "C");
#endif
    if (argv != NULL) {
	PySys_SetArgv(argc, argv);
	for (i = 0; i < argc; i++)
	    g_free(argv[i]);
	g_free(argv);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 124987 "gtk.c"


static PyObject *
_wrap_gtk_disable_setlocale(PyObject *self)
{
    
    gtk_disable_setlocale();
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_get_default_language(PyObject *self)
{
    PangoLanguage *ret;

    
    ret = gtk_get_default_language();
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PANGO_TYPE_LANGUAGE, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_events_pending(PyObject *self)
{
    int ret;

    
    ret = gtk_events_pending();
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_main_do_event(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "event", NULL };
    GdkEvent *event = NULL;
    PyObject *py_event;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:main_do_event", kwlist, &py_event))
        return NULL;
    if (pyg_boxed_check(py_event, GDK_TYPE_EVENT))
        event = pyg_boxed_get(py_event, GdkEvent);
    else {
        PyErr_SetString(PyExc_TypeError, "event should be a GdkEvent");
        return NULL;
    }
    
    gtk_main_do_event(event);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 1103 "./gtk.override"

  /* This code (pygtk main watch) was copied with minor changes from
   * pygobject/gobject/pygmainloop.c */

static int pipe_fds[2];

typedef struct {
    GSource source;
    GPollFD fd;
} PySignalWatchSource;

static gboolean
pygtk_main_watch_prepare(GSource *source,
                         int     *timeout)
{
    /* Python only invokes signal handlers from the main thread,
     * so if a thread other than the main thread receives the signal
     * from the kernel, PyErr_CheckSignals() from that thread will
     * do nothing.
     */

#ifdef HAVE_PYSIGNAL_SETWAKEUPFD
    return FALSE;
#else /* !HAVE_PYSIGNAL_SETWAKEUPFD */
    /* On Windows g_poll() won't be interrupted by a signal
     * (AFAIK), so we need the timeout there too, even if there's
     * only one thread.
     */
#ifndef PLATFORM_WIN32
    if (!pyg_threads_enabled)
        return FALSE;
#endif /* PLATFORM_WIN32 */

    /* If we're using 2.5 or an earlier version of python we
     * will default to a timeout every second, be aware,
     * this will cause unnecessary wakeups, see
     * http://bugzilla.gnome.org/show_bug.cgi?id=481569
     */
    *timeout = 1000;
    return FALSE;
#endif /* HAVE_PYSIGNAL_SETWAKEUPFD */
}

static gboolean
pygtk_main_watch_check(GSource *source)
{
    PyGILState_STATE state;

#ifdef HAVE_PYSIGNAL_SETWAKEUPFD
    PySignalWatchSource *real_source = (PySignalWatchSource *)source;
    GPollFD *poll_fd = &real_source->fd;
    unsigned char dummy;
    gssize ret;
    if (poll_fd->revents & G_IO_IN)
        ret = read(poll_fd->fd, &dummy, 1);
#endif

    state = pyg_gil_state_ensure();

    if (PyErr_CheckSignals() == -1 && gtk_main_level() > 0) {
        PyErr_SetNone(PyExc_KeyboardInterrupt);
        gtk_main_quit();
    }

    pyg_gil_state_release(state);

    return FALSE;
}

static gboolean
pygtk_main_watch_dispatch(GSource    *source,
			  GSourceFunc callback,
			  gpointer    user_data)
{
    /* We should never be dispatched */
    g_assert_not_reached();
    return TRUE;
}

static GSourceFuncs pygtk_main_watch_funcs =
{
    pygtk_main_watch_prepare,
    pygtk_main_watch_check,
    pygtk_main_watch_dispatch
};

static GSource *
pygtk_main_watch_new(void)
{
    GSource *source = g_source_new(&pygtk_main_watch_funcs, sizeof(PySignalWatchSource));

#ifdef HAVE_PYSIGNAL_SETWAKEUPFD
    PySignalWatchSource *real_source = (PySignalWatchSource *)source;
    int flag;

    /* Unfortunately we need to create a new pipe here instead of
     * reusing the pipe inside the GMainContext.
     * Ideally an api should be added to GMainContext which allows us
     * to reuse that pipe which would suit us perfectly fine.
     * XXX More efficient than a pipe, we could use an eventfd on Linux
     * kernels that support it.
     */
    gint already_piped = (pipe_fds[0] > 0);
    if (!already_piped) {
	if (pipe(pipe_fds) < 0)
	    g_error("Cannot create main loop pipe: %s\n",
	            g_strerror(errno));

        /* Make the write end of the fd non blocking */
        flag = fcntl(pipe_fds[1], F_GETFL, 0);
        flag |= O_NONBLOCK;
        fcntl(pipe_fds[1], F_SETFL, flag);
    }

    real_source->fd.fd = pipe_fds[0];
    real_source->fd.events = G_IO_IN | G_IO_HUP | G_IO_ERR;
    g_source_add_poll(source, &real_source->fd);

    if (!already_piped)
      PySignal_SetWakeupFd(pipe_fds[1]);
#endif
    return source;
}


static PyObject *
_wrap_gtk_main(PyObject *self)
{
    GSource *main_watch;
    // Call enable_threads again to ensure that the thread state is recorded
    if (pyg_threads_enabled)
	pyg_enable_threads();

    main_watch = pygtk_main_watch_new();
    pyg_begin_allow_threads;
    g_source_attach(main_watch, NULL);
    g_source_unref(main_watch);
    gtk_main();
    g_source_destroy(main_watch);
    pyg_end_allow_threads;
    if (PyErr_Occurred())
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
#line 125191 "gtk.c"


static PyObject *
_wrap_gtk_main_level(PyObject *self)
{
    guint ret;

    
    ret = gtk_main_level();
    
    return PyLong_FromUnsignedLong(ret);
}

#line 1267 "./gtk.override"
static PyObject *
_wrap_gtk_main_quit(PyObject *self, PyObject *args)
{
    /* args is just ignored, so obj.connect(signal, func) always works */

    /* Sanity check to make sure we're in a mainloop */
    if (gtk_main_level() == 0) {
	PyErr_SetString(PyExc_RuntimeError,
			"called outside of a mainloop");
	return NULL;
    }
	
    gtk_main_quit();
    Py_INCREF(Py_None);
    return Py_None;
}
#line 125222 "gtk.c"


#line 1250 "./gtk.override"
static PyObject *
_wrap_gtk_main_iteration(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration", kwlist,
                                    &block))
        return NULL;
    pyg_begin_allow_threads;
    ret = gtk_main_iteration_do(block);
    pyg_end_allow_threads;

    return PyBool_FromLong(ret);
}
#line 125241 "gtk.c"


#line 1285 "./gtk.override"
static PyObject *
_wrap_gtk_main_iteration_do(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration_do",
                                    kwlist, &block))
        return NULL;

    pyg_begin_allow_threads;
    ret = gtk_main_iteration_do(block);
    pyg_end_allow_threads;

    return PyBool_FromLong(ret);
}
#line 125261 "gtk.c"


static PyObject *
_wrap_gtk_grab_get_current(PyObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_grab_get_current();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 1303 "./gtk.override"
static gboolean
quit_handler_marshal(gpointer user_data)
{
    PyGILState_STATE state;
    PyObject *tuple, *ret;
    gboolean res;

    g_return_val_if_fail(user_data != NULL, FALSE);

    state = pyg_gil_state_ensure();

    tuple = (PyObject *)user_data;
    ret = PyObject_CallObject(PyTuple_GetItem(tuple, 0),
                              PyTuple_GetItem(tuple, 1));
    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }
    pyg_gil_state_release(state);

    return res;
}

static PyObject *
_wrap_gtk_quit_add(PyObject *self, PyObject *args)
{
    gint main_level;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
        PyErr_SetString(PyExc_TypeError,
                        "quit_add requires at least 2 args");
        return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:quit_add", &main_level, &callback)) {
        Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second argument not callable");
        return NULL;
    }

    cbargs = PySequence_GetSlice(args, 2, len);
    if (cbargs == NULL)
      return NULL;

    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_quit_add_full(main_level, quit_handler_marshal,
                                            NULL, data, pyg_destroy_notify));
}
#line 125337 "gtk.c"


static PyObject *
_wrap_gtk_quit_remove(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "quit_handler_id", NULL };
    PyObject *py_quit_handler_id = NULL;
    guint quit_handler_id = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:quit_remove", kwlist, &py_quit_handler_id))
        return NULL;
    if (py_quit_handler_id) {
        if (PyLong_Check(py_quit_handler_id))
            quit_handler_id = PyLong_AsUnsignedLong(py_quit_handler_id);
        else if (PyInt_Check(py_quit_handler_id))
            quit_handler_id = PyInt_AsLong(py_quit_handler_id);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'quit_handler_id' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_quit_remove(quit_handler_id);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_get_current_event(PyObject *self)
{
    GdkEvent *ret;

    
    ret = gtk_get_current_event();
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GDK_TYPE_EVENT, ret, FALSE, TRUE);
}

static PyObject *
_wrap_gtk_get_current_event_time(PyObject *self)
{
    guint32 ret;

    
    ret = gtk_get_current_event_time();
    
    return PyLong_FromUnsignedLong(ret);

}

#line 1365 "./gtk.override"
static PyObject *
_wrap_gtk_get_current_event_state (PyGObject *self)
{
    GdkModifierType state = 0;

    if (gtk_get_current_event_state (&state)) {
	return pyg_flags_from_gtype (GDK_TYPE_MODIFIER_TYPE, state);
    } else {
	Py_INCREF (Py_None);
	return Py_None;
    }
}
#line 125403 "gtk.c"


static PyObject *
_wrap_gtk_plug_new_for_display(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "display", "socket_id", NULL };
    PyGObject *display;
    unsigned long socket_id;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!k:plug_new_for_display", kwlist, &PyGdkDisplay_Type, &display, &socket_id))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gtk.Plug(socket_id, display)") < 0)
        return NULL;
    
    ret = gtk_plug_new_for_display(GDK_DISPLAY(display->obj), socket_id);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_preview_set_gamma(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gamma", NULL };
    double gamma;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:preview_set_gamma", kwlist, &gamma))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkPixbuf") < 0)
        return NULL;
    
    gtk_preview_set_gamma(gamma);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_preview_set_color_cube(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "nred_shades", "ngreen_shades", "nblue_shades", "ngray_shades", NULL };
    PyObject *py_nred_shades = NULL, *py_ngreen_shades = NULL, *py_nblue_shades = NULL, *py_ngray_shades = NULL;
    guint nred_shades = 0, ngreen_shades = 0, nblue_shades = 0, ngray_shades = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOOO:preview_set_color_cube", kwlist, &py_nred_shades, &py_ngreen_shades, &py_nblue_shades, &py_ngray_shades))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkPixbuf") < 0)
        return NULL;
    if (py_nred_shades) {
        if (PyLong_Check(py_nred_shades))
            nred_shades = PyLong_AsUnsignedLong(py_nred_shades);
        else if (PyInt_Check(py_nred_shades))
            nred_shades = PyInt_AsLong(py_nred_shades);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'nred_shades' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_ngreen_shades) {
        if (PyLong_Check(py_ngreen_shades))
            ngreen_shades = PyLong_AsUnsignedLong(py_ngreen_shades);
        else if (PyInt_Check(py_ngreen_shades))
            ngreen_shades = PyInt_AsLong(py_ngreen_shades);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'ngreen_shades' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_nblue_shades) {
        if (PyLong_Check(py_nblue_shades))
            nblue_shades = PyLong_AsUnsignedLong(py_nblue_shades);
        else if (PyInt_Check(py_nblue_shades))
            nblue_shades = PyInt_AsLong(py_nblue_shades);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'nblue_shades' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    if (py_ngray_shades) {
        if (PyLong_Check(py_ngray_shades))
            ngray_shades = PyLong_AsUnsignedLong(py_ngray_shades);
        else if (PyInt_Check(py_ngray_shades))
            ngray_shades = PyInt_AsLong(py_ngray_shades);
        else
            PyErr_SetString(PyExc_TypeError, "Parameter 'ngray_shades' must be an int or a long");
        if (PyErr_Occurred())
            return NULL;
    }
    
    gtk_preview_set_color_cube(nred_shades, ngreen_shades, nblue_shades, ngray_shades);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_preview_set_install_cmap(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "install_cmap", NULL };
    int install_cmap;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:preview_set_install_cmap", kwlist, &install_cmap))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkPixbuf") < 0)
        return NULL;
    
    gtk_preview_set_install_cmap(install_cmap);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_preview_set_reserved(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "nreserved", NULL };
    int nreserved;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:preview_set_reserved", kwlist, &nreserved))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkPixbuf") < 0)
        return NULL;
    
    gtk_preview_set_reserved(nreserved);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_preview_get_visual(PyObject *self)
{
    GdkVisual *ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkPixbuf") < 0)
        return NULL;
    
    ret = gtk_preview_get_visual();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_preview_get_cmap(PyObject *self)
{
    GdkColormap *ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkPixbuf") < 0)
        return NULL;
    
    ret = gtk_preview_get_cmap();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_preview_reset(PyObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkPixbuf") < 0)
        return NULL;
    
    gtk_preview_reset();
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_add_default_file(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:rc_add_default_file", kwlist, &filename))
        return NULL;
    
    gtk_rc_add_default_file(filename);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 2900 "./gtk.override"
static PyObject *
_wrap_gtk_rc_set_default_files(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    gchar **filenames = NULL;
    static char *kwlist[] = { "filenames", NULL };
    PyObject *py_filenames = NULL;
    int i, n_files;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:rc_set_default_files",
                                     kwlist, &py_filenames))
        return NULL;

    if (!PySequence_Check(py_filenames)) {
        PyErr_SetString(PyExc_TypeError, "filenames must be a sequence");
        return NULL;
    }

    n_files = PySequence_Length(py_filenames);
    filenames = g_new(gchar *, n_files + 1);
    for (i = 0; i < n_files; i++) {
        PyObject *item = PySequence_GetItem(py_filenames, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        filenames[i] = PyString_AsString(item);
    }
    filenames[n_files] = NULL;

    gtk_rc_set_default_files(filenames);

    g_free(filenames);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 125624 "gtk.c"


#line 2936 "./gtk.override"
static PyObject *
_wrap_gtk_rc_get_default_files(PyGObject *self)
{
    gchar **filenames = NULL, **tmp;
    int i = 0, j;
    PyObject *ret;

    filenames = gtk_rc_get_default_files();

    tmp = filenames;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(filenames[j]));

    return ret;
}
#line 125647 "gtk.c"


static PyObject *
_wrap_gtk_rc_get_style_by_paths(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "settings", "widget_path", "class_path", "type", NULL };
    PyGObject *settings;
    char *widget_path = NULL, *class_path = NULL;
    GType type;
    PyObject *py_type = NULL;
    GtkStyle *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!|zzO:rc_get_style_by_paths", kwlist, &PyGtkSettings_Type, &settings, &widget_path, &class_path, &py_type))
        return NULL;
    if ((type = pyg_type_from_object(py_type)) == 0)
        return NULL;
    
    ret = gtk_rc_get_style_by_paths(GTK_SETTINGS(settings->obj), widget_path, class_path, type);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_rc_reparse_all_for_settings(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "settings", "force_load", NULL };
    PyGObject *settings;
    int force_load, ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!i:rc_reparse_all_for_settings", kwlist, &PyGtkSettings_Type, &settings, &force_load))
        return NULL;
    
    ret = gtk_rc_reparse_all_for_settings(GTK_SETTINGS(settings->obj), force_load);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_rc_reset_styles(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "settings", NULL };
    PyGObject *settings;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:rc_reset_styles", kwlist, &PyGtkSettings_Type, &settings))
        return NULL;
    
    gtk_rc_reset_styles(GTK_SETTINGS(settings->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_parse(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:rc_parse", kwlist, &filename))
        return NULL;
    
    gtk_rc_parse(filename);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_parse_string(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "rc_string", NULL };
    char *rc_string;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:rc_parse_string", kwlist, &rc_string))
        return NULL;
    
    gtk_rc_parse_string(rc_string);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_reparse_all(PyObject *self)
{
    int ret;

    
    ret = gtk_rc_reparse_all();
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_rc_find_module_in_path(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "module_file", NULL };
    char *module_file;
    gchar *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:rc_find_module_in_path", kwlist, &module_file))
        return NULL;
    
    ret = gtk_rc_find_module_in_path(module_file);
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_get_theme_dir(PyObject *self)
{
    gchar *ret;

    
    ret = gtk_rc_get_theme_dir();
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_get_module_dir(PyObject *self)
{
    gchar *ret;

    
    ret = gtk_rc_get_module_dir();
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_get_im_module_path(PyObject *self)
{
    gchar *ret;

    
    ret = gtk_rc_get_im_module_path();
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_rc_get_im_module_file(PyObject *self)
{
    gchar *ret;

    
    ret = gtk_rc_get_im_module_file();
    
    if (ret) {
        PyObject *py_ret = PyString_FromString(ret);
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_selection_owner_set_for_display(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "display", "widget", "selection", "time", NULL };
    PyObject *py_selection = NULL;
    GdkAtom selection;
    int ret;
    unsigned long time = GDK_CURRENT_TIME;
    GtkWidget *widget = NULL;
    PyGObject *display, *py_widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!OO|k:selection_owner_set_for_display", kwlist, &PyGdkDisplay_Type, &display, &py_widget, &py_selection, &time))
        return NULL;
    if (py_widget && pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError, "widget should be a GtkWidget or None");
        return NULL;
    }
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;
    
    ret = gtk_selection_owner_set_for_display(GDK_DISPLAY(display->obj), (GtkWidget *) widget, selection, time);
    
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_settings_get_default(PyObject *self)
{
    GtkSettings *ret;

    
    ret = gtk_settings_get_default();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_settings_get_for_screen(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *screen;
    GtkSettings *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:settings_get_for_screen", kwlist, &PyGdkScreen_Type, &screen))
        return NULL;
    
    ret = gtk_settings_get_for_screen(GDK_SCREEN(screen->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 3003 "./gtk.override"
static PyObject *
_wrap_gtk_stock_add(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    PyObject *py_item;
    GtkStockItem *items = NULL;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:stock_add", kwlist,
                                     &py_items))
        return NULL;

    if (!PySequence_Check(py_items)) {
        PyErr_SetString(PyExc_TypeError,
                        "items must be a sequence of five-element tuples");
        return NULL;
    }

    len = PySequence_Length(py_items);
    if (len > 0) {
        items = g_new(GtkStockItem, len);
        for (i = 0; i < len; i++) {
            py_item = PySequence_GetItem(py_items, i);
            if (!py_item) goto error;
            if (!PyArg_ParseTuple(py_item, "zziiz",
                                  &items[i].stock_id, &items[i].label,
                                  &items[i].modifier, &items[i].keyval,
                                  &items[i].translation_domain)) {
                PyErr_Clear();
                PyErr_SetString(PyExc_TypeError, "items sequence members "
                                "must be of form (stock_id, label, modifiers, "
                                "keyval, domain)");
                goto error;
            }
	    Py_DECREF(py_item);
        }
        gtk_stock_add(items, PySequence_Length(py_items));
        g_free(items);
    }
    Py_INCREF(Py_None);
    return Py_None;
 error:
    g_free(items);
    return NULL;
}
#line 125938 "gtk.c"


#line 3072 "./gtk.override"
static PyObject *
_wrap_gtk_stock_lookup(PyGObject *self, PyObject *args)
{
    gchar *stock_id;
    GtkStockItem item;

    if (!PyArg_ParseTuple(args, "s:gtk.stock_lookup",
                          &stock_id)) {
        return NULL;
    }

    if(gtk_stock_lookup(stock_id, &item)) {
        return Py_BuildValue("zzNiz",
                             item.stock_id,
                             item.label,
                             pyg_flags_from_gtype(GDK_TYPE_MODIFIER_TYPE,
                                                  item.modifier),
                             item.keyval,
                             item.translation_domain);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
#line 125966 "gtk.c"


#line 3052 "./gtk.override"
static PyObject *
_wrap_gtk_stock_list_ids(PyGObject *self)
{
    GSList *ids;
    PyObject *list;
    int i = 0;

    ids = gtk_stock_list_ids();

    list = PyList_New(g_slist_length(ids));
    for (; ids; ids = ids->next, i++) {
        PyList_SetItem(list, i, PyString_FromString(ids->data));
        g_free(ids->data);
    }
    g_slist_free(ids);

    return list;
}
#line 125988 "gtk.c"


static PyObject *
_wrap_gtk_draw_insertion_cursor(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "drawable", "area", "location", "is_primary", "direction", "draw_arrow", NULL };
    PyGObject *widget, *drawable;
    PyObject *py_area = Py_None, *py_location, *py_direction = NULL;
    int is_primary, draw_arrow;
    GdkRectangle area_rect = { 0, 0, 0, 0 }, *area, location = { 0, 0, 0, 0 };
    GtkTextDirection direction;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!OOiOi:draw_insertion_cursor", kwlist, &PyGtkWidget_Type, &widget, &PyGdkDrawable_Type, &drawable, &py_area, &py_location, &is_primary, &py_direction, &draw_arrow))
        return NULL;
    if (py_area == Py_None)
        area = NULL;
    else if (pygdk_rectangle_from_pyobject(py_area, &area_rect))
        area = &area_rect;
    else
            return NULL;
    if (!pygdk_rectangle_from_pyobject(py_location, &location))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, py_direction, (gpointer)&direction))
        return NULL;
    
    gtk_draw_insertion_cursor(GTK_WIDGET(widget->obj), GDK_DRAWABLE(drawable->obj), area, &location, is_primary, direction, draw_arrow);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 3632 "./gtk.override"
static PyObject *
_wrap_gtk_tooltips_data_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;
    GtkTooltipsData *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkTooltips.data_get",
				     kwlist, &PyGtkWidget_Type, &widget))
        return NULL;

    data = gtk_tooltips_data_get(GTK_WIDGET(widget->obj));

    if (!data) {
	Py_INCREF(Py_None);
	return Py_None;
    }

    return Py_BuildValue("NNss",
			 pygobject_new((GObject *)data->tooltips),
			 pygobject_new((GObject *)data->widget),
			 data->tip_text,
			 data->tip_private);
}
#line 126046 "gtk.c"


#line 3659 "./gtk.override"
static PyObject *
_wrap_gtk_tooltips_data_get1(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use tooltips_data_get") < 0)
        return NULL;

    return _wrap_gtk_tooltips_data_get(self, args, kwargs);
}
#line 126058 "gtk.c"


static PyObject *
_wrap_gtk_vbutton_box_get_spacing_default(PyObject *self)
{
    int ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    ret = gtk_vbutton_box_get_spacing_default();
    
    return PyInt_FromLong(ret);
}

static PyObject *
_wrap_gtk_vbutton_box_set_spacing_default(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "spacing", NULL };
    int spacing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:vbutton_box_set_spacing_default", kwlist, &spacing))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    gtk_vbutton_box_set_spacing_default(spacing);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_vbutton_box_get_layout_default(PyObject *self)
{
    gint ret;

    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    
    ret = gtk_vbutton_box_get_layout_default();
    
    return pyg_enum_from_gtype(GTK_TYPE_BUTTON_BOX_STYLE, ret);
}

static PyObject *
_wrap_gtk_vbutton_box_set_layout_default(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "layout", NULL };
    PyObject *py_layout = NULL;
    GtkButtonBoxStyle layout;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:vbutton_box_set_layout_default", kwlist, &py_layout))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "") < 0)
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_BUTTON_BOX_STYLE, py_layout, (gpointer)&layout))
        return NULL;
    
    gtk_vbutton_box_set_layout_default(layout);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_push_colormap(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "cmap", NULL };
    PyGObject *cmap;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:widget_push_colormap", kwlist, &PyGdkColormap_Type, &cmap))
        return NULL;
    
    gtk_widget_push_colormap(GDK_COLORMAP(cmap->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_push_composite_child(PyObject *self)
{
    
    gtk_widget_push_composite_child();
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_pop_composite_child(PyObject *self)
{
    
    gtk_widget_pop_composite_child();
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_pop_colormap(PyObject *self)
{
    
    gtk_widget_pop_colormap();
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 214 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_class_install_style_property (PyObject *self,
					       PyObject *args,
					       PyObject* kwargs)
{
    static char *kwlist[] = { "widget", "pspec", NULL };
    PyObject *py_itype, *property;
    GType itype;
    GtkWidgetClass *class;
    GParamSpec *pspec;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:widget_class_install_style_property",
				     kwlist,
				     &py_itype, &property))
	return NULL;


    if ((itype = pyg_type_from_object(py_itype)) == 0)
	return NULL;

    if (!g_type_is_a(itype, GTK_TYPE_WIDGET)) {
	PyErr_SetString(PyExc_TypeError, "type must be derived from GtkWidget");
	return NULL;
    }

    class = g_type_class_ref(itype);
    if (!class) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not get a reference to type class");
	return NULL;
    }

    pspec = pyg_param_spec_from_object(property);
    if(!pspec) {
	g_type_class_unref(class);
	return NULL;
    }

    if (gtk_widget_class_find_style_property(class, pspec->name)) {
	PyErr_Format(PyExc_TypeError,
		     "there is already a '%s' property installed", pspec->name);
	g_type_class_unref(class);
	return NULL;
    }

    gtk_widget_class_install_style_property(class, pspec);

    g_type_class_unref(class);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 126223 "gtk.c"


#line 473 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_class_find_style_property (PyObject *self, PyObject *args,
                                            PyObject*kwargs)
{
    static char *kwlist[] = { "widget", "property_name", NULL };
    GParamSpec *spec;
    PyObject *py_itype, *pyspec;
    GType itype;
    GtkWidgetClass *class;
    const gchar *property_name;

    if (!PyArg_ParseTupleAndKeywords(
	    args, kwargs, "Os:gtk.widget_class_find_style_property", kwlist,
            &py_itype, &property_name))
	return NULL;
    if ((itype = pyg_type_from_object(py_itype)) == 0)
	return NULL;

    if (!g_type_is_a(itype, GTK_TYPE_WIDGET)) {
	PyErr_SetString(PyExc_TypeError,
                        "type must be derived from GtkWidget");
	return NULL;
    }

    class = g_type_class_ref(itype);
    if (!class) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not get a reference to type class");
	return NULL;
    }

    spec = gtk_widget_class_find_style_property(class, property_name);
    if (spec) {
        pyspec = pyg_param_spec_new(spec);
    } else {
        pyspec = Py_None;
        Py_INCREF(pyspec);
    }
    g_type_class_unref(class);

    return pyspec;
}
#line 126269 "gtk.c"


#line 166 "gtkwidget.override"
static PyObject *
_wrap_gtk_widget_class_list_style_properties (PyObject *self, PyObject *args,
					      PyObject*kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    GParamSpec **specs;
    PyObject *py_itype, *list;
    GType itype;
    GtkWidgetClass *class;
    guint nprops;
    guint i;

    if (!PyArg_ParseTupleAndKeywords(
	    args, kwargs, "O:gtk.widget_class_list_style_properties", kwlist,
			  &py_itype))
	return NULL;
    if ((itype = pyg_type_from_object(py_itype)) == 0)
	return NULL;

    if (!g_type_is_a(itype, GTK_TYPE_WIDGET)) {
	PyErr_SetString(PyExc_TypeError, "type must be derived from GtkWidget");
	return NULL;
    }

    class = g_type_class_ref(itype);
    if (!class) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not get a reference to type class");
	return NULL;
    }

    specs = gtk_widget_class_list_style_properties(class, &nprops);
    list = PyTuple_New(nprops);
    if (list == NULL) {
	g_free(specs);
	g_type_class_unref(class);
	return NULL;
    }
    for (i = 0; i < nprops; i++) {
	PyTuple_SetItem(list, i, pyg_param_spec_new(specs[i]));
    }
    g_free(specs);
    g_type_class_unref(class);

    return list;
}
#line 126319 "gtk.c"


static PyObject *
_wrap_gtk_widget_get_default_style(PyObject *self)
{
    GtkStyle *ret;

    
    ret = gtk_widget_get_default_style();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_set_default_colormap(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "colormap", NULL };
    PyGObject *colormap;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:widget_set_default_colormap", kwlist, &PyGdkColormap_Type, &colormap))
        return NULL;
    
    gtk_widget_set_default_colormap(GDK_COLORMAP(colormap->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_default_colormap(PyObject *self)
{
    GdkColormap *ret;

    
    ret = gtk_widget_get_default_colormap();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_get_default_visual(PyObject *self)
{
    GdkVisual *ret;

    
    ret = gtk_widget_get_default_visual();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_widget_set_default_direction(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dir", NULL };
    GtkTextDirection dir;
    PyObject *py_dir = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:widget_set_default_direction", kwlist, &py_dir))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, py_dir, (gpointer)&dir))
        return NULL;
    
    gtk_widget_set_default_direction(dir);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_widget_get_default_direction(PyObject *self)
{
    gint ret;

    
    ret = gtk_widget_get_default_direction();
    
    return pyg_enum_from_gtype(GTK_TYPE_TEXT_DIRECTION, ret);
}

#line 240 "gtkwindow.override"
static PyObject *
_wrap_gtk_window_set_default_icon_list(PyGObject *self, PyObject *args)
{
    GList *icon_list = NULL;
    PyObject *pyicon;
    gint len, i;

    len = PyTuple_Size(args);
    for (i = 0; i < len; i++) {
	pyicon = PyTuple_GetItem(args, i);
	if (!pygobject_check(pyicon, &PyGdkPixbuf_Type)) {
            PyErr_SetString(PyExc_TypeError,
                            "icons must be GdkPixbufs");
	    g_list_free(icon_list);
            return NULL;
        }
	icon_list = g_list_prepend(icon_list, pygobject_get(pyicon));
    }
    gtk_window_set_default_icon_list(icon_list);
    g_list_free(icon_list);
    Py_INCREF(Py_None);
    return Py_None;
}
#line 126426 "gtk.c"


#line 265 "gtkwindow.override"
static PyObject *
_wrap_gtk_window_get_default_icon_list(PyGObject *self)
{
    GList *icon_list = NULL;
    PyObject *pyicon;

    if ((icon_list = gtk_window_get_default_icon_list())) {
        PyObject *py_list;
        GList *tmp;

        if ((py_list = PyList_New(0)) == NULL) {
            g_list_free(icon_list);
            return NULL;
        }
        for (tmp = icon_list; tmp != NULL; tmp = tmp->next) {
            pyicon = pygobject_new(G_OBJECT(tmp->data));

            if (pyicon == NULL) {
                g_list_free(icon_list);
                Py_DECREF(py_list);
                return NULL;
            }
            PyList_Append(py_list, pyicon);
            Py_DECREF(pyicon);
        }
        g_list_free(icon_list);
        return py_list;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 126461 "gtk.c"


static PyObject *
_wrap_gtk_window_set_default_icon(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon", NULL };
    PyGObject *icon;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:window_set_default_icon", kwlist, &PyGdkPixbuf_Type, &icon))
        return NULL;
    
    gtk_window_set_default_icon(GDK_PIXBUF(icon->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_default_icon_from_file(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:window_set_default_icon_from_file", kwlist, &filename))
        return NULL;
    
    gtk_window_set_default_icon_from_file(filename, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_window_set_auto_startup_notification(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "setting", NULL };
    int setting;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"i:window_set_auto_startup_notification", kwlist, &setting))
        return NULL;
    
    gtk_window_set_auto_startup_notification(setting);
    
    Py_INCREF(Py_None);
    return Py_None;
}

#line 28 "gtkwindow.override"
static PyObject *
_wrap_gtk_window_list_toplevels(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *py_list;
    PyObject *gtk_obj;

    list = gtk_window_list_toplevels();

    /* See bug #574259.  We temporarily reference each window.  After
     * the list is created, windows will be referenced from PyGTK
     * wrappers, so we remove the temporary refs. */
    g_list_foreach(list, (GFunc) g_object_ref, NULL);
    
    if ((py_list = PyList_New(0)) == NULL) {
        g_list_foreach(list, (GFunc) g_object_unref, NULL);
        g_list_free(list);
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            g_list_foreach(list, (GFunc) g_object_unref, NULL);
            g_list_free(list);
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }

    g_list_foreach(list, (GFunc) g_object_unref, NULL);
    g_list_free(list);
    return py_list;
}
#line 126548 "gtk.c"


static PyObject *
_wrap_gtk_window_set_default_icon_name(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:window_set_default_icon_name", kwlist, &name))
        return NULL;
    
    gtk_window_set_default_icon_name(name);
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_link_button_new(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "uri", NULL };
    char *uri;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:link_button_new", kwlist, &uri))
        return NULL;
    
    ret = gtk_link_button_new(uri);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 7078 "./gtk.override"
static void
pygtk_link_button_set_uri_hook_cb(GtkLinkButton *button,
                                  const gchar *link,
                                  gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *retobj;
    g_assert(cunote->func);
 
    state = pyg_gil_state_ensure();
  
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NsO)",
                                     pygobject_new((GObject *)button),
                                     link, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(Ns)",
                                     pygobject_new((GObject *)button), link);
    }
 
    if (retobj == NULL)
        PyErr_Print();

    Py_XDECREF(retobj);
  
    pyg_gil_state_release(state);
}
static PyObject *
_wrap_gtk_link_button_set_uri_hook(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                          "O|O:gtk.link_button_set_uri_hook",
                          kwlist, &pyfunc, &pyarg))
        return NULL;
  
    if (pyfunc != Py_None  && !PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError, "func must be a callable object or None");
        return NULL;
    }

    if (pyfunc == Py_None) {
        gtk_link_button_set_uri_hook(NULL, NULL, NULL);
    } else {
        cunote = g_new0(PyGtkCustomNotify, 1);
        cunote->func = pyfunc;
        cunote->data = pyarg;
        Py_INCREF(cunote->func);
        Py_XINCREF(cunote->data);
 
        gtk_link_button_set_uri_hook(pygtk_link_button_set_uri_hook_cb,
                                     cunote, pygtk_custom_destroy_notify);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 126644 "gtk.c"


#line 8137 "./gtk.override"
static GtkNotebook *
pygtk_notebook_set_window_creation_hook_cb(GtkNotebook *notebook,
                                           GtkWidget *page,
                                           gint x, gint y,
                                           gpointer user_data)
{
    PyGILState_STATE state;
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_notebook, *py_page, *retobj;
    GtkNotebook *ret = NULL;

    g_assert(cunote->func);

    state = pyg_gil_state_ensure();

    py_notebook = pygobject_new((GObject*)notebook);
    py_page = pygobject_new((GObject*)page);
    
    if (cunote->data) {
        retobj = PyEval_CallFunction(cunote->func, "(NNiiO)", py_notebook,
                                     py_page, x, y, cunote->data);
    } else {
        retobj = PyEval_CallFunction(cunote->func, "(NNii)", py_notebook,
                                     py_page, x, y);
    }

    if (retobj) {
        if (!pygobject_check((PyGObject*)retobj, &PyGtkNotebook_Type)) {
            PyErr_SetString(PyExc_TypeError,
                            "GtkNotebook window creation hook function return should be a GtkNotebook or None");
            PyErr_Print();
            ret = NULL;
        } else {
            ret = GTK_NOTEBOOK(pygobject_get(retobj));
        }
        Py_DECREF(retobj);
    } else {
        PyErr_Print();
        ret = NULL;
    }

    pyg_gil_state_release(state);
    return ret;
}
static PyObject *
_wrap_gtk_notebook_set_window_creation_hook(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "func", "data", NULL };
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:gtk.notebook_set_window_creation_hook",
                                     kwlist, &pyfunc, &pyarg))
        return NULL;

    if (!PyCallable_Check(pyfunc)) {
        PyErr_SetString(PyExc_TypeError,
                        "func must be a callable object");
        return NULL;
    }
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
 
    gtk_notebook_set_window_creation_hook(
        pygtk_notebook_set_window_creation_hook_cb,
        cunote, pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
#line 126723 "gtk.c"


static PyObject *
_wrap_gtk_paper_size_new_from_ppd(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "ppd_name", "ppd_display_name", "width", "height", NULL };
    char *ppd_name, *ppd_display_name;
    double width, height;
    GtkPaperSize *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ssdd:paper_size_new_from_ppd", kwlist, &ppd_name, &ppd_display_name, &width, &height))
        return NULL;
    
    ret = gtk_paper_size_new_from_ppd(ppd_name, ppd_display_name, width, height);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_PAPER_SIZE, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_paper_size_new_custom(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "display_name", "width", "height", "unit", NULL };
    char *name, *display_name;
    double width, height;
    GtkUnit unit;
    PyObject *py_unit = NULL;
    GtkPaperSize *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"ssddO:paper_size_new_custom", kwlist, &name, &display_name, &width, &height, &py_unit))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_UNIT, py_unit, (gpointer)&unit))
        return NULL;
    
    ret = gtk_paper_size_new_custom(name, display_name, width, height, unit);
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_PAPER_SIZE, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_paper_size_get_default(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_paper_size_get_default();
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_print_run_page_setup_dialog(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "page_setup", "settings", NULL };
    PyGObject *py_parent, *py_page_setup, *settings;
    GtkPageSetup *page_setup = NULL, *ret;
    GtkWindow *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOO!:print_run_page_setup_dialog", kwlist, &py_parent, &py_page_setup, &PyGtkPrintSettings_Type, &settings))
        return NULL;
    if (py_parent && pygobject_check(py_parent, &PyGtkWindow_Type))
        parent = GTK_WINDOW(py_parent->obj);
    else if ((PyObject *)py_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkWindow or None");
        return NULL;
    }
    if (py_page_setup && pygobject_check(py_page_setup, &PyGtkPageSetup_Type))
        page_setup = GTK_PAGE_SETUP(py_page_setup->obj);
    else if ((PyObject *)py_page_setup != Py_None) {
        PyErr_SetString(PyExc_TypeError, "page_setup should be a GtkPageSetup or None");
        return NULL;
    }
    
    ret = gtk_print_run_page_setup_dialog((GtkWindow *) parent, (GtkPageSetup *) page_setup, GTK_PRINT_SETTINGS(settings->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_recent_manager_get_default(PyObject *self)
{
    GtkRecentManager *ret;

    
    ret = gtk_recent_manager_get_default();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_recent_manager_get_for_screen(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", NULL };
    PyGObject *screen;
    GtkRecentManager *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:recent_manager_get_for_screen", kwlist, &PyGdkScreen_Type, &screen))
        return NULL;
    
    ret = gtk_recent_manager_get_for_screen(GDK_SCREEN(screen->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 8107 "./gtk.override"
static PyObject *
_wrap_gtk_target_list_add_rich_text_targets(PyGObject *self, PyObject *args,
                                       PyObject *kwargs)
{
    static char *kwlist[] = { "list", "info", "deserializable", "buffer", NULL };
    PyObject *list = NULL;
    guint info = 0;
    GtkTargetList *targets;
    gboolean deserializable;
    PyGObject *buffer;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OiiO!:gtk.target_list_add_rich_text_targets",
                                     kwlist, &list, &info, &deserializable,
                                     &PyGtkTextBuffer_Type, &buffer)) {
        return NULL;
    }
    if (!list || list == Py_None) {
        targets = gtk_target_list_new(NULL, 0);
    } else if (!(targets = pygtk_target_list_from_sequence(list)))
        return NULL;

    gtk_target_list_add_rich_text_targets(targets, info, deserializable,
                                          GTK_TEXT_BUFFER(buffer->obj));
    list = pygtk_target_list_to_list(targets);
    gtk_target_list_unref(targets);
    return list;
}
#line 126864 "gtk.c"


#line 8026 "./gtk.override"
static PyObject *
_wrap_gtk_targets_include_text(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    GdkAtom *targets;
    gint n_targets;
    PyObject *py_targets, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:gtk.targets_include_text",
                                     kwlist, &py_targets))
        return NULL;

    if (!(targets = pygdk_atom_vector_from_sequence(py_targets, &n_targets)))
        return NULL;

    if (gtk_targets_include_text(targets, n_targets))
        py_ret = Py_True;
    else
        py_ret = Py_False;
    g_free(targets);
    return py_ret;
}
#line 126892 "gtk.c"


#line 8078 "./gtk.override"
static PyObject *
_wrap_gtk_targets_include_rich_text(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "buffer", NULL };
    GdkAtom *targets;
    PyGObject *buffer;
    gint n_targets;
    PyObject *py_targets, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO!:gtk.targets_include_rich_text",
                                     kwlist, &py_targets,
                                     &PyGtkTextBuffer_Type, &buffer))
        return NULL;

    if (!(targets = pygdk_atom_vector_from_sequence(py_targets, &n_targets)))
        return NULL;

    if (gtk_targets_include_rich_text(targets, n_targets,
                                      GTK_TEXT_BUFFER(buffer->obj)))
        py_ret = Py_True;
    else
        py_ret = Py_False;
    g_free(targets);
    return py_ret;
}
#line 126923 "gtk.c"


#line 7999 "./gtk.override"
static PyObject *
_wrap_gtk_targets_include_image(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "writable", NULL };
    GdkAtom *targets;
    gint n_targets;
    gboolean writable;
    PyObject *py_targets, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oi:gtk.targets_include_image",
                                     kwlist, &py_targets, &writable))
        return NULL;

    if (!(targets = pygdk_atom_vector_from_sequence(py_targets, &n_targets)))
        return NULL;

    if (gtk_targets_include_image(targets, n_targets, writable))
        py_ret = Py_True;
    else
        py_ret = Py_False;
    g_free(targets);
    return py_ret;
}
#line 126952 "gtk.c"


#line 8052 "./gtk.override"
static PyObject *
_wrap_gtk_targets_include_uri(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    GdkAtom *targets;
    gint n_targets;
    PyObject *py_targets, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:gtk.targets_include_uri",
                                     kwlist, &py_targets))
        return NULL;

    if (!(targets = pygdk_atom_vector_from_sequence(py_targets, &n_targets)))
        return NULL;

    if (gtk_targets_include_uri(targets, n_targets))
        py_ret = Py_True;
    else
        py_ret = Py_False;
    g_free(targets);
    return py_ret;
}
#line 126980 "gtk.c"


static PyObject *
_wrap_gtk_status_icon_new_from_pixbuf(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf;
    GtkStatusIcon *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:status_icon_new_from_pixbuf", kwlist, &PyGdkPixbuf_Type, &pixbuf))
        return NULL;
    
    ret = gtk_status_icon_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_status_icon_new_from_file(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    char *filename;
    GtkStatusIcon *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:status_icon_new_from_file", kwlist, &filename))
        return NULL;
    
    ret = gtk_status_icon_new_from_file(filename);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_status_icon_new_from_stock(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", NULL };
    char *stock_id;
    GtkStatusIcon *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:status_icon_new_from_stock", kwlist, &stock_id))
        return NULL;
    
    ret = gtk_status_icon_new_from_stock(stock_id);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_status_icon_new_from_icon_name(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_name", NULL };
    char *icon_name;
    GtkStatusIcon *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:status_icon_new_from_icon_name", kwlist, &icon_name))
        return NULL;
    
    ret = gtk_status_icon_new_from_icon_name(icon_name);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 7981 "./gtk.override"
static PyObject *
_wrap_gtk_status_icon_position_menu(PyGObject *self, PyObject *args)
{
    PyGObject *menu, *icon;
    gint x, y;
    gboolean push_in;

    if (!PyArg_ParseTuple(args,"O!O!:gtk.status_icon_position_menu",
                          &PyGtkMenu_Type, &menu,
                          &PyGtkStatusIcon_Type, &icon))
        return NULL;

    gtk_status_icon_position_menu(GTK_MENU(menu->obj), &x, &y, &push_in,
                                  (gpointer)icon->obj);
    return Py_BuildValue("(iii)", x, y, push_in);
}
#line 127064 "gtk.c"


static PyObject *
_wrap_gtk_page_setup_new_from_file(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file_name", NULL };
    char *file_name;
    GtkPageSetup *ret;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:page_setup_new_from_file", kwlist, &file_name))
        return NULL;
    
    ret = gtk_page_setup_new_from_file(file_name, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_print_settings_new_from_file(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "file_name", NULL };
    char *file_name;
    GError *error = NULL;
    GtkPrintSettings *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s:print_settings_new_from_file", kwlist, &file_name))
        return NULL;
    
    ret = gtk_print_settings_new_from_file(file_name, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_recent_action_new_for_manager(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", "label", "tooltip", "stock_id", "manager", NULL };
    char *name, *label, *tooltip, *stock_id;
    PyGObject *py_manager;
    GtkRecentManager *manager = NULL;
    GtkAction *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"szzzO:recent_action_new_for_manager", kwlist, &name, &label, &tooltip, &stock_id, &py_manager))
        return NULL;
    if (py_manager && pygobject_check(py_manager, &PyGtkRecentManager_Type))
        manager = GTK_RECENT_MANAGER(py_manager->obj);
    else if ((PyObject *)py_manager != Py_None) {
        PyErr_SetString(PyExc_TypeError, "manager should be a GtkRecentManager or None");
        return NULL;
    }
    
    ret = gtk_recent_action_new_for_manager(name, label, tooltip, stock_id, (GtkRecentManager *) manager);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_tooltip_trigger_tooltip_query(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "display", NULL };
    PyGObject *display;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:tooltip_trigger_tooltip_query", kwlist, &PyGdkDisplay_Type, &display))
        return NULL;
    
    gtk_tooltip_trigger_tooltip_query(GDK_DISPLAY(display->obj));
    
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_icon_info_new_for_pixbuf(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_theme", "pixbuf", NULL };
    PyGObject *icon_theme, *pixbuf;
    GtkIconInfo *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O!:icon_info_new_for_pixbuf", kwlist, &PyGtkIconTheme_Type, &icon_theme, &PyGdkPixbuf_Type, &pixbuf))
        return NULL;
    
    ret = gtk_icon_info_new_for_pixbuf(GTK_ICON_THEME(icon_theme->obj), GDK_PIXBUF(pixbuf->obj));
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GTK_TYPE_ICON_INFO, ret, TRUE, TRUE);
}

static PyObject *
_wrap_gtk_image_new_from_gicon(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon", "size", NULL };
    PyGObject *icon;
    PyObject *py_size = NULL;
    GtkIconSize size;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!O:image_new_from_gicon", kwlist, &PyGIcon_Type, &icon, &py_size))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_size, (gpointer)&size))
        return NULL;
    
    ret = gtk_image_new_from_gicon(G_ICON(icon->obj), size);
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_show_uri(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "screen", "uri", "timestamp", NULL };
    int ret;
    GError *error = NULL;
    char *uri;
    unsigned long timestamp;
    PyGObject *py_screen;
    GdkScreen *screen = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Osk:show_uri", kwlist, &py_screen, &uri, &timestamp))
        return NULL;
    if (py_screen && pygobject_check(py_screen, &PyGdkScreen_Type))
        screen = GDK_SCREEN(py_screen->obj);
    else if ((PyObject *)py_screen != Py_None) {
        PyErr_SetString(PyExc_TypeError, "screen should be a GdkScreen or None");
        return NULL;
    }
    
    ret = gtk_show_uri((GdkScreen *) screen, uri, timestamp, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    return PyBool_FromLong(ret);

}

static PyObject *
_wrap_gtk_status_icon_new_from_gicon(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon", NULL };
    PyGObject *icon;
    GtkStatusIcon *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:status_icon_new_from_gicon", kwlist, &PyGIcon_Type, &icon))
        return NULL;
    
    ret = gtk_status_icon_new_from_gicon(G_ICON(icon->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_window_get_default_icon_name(PyObject *self)
{
    const gchar *ret;

    
    ret = gtk_window_get_default_icon_name();
    
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
_wrap_gtk_entry_new_with_buffer(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "buffer", NULL };
    PyGObject *buffer;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:new_with_buffer", kwlist, &PyGtkEntryBuffer_Type, &buffer))
        return NULL;
    
    ret = gtk_entry_new_with_buffer(GTK_ENTRY_BUFFER(buffer->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 8767 "./gtk.override"
static PyObject *
_wrap_gtk_hsv_to_rgb(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "h", "s", "v", NULL };
    gdouble h=0, s=0, v=0;
    gdouble r, g, b;
    
    if (!PyArg_ParseTupleAndKeywords(args,kwargs,
                                     "ddd:gtk.hsv_to_rgb",
                                     kwlist, &h, &s, &v))
        return NULL;
    
    gtk_hsv_to_rgb(h, s, v, &r, &g, &b);

    return Py_BuildValue("(ddd)", r, g, b);
}
#line 127271 "gtk.c"


static PyObject *
_wrap_gtk_combo_box_new_with_entry(PyObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_combo_box_new_with_entry();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_combo_box_new_with_model_and_entry(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "model", NULL };
    PyGObject *model;
    GtkWidget *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:combo_box_new_with_model_and_entry", kwlist, &PyGtkTreeModel_Type, &model))
        return NULL;
    
    ret = gtk_combo_box_new_with_model_and_entry(GTK_TREE_MODEL(model->obj));
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

static PyObject *
_wrap_gtk_combo_box_text_new_with_entry(PyObject *self)
{
    GtkWidget *ret;

    
    ret = gtk_combo_box_text_new_with_entry();
    
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}

#line 512 "./gtk.override"
static PyObject *
_wrap_remove_log_handlers(PyGObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":remove_log_handlers"))
	return NULL;

#ifndef pyg_disable_warning_redirections

    g_log_remove_handler("Gtk", _gtk_handler);
    _gtk_handler = -1;
    g_log_remove_handler("Gdk", _gdk_handler);
    _gdk_handler = -1;
    g_log_remove_handler("GdkPixbuf", _gdk_pixbuf_handler);
    _gdk_pixbuf_handler = -1;

#else

    pyg_disable_warning_redirections();

#endif /* ifndef pyg_disable_warning_redirections */

    Py_INCREF(Py_None);
    return Py_None;
}

#line 127340 "gtk.c"


#line 483 "./gtk.override"
static PyObject *
_wrap_add_log_handlers(PyGObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":add_log_handlers"))
	return NULL;
#ifndef pyg_add_warning_redirection

    _gtk_handler = g_log_set_handler("Gtk",
				     G_LOG_LEVEL_CRITICAL|G_LOG_LEVEL_WARNING,
				     _pygtk_log_func, NULL);
    _gdk_handler = g_log_set_handler("Gdk",
				     G_LOG_LEVEL_CRITICAL|G_LOG_LEVEL_WARNING,
				     _pygtk_log_func, NULL);
    _gdk_pixbuf_handler = g_log_set_handler("GdkPixbuf",
					    G_LOG_LEVEL_CRITICAL|G_LOG_LEVEL_WARNING,
					    _pygtk_log_func, NULL);
#else

    pyg_add_warning_redirection("Gtk", PyGtkWarning);
    pyg_add_warning_redirection("Gdk", PyGtkWarning);
    pyg_add_warning_redirection("GdkPixbuf", PyGtkWarning);

#endif /* ifndef pyg_add_warning_redirection */

    Py_INCREF(Py_None);
    return Py_None;
}
#line 127371 "gtk.c"


#line 458 "./gtk.override"
static PyObject *
_wrap_set_interactive(PyGObject *self, PyObject *args)
{
    int flag = 1;
    if (!PyArg_ParseTuple(args, "|i", &flag)) return NULL;
    if (flag)
    {
        if (PyOS_InputHook == NULL) {
            PyOS_InputHook = _loop;
        }
        else if (PyOS_InputHook != _loop)
            PyErr_Warn(PyExc_RuntimeWarning, "PyOS_InputHook is not available for interactive use of PyGTK");
    }
    else
    {
        if (PyOS_InputHook == _loop)
            PyOS_InputHook = NULL;
        else if (PyOS_InputHook != NULL)
            PyErr_Warn(PyExc_RuntimeWarning, "PyOS_InputHook was set by a module other than PyGTK");
    }
    Py_INCREF(Py_None);
    return Py_None;
}
#line 127398 "gtk.c"


const PyMethodDef pygtk_functions[] = {
    { "about_dialog_set_email_hook", (PyCFunction)_wrap_gtk_about_dialog_set_email_hook, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "about_dialog_set_url_hook", (PyCFunction)_wrap_gtk_about_dialog_set_url_hook, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "show_about_dialog", (PyCFunction)_wrap_gtk_show_about_dialog, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_groups_activate", (PyCFunction)_wrap_gtk_accel_groups_activate, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_groups_from_object", (PyCFunction)_wrap_gtk_accel_groups_from_object, METH_VARARGS,
      NULL },
    { "accel_group_from_accel_closure", (PyCFunction)_wrap_gtk_accel_group_from_accel_closure, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accelerator_valid", (PyCFunction)_wrap_gtk_accelerator_valid, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accelerator_parse", (PyCFunction)_wrap_gtk_accelerator_parse, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accelerator_name", (PyCFunction)_wrap_gtk_accelerator_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accelerator_set_default_mod_mask", (PyCFunction)_wrap_gtk_accelerator_set_default_mod_mask, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accelerator_get_default_mod_mask", (PyCFunction)_wrap_gtk_accelerator_get_default_mod_mask, METH_NOARGS,
      NULL },
    { "accelerator_get_label", (PyCFunction)_wrap_gtk_accelerator_get_label, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_add_entry", (PyCFunction)_wrap_gtk_accel_map_add_entry, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_lookup_entry", (PyCFunction)_wrap_gtk_accel_map_lookup_entry, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_change_entry", (PyCFunction)_wrap_gtk_accel_map_change_entry, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_load", (PyCFunction)_wrap_gtk_accel_map_load, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_save", (PyCFunction)_wrap_gtk_accel_map_save, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_foreach", (PyCFunction)_wrap_gtk_accel_map_foreach, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_load_fd", (PyCFunction)_wrap_gtk_accel_map_load_fd, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_save_fd", (PyCFunction)_wrap_gtk_accel_map_save_fd, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_lock_path", (PyCFunction)_wrap_gtk_accel_map_lock_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_unlock_path", (PyCFunction)_wrap_gtk_accel_map_unlock_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_add_filter", (PyCFunction)_wrap_gtk_accel_map_add_filter, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_foreach_unfiltered", (PyCFunction)_wrap_gtk_accel_map_foreach_unfiltered, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "accel_map_get", (PyCFunction)_wrap_gtk_accel_map_get, METH_NOARGS,
      NULL },
    { "bindings_activate", (PyCFunction)_wrap_gtk_bindings_activate, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "bindings_activate_event", (PyCFunction)_wrap_gtk_bindings_activate_event, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "binding_entry_add_signal", (PyCFunction)_wrap_gtk_binding_entry_add_signal, METH_VARARGS,
      NULL },
    { "binding_entry_remove", (PyCFunction)_wrap_gtk_binding_entry_remove, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "cell_view_new_with_text", (PyCFunction)_wrap_gtk_cell_view_new_with_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "cell_view_new_with_markup", (PyCFunction)_wrap_gtk_cell_view_new_with_markup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "cell_view_new_with_pixbuf", (PyCFunction)_wrap_gtk_cell_view_new_with_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "clipboard_get", (PyCFunction)_wrap_gtk_clipboard_get, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "color_selection_palette_from_string", (PyCFunction)_wrap_gtk_color_selection_palette_from_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "color_selection_palette_to_string", (PyCFunction)_wrap_gtk_color_selection_palette_to_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "combo_box_new_text", (PyCFunction)_wrap_gtk_combo_box_new_text, METH_NOARGS,
      NULL },
    { "combo_box_entry_new_with_model", (PyCFunction)_wrap_gtk_combo_box_entry_new_with_model, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "combo_box_entry_new_text", (PyCFunction)_wrap_gtk_combo_box_entry_new_text, METH_NOARGS,
      NULL },
    { "container_class_install_child_property", (PyCFunction)_wrap_gtk_container_class_install_child_property, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "container_class_list_child_properties", (PyCFunction)_wrap_gtk_container_class_list_child_properties, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "alternative_dialog_button_order", (PyCFunction)_wrap_gtk_alternative_dialog_button_order, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_set_default_icon", (PyCFunction)_wrap_gtk_drag_set_default_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "target_list_add_text_targets", (PyCFunction)_wrap_gtk_target_list_add_text_targets, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "target_list_add_image_targets", (PyCFunction)_wrap_gtk_target_list_add_image_targets, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "target_list_add_uri_targets", (PyCFunction)_wrap_gtk_target_list_add_uri_targets, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_get_source_widget", (PyCFunction)_wrap_gtk_drag_get_source_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "drag_source_set_icon_name", (PyCFunction)_wrap_gtk_drag_source_set_icon_name1, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "expander_new_with_mnemonic", (PyCFunction)_wrap_gtk_expander_new_with_mnemonic, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "file_chooser_widget_new_with_backend", (PyCFunction)_wrap_gtk_file_chooser_widget_new_with_backend, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "hbutton_box_get_spacing_default", (PyCFunction)_wrap_gtk_hbutton_box_get_spacing_default, METH_NOARGS,
      NULL },
    { "hbutton_box_get_layout_default", (PyCFunction)_wrap_gtk_hbutton_box_get_layout_default, METH_NOARGS,
      NULL },
    { "hbutton_box_set_spacing_default", (PyCFunction)_wrap_gtk_hbutton_box_set_spacing_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "hbutton_box_set_layout_default", (PyCFunction)_wrap_gtk_hbutton_box_set_layout_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "icon_factory_lookup_default", (PyCFunction)_wrap_gtk_icon_factory_lookup_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "icon_size_lookup", (PyCFunction)_wrap_gtk_icon_size_lookup, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "icon_size_lookup_for_settings", (PyCFunction)_wrap_gtk_icon_size_lookup_for_settings, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "icon_size_register", (PyCFunction)_wrap_gtk_icon_size_register, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "icon_size_register_alias", (PyCFunction)_wrap_gtk_icon_size_register_alias, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "icon_size_from_name", (PyCFunction)_wrap_gtk_icon_size_from_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "icon_size_get_name", (PyCFunction)_wrap_gtk_icon_size_get_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "icon_set_new", (PyCFunction)_wrap_gtk_icon_set_new, METH_NOARGS,
      NULL },
    { "icon_theme_get_default", (PyCFunction)_wrap_gtk_icon_theme_get_default, METH_NOARGS,
      NULL },
    { "icon_theme_get_for_screen", (PyCFunction)_wrap_gtk_icon_theme_get_for_screen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "icon_theme_add_builtin_icon", (PyCFunction)_wrap_gtk_icon_theme_add_builtin_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "image_new_from_pixmap", (PyCFunction)_wrap_gtk_image_new_from_pixmap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "image_new_from_image", (PyCFunction)_wrap_gtk_image_new_from_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "image_new_from_file", (PyCFunction)_wrap_gtk_image_new_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "image_new_from_pixbuf", (PyCFunction)_wrap_gtk_image_new_from_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "image_new_from_stock", (PyCFunction)_wrap_gtk_image_new_from_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "image_new_from_icon_set", (PyCFunction)_wrap_gtk_image_new_from_icon_set, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "image_new_from_animation", (PyCFunction)_wrap_gtk_image_new_from_animation, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "image_new_from_icon_name", (PyCFunction)_wrap_gtk_image_new_from_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "item_factory_add_foreign", (PyCFunction)_wrap_gtk_item_factory_add_foreign, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "item_factory_from_widget", (PyCFunction)_wrap_gtk_item_factory_from_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "item_factory_path_from_widget", (PyCFunction)_wrap_gtk_item_factory_path_from_widget, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "item_factory_from_path", (PyCFunction)_wrap_gtk_item_factory_from_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "item_factories_path_delete", (PyCFunction)_wrap_gtk_item_factories_path_delete, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "check_version", (PyCFunction)_wrap_gtk_check_version, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "init_check", (PyCFunction)_wrap_gtk_init_check, METH_NOARGS,
      NULL },
    { "disable_setlocale", (PyCFunction)_wrap_gtk_disable_setlocale, METH_NOARGS,
      NULL },
    { "get_default_language", (PyCFunction)_wrap_gtk_get_default_language, METH_NOARGS,
      NULL },
    { "events_pending", (PyCFunction)_wrap_gtk_events_pending, METH_NOARGS,
      NULL },
    { "main_do_event", (PyCFunction)_wrap_gtk_main_do_event, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "main", (PyCFunction)_wrap_gtk_main, METH_NOARGS,
      NULL },
    { "main_level", (PyCFunction)_wrap_gtk_main_level, METH_NOARGS,
      NULL },
    { "main_quit", (PyCFunction)_wrap_gtk_main_quit, METH_VARARGS,
      NULL },
    { "main_iteration", (PyCFunction)_wrap_gtk_main_iteration, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "main_iteration_do", (PyCFunction)_wrap_gtk_main_iteration_do, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "grab_get_current", (PyCFunction)_wrap_gtk_grab_get_current, METH_NOARGS,
      NULL },
    { "quit_add", (PyCFunction)_wrap_gtk_quit_add, METH_VARARGS,
      NULL },
    { "quit_remove", (PyCFunction)_wrap_gtk_quit_remove, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "get_current_event", (PyCFunction)_wrap_gtk_get_current_event, METH_NOARGS,
      NULL },
    { "get_current_event_time", (PyCFunction)_wrap_gtk_get_current_event_time, METH_NOARGS,
      NULL },
    { "get_current_event_state", (PyCFunction)_wrap_gtk_get_current_event_state, METH_NOARGS,
      NULL },
    { "plug_new_for_display", (PyCFunction)_wrap_gtk_plug_new_for_display, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "preview_set_gamma", (PyCFunction)_wrap_gtk_preview_set_gamma, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "preview_set_color_cube", (PyCFunction)_wrap_gtk_preview_set_color_cube, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "preview_set_install_cmap", (PyCFunction)_wrap_gtk_preview_set_install_cmap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "preview_set_reserved", (PyCFunction)_wrap_gtk_preview_set_reserved, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "preview_get_visual", (PyCFunction)_wrap_gtk_preview_get_visual, METH_NOARGS,
      NULL },
    { "preview_get_cmap", (PyCFunction)_wrap_gtk_preview_get_cmap, METH_NOARGS,
      NULL },
    { "preview_reset", (PyCFunction)_wrap_gtk_preview_reset, METH_NOARGS,
      NULL },
    { "rc_add_default_file", (PyCFunction)_wrap_gtk_rc_add_default_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rc_set_default_files", (PyCFunction)_wrap_gtk_rc_set_default_files, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rc_get_default_files", (PyCFunction)_wrap_gtk_rc_get_default_files, METH_NOARGS,
      NULL },
    { "rc_get_style_by_paths", (PyCFunction)_wrap_gtk_rc_get_style_by_paths, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rc_reparse_all_for_settings", (PyCFunction)_wrap_gtk_rc_reparse_all_for_settings, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rc_reset_styles", (PyCFunction)_wrap_gtk_rc_reset_styles, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rc_parse", (PyCFunction)_wrap_gtk_rc_parse, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rc_parse_string", (PyCFunction)_wrap_gtk_rc_parse_string, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rc_reparse_all", (PyCFunction)_wrap_gtk_rc_reparse_all, METH_NOARGS,
      NULL },
    { "rc_find_module_in_path", (PyCFunction)_wrap_gtk_rc_find_module_in_path, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "rc_get_theme_dir", (PyCFunction)_wrap_gtk_rc_get_theme_dir, METH_NOARGS,
      NULL },
    { "rc_get_module_dir", (PyCFunction)_wrap_gtk_rc_get_module_dir, METH_NOARGS,
      NULL },
    { "rc_get_im_module_path", (PyCFunction)_wrap_gtk_rc_get_im_module_path, METH_NOARGS,
      NULL },
    { "rc_get_im_module_file", (PyCFunction)_wrap_gtk_rc_get_im_module_file, METH_NOARGS,
      NULL },
    { "selection_owner_set_for_display", (PyCFunction)_wrap_gtk_selection_owner_set_for_display, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "settings_get_default", (PyCFunction)_wrap_gtk_settings_get_default, METH_NOARGS,
      NULL },
    { "settings_get_for_screen", (PyCFunction)_wrap_gtk_settings_get_for_screen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "stock_add", (PyCFunction)_wrap_gtk_stock_add, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "stock_lookup", (PyCFunction)_wrap_gtk_stock_lookup, METH_VARARGS,
      NULL },
    { "stock_list_ids", (PyCFunction)_wrap_gtk_stock_list_ids, METH_NOARGS,
      NULL },
    { "draw_insertion_cursor", (PyCFunction)_wrap_gtk_draw_insertion_cursor, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "tooltips_data_get", (PyCFunction)_wrap_gtk_tooltips_data_get, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "gtk_tooltips_data_get", (PyCFunction)_wrap_gtk_tooltips_data_get1, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "vbutton_box_get_spacing_default", (PyCFunction)_wrap_gtk_vbutton_box_get_spacing_default, METH_NOARGS,
      NULL },
    { "vbutton_box_set_spacing_default", (PyCFunction)_wrap_gtk_vbutton_box_set_spacing_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "vbutton_box_get_layout_default", (PyCFunction)_wrap_gtk_vbutton_box_get_layout_default, METH_NOARGS,
      NULL },
    { "vbutton_box_set_layout_default", (PyCFunction)_wrap_gtk_vbutton_box_set_layout_default, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "widget_push_colormap", (PyCFunction)_wrap_gtk_widget_push_colormap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "widget_push_composite_child", (PyCFunction)_wrap_gtk_widget_push_composite_child, METH_NOARGS,
      NULL },
    { "widget_pop_composite_child", (PyCFunction)_wrap_gtk_widget_pop_composite_child, METH_NOARGS,
      NULL },
    { "widget_pop_colormap", (PyCFunction)_wrap_gtk_widget_pop_colormap, METH_NOARGS,
      NULL },
    { "widget_class_install_style_property", (PyCFunction)_wrap_gtk_widget_class_install_style_property, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "widget_class_find_style_property", (PyCFunction)_wrap_gtk_widget_class_find_style_property, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "widget_class_list_style_properties", (PyCFunction)_wrap_gtk_widget_class_list_style_properties, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "widget_get_default_style", (PyCFunction)_wrap_gtk_widget_get_default_style, METH_NOARGS,
      NULL },
    { "widget_set_default_colormap", (PyCFunction)_wrap_gtk_widget_set_default_colormap, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "widget_get_default_colormap", (PyCFunction)_wrap_gtk_widget_get_default_colormap, METH_NOARGS,
      NULL },
    { "widget_get_default_visual", (PyCFunction)_wrap_gtk_widget_get_default_visual, METH_NOARGS,
      NULL },
    { "widget_set_default_direction", (PyCFunction)_wrap_gtk_widget_set_default_direction, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "widget_get_default_direction", (PyCFunction)_wrap_gtk_widget_get_default_direction, METH_NOARGS,
      NULL },
    { "window_set_default_icon_list", (PyCFunction)_wrap_gtk_window_set_default_icon_list, METH_VARARGS,
      NULL },
    { "window_get_default_icon_list", (PyCFunction)_wrap_gtk_window_get_default_icon_list, METH_NOARGS,
      NULL },
    { "window_set_default_icon", (PyCFunction)_wrap_gtk_window_set_default_icon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "window_set_default_icon_from_file", (PyCFunction)_wrap_gtk_window_set_default_icon_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "window_set_auto_startup_notification", (PyCFunction)_wrap_gtk_window_set_auto_startup_notification, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "window_list_toplevels", (PyCFunction)_wrap_gtk_window_list_toplevels, METH_NOARGS,
      NULL },
    { "window_set_default_icon_name", (PyCFunction)_wrap_gtk_window_set_default_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "link_button_new", (PyCFunction)_wrap_gtk_link_button_new, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "link_button_set_uri_hook", (PyCFunction)_wrap_gtk_link_button_set_uri_hook, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "notebook_set_window_creation_hook", (PyCFunction)_wrap_gtk_notebook_set_window_creation_hook, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paper_size_new_from_ppd", (PyCFunction)_wrap_gtk_paper_size_new_from_ppd, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paper_size_new_custom", (PyCFunction)_wrap_gtk_paper_size_new_custom, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "paper_size_get_default", (PyCFunction)_wrap_gtk_paper_size_get_default, METH_NOARGS,
      NULL },
    { "print_run_page_setup_dialog", (PyCFunction)_wrap_gtk_print_run_page_setup_dialog, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "recent_manager_get_default", (PyCFunction)_wrap_gtk_recent_manager_get_default, METH_NOARGS,
      NULL },
    { "recent_manager_get_for_screen", (PyCFunction)_wrap_gtk_recent_manager_get_for_screen, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "target_list_add_rich_text_targets", (PyCFunction)_wrap_gtk_target_list_add_rich_text_targets, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "targets_include_text", (PyCFunction)_wrap_gtk_targets_include_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "targets_include_rich_text", (PyCFunction)_wrap_gtk_targets_include_rich_text, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "targets_include_image", (PyCFunction)_wrap_gtk_targets_include_image, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "targets_include_uri", (PyCFunction)_wrap_gtk_targets_include_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "status_icon_new_from_pixbuf", (PyCFunction)_wrap_gtk_status_icon_new_from_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "status_icon_new_from_file", (PyCFunction)_wrap_gtk_status_icon_new_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "status_icon_new_from_stock", (PyCFunction)_wrap_gtk_status_icon_new_from_stock, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "status_icon_new_from_icon_name", (PyCFunction)_wrap_gtk_status_icon_new_from_icon_name, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "status_icon_position_menu", (PyCFunction)_wrap_gtk_status_icon_position_menu, METH_VARARGS,
      NULL },
    { "page_setup_new_from_file", (PyCFunction)_wrap_gtk_page_setup_new_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "print_settings_new_from_file", (PyCFunction)_wrap_gtk_print_settings_new_from_file, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "recent_action_new_for_manager", (PyCFunction)_wrap_gtk_recent_action_new_for_manager, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "tooltip_trigger_tooltip_query", (PyCFunction)_wrap_gtk_tooltip_trigger_tooltip_query, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "icon_info_new_for_pixbuf", (PyCFunction)_wrap_gtk_icon_info_new_for_pixbuf, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "image_new_from_gicon", (PyCFunction)_wrap_gtk_image_new_from_gicon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "show_uri", (PyCFunction)_wrap_gtk_show_uri, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "status_icon_new_from_gicon", (PyCFunction)_wrap_gtk_status_icon_new_from_gicon, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "gtk_window_get_default_icon_name", (PyCFunction)_wrap_gtk_window_get_default_icon_name, METH_NOARGS,
      NULL },
    { "new_with_buffer", (PyCFunction)_wrap_gtk_entry_new_with_buffer, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "hsv_to_rgb", (PyCFunction)_wrap_gtk_hsv_to_rgb, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "combo_box_new_with_entry", (PyCFunction)_wrap_gtk_combo_box_new_with_entry, METH_NOARGS,
      NULL },
    { "combo_box_new_with_model_and_entry", (PyCFunction)_wrap_gtk_combo_box_new_with_model_and_entry, METH_VARARGS|METH_KEYWORDS,
      NULL },
    { "combo_box_text_new_with_entry", (PyCFunction)_wrap_gtk_combo_box_text_new_with_entry, METH_NOARGS,
      NULL },
    { "remove_log_handlers", (PyCFunction)_wrap_remove_log_handlers, METH_VARARGS,
      NULL },
    { "add_log_handlers", (PyCFunction)_wrap_add_log_handlers, METH_VARARGS,
      NULL },
    { "set_interactive", (PyCFunction)_wrap_set_interactive, METH_VARARGS,
      NULL },
    { NULL, NULL, 0, NULL }
};


/* ----------- enums and flags ----------- */

void
pygtk_add_constants(PyObject *module, const gchar *strip_prefix)
{
#ifdef VERSION
    PyModule_AddStringConstant(module, "__version__", VERSION);
#endif
  pyg_enum_add(module, "AnchorType", strip_prefix, GTK_TYPE_ANCHOR_TYPE);
  pyg_enum_add(module, "ArrowType", strip_prefix, GTK_TYPE_ARROW_TYPE);
  pyg_enum_add(module, "ButtonBoxStyle", strip_prefix, GTK_TYPE_BUTTON_BOX_STYLE);
  pyg_enum_add(module, "ButtonsType", strip_prefix, GTK_TYPE_BUTTONS_TYPE);
  pyg_enum_add(module, "CellRendererMode", strip_prefix, GTK_TYPE_CELL_RENDERER_MODE);
  pyg_enum_add(module, "CellType", strip_prefix, GTK_TYPE_CELL_TYPE);
  pyg_enum_add(module, "CListDragPos", strip_prefix, GTK_TYPE_CLIST_DRAG_POS);
  pyg_enum_add(module, "CornerType", strip_prefix, GTK_TYPE_CORNER_TYPE);
  pyg_enum_add(module, "CTreeExpanderStyle", strip_prefix, GTK_TYPE_CTREE_EXPANDER_STYLE);
  pyg_enum_add(module, "CTreeExpansionType", strip_prefix, GTK_TYPE_CTREE_EXPANSION_TYPE);
  pyg_enum_add(module, "CTreeLineStyle", strip_prefix, GTK_TYPE_CTREE_LINE_STYLE);
  pyg_enum_add(module, "CTreePos", strip_prefix, GTK_TYPE_CTREE_POS);
  pyg_enum_add(module, "CurveType", strip_prefix, GTK_TYPE_CURVE_TYPE);
  pyg_enum_add(module, "DeleteType", strip_prefix, GTK_TYPE_DELETE_TYPE);
  pyg_enum_add(module, "DirectionType", strip_prefix, GTK_TYPE_DIRECTION_TYPE);
  pyg_enum_add(module, "ExpanderStyle", strip_prefix, GTK_TYPE_EXPANDER_STYLE);
  pyg_enum_add(module, "FileChooserAction", strip_prefix, GTK_TYPE_FILE_CHOOSER_ACTION);
  pyg_enum_add(module, "FileChooserConfirmation", strip_prefix, GTK_TYPE_FILE_CHOOSER_CONFIRMATION);
  pyg_enum_add(module, "FileChooserError", strip_prefix, GTK_TYPE_FILE_CHOOSER_ERROR);
  pyg_enum_add(module, "IconSize", strip_prefix, GTK_TYPE_ICON_SIZE);
  pyg_enum_add(module, "IconThemeError", strip_prefix, GTK_TYPE_ICON_THEME_ERROR);
  pyg_enum_add(module, "IconViewDropPosition", strip_prefix, GTK_TYPE_ICON_VIEW_DROP_POSITION);
  pyg_enum_add(module, "ImageType", strip_prefix, GTK_TYPE_IMAGE_TYPE);
  pyg_enum_add(module, "IMPreeditStyle", strip_prefix, GTK_TYPE_IM_PREEDIT_STYLE);
  pyg_enum_add(module, "IMStatusStyle", strip_prefix, GTK_TYPE_IM_STATUS_STYLE);
  pyg_enum_add(module, "PackDirection", strip_prefix, GTK_TYPE_PACK_DIRECTION);
  pyg_enum_add(module, "Justification", strip_prefix, GTK_TYPE_JUSTIFICATION);
  pyg_enum_add(module, "MatchType", strip_prefix, GTK_TYPE_MATCH_TYPE);
  pyg_enum_add(module, "MenuDirectionType", strip_prefix, GTK_TYPE_MENU_DIRECTION_TYPE);
  pyg_enum_add(module, "MessageType", strip_prefix, GTK_TYPE_MESSAGE_TYPE);
  pyg_enum_add(module, "MetricType", strip_prefix, GTK_TYPE_METRIC_TYPE);
  pyg_enum_add(module, "MovementStep", strip_prefix, GTK_TYPE_MOVEMENT_STEP);
  pyg_enum_add(module, "NotebookTab", strip_prefix, GTK_TYPE_NOTEBOOK_TAB);
  pyg_enum_add(module, "Orientation", strip_prefix, GTK_TYPE_ORIENTATION);
  pyg_enum_add(module, "PackType", strip_prefix, GTK_TYPE_PACK_TYPE);
  pyg_enum_add(module, "PathPriorityType", strip_prefix, GTK_TYPE_PATH_PRIORITY_TYPE);
  pyg_enum_add(module, "PathType", strip_prefix, GTK_TYPE_PATH_TYPE);
  pyg_enum_add(module, "PolicyType", strip_prefix, GTK_TYPE_POLICY_TYPE);
  pyg_enum_add(module, "PositionType", strip_prefix, GTK_TYPE_POSITION_TYPE);
  pyg_enum_add(module, "PreviewType", strip_prefix, GTK_TYPE_PREVIEW_TYPE);
  pyg_enum_add(module, "ProgressBarOrientation", strip_prefix, GTK_TYPE_PROGRESS_BAR_ORIENTATION);
  pyg_enum_add(module, "ProgressBarStyle", strip_prefix, GTK_TYPE_PROGRESS_BAR_STYLE);
  pyg_enum_add(module, "RcTokenType", strip_prefix, GTK_TYPE_RC_TOKEN_TYPE);
  pyg_enum_add(module, "ReliefStyle", strip_prefix, GTK_TYPE_RELIEF_STYLE);
  pyg_enum_add(module, "ResizeMode", strip_prefix, GTK_TYPE_RESIZE_MODE);
  pyg_enum_add(module, "ResponseType", strip_prefix, GTK_TYPE_RESPONSE_TYPE);
  pyg_enum_add(module, "ScrollStep", strip_prefix, GTK_TYPE_SCROLL_STEP);
  pyg_enum_add(module, "ScrollType", strip_prefix, GTK_TYPE_SCROLL_TYPE);
  pyg_enum_add(module, "SelectionMode", strip_prefix, GTK_TYPE_SELECTION_MODE);
  pyg_enum_add(module, "ShadowType", strip_prefix, GTK_TYPE_SHADOW_TYPE);
  pyg_enum_add(module, "SideType", strip_prefix, GTK_TYPE_SIDE_TYPE);
  pyg_enum_add(module, "SizeGroupMode", strip_prefix, GTK_TYPE_SIZE_GROUP_MODE);
    PyModule_AddIntConstant(module, (char *) pyg_constant_strip_prefix("GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID", strip_prefix), GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID);
    PyModule_AddIntConstant(module, (char *) pyg_constant_strip_prefix("GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID", strip_prefix), GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID);
  pyg_enum_add(module, "SortType", strip_prefix, GTK_TYPE_SORT_TYPE);
  pyg_enum_add(module, "SpinButtonUpdatePolicy", strip_prefix, GTK_TYPE_SPIN_BUTTON_UPDATE_POLICY);
  pyg_enum_add(module, "SpinType", strip_prefix, GTK_TYPE_SPIN_TYPE);
  pyg_enum_add(module, "StateType", strip_prefix, GTK_TYPE_STATE_TYPE);
  pyg_enum_add(module, "SubmenuDirection", strip_prefix, GTK_TYPE_SUBMENU_DIRECTION);
  pyg_enum_add(module, "SubmenuPlacement", strip_prefix, GTK_TYPE_SUBMENU_PLACEMENT);
  pyg_enum_add(module, "TextDirection", strip_prefix, GTK_TYPE_TEXT_DIRECTION);
  pyg_enum_add(module, "TextWindowType", strip_prefix, GTK_TYPE_TEXT_WINDOW_TYPE);
  pyg_enum_add(module, "ToolbarChildType", strip_prefix, GTK_TYPE_TOOLBAR_CHILD_TYPE);
  pyg_enum_add(module, "ToolbarSpaceStyle", strip_prefix, GTK_TYPE_TOOLBAR_SPACE_STYLE);
  pyg_enum_add(module, "ToolbarStyle", strip_prefix, GTK_TYPE_TOOLBAR_STYLE);
  pyg_enum_add(module, "TreeViewColumnSizing", strip_prefix, GTK_TYPE_TREE_VIEW_COLUMN_SIZING);
  pyg_enum_add(module, "TreeViewDropPosition", strip_prefix, GTK_TYPE_TREE_VIEW_DROP_POSITION);
  pyg_enum_add(module, "TreeViewMode", strip_prefix, GTK_TYPE_TREE_VIEW_MODE);
  pyg_enum_add(module, "UpdateType", strip_prefix, GTK_TYPE_UPDATE_TYPE);
  pyg_enum_add(module, "Visibility", strip_prefix, GTK_TYPE_VISIBILITY);
  pyg_enum_add(module, "WidgetHelpType", strip_prefix, GTK_TYPE_WIDGET_HELP_TYPE);
  pyg_enum_add(module, "WindowPosition", strip_prefix, GTK_TYPE_WINDOW_POSITION);
  pyg_enum_add(module, "WindowType", strip_prefix, GTK_TYPE_WINDOW_TYPE);
  pyg_enum_add(module, "WrapMode", strip_prefix, GTK_TYPE_WRAP_MODE);
  pyg_flags_add(module, "AccelFlags", strip_prefix, GTK_TYPE_ACCEL_FLAGS);
  pyg_flags_add(module, "ArgFlags", strip_prefix, GTK_TYPE_ARG_FLAGS);
  pyg_flags_add(module, "AttachOptions", strip_prefix, GTK_TYPE_ATTACH_OPTIONS);
  pyg_flags_add(module, "ButtonAction", strip_prefix, GTK_TYPE_BUTTON_ACTION);
  pyg_flags_add(module, "CalendarDisplayOptions", strip_prefix, GTK_TYPE_CALENDAR_DISPLAY_OPTIONS);
  pyg_flags_add(module, "CellRendererState", strip_prefix, GTK_TYPE_CELL_RENDERER_STATE);
  pyg_flags_add(module, "DebugFlag", strip_prefix, GTK_TYPE_DEBUG_FLAG);
  pyg_flags_add(module, "DestDefaults", strip_prefix, GTK_TYPE_DEST_DEFAULTS);
  pyg_flags_add(module, "DialogFlags", strip_prefix, GTK_TYPE_DIALOG_FLAGS);
  pyg_flags_add(module, "FileFilterFlags", strip_prefix, GTK_TYPE_FILE_FILTER_FLAGS);
  pyg_flags_add(module, "IconLookupFlags", strip_prefix, GTK_TYPE_ICON_LOOKUP_FLAGS);
  pyg_flags_add(module, "ObjectFlags", strip_prefix, GTK_TYPE_OBJECT_FLAGS);
  pyg_flags_add(module, "PrivateFlags", strip_prefix, GTK_TYPE_PRIVATE_FLAGS);
  pyg_flags_add(module, "RcFlags", strip_prefix, GTK_TYPE_RC_FLAGS);
  pyg_flags_add(module, "TargetFlags", strip_prefix, GTK_TYPE_TARGET_FLAGS);
  pyg_flags_add(module, "TextSearchFlags", strip_prefix, GTK_TYPE_TEXT_SEARCH_FLAGS);
  pyg_flags_add(module, "TreeModelFlags", strip_prefix, GTK_TYPE_TREE_MODEL_FLAGS);
  pyg_flags_add(module, "UIManagerItemType", strip_prefix, GTK_TYPE_UI_MANAGER_ITEM_TYPE);
  pyg_flags_add(module, "WidgetFlags", strip_prefix, GTK_TYPE_WIDGET_FLAGS);
  pyg_enum_add(module, "AssistantPageType", strip_prefix, GTK_TYPE_ASSISTANT_PAGE_TYPE);
  pyg_enum_add(module, "CellRendererAccelMode", strip_prefix, GTK_TYPE_CELL_RENDERER_ACCEL_MODE);
  pyg_enum_add(module, "PageOrientation", strip_prefix, GTK_TYPE_PAGE_ORIENTATION);
  pyg_enum_add(module, "PageSet", strip_prefix, GTK_TYPE_PAGE_SET);
  pyg_enum_add(module, "PrintDuplex", strip_prefix, GTK_TYPE_PRINT_DUPLEX);
  pyg_enum_add(module, "PrintError", strip_prefix, GTK_TYPE_PRINT_ERROR);
  pyg_enum_add(module, "PrintOperationAction", strip_prefix, GTK_TYPE_PRINT_OPERATION_ACTION);
  pyg_enum_add(module, "PrintOperationResult", strip_prefix, GTK_TYPE_PRINT_OPERATION_RESULT);
  pyg_enum_add(module, "PrintPages", strip_prefix, GTK_TYPE_PRINT_PAGES);
  pyg_enum_add(module, "PrintQuality", strip_prefix, GTK_TYPE_PRINT_QUALITY);
  pyg_enum_add(module, "PrintStatus", strip_prefix, GTK_TYPE_PRINT_STATUS);
  pyg_enum_add(module, "RecentChooserError", strip_prefix, GTK_TYPE_RECENT_CHOOSER_ERROR);
  pyg_enum_add(module, "RecentManagerError", strip_prefix, GTK_TYPE_RECENT_MANAGER_ERROR);
  pyg_enum_add(module, "RecentSortType", strip_prefix, GTK_TYPE_RECENT_SORT_TYPE);
  pyg_enum_add(module, "SensitivityType", strip_prefix, GTK_TYPE_SENSITIVITY_TYPE);
  pyg_enum_add(module, "TextBufferTargetInfo", strip_prefix, GTK_TYPE_TEXT_BUFFER_TARGET_INFO);
  pyg_enum_add(module, "TreeViewGridLines", strip_prefix, GTK_TYPE_TREE_VIEW_GRID_LINES);
  pyg_enum_add(module, "Unit", strip_prefix, GTK_TYPE_UNIT);
  pyg_flags_add(module, "RecentFilterFlags", strip_prefix, GTK_TYPE_RECENT_FILTER_FLAGS);
  pyg_enum_add(module, "BuilderError", strip_prefix, GTK_TYPE_BUILDER_ERROR);
  pyg_enum_add(module, "NumberUpLayout", strip_prefix, GTK_TYPE_NUMBER_UP_LAYOUT);
  pyg_enum_add(module, "EntryIconPosition", strip_prefix, GTK_TYPE_ENTRY_ICON_POSITION);
  pyg_flags_add(module, "ToolPaletteDragTargets", strip_prefix, GTK_TYPE_TOOL_PALETTE_DRAG_TARGETS);

  if (PyErr_Occurred())
    PyErr_Print();
}

/* initialise stuff extension classes */
void
pygtk_register_classes(PyObject *d)
{
    PyObject *module;

    if ((module = PyImport_ImportModule("gio")) != NULL) {
        _PyGFile_Type = (PyTypeObject *)PyObject_GetAttrString(module, "File");
        if (_PyGFile_Type == NULL) {
            PyErr_SetString(PyExc_ImportError,
                "cannot import name File from gio");
            return ;
        }
        _PyGIcon_Type = (PyTypeObject *)PyObject_GetAttrString(module, "Icon");
        if (_PyGIcon_Type == NULL) {
            PyErr_SetString(PyExc_ImportError,
                "cannot import name Icon from gio");
            return ;
        }
        _PyGMountOperation_Type = (PyTypeObject *)PyObject_GetAttrString(module, "MountOperation");
        if (_PyGMountOperation_Type == NULL) {
            PyErr_SetString(PyExc_ImportError,
                "cannot import name MountOperation from gio");
            return ;
        }
    } else {
        PyErr_SetString(PyExc_ImportError,
            "could not import gio");
        return ;
    }
    if ((module = PyImport_ImportModule("gobject")) != NULL) {
        _PyGObject_Type = (PyTypeObject *)PyObject_GetAttrString(module, "GObject");
        if (_PyGObject_Type == NULL) {
            PyErr_SetString(PyExc_ImportError,
                "cannot import name GObject from gobject");
            return ;
        }
    } else {
        PyErr_SetString(PyExc_ImportError,
            "could not import gobject");
        return ;
    }
    if ((module = PyImport_ImportModule("pango")) != NULL) {
        _PyPangoContext_Type = (PyTypeObject *)PyObject_GetAttrString(module, "Context");
        if (_PyPangoContext_Type == NULL) {
            PyErr_SetString(PyExc_ImportError,
                "cannot import name Context from pango");
            return ;
        }
        _PyPangoFont_Type = (PyTypeObject *)PyObject_GetAttrString(module, "Font");
        if (_PyPangoFont_Type == NULL) {
            PyErr_SetString(PyExc_ImportError,
                "cannot import name Font from pango");
            return ;
        }
        _PyPangoLayout_Type = (PyTypeObject *)PyObject_GetAttrString(module, "Layout");
        if (_PyPangoLayout_Type == NULL) {
            PyErr_SetString(PyExc_ImportError,
                "cannot import name Layout from pango");
            return ;
        }
    } else {
        PyErr_SetString(PyExc_ImportError,
            "could not import pango");
        return ;
    }
    if ((module = PyImport_ImportModule("atk")) != NULL) {
        _PyAtkObject_Type = (PyTypeObject *)PyObject_GetAttrString(module, "Object");
        if (_PyAtkObject_Type == NULL) {
            PyErr_SetString(PyExc_ImportError,
                "cannot import name Object from atk");
            return ;
        }
    } else {
        PyErr_SetString(PyExc_ImportError,
            "could not import atk");
        return ;
    }


#line 36 "gtktreeview.override"
    PyGtkListStore_Type.tp_as_number  = PyGtkTreeModel_Type.tp_as_number;
    PyGtkListStore_Type.tp_as_mapping = PyGtkTreeModel_Type.tp_as_mapping;
    PyGtkListStore_Type.tp_iter       = PyGtkTreeModel_Type.tp_iter;
    PyGtkTreeStore_Type.tp_as_number  = PyGtkTreeModel_Type.tp_as_number;
    PyGtkTreeStore_Type.tp_as_mapping = PyGtkTreeModel_Type.tp_as_mapping;
    PyGtkTreeStore_Type.tp_iter       = PyGtkTreeModel_Type.tp_iter;
    PyPyGtkGenericTreeModel_Type.tp_as_number  = PyGtkTreeModel_Type.tp_as_number;
    PyPyGtkGenericTreeModel_Type.tp_as_mapping = PyGtkTreeModel_Type.tp_as_mapping;
    PyPyGtkGenericTreeModel_Type.tp_iter       = PyGtkTreeModel_Type.tp_iter;
    PyGtkTreeModelSort_Type.tp_as_number  = PyGtkTreeModel_Type.tp_as_number;
    PyGtkTreeModelSort_Type.tp_as_mapping = PyGtkTreeModel_Type.tp_as_mapping;
    PyGtkTreeModelSort_Type.tp_iter       = PyGtkTreeModel_Type.tp_iter;
    PyGtkTreeModelFilter_Type.tp_as_number  = PyGtkTreeModel_Type.tp_as_number;
    PyGtkTreeModelFilter_Type.tp_as_mapping = PyGtkTreeModel_Type.tp_as_mapping;
    PyGtkTreeModelFilter_Type.tp_iter       = PyGtkTreeModel_Type.tp_iter;

#line 2772 "./gtk.override"
#if GTK_CHECK_VERSION(2, 9, 0)
    pyg_set_object_has_new_constructor(GTK_TYPE_MESSAGE_DIALOG);
#endif

#line 128007 "gtk.c"
    pyg_register_boxed(d, "Border", GTK_TYPE_BORDER, &PyGtkBorder_Type);
    pyg_register_boxed(d, "IconInfo", GTK_TYPE_ICON_INFO, &PyGtkIconInfo_Type);
    pyg_register_boxed(d, "IconSet", GTK_TYPE_ICON_SET, &PyGtkIconSet_Type);
    pyg_register_boxed(d, "IconSource", GTK_TYPE_ICON_SOURCE, &PyGtkIconSource_Type);
    pyg_register_boxed(d, "Requisition", GTK_TYPE_REQUISITION, &PyGtkRequisition_Type);
    pyg_register_boxed(d, "SelectionData", GTK_TYPE_SELECTION_DATA, &PyGtkSelectionData_Type);
    pyg_register_boxed(d, "TextAttributes", GTK_TYPE_TEXT_ATTRIBUTES, &PyGtkTextAttributes_Type);
    pyg_register_boxed(d, "TextIter", GTK_TYPE_TEXT_ITER, &PyGtkTextIter_Type);
    pyg_register_boxed(d, "TreeIter", GTK_TYPE_TREE_ITER, &PyGtkTreeIter_Type);
    pyg_register_boxed(d, "TreeRowReference", GTK_TYPE_TREE_ROW_REFERENCE, &PyGtkTreeRowReference_Type);
    pyg_register_boxed(d, "PaperSize", GTK_TYPE_PAPER_SIZE, &PyGtkPaperSize_Type);
    pyg_register_boxed(d, "RecentInfo", GTK_TYPE_RECENT_INFO, &PyGtkRecentInfo_Type);
    pyg_register_pointer(d, "CTreeNode", GTK_TYPE_CTREE_NODE, &PyGtkCTreeNode_Type);
    pyg_register_interface(d, "CellEditable", GTK_TYPE_CELL_EDITABLE, &PyGtkCellEditable_Type);
    pyg_register_interface_info(GTK_TYPE_CELL_EDITABLE, &__GtkCellEditable__iinfo);
    pyg_register_interface(d, "CellLayout", GTK_TYPE_CELL_LAYOUT, &PyGtkCellLayout_Type);
    pyg_register_interface_info(GTK_TYPE_CELL_LAYOUT, &__GtkCellLayout__iinfo);
    pyg_register_interface(d, "Editable", GTK_TYPE_EDITABLE, &PyGtkEditable_Type);
    pyg_register_interface_info(GTK_TYPE_EDITABLE, &__GtkEditable__iinfo);
    pyg_register_interface(d, "FileChooser", GTK_TYPE_FILE_CHOOSER, &PyGtkFileChooser_Type);
    pyg_register_interface(d, "TreeDragDest", GTK_TYPE_TREE_DRAG_DEST, &PyGtkTreeDragDest_Type);
    pyg_register_interface_info(GTK_TYPE_TREE_DRAG_DEST, &__GtkTreeDragDest__iinfo);
    pyg_register_interface(d, "TreeDragSource", GTK_TYPE_TREE_DRAG_SOURCE, &PyGtkTreeDragSource_Type);
    pyg_register_interface_info(GTK_TYPE_TREE_DRAG_SOURCE, &__GtkTreeDragSource__iinfo);
    pyg_register_interface(d, "TreeModel", GTK_TYPE_TREE_MODEL, &PyGtkTreeModel_Type);
    pyg_register_interface_info(GTK_TYPE_TREE_MODEL, &__GtkTreeModel__iinfo);
    pyg_register_interface(d, "TreeSortable", GTK_TYPE_TREE_SORTABLE, &PyGtkTreeSortable_Type);
    pyg_register_interface_info(GTK_TYPE_TREE_SORTABLE, &__GtkTreeSortable__iinfo);
    pyg_register_interface(d, "PrintOperationPreview", GTK_TYPE_PRINT_OPERATION_PREVIEW, &PyGtkPrintOperationPreview_Type);
    pyg_register_interface_info(GTK_TYPE_PRINT_OPERATION_PREVIEW, &__GtkPrintOperationPreview__iinfo);
    pyg_register_interface(d, "RecentChooser", GTK_TYPE_RECENT_CHOOSER, &PyGtkRecentChooser_Type);
    pyg_register_interface_info(GTK_TYPE_RECENT_CHOOSER, &__GtkRecentChooser__iinfo);
    pyg_register_interface(d, "Buildable", GTK_TYPE_BUILDABLE, &PyGtkBuildable_Type);
    pyg_register_interface_info(GTK_TYPE_BUILDABLE, &__GtkBuildable__iinfo);
    pyg_register_interface(d, "ToolShell", GTK_TYPE_TOOL_SHELL, &PyGtkToolShell_Type);
    pyg_register_interface_info(GTK_TYPE_TOOL_SHELL, &__GtkToolShell__iinfo);
    pyg_register_interface(d, "Activatable", GTK_TYPE_ACTIVATABLE, &PyGtkActivatable_Type);
    pyg_register_interface_info(GTK_TYPE_ACTIVATABLE, &__GtkActivatable__iinfo);
    pyg_register_interface(d, "Orientable", GTK_TYPE_ORIENTABLE, &PyGtkOrientable_Type);
    pygobject_register_class(d, "PyGtkGenericTreeModel", PYGTK_TYPE_GENERIC_TREE_MODEL, &PyPyGtkGenericTreeModel_Type, Py_BuildValue("(OO)", &PyGObject_Type, &PyGtkTreeModel_Type));
    pyg_set_object_has_new_constructor(PYGTK_TYPE_GENERIC_TREE_MODEL);
    pygobject_register_class(d, "GtkAccelGroup", GTK_TYPE_ACCEL_GROUP, &PyGtkAccelGroup_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ACCEL_GROUP);
    pyg_register_class_init(GTK_TYPE_ACCEL_GROUP, __GtkAccelGroup_class_init);
    pygobject_register_class(d, "GtkAccelMap", GTK_TYPE_ACCEL_MAP, &PyGtkAccelMap_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ACCEL_MAP);
    pygobject_register_class(d, "GtkAccessible", GTK_TYPE_ACCESSIBLE, &PyGtkAccessible_Type, Py_BuildValue("(O)", &PyAtkObject_Type));
    pyg_register_class_init(GTK_TYPE_ACCESSIBLE, __GtkAccessible_class_init);
    pygobject_register_class(d, "GtkAction", GTK_TYPE_ACTION, &PyGtkAction_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ACTION);
    pyg_register_class_init(GTK_TYPE_ACTION, __GtkAction_class_init);
    pygobject_register_class(d, "GtkActionGroup", GTK_TYPE_ACTION_GROUP, &PyGtkActionGroup_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ACTION_GROUP);
    pyg_register_class_init(GTK_TYPE_ACTION_GROUP, __GtkActionGroup_class_init);
    pygobject_register_class(d, "GtkClipboard", GTK_TYPE_CLIPBOARD, &PyGtkClipboard_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pygobject_register_class(d, "GtkEntryCompletion", GTK_TYPE_ENTRY_COMPLETION, &PyGtkEntryCompletion_Type, Py_BuildValue("(OO)", &PyGObject_Type, &PyGtkCellLayout_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ENTRY_COMPLETION);
    pyg_register_class_init(GTK_TYPE_ENTRY_COMPLETION, __GtkEntryCompletion_class_init);
    pygobject_register_class(d, "GtkIconFactory", GTK_TYPE_ICON_FACTORY, &PyGtkIconFactory_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ICON_FACTORY);
    pygobject_register_class(d, "GtkIconTheme", GTK_TYPE_ICON_THEME, &PyGtkIconTheme_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ICON_THEME);
    pyg_register_class_init(GTK_TYPE_ICON_THEME, __GtkIconTheme_class_init);
    pygobject_register_class(d, "GtkListStore", GTK_TYPE_LIST_STORE, &PyGtkListStore_Type, Py_BuildValue("(OOOOO)", &PyGObject_Type, &PyGtkTreeModel_Type, &PyGtkTreeDragSource_Type, &PyGtkTreeDragDest_Type, &PyGtkTreeSortable_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_LIST_STORE);
    pygobject_register_class(d, "GtkObject", GTK_TYPE_OBJECT, &PyGtkObject_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_OBJECT);
    pyg_register_class_init(GTK_TYPE_OBJECT, __GtkObject_class_init);
    pygobject_register_class(d, "GtkItemFactory", GTK_TYPE_ITEM_FACTORY, &PyGtkItemFactory_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
    pygobject_register_class(d, "GtkIMContext", GTK_TYPE_IM_CONTEXT, &PyGtkIMContext_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_IM_CONTEXT);
    pyg_register_class_init(GTK_TYPE_IM_CONTEXT, __GtkIMContext_class_init);
    pygobject_register_class(d, "GtkIMMulticontext", GTK_TYPE_IM_MULTICONTEXT, &PyGtkIMMulticontext_Type, Py_BuildValue("(O)", &PyGtkIMContext_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_IM_MULTICONTEXT);
    pygobject_register_class(d, "GtkIMContextSimple", GTK_TYPE_IM_CONTEXT_SIMPLE, &PyGtkIMContextSimple_Type, Py_BuildValue("(O)", &PyGtkIMContext_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_IM_CONTEXT_SIMPLE);
    pygobject_register_class(d, "GtkFileFilter", GTK_TYPE_FILE_FILTER, &PyGtkFileFilter_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_FILE_FILTER);
    pygobject_register_class(d, "GtkCellRenderer", GTK_TYPE_CELL_RENDERER, &PyGtkCellRenderer_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CELL_RENDERER);
    pyg_register_class_init(GTK_TYPE_CELL_RENDERER, __GtkCellRenderer_class_init);
    pygobject_register_class(d, "GtkCellRendererToggle", GTK_TYPE_CELL_RENDERER_TOGGLE, &PyGtkCellRendererToggle_Type, Py_BuildValue("(O)", &PyGtkCellRenderer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CELL_RENDERER_TOGGLE);
    pyg_register_class_init(GTK_TYPE_CELL_RENDERER_TOGGLE, __GtkCellRendererToggle_class_init);
    pygobject_register_class(d, "GtkCellRendererText", GTK_TYPE_CELL_RENDERER_TEXT, &PyGtkCellRendererText_Type, Py_BuildValue("(O)", &PyGtkCellRenderer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CELL_RENDERER_TEXT);
    pyg_register_class_init(GTK_TYPE_CELL_RENDERER_TEXT, __GtkCellRendererText_class_init);
    pygobject_register_class(d, "GtkCellRendererCombo", GTK_TYPE_CELL_RENDERER_COMBO, &PyGtkCellRendererCombo_Type, Py_BuildValue("(O)", &PyGtkCellRendererText_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CELL_RENDERER_COMBO);
    pygobject_register_class(d, "GtkCellRendererProgress", GTK_TYPE_CELL_RENDERER_PROGRESS, &PyGtkCellRendererProgress_Type, Py_BuildValue("(O)", &PyGtkCellRenderer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CELL_RENDERER_PROGRESS);
    pygobject_register_class(d, "GtkCellRendererPixbuf", GTK_TYPE_CELL_RENDERER_PIXBUF, &PyGtkCellRendererPixbuf_Type, Py_BuildValue("(O)", &PyGtkCellRenderer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CELL_RENDERER_PIXBUF);
    pygobject_register_class(d, "PyGtkGenericCellRenderer", PYGTK_TYPE_GENERIC_CELL_RENDERER, &PyPyGtkGenericCellRenderer_Type, Py_BuildValue("(O)", &PyGtkCellRenderer_Type));
    pyg_set_object_has_new_constructor(PYGTK_TYPE_GENERIC_CELL_RENDERER);
    pygobject_register_class(d, "GtkAdjustment", GTK_TYPE_ADJUSTMENT, &PyGtkAdjustment_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ADJUSTMENT);
    pyg_register_class_init(GTK_TYPE_ADJUSTMENT, __GtkAdjustment_class_init);
    pygobject_register_class(d, "GtkRcStyle", GTK_TYPE_RC_STYLE, &PyGtkRcStyle_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RC_STYLE);
    pyg_register_class_init(GTK_TYPE_RC_STYLE, __GtkRcStyle_class_init);
    pygobject_register_class(d, "GtkSettings", GTK_TYPE_SETTINGS, &PyGtkSettings_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SETTINGS);
    pygobject_register_class(d, "GtkSizeGroup", GTK_TYPE_SIZE_GROUP, &PyGtkSizeGroup_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SIZE_GROUP);
    pygobject_register_class(d, "GtkStyle", GTK_TYPE_STYLE, &PyGtkStyle_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_STYLE);
    pyg_register_class_init(GTK_TYPE_STYLE, __GtkStyle_class_init);
    pygobject_register_class(d, "GtkTextBuffer", GTK_TYPE_TEXT_BUFFER, &PyGtkTextBuffer_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TEXT_BUFFER);
    pyg_register_class_init(GTK_TYPE_TEXT_BUFFER, __GtkTextBuffer_class_init);
    pygobject_register_class(d, "GtkTextChildAnchor", GTK_TYPE_TEXT_CHILD_ANCHOR, &PyGtkTextChildAnchor_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TEXT_CHILD_ANCHOR);
    pygobject_register_class(d, "GtkTextMark", GTK_TYPE_TEXT_MARK, &PyGtkTextMark_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TEXT_MARK);
    pygobject_register_class(d, "GtkTextTag", GTK_TYPE_TEXT_TAG, &PyGtkTextTag_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TEXT_TAG);
    pyg_register_class_init(GTK_TYPE_TEXT_TAG, __GtkTextTag_class_init);
    pygobject_register_class(d, "GtkTextTagTable", GTK_TYPE_TEXT_TAG_TABLE, &PyGtkTextTagTable_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TEXT_TAG_TABLE);
    pyg_register_class_init(GTK_TYPE_TEXT_TAG_TABLE, __GtkTextTagTable_class_init);
    pygobject_register_class(d, "GtkToggleAction", GTK_TYPE_TOGGLE_ACTION, &PyGtkToggleAction_Type, Py_BuildValue("(O)", &PyGtkAction_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TOGGLE_ACTION);
    pyg_register_class_init(GTK_TYPE_TOGGLE_ACTION, __GtkToggleAction_class_init);
    pygobject_register_class(d, "GtkRadioAction", GTK_TYPE_RADIO_ACTION, &PyGtkRadioAction_Type, Py_BuildValue("(O)", &PyGtkToggleAction_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RADIO_ACTION);
    pyg_register_class_init(GTK_TYPE_RADIO_ACTION, __GtkRadioAction_class_init);
    pygobject_register_class(d, "GtkTooltips", GTK_TYPE_TOOLTIPS, &PyGtkTooltips_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TOOLTIPS);
    pygobject_register_class(d, "GtkTreeModelFilter", GTK_TYPE_TREE_MODEL_FILTER, &PyGtkTreeModelFilter_Type, Py_BuildValue("(OOO)", &PyGObject_Type, &PyGtkTreeModel_Type, &PyGtkTreeDragSource_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TREE_MODEL_FILTER);
    pygobject_register_class(d, "GtkTreeModelSort", GTK_TYPE_TREE_MODEL_SORT, &PyGtkTreeModelSort_Type, Py_BuildValue("(OOOO)", &PyGObject_Type, &PyGtkTreeModel_Type, &PyGtkTreeDragSource_Type, &PyGtkTreeSortable_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TREE_MODEL_SORT);
    pygobject_register_class(d, "GtkTreeSelection", GTK_TYPE_TREE_SELECTION, &PyGtkTreeSelection_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TREE_SELECTION);
    pyg_register_class_init(GTK_TYPE_TREE_SELECTION, __GtkTreeSelection_class_init);
    pygobject_register_class(d, "GtkTreeStore", GTK_TYPE_TREE_STORE, &PyGtkTreeStore_Type, Py_BuildValue("(OOOOO)", &PyGObject_Type, &PyGtkTreeModel_Type, &PyGtkTreeDragSource_Type, &PyGtkTreeDragDest_Type, &PyGtkTreeSortable_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TREE_STORE);
    pygobject_register_class(d, "GtkTreeViewColumn", GTK_TYPE_TREE_VIEW_COLUMN, &PyGtkTreeViewColumn_Type, Py_BuildValue("(OO)", &PyGtkObject_Type, &PyGtkCellLayout_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TREE_VIEW_COLUMN);
    pyg_register_class_init(GTK_TYPE_TREE_VIEW_COLUMN, __GtkTreeViewColumn_class_init);
    pygobject_register_class(d, "GtkUIManager", GTK_TYPE_UI_MANAGER, &PyGtkUIManager_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_UI_MANAGER);
    pyg_register_class_init(GTK_TYPE_UI_MANAGER, __GtkUIManager_class_init);
    pygobject_register_class(d, "GtkWidget", GTK_TYPE_WIDGET, &PyGtkWidget_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_WIDGET);
    pyg_register_class_init(GTK_TYPE_WIDGET, __GtkWidget_class_init);
    pygobject_register_class(d, "GtkSeparator", GTK_TYPE_SEPARATOR, &PyGtkSeparator_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SEPARATOR);
    pygobject_register_class(d, "GtkVSeparator", GTK_TYPE_VSEPARATOR, &PyGtkVSeparator_Type, Py_BuildValue("(O)", &PyGtkSeparator_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_VSEPARATOR);
    pygobject_register_class(d, "GtkHSeparator", GTK_TYPE_HSEPARATOR, &PyGtkHSeparator_Type, Py_BuildValue("(O)", &PyGtkSeparator_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_HSEPARATOR);
    pygobject_register_class(d, "GtkRuler", GTK_TYPE_RULER, &PyGtkRuler_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RULER);
    pyg_register_class_init(GTK_TYPE_RULER, __GtkRuler_class_init);
    pygobject_register_class(d, "GtkVRuler", GTK_TYPE_VRULER, &PyGtkVRuler_Type, Py_BuildValue("(O)", &PyGtkRuler_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_VRULER);
    pygobject_register_class(d, "GtkHRuler", GTK_TYPE_HRULER, &PyGtkHRuler_Type, Py_BuildValue("(O)", &PyGtkRuler_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_HRULER);
    pygobject_register_class(d, "GtkRange", GTK_TYPE_RANGE, &PyGtkRange_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RANGE);
    pyg_register_class_init(GTK_TYPE_RANGE, __GtkRange_class_init);
    pygobject_register_class(d, "GtkScrollbar", GTK_TYPE_SCROLLBAR, &PyGtkScrollbar_Type, Py_BuildValue("(O)", &PyGtkRange_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SCROLLBAR);
    pygobject_register_class(d, "GtkVScrollbar", GTK_TYPE_VSCROLLBAR, &PyGtkVScrollbar_Type, Py_BuildValue("(O)", &PyGtkScrollbar_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_VSCROLLBAR);
    pygobject_register_class(d, "GtkHScrollbar", GTK_TYPE_HSCROLLBAR, &PyGtkHScrollbar_Type, Py_BuildValue("(O)", &PyGtkScrollbar_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_HSCROLLBAR);
    pygobject_register_class(d, "GtkScale", GTK_TYPE_SCALE, &PyGtkScale_Type, Py_BuildValue("(O)", &PyGtkRange_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SCALE);
    pyg_register_class_init(GTK_TYPE_SCALE, __GtkScale_class_init);
    pygobject_register_class(d, "GtkVScale", GTK_TYPE_VSCALE, &PyGtkVScale_Type, Py_BuildValue("(O)", &PyGtkScale_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_VSCALE);
    pygobject_register_class(d, "GtkHScale", GTK_TYPE_HSCALE, &PyGtkHScale_Type, Py_BuildValue("(O)", &PyGtkScale_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_HSCALE);
    pygobject_register_class(d, "GtkProgress", GTK_TYPE_PROGRESS, &PyGtkProgress_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_PROGRESS);
    pyg_register_class_init(GTK_TYPE_PROGRESS, __GtkProgress_class_init);
    pygobject_register_class(d, "GtkProgressBar", GTK_TYPE_PROGRESS_BAR, &PyGtkProgressBar_Type, Py_BuildValue("(O)", &PyGtkProgress_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_PROGRESS_BAR);
    pygobject_register_class(d, "GtkPreview", GTK_TYPE_PREVIEW, &PyGtkPreview_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pygobject_register_class(d, "GtkOldEditable", GTK_TYPE_OLD_EDITABLE, &PyGtkOldEditable_Type, Py_BuildValue("(OO)", &PyGtkWidget_Type, &PyGtkEditable_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_OLD_EDITABLE);
    pyg_register_class_init(GTK_TYPE_OLD_EDITABLE, __GtkOldEditable_class_init);
    pygobject_register_class(d, "GtkMisc", GTK_TYPE_MISC, &PyGtkMisc_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_MISC);
    pygobject_register_class(d, "GtkPixmap", GTK_TYPE_PIXMAP, &PyGtkPixmap_Type, Py_BuildValue("(O)", &PyGtkMisc_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_PIXMAP);
    pygobject_register_class(d, "GtkArrow", GTK_TYPE_ARROW, &PyGtkArrow_Type, Py_BuildValue("(O)", &PyGtkMisc_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ARROW);
    pygobject_register_class(d, "GtkImage", GTK_TYPE_IMAGE, &PyGtkImage_Type, Py_BuildValue("(O)", &PyGtkMisc_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_IMAGE);
    pygobject_register_class(d, "GtkLabel", GTK_TYPE_LABEL, &PyGtkLabel_Type, Py_BuildValue("(O)", &PyGtkMisc_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_LABEL);
    pyg_register_class_init(GTK_TYPE_LABEL, __GtkLabel_class_init);
    pygobject_register_class(d, "GtkAccelLabel", GTK_TYPE_ACCEL_LABEL, &PyGtkAccelLabel_Type, Py_BuildValue("(O)", &PyGtkLabel_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ACCEL_LABEL);
    pygobject_register_class(d, "GtkInvisible", GTK_TYPE_INVISIBLE, &PyGtkInvisible_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_INVISIBLE);
    pygobject_register_class(d, "GtkEntry", GTK_TYPE_ENTRY, &PyGtkEntry_Type, Py_BuildValue("(OOO)", &PyGtkWidget_Type, &PyGtkEditable_Type, &PyGtkCellEditable_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ENTRY);
    pyg_register_class_init(GTK_TYPE_ENTRY, __GtkEntry_class_init);
    pygobject_register_class(d, "GtkSpinButton", GTK_TYPE_SPIN_BUTTON, &PyGtkSpinButton_Type, Py_BuildValue("(OOO)", &PyGtkEntry_Type, &PyGtkEditable_Type, &PyGtkCellEditable_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SPIN_BUTTON);
    pyg_register_class_init(GTK_TYPE_SPIN_BUTTON, __GtkSpinButton_class_init);
    pygobject_register_class(d, "GtkDrawingArea", GTK_TYPE_DRAWING_AREA, &PyGtkDrawingArea_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_DRAWING_AREA);
    pygobject_register_class(d, "GtkCurve", GTK_TYPE_CURVE, &PyGtkCurve_Type, Py_BuildValue("(O)", &PyGtkDrawingArea_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CURVE);
    pyg_register_class_init(GTK_TYPE_CURVE, __GtkCurve_class_init);
    pygobject_register_class(d, "GtkContainer", GTK_TYPE_CONTAINER, &PyGtkContainer_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CONTAINER);
    pyg_register_class_init(GTK_TYPE_CONTAINER, __GtkContainer_class_init);
    pygobject_register_class(d, "GtkTreeView", GTK_TYPE_TREE_VIEW, &PyGtkTreeView_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TREE_VIEW);
    pyg_register_class_init(GTK_TYPE_TREE_VIEW, __GtkTreeView_class_init);
    pygobject_register_class(d, "GtkToolbar", GTK_TYPE_TOOLBAR, &PyGtkToolbar_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TOOLBAR);
    pyg_register_class_init(GTK_TYPE_TOOLBAR, __GtkToolbar_class_init);
    pygobject_register_class(d, "GtkTextView", GTK_TYPE_TEXT_VIEW, &PyGtkTextView_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TEXT_VIEW);
    pyg_register_class_init(GTK_TYPE_TEXT_VIEW, __GtkTextView_class_init);
    pygobject_register_class(d, "GtkTable", GTK_TYPE_TABLE, &PyGtkTable_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TABLE);
    pygobject_register_class(d, "GtkSocket", GTK_TYPE_SOCKET, &PyGtkSocket_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SOCKET);
    pyg_register_class_init(GTK_TYPE_SOCKET, __GtkSocket_class_init);
    pygobject_register_class(d, "GtkPaned", GTK_TYPE_PANED, &PyGtkPaned_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_PANED);
    pyg_register_class_init(GTK_TYPE_PANED, __GtkPaned_class_init);
    pygobject_register_class(d, "GtkVPaned", GTK_TYPE_VPANED, &PyGtkVPaned_Type, Py_BuildValue("(O)", &PyGtkPaned_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_VPANED);
    pygobject_register_class(d, "GtkHPaned", GTK_TYPE_HPANED, &PyGtkHPaned_Type, Py_BuildValue("(O)", &PyGtkPaned_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_HPANED);
    pygobject_register_class(d, "GtkNotebook", GTK_TYPE_NOTEBOOK, &PyGtkNotebook_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_NOTEBOOK);
    pyg_register_class_init(GTK_TYPE_NOTEBOOK, __GtkNotebook_class_init);
    pygobject_register_class(d, "GtkMenuShell", GTK_TYPE_MENU_SHELL, &PyGtkMenuShell_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_MENU_SHELL);
    pyg_register_class_init(GTK_TYPE_MENU_SHELL, __GtkMenuShell_class_init);
    pygobject_register_class(d, "GtkMenu", GTK_TYPE_MENU, &PyGtkMenu_Type, Py_BuildValue("(O)", &PyGtkMenuShell_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_MENU);
    pygobject_register_class(d, "GtkMenuBar", GTK_TYPE_MENU_BAR, &PyGtkMenuBar_Type, Py_BuildValue("(O)", &PyGtkMenuShell_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_MENU_BAR);
    pygobject_register_class(d, "GtkList", GTK_TYPE_LIST, &PyGtkList_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_LIST);
    pyg_register_class_init(GTK_TYPE_LIST, __GtkList_class_init);
    pygobject_register_class(d, "GtkLayout", GTK_TYPE_LAYOUT, &PyGtkLayout_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_LAYOUT);
    pyg_register_class_init(GTK_TYPE_LAYOUT, __GtkLayout_class_init);
    pygobject_register_class(d, "GtkIconView", GTK_TYPE_ICON_VIEW, &PyGtkIconView_Type, Py_BuildValue("(OO)", &PyGtkContainer_Type, &PyGtkCellLayout_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ICON_VIEW);
    pyg_register_class_init(GTK_TYPE_ICON_VIEW, __GtkIconView_class_init);
    pygobject_register_class(d, "GtkFixed", GTK_TYPE_FIXED, &PyGtkFixed_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_FIXED);
    pygobject_register_class(d, "GtkBin", GTK_TYPE_BIN, &PyGtkBin_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_BIN);
    pygobject_register_class(d, "GtkViewport", GTK_TYPE_VIEWPORT, &PyGtkViewport_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_VIEWPORT);
    pyg_register_class_init(GTK_TYPE_VIEWPORT, __GtkViewport_class_init);
    pygobject_register_class(d, "GtkToolItem", GTK_TYPE_TOOL_ITEM, &PyGtkToolItem_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TOOL_ITEM);
    pyg_register_class_init(GTK_TYPE_TOOL_ITEM, __GtkToolItem_class_init);
    pygobject_register_class(d, "GtkSeparatorToolItem", GTK_TYPE_SEPARATOR_TOOL_ITEM, &PyGtkSeparatorToolItem_Type, Py_BuildValue("(O)", &PyGtkToolItem_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SEPARATOR_TOOL_ITEM);
    pygobject_register_class(d, "GtkToolButton", GTK_TYPE_TOOL_BUTTON, &PyGtkToolButton_Type, Py_BuildValue("(O)", &PyGtkToolItem_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TOOL_BUTTON);
    pyg_register_class_init(GTK_TYPE_TOOL_BUTTON, __GtkToolButton_class_init);
    pygobject_register_class(d, "GtkToggleToolButton", GTK_TYPE_TOGGLE_TOOL_BUTTON, &PyGtkToggleToolButton_Type, Py_BuildValue("(O)", &PyGtkToolButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TOGGLE_TOOL_BUTTON);
    pyg_register_class_init(GTK_TYPE_TOGGLE_TOOL_BUTTON, __GtkToggleToolButton_class_init);
    pygobject_register_class(d, "GtkRadioToolButton", GTK_TYPE_RADIO_TOOL_BUTTON, &PyGtkRadioToolButton_Type, Py_BuildValue("(O)", &PyGtkToggleToolButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RADIO_TOOL_BUTTON);
    pygobject_register_class(d, "GtkMenuToolButton", GTK_TYPE_MENU_TOOL_BUTTON, &PyGtkMenuToolButton_Type, Py_BuildValue("(O)", &PyGtkToolButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_MENU_TOOL_BUTTON);
    pyg_register_class_init(GTK_TYPE_MENU_TOOL_BUTTON, __GtkMenuToolButton_class_init);
    pygobject_register_class(d, "GtkScrolledWindow", GTK_TYPE_SCROLLED_WINDOW, &PyGtkScrolledWindow_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SCROLLED_WINDOW);
    pyg_register_class_init(GTK_TYPE_SCROLLED_WINDOW, __GtkScrolledWindow_class_init);
    pygobject_register_class(d, "GtkItem", GTK_TYPE_ITEM, &PyGtkItem_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ITEM);
    pyg_register_class_init(GTK_TYPE_ITEM, __GtkItem_class_init);
    pygobject_register_class(d, "GtkMenuItem", GTK_TYPE_MENU_ITEM, &PyGtkMenuItem_Type, Py_BuildValue("(O)", &PyGtkItem_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_MENU_ITEM);
    pyg_register_class_init(GTK_TYPE_MENU_ITEM, __GtkMenuItem_class_init);
    pygobject_register_class(d, "GtkTearoffMenuItem", GTK_TYPE_TEAROFF_MENU_ITEM, &PyGtkTearoffMenuItem_Type, Py_BuildValue("(O)", &PyGtkMenuItem_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TEAROFF_MENU_ITEM);
    pygobject_register_class(d, "GtkSeparatorMenuItem", GTK_TYPE_SEPARATOR_MENU_ITEM, &PyGtkSeparatorMenuItem_Type, Py_BuildValue("(O)", &PyGtkMenuItem_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SEPARATOR_MENU_ITEM);
    pygobject_register_class(d, "GtkCheckMenuItem", GTK_TYPE_CHECK_MENU_ITEM, &PyGtkCheckMenuItem_Type, Py_BuildValue("(O)", &PyGtkMenuItem_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CHECK_MENU_ITEM);
    pyg_register_class_init(GTK_TYPE_CHECK_MENU_ITEM, __GtkCheckMenuItem_class_init);
    pygobject_register_class(d, "GtkRadioMenuItem", GTK_TYPE_RADIO_MENU_ITEM, &PyGtkRadioMenuItem_Type, Py_BuildValue("(O)", &PyGtkCheckMenuItem_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RADIO_MENU_ITEM);
    pyg_register_class_init(GTK_TYPE_RADIO_MENU_ITEM, __GtkRadioMenuItem_class_init);
    pygobject_register_class(d, "GtkImageMenuItem", GTK_TYPE_IMAGE_MENU_ITEM, &PyGtkImageMenuItem_Type, Py_BuildValue("(O)", &PyGtkMenuItem_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_IMAGE_MENU_ITEM);
    pygobject_register_class(d, "GtkListItem", GTK_TYPE_LIST_ITEM, &PyGtkListItem_Type, Py_BuildValue("(O)", &PyGtkItem_Type));
    pyg_register_class_init(GTK_TYPE_LIST_ITEM, __GtkListItem_class_init);
    pygobject_register_class(d, "GtkHandleBox", GTK_TYPE_HANDLE_BOX, &PyGtkHandleBox_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_HANDLE_BOX);
    pyg_register_class_init(GTK_TYPE_HANDLE_BOX, __GtkHandleBox_class_init);
    pygobject_register_class(d, "GtkFrame", GTK_TYPE_FRAME, &PyGtkFrame_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_FRAME);
    pyg_register_class_init(GTK_TYPE_FRAME, __GtkFrame_class_init);
    pygobject_register_class(d, "GtkAspectFrame", GTK_TYPE_ASPECT_FRAME, &PyGtkAspectFrame_Type, Py_BuildValue("(O)", &PyGtkFrame_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ASPECT_FRAME);
    pygobject_register_class(d, "GtkExpander", GTK_TYPE_EXPANDER, &PyGtkExpander_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_EXPANDER);
    pyg_register_class_init(GTK_TYPE_EXPANDER, __GtkExpander_class_init);
    pygobject_register_class(d, "GtkEventBox", GTK_TYPE_EVENT_BOX, &PyGtkEventBox_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_EVENT_BOX);
    pygobject_register_class(d, "GtkAlignment", GTK_TYPE_ALIGNMENT, &PyGtkAlignment_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ALIGNMENT);
    pygobject_register_class(d, "GtkButton", GTK_TYPE_BUTTON, &PyGtkButton_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_BUTTON);
    pyg_register_class_init(GTK_TYPE_BUTTON, __GtkButton_class_init);
    pygobject_register_class(d, "GtkToggleButton", GTK_TYPE_TOGGLE_BUTTON, &PyGtkToggleButton_Type, Py_BuildValue("(O)", &PyGtkButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TOGGLE_BUTTON);
    pyg_register_class_init(GTK_TYPE_TOGGLE_BUTTON, __GtkToggleButton_class_init);
    pygobject_register_class(d, "GtkCheckButton", GTK_TYPE_CHECK_BUTTON, &PyGtkCheckButton_Type, Py_BuildValue("(O)", &PyGtkToggleButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CHECK_BUTTON);
    pyg_register_class_init(GTK_TYPE_CHECK_BUTTON, __GtkCheckButton_class_init);
    pygobject_register_class(d, "GtkRadioButton", GTK_TYPE_RADIO_BUTTON, &PyGtkRadioButton_Type, Py_BuildValue("(O)", &PyGtkCheckButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RADIO_BUTTON);
    pyg_register_class_init(GTK_TYPE_RADIO_BUTTON, __GtkRadioButton_class_init);
    pygobject_register_class(d, "GtkOptionMenu", GTK_TYPE_OPTION_MENU, &PyGtkOptionMenu_Type, Py_BuildValue("(O)", &PyGtkButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_OPTION_MENU);
    pyg_register_class_init(GTK_TYPE_OPTION_MENU, __GtkOptionMenu_class_init);
    pygobject_register_class(d, "GtkFontButton", GTK_TYPE_FONT_BUTTON, &PyGtkFontButton_Type, Py_BuildValue("(O)", &PyGtkButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_FONT_BUTTON);
    pyg_register_class_init(GTK_TYPE_FONT_BUTTON, __GtkFontButton_class_init);
    pygobject_register_class(d, "GtkColorButton", GTK_TYPE_COLOR_BUTTON, &PyGtkColorButton_Type, Py_BuildValue("(O)", &PyGtkButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_COLOR_BUTTON);
    pyg_register_class_init(GTK_TYPE_COLOR_BUTTON, __GtkColorButton_class_init);
    pygobject_register_class(d, "GtkComboBox", GTK_TYPE_COMBO_BOX, &PyGtkComboBox_Type, Py_BuildValue("(OOO)", &PyGtkBin_Type, &PyGtkCellEditable_Type, &PyGtkCellLayout_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_COMBO_BOX);
    pyg_register_class_init(GTK_TYPE_COMBO_BOX, __GtkComboBox_class_init);
    pygobject_register_class(d, "GtkComboBoxEntry", GTK_TYPE_COMBO_BOX_ENTRY, &PyGtkComboBoxEntry_Type, Py_BuildValue("(OOO)", &PyGtkComboBox_Type, &PyGtkCellEditable_Type, &PyGtkCellLayout_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_COMBO_BOX_ENTRY);
    pygobject_register_class(d, "GtkBox", GTK_TYPE_BOX, &PyGtkBox_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_BOX);
    pygobject_register_class(d, "GtkVBox", GTK_TYPE_VBOX, &PyGtkVBox_Type, Py_BuildValue("(O)", &PyGtkBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_VBOX);
    pygobject_register_class(d, "GtkColorSelection", GTK_TYPE_COLOR_SELECTION, &PyGtkColorSelection_Type, Py_BuildValue("(O)", &PyGtkVBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_COLOR_SELECTION);
    pyg_register_class_init(GTK_TYPE_COLOR_SELECTION, __GtkColorSelection_class_init);
    pygobject_register_class(d, "GtkFileChooserWidget", GTK_TYPE_FILE_CHOOSER_WIDGET, &PyGtkFileChooserWidget_Type, Py_BuildValue("(OO)", &PyGtkVBox_Type, &PyGtkFileChooser_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_FILE_CHOOSER_WIDGET);
    pygobject_register_class(d, "GtkFontSelection", GTK_TYPE_FONT_SELECTION, &PyGtkFontSelection_Type, Py_BuildValue("(O)", &PyGtkVBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_FONT_SELECTION);
    pygobject_register_class(d, "GtkGammaCurve", GTK_TYPE_GAMMA_CURVE, &PyGtkGammaCurve_Type, Py_BuildValue("(O)", &PyGtkVBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_GAMMA_CURVE);
    pygobject_register_class(d, "GtkHBox", GTK_TYPE_HBOX, &PyGtkHBox_Type, Py_BuildValue("(O)", &PyGtkBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_HBOX);
    pygobject_register_class(d, "GtkStatusbar", GTK_TYPE_STATUSBAR, &PyGtkStatusbar_Type, Py_BuildValue("(O)", &PyGtkHBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_STATUSBAR);
    pyg_register_class_init(GTK_TYPE_STATUSBAR, __GtkStatusbar_class_init);
    pygobject_register_class(d, "GtkCombo", GTK_TYPE_COMBO, &PyGtkCombo_Type, Py_BuildValue("(O)", &PyGtkHBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_COMBO);
    pygobject_register_class(d, "GtkFileChooserButton", GTK_TYPE_FILE_CHOOSER_BUTTON, &PyGtkFileChooserButton_Type, Py_BuildValue("(OO)", &PyGtkHBox_Type, &PyGtkFileChooser_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_FILE_CHOOSER_BUTTON);
    pygobject_register_class(d, "GtkButtonBox", GTK_TYPE_BUTTON_BOX, &PyGtkButtonBox_Type, Py_BuildValue("(O)", &PyGtkBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_BUTTON_BOX);
    pygobject_register_class(d, "GtkVButtonBox", GTK_TYPE_VBUTTON_BOX, &PyGtkVButtonBox_Type, Py_BuildValue("(O)", &PyGtkButtonBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_VBUTTON_BOX);
    pygobject_register_class(d, "GtkHButtonBox", GTK_TYPE_HBUTTON_BOX, &PyGtkHButtonBox_Type, Py_BuildValue("(O)", &PyGtkButtonBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_HBUTTON_BOX);
    pygobject_register_class(d, "GtkCList", GTK_TYPE_CLIST, &PyGtkCList_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_register_class_init(GTK_TYPE_CLIST, __GtkCList_class_init);
    pygobject_register_class(d, "GtkCTree", GTK_TYPE_CTREE, &PyGtkCTree_Type, Py_BuildValue("(O)", &PyGtkCList_Type));
    pyg_register_class_init(GTK_TYPE_CTREE, __GtkCTree_class_init);
    pygobject_register_class(d, "GtkCellView", GTK_TYPE_CELL_VIEW, &PyGtkCellView_Type, Py_BuildValue("(OO)", &PyGtkWidget_Type, &PyGtkCellLayout_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CELL_VIEW);
    pygobject_register_class(d, "GtkCalendar", GTK_TYPE_CALENDAR, &PyGtkCalendar_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CALENDAR);
    pyg_register_class_init(GTK_TYPE_CALENDAR, __GtkCalendar_class_init);
    pygobject_register_class(d, "GtkWindow", GTK_TYPE_WINDOW, &PyGtkWindow_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_WINDOW);
    pyg_register_class_init(GTK_TYPE_WINDOW, __GtkWindow_class_init);
    pygobject_register_class(d, "GtkPlug", GTK_TYPE_PLUG, &PyGtkPlug_Type, Py_BuildValue("(O)", &PyGtkWindow_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_PLUG);
    pyg_register_class_init(GTK_TYPE_PLUG, __GtkPlug_class_init);
    pygobject_register_class(d, "GtkDialog", GTK_TYPE_DIALOG, &PyGtkDialog_Type, Py_BuildValue("(O)", &PyGtkWindow_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_DIALOG);
    pyg_register_class_init(GTK_TYPE_DIALOG, __GtkDialog_class_init);
    pygobject_register_class(d, "GtkMessageDialog", GTK_TYPE_MESSAGE_DIALOG, &PyGtkMessageDialog_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
    pygobject_register_class(d, "GtkInputDialog", GTK_TYPE_INPUT_DIALOG, &PyGtkInputDialog_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_INPUT_DIALOG);
    pyg_register_class_init(GTK_TYPE_INPUT_DIALOG, __GtkInputDialog_class_init);
    pygobject_register_class(d, "GtkFontSelectionDialog", GTK_TYPE_FONT_SELECTION_DIALOG, &PyGtkFontSelectionDialog_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_FONT_SELECTION_DIALOG);
    pygobject_register_class(d, "GtkFileSelection", GTK_TYPE_FILE_SELECTION, &PyGtkFileSelection_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_FILE_SELECTION);
    pygobject_register_class(d, "GtkFileChooserDialog", GTK_TYPE_FILE_CHOOSER_DIALOG, &PyGtkFileChooserDialog_Type, Py_BuildValue("(OO)", &PyGtkDialog_Type, &PyGtkFileChooser_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_FILE_CHOOSER_DIALOG);
    pygobject_register_class(d, "GtkAboutDialog", GTK_TYPE_ABOUT_DIALOG, &PyGtkAboutDialog_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ABOUT_DIALOG);
    pygobject_register_class(d, "GtkColorSelectionDialog", GTK_TYPE_COLOR_SELECTION_DIALOG, &PyGtkColorSelectionDialog_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_COLOR_SELECTION_DIALOG);
    pygobject_register_class(d, "GtkWindowGroup", GTK_TYPE_WINDOW_GROUP, &PyGtkWindowGroup_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_WINDOW_GROUP);
    pygobject_register_class(d, "GtkAssistant", GTK_TYPE_ASSISTANT, &PyGtkAssistant_Type, Py_BuildValue("(O)", &PyGtkWindow_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_ASSISTANT);
    pyg_register_class_init(GTK_TYPE_ASSISTANT, __GtkAssistant_class_init);
    pygobject_register_class(d, "GtkCellRendererAccel", GTK_TYPE_CELL_RENDERER_ACCEL, &PyGtkCellRendererAccel_Type, Py_BuildValue("(O)", &PyGtkCellRendererText_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CELL_RENDERER_ACCEL);
    pyg_register_class_init(GTK_TYPE_CELL_RENDERER_ACCEL, __GtkCellRendererAccel_class_init);
    pygobject_register_class(d, "GtkCellRendererSpin", GTK_TYPE_CELL_RENDERER_SPIN, &PyGtkCellRendererSpin_Type, Py_BuildValue("(O)", &PyGtkCellRendererText_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CELL_RENDERER_SPIN);
    pygobject_register_class(d, "GtkLinkButton", GTK_TYPE_LINK_BUTTON, &PyGtkLinkButton_Type, Py_BuildValue("(O)", &PyGtkButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_LINK_BUTTON);
    pygobject_register_class(d, "GtkPageSetup", GTK_TYPE_PAGE_SETUP, &PyGtkPageSetup_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_PAGE_SETUP);
    pygobject_register_class(d, "GtkPrintContext", GTK_TYPE_PRINT_CONTEXT, &PyGtkPrintContext_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_PRINT_CONTEXT);
    pygobject_register_class(d, "GtkPrintOperation", GTK_TYPE_PRINT_OPERATION, &PyGtkPrintOperation_Type, Py_BuildValue("(OO)", &PyGObject_Type, &PyGtkPrintOperationPreview_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_PRINT_OPERATION);
    pyg_register_class_init(GTK_TYPE_PRINT_OPERATION, __GtkPrintOperation_class_init);
    pygobject_register_class(d, "GtkPrintSettings", GTK_TYPE_PRINT_SETTINGS, &PyGtkPrintSettings_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_PRINT_SETTINGS);
    pygobject_register_class(d, "GtkRecentChooserDialog", GTK_TYPE_RECENT_CHOOSER_DIALOG, &PyGtkRecentChooserDialog_Type, Py_BuildValue("(OO)", &PyGtkDialog_Type, &PyGtkRecentChooser_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RECENT_CHOOSER_DIALOG);
    pygobject_register_class(d, "GtkRecentChooserMenu", GTK_TYPE_RECENT_CHOOSER_MENU, &PyGtkRecentChooserMenu_Type, Py_BuildValue("(OO)", &PyGtkMenu_Type, &PyGtkRecentChooser_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RECENT_CHOOSER_MENU);
    pygobject_register_class(d, "GtkRecentChooserWidget", GTK_TYPE_RECENT_CHOOSER_WIDGET, &PyGtkRecentChooserWidget_Type, Py_BuildValue("(OO)", &PyGtkVBox_Type, &PyGtkRecentChooser_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RECENT_CHOOSER_WIDGET);
    pygobject_register_class(d, "GtkRecentFilter", GTK_TYPE_RECENT_FILTER, &PyGtkRecentFilter_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RECENT_FILTER);
    pygobject_register_class(d, "GtkRecentManager", GTK_TYPE_RECENT_MANAGER, &PyGtkRecentManager_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_RECENT_MANAGER);
    pyg_register_class_init(GTK_TYPE_RECENT_MANAGER, __GtkRecentManager_class_init);
    pygobject_register_class(d, "GtkStatusIcon", GTK_TYPE_STATUS_ICON, &PyGtkStatusIcon_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_STATUS_ICON);
    pyg_register_class_init(GTK_TYPE_STATUS_ICON, __GtkStatusIcon_class_init);
    pygobject_register_class(d, "GtkBuilder", GTK_TYPE_BUILDER, &PyGtkBuilder_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_BUILDER);
    pyg_register_class_init(GTK_TYPE_BUILDER, __GtkBuilder_class_init);
    pygobject_register_class(d, "GtkRecentAction", GTK_TYPE_RECENT_ACTION, &PyGtkRecentAction_Type, Py_BuildValue("(O)", &PyGtkAction_Type));
    pygobject_register_class(d, "GtkScaleButton", GTK_TYPE_SCALE_BUTTON, &PyGtkScaleButton_Type, Py_BuildValue("(O)", &PyGtkButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SCALE_BUTTON);
    pygobject_register_class(d, "GtkTooltip", GTK_TYPE_TOOLTIP, &PyGtkTooltip_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TOOLTIP);
    pygobject_register_class(d, "GtkVolumeButton", GTK_TYPE_VOLUME_BUTTON, &PyGtkVolumeButton_Type, Py_BuildValue("(O)", &PyGtkScaleButton_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_VOLUME_BUTTON);
    pygobject_register_class(d, "GtkMountOperation", GTK_TYPE_MOUNT_OPERATION, &PyGtkMountOperation_Type, Py_BuildValue("(O)", &PyGMountOperation_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_MOUNT_OPERATION);
    pygobject_register_class(d, "GtkEntryBuffer", GTK_TYPE_ENTRY_BUFFER, &PyGtkEntryBuffer_Type, Py_BuildValue("(O)", &PyGObject_Type));
    pygobject_register_class(d, "GtkInfoBar", GTK_TYPE_INFO_BAR, &PyGtkInfoBar_Type, Py_BuildValue("(O)", &PyGtkHBox_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_INFO_BAR);
    pygobject_register_class(d, "GtkHSV", GTK_TYPE_HSV, &PyGtkHSV_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_HSV);
    pygobject_register_class(d, "GtkToolItemGroup", GTK_TYPE_TOOL_ITEM_GROUP, &PyGtkToolItemGroup_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pygobject_register_class(d, "GtkToolPalette", GTK_TYPE_TOOL_PALETTE, &PyGtkToolPalette_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_TOOL_PALETTE);
    pygobject_register_class(d, "GtkCellRendererSpinner", GTK_TYPE_CELL_RENDERER_SPINNER, &PyGtkCellRendererSpinner_Type, Py_BuildValue("(O)", &PyGtkCellRenderer_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_CELL_RENDERER_SPINNER);
    pygobject_register_class(d, "GtkOffscreenWindow", GTK_TYPE_OFFSCREEN_WINDOW, &PyGtkOffscreenWindow_Type, Py_BuildValue("(O)", &PyGtkWindow_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_OFFSCREEN_WINDOW);
    pygobject_register_class(d, "GtkSpinner", GTK_TYPE_SPINNER, &PyGtkSpinner_Type, Py_BuildValue("(O)", &PyGtkDrawingArea_Type));
    pyg_set_object_has_new_constructor(GTK_TYPE_SPINNER);
}
